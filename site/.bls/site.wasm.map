{"version":3,"sources":["~lib/rt/common.ts","~lib/rt/tlsf.ts","~lib/shared/typeinfo.ts","~lib/rt/itcms.ts","~lib/@blockless/sdk/assembly/error.ts","~lib/@blockless/sdk/assembly/http/stdin.ts","~lib/wasi_internal.ts","~lib/bindings/wasi_snapshot_preview1.ts","~lib/util/math.ts","~lib/util/string.ts","~lib/util/number.ts","~lib/shared/runtime.ts","~lib/util/sort.ts","~lib/string.ts","~lib/util/error.ts","~lib/rt.ts","~lib/arraybuffer.ts","~lib/util/hash.ts","~lib/map.ts","~lib/@blockless/sdk/assembly/memory/index.ts","index.ts","~lib/array.ts","~lib/builtins.ts","~lib/@blockless/sdk/assembly/http/index.ts","~lib/@blockless/sdk/assembly/json/JSON.ts","~lib/@blockless/sdk/assembly/json/decoder.ts","~lib/@blockless/sdk/assembly/json/util/index.ts","~lib/typedarray.ts","~lib/number.ts","~lib/math.ts","~lib/wasi_process.ts","~lib/staticarray.ts","~lib/function.ts"],"names":[],"mappings":"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","sourceRoot":"./site","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","import { AL_BITS, AL_SIZE, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./common\";\nimport { oninit, onalloc, onresize, onmove, onfree } from \"./rtrace\";\nimport { E_ALLOCATION_TOO_LARGE } from \"../util/error\";\n\n// === The TLSF (Two-Level Segregate Fit) memory allocator ===\n// see: http://www.gii.upv.es/tlsf/\n\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\n\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─╫─┴─┴─┴─┤\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\n// └───────────────────────────────────────────────┴───────╨───────┘\n// FL: first level, SL: second level, AL: alignment, SB: small block\n\n// @ts-ignore: decorator\n@inline const SL_BITS: u32 = 4;\n// @ts-ignore: decorator\n@inline const SL_SIZE: u32 = 1 << SL_BITS;\n\n// @ts-ignore: decorator\n@inline const SB_BITS: u32 = SL_BITS + AL_BITS;\n// @ts-ignore: decorator\n@inline const SB_SIZE: u32 = 1 << SB_BITS;\n\n// @ts-ignore: decorator\n@inline const FL_BITS: u32 = 31 - SB_BITS;\n\n// [00]: < 256B (SB)  [12]: < 1M\n// [01]: < 512B       [13]: < 2M\n// [02]: < 1K         [14]: < 4M\n// [03]: < 2K         [15]: < 8M\n// [04]: < 4K         [16]: < 16M\n// [05]: < 8K         [17]: < 32M\n// [06]: < 16K        [18]: < 64M\n// [07]: < 32K        [19]: < 128M\n// [08]: < 64K        [20]: < 256M\n// [09]: < 128K       [21]: < 512M\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\n// [11]: < 512K\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\n\n// Tags stored in otherwise unused alignment bits\n\n// @ts-ignore: decorator\n@inline const FREE: usize = 1 << 0;\n// @ts-ignore: decorator\n@inline const LEFTFREE: usize = 1 << 1;\n// @ts-ignore: decorator\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\n\n// ╒════════════════════ Block layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┤            ┐\n// │                          size                             │L│F│ ◄─┐ info   overhead\n// ╞>ptr═══════════════════════════════════════════════════════╧═╧═╡   │        ┘\n// │                        if free: ◄ prev                        │ ◄─┤ usize\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: next ►                        │ ◄─┤\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                             ...                               │   │ >= 0\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: back ▲                        │ ◄─┘\n// └───────────────────────────────────────────────────────────────┘ >= MIN SIZE\n// F: FREE, L: LEFTFREE\n@unmanaged export class Block extends BLOCK {\n\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\n  next: Block | null;\n\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\n}\n\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\n// `next` and `back` if free.\n\n// @ts-ignore: decorator\n@inline const BLOCK_MINSIZE: usize = ((3 * sizeof<usize>() + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD; // prev + next + back\n// @ts-ignore: decorator\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\n\n/** Gets the left block of a block. Only valid if the left block is free. */\n// @ts-ignore: decorator\n@inline function GETFREELEFT(block: Block): Block {\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\n}\n\n/** Gets the right block of a block by advancing to the right by its size. */\n// @ts-ignore: decorator\n@inline function GETRIGHT(block: Block): Block {\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\n}\n\n// ╒═════════════════════ Root layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\n// │        0        |           flMap                            S│ ◄────┐\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                           slMap[0] S                          │ ◄─┐  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[1]                            │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤  u32 │\n// │                           slMap[22]                           │ ◄─┘  │\n// ╞═══════════════════════════════════════════════════════════════╡    usize\n// │                            head[0]                            │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                              ...                              │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                           head[367]                           │ ◄────┤\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                             tail                              │ ◄────┘\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\n// S: Small blocks map\n@unmanaged class Root {\n  /** First level bitmap. */\n  flMap: usize;\n}\n\n// Root constants. Where stuff is stored inside of the root structure.\n\n// @ts-ignore: decorator\n@inline const SL_START: usize = sizeof<usize>();\n// @ts-ignore: decorator\n@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());\n// @ts-ignore: decorator\n@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;\n// @ts-ignore: decorator\n@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\n// @ts-ignore: decorator\n@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();\n\n// @ts-ignore: decorator\n@lazy export let ROOT: Root = changetype<Root>(0); // unsafe initializion below\n\n/** Gets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function GETSL(root: Root, fl: usize): u32 {\n  return load<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    SL_START\n  );\n}\n\n/** Sets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\n  store<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    slMap,\n    SL_START\n  );\n}\n\n/** Gets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\n  return load<Block>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    HL_START\n  );\n}\n\n/** Sets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\n  store<Block | null>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    head,\n    HL_START\n  );\n}\n\n/** Gets the tail block.. */\n// @ts-ignore: decorator\n@inline function GETTAIL(root: Root): Block {\n  return load<Block>(\n    changetype<usize>(root),\n    HL_END\n  );\n}\n\n/** Sets the tail block. */\n// @ts-ignore: decorator\n@inline function SETTAIL(root: Root, tail: Block): void {\n  store<Block>(\n    changetype<usize>(root),\n    tail,\n    HL_END\n  );\n}\n\n/** Inserts a previously used block back into the free list. */\nfunction insertBlock(root: Root, block: Block): void {\n  if (DEBUG) assert(block); // cannot be null\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n\n  let right = GETRIGHT(block);\n  let rightInfo = right.mmInfo;\n\n  // merge with right block if also free\n  if (rightInfo & FREE) {\n    removeBlock(root, right);\n    block.mmInfo = blockInfo = blockInfo + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK); // keep block tags\n    right = GETRIGHT(block);\n    rightInfo = right.mmInfo;\n    // 'back' is set below\n  }\n\n  // merge with left block if also free\n  if (blockInfo & LEFTFREE) {\n    let left = GETFREELEFT(block);\n    let leftInfo = left.mmInfo;\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\n    removeBlock(root, left);\n    block = left;\n    block.mmInfo = blockInfo = leftInfo + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK); // keep left tags\n    // 'back' is set below\n  }\n\n  right.mmInfo = rightInfo | LEFTFREE;\n  // reference to right is no longer used now, hence rightInfo is not synced\n\n  // we now know the size of the block\n  let size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be a valid size\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\n\n  // set 'back' to itself at the end of block\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\n\n  // mapping_insert\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // perform insertion\n  let head = GETHEAD(root, fl, sl);\n  block.prev = null;\n  block.next = head;\n  if (head) head.prev = block;\n  SETHEAD(root, fl, sl, block);\n\n  // update first and second level maps\n  root.flMap |= (1 << fl);\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\n}\n\n/** Removes a free block from internal lists. */\nfunction removeBlock(root: Root, block: Block): void {\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n  let size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be valid\n\n  // mapping_insert\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // link previous and next free block\n  let prev = block.prev;\n  let next = block.next;\n  if (prev) prev.next = next;\n  if (next) next.prev = prev;\n\n  // update head if we are removing it\n  if (block == GETHEAD(root, fl, sl)) {\n    SETHEAD(root, fl, sl, next);\n\n    // clear second level map if head is empty now\n    if (!next) {\n      let slMap = GETSL(root, fl);\n      SETSL(root, fl, slMap &= ~(1 << sl));\n\n      // clear first level map if second level is empty now\n      if (!slMap) root.flMap &= ~(1 << fl);\n    }\n  }\n  // note: does not alter left/back because it is likely that splitting\n  // is performed afterwards, invalidating those changes. so, the caller\n  // must perform those updates.\n}\n\n/** Searches for a free block of at least the specified size. */\nfunction searchBlock(root: Root, size: usize): Block | null {\n  // size was already asserted by caller\n\n  // mapping_search\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    const invRound = inv - SL_BITS;\n    let requestSize = size < halfMaxSize\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\n      : size;\n    fl = inv - clz<usize>(requestSize);\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // search second level\n  let slMap = GETSL(root, fl) & (~0 << sl);\n  let head: Block | null = null;\n  if (!slMap) {\n    // search next larger first level\n    let flMap = root.flMap & (~0 << (fl + 1));\n    if (!flMap) {\n      head = null;\n    } else {\n      fl = ctz<usize>(flMap);\n      slMap = GETSL(root, fl);\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\n    }\n  } else {\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\n  }\n  return head;\n}\n\n/** Prepares the specified block before (re-)use, possibly splitting it. */\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\n  // size was already asserted by caller\n\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(!((size + BLOCK_OVERHEAD) & AL_MASK)); // size must be aligned so the new block is\n\n  // split if the block can hold another MINSIZE block incl. overhead\n  let remaining = (blockInfo & ~TAGS_MASK) - size;\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\n\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\n    insertBlock(root, spare); // also sets 'back'\n\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\n  } else {\n    block.mmInfo = blockInfo & ~FREE;\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\n  }\n}\n\n/** Adds more memory to the pool. */\nfunction addMemory(root: Root, start: usize, end: usize): bool {\n  if (DEBUG) assert(start <= end); // must be valid\n  start = ((start + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n  end &= ~AL_MASK;\n\n  let tail = GETTAIL(root);\n  let tailInfo: usize = 0;\n  if (tail) { // more memory\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\n\n    // merge with current tail if adjacent\n    const offsetToTail = AL_SIZE;\n    if (start - offsetToTail == changetype<usize>(tail)) {\n      start -= offsetToTail;\n      tailInfo = tail.mmInfo;\n    } else {\n      // We don't do this, but a user might `memory.grow` manually\n      // leading to non-adjacent pages managed by TLSF.\n    }\n\n  } else if (DEBUG) { // first memory\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\n  }\n\n  // check if size is large enough for a free block and the tail block\n  let size = end - start;\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\n    return false;\n  }\n\n  // left size is total minus its own and the zero-length tail's header\n  let leftSize = size - 2 * BLOCK_OVERHEAD;\n  let left = changetype<Block>(start);\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\n  left.prev = null;\n  left.next = null;\n\n  // tail is a zero-length used block\n  tail = changetype<Block>(start + BLOCK_OVERHEAD + leftSize);\n  tail.mmInfo = 0 | LEFTFREE;\n  SETTAIL(root, tail);\n\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\n\n  return true;\n}\n\n/** Grows memory to fit at least another block of the specified size. */\nfunction growMemory(root: Root, size: usize): void {\n  if (ASC_LOW_MEMORY_LIMIT) {\n    unreachable();\n    return;\n  }\n  // Here, both rounding performed in searchBlock ...\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\n  if (size < halfMaxSize) { // don't round last fl\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\n    size += (1 << (invRound - clz<usize>(size))) - 1;\n  }\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\n  // to merge with the tail block, that's one time, otherwise it's two times.\n  let pagesBefore = memory.size();\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\n  let pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n  let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n  if (memory.grow(pagesWanted) < 0) {\n    if (memory.grow(pagesNeeded) < 0) unreachable();\n  }\n  let pagesAfter = memory.size();\n  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);\n}\n\n/** Computes the size (excl. header) of a block. */\nfunction computeSize(size: usize): usize {\n  // Size must be large enough and aligned minus preceeding overhead\n  return size <= BLOCK_MINSIZE\n    ? BLOCK_MINSIZE\n    : ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n}\n\n/** Prepares and checks an allocation size. */\nfunction prepareSize(size: usize): usize {\n  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  return computeSize(size);\n}\n\n/** Initializes the root structure. */\nfunction initialize(): void {\n  if (isDefined(ASC_RTRACE)) oninit(__heap_base);\n  let rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\n  let pagesBefore = memory.size();\n  let pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n  let root = changetype<Root>(rootOffset);\n  root.flMap = 0;\n  SETTAIL(root, changetype<Block>(0));\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n    SETSL(root, fl, 0);\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n      SETHEAD(root, fl, sl, null);\n    }\n  }\n  let memStart = rootOffset + ROOT_SIZE;\n  if (ASC_LOW_MEMORY_LIMIT) {\n    const memEnd = <usize>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;\n    if (memStart <= memEnd) addMemory(root, memStart, memEnd);\n    else unreachable(); // low memory limit already exceeded\n  } else {\n    addMemory(root, memStart, memory.size() << 16);\n  }\n  ROOT = root;\n}\n\n/** Allocates a block of the specified size. */\nexport function allocateBlock(root: Root, size: usize): Block {\n  let payloadSize = prepareSize(size);\n  let block = searchBlock(root, payloadSize);\n  if (!block) {\n    growMemory(root, payloadSize);\n    block = changetype<Block>(searchBlock(root, payloadSize));\n    if (DEBUG) assert(block); // must be found now\n  }\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\n  removeBlock(root, block);\n  prepareBlock(root, block, payloadSize);\n  if (isDefined(ASC_RTRACE)) onalloc(block);\n  return block;\n}\n\n/** Reallocates a block to the specified size. */\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\n  let payloadSize = prepareSize(size);\n  let blockInfo = block.mmInfo;\n  let blockSize = blockInfo & ~TAGS_MASK;\n\n  // possibly split and update runtime size if it still fits\n  if (payloadSize <= blockSize) {\n    prepareBlock(root, block, payloadSize);\n    if (isDefined(ASC_RTRACE)) {\n      if (payloadSize != blockSize) onresize(block, BLOCK_OVERHEAD + blockSize);\n    }\n    return block;\n  }\n\n  // merge with right free block if merger is large enough\n  let right = GETRIGHT(block);\n  let rightInfo = right.mmInfo;\n  if (rightInfo & FREE) {\n    let mergeSize = blockSize + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (mergeSize >= payloadSize) {\n      removeBlock(root, right);\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\n      prepareBlock(root, block, payloadSize);\n      if (isDefined(ASC_RTRACE)) onresize(block, BLOCK_OVERHEAD + blockSize);\n      return block;\n    }\n  }\n\n  // otherwise move the block\n  return moveBlock(root, block, size);\n}\n\n/** Moves a block to a new one of the specified size. */\nfunction moveBlock(root: Root, block: Block, newSize: usize): Block {\n  let newBlock = allocateBlock(root, newSize);\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, block.mmInfo & ~TAGS_MASK);\n  if (changetype<usize>(block) >= __heap_base) {\n    if (isDefined(ASC_RTRACE)) onmove(block, newBlock);\n    freeBlock(root, block);\n  }\n  return newBlock;\n}\n\n/** Frees a block. */\nexport function freeBlock(root: Root, block: Block): void {\n  if (isDefined(ASC_RTRACE)) onfree(block);\n  block.mmInfo = block.mmInfo | FREE;\n  insertBlock(root, block);\n}\n\n/** Checks that a used block is valid to be freed or reallocated. */\nfunction checkUsedBlock(ptr: usize): Block {\n  let block = changetype<Block>(ptr - BLOCK_OVERHEAD);\n  assert(\n    ptr != 0 && !(ptr & AL_MASK) &&  // must exist and be aligned\n    !(block.mmInfo & FREE)           // must be used\n  );\n  return block;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __alloc(size: usize): usize {\n  if (!ROOT) initialize();\n  return changetype<usize>(allocateBlock(ROOT, size)) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __realloc(ptr: usize, size: usize): usize {\n  if (!ROOT) initialize();\n  return (ptr < __heap_base\n    ? changetype<usize>(moveBlock(ROOT, checkUsedBlock(ptr), size))\n    : changetype<usize>(reallocateBlock(ROOT, checkUsedBlock(ptr), size))\n  ) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __free(ptr: usize): void {\n  if (ptr < __heap_base) return;\n  if (!ROOT) initialize();\n  freeBlock(ROOT, checkUsedBlock(ptr));\n}\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE, PROFILE } from \"./common\";\nimport { onvisit, oncollect, oninterrupt, onyield } from \"./rtrace\";\nimport { TypeinfoFlags } from \"../shared/typeinfo\";\nimport { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from \"../util/error\";\n\n// === ITCMS: An incremental Tri-Color Mark & Sweep garbage collector ===\n// Adapted from Bach Le's μgc, see: https://github.com/bullno1/ugc\n\n// ╒═════════════╤══════════════ Colors ═══════════════════════════╕\n// │ Color       │ Meaning                                         │\n// ├─────────────┼─────────────────────────────────────────────────┤\n// │ WHITE*      │ Unprocessed                                     │\n// │ BLACK*      │ Processed                                       │\n// │ GRAY        │ Processed with unprocessed children             │\n// │ TRANSPARENT │ Manually pinned (always reachable)              │\n// └─────────────┴─────────────────────────────────────────────────┘\n// * flipped between cycles\n\n// @ts-ignore: decorator\n@lazy let white = 0;\n// @ts-ignore: decorator\n@inline const gray = 2;\n// @ts-ignore: decorator\n@inline const transparent = 3;\n// @ts-ignore: decorator\n@inline const COLOR_MASK = 3;\n\n/** Size in memory of all objects currently managed by the GC. */\n// @ts-ignore: decorator\n@lazy let total: usize = 0;\n\n/** Currently transitioning from SWEEP to MARK state. */\n// @ts-ignore: decorator\n@inline const STATE_IDLE = 0;\n/** Currently marking reachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_MARK = 1;\n/** Currently sweeping unreachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_SWEEP = 2;\n/** Current collector state. */\n// @ts-ignore: decorator\n@lazy let state = STATE_IDLE;\n\n// @ts-ignore: decorator\n@lazy let fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy let toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy let pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy let iter: Object = changetype<Object>(0); // unsafe initializion below\n\nfunction initLazy(space: Object): Object {\n  space.nextWithColor = changetype<usize>(space);\n  space.prev = space;\n  return space;\n}\n\n/** Visit cookie indicating scanning of an object. */\n// @ts-ignore: decorator\n@inline const VISIT_SCAN = 0;\n\n// ╒═══════════════ Managed object layout (32-bit) ════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                      Memory manager block                     │\n// ╞═══════════════════════════════════════════════════════════╤═══╡\n// │                              next                         │ C │ = nextWithColor\n// ├───────────────────────────────────────────────────────────┴───┤\n// │                              prev                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtId                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtSize                           │\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                               ...                             │\n// C: color\n\n/** Represents a managed object in memory, consisting of a header followed by the object's data. */\n@unmanaged class Object extends BLOCK {\n  /** Pointer to the next object with color flags stored in the alignment bits. */\n  nextWithColor: usize; // *u32\n  /** Pointer to the previous object. */\n  prev: Object; // *u32\n  /** Runtime id. */\n  rtId: u32;\n  /** Runtime size. */\n  rtSize: u32;\n\n  /** Gets the pointer to the next object. */\n  get next(): Object {\n    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);\n  }\n\n  /** Sets the pointer to the next object. */\n  set next(obj: Object) {\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Gets this object's color. */\n  get color(): i32 {\n    return i32(this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Sets this object's color. */\n  set color(color: i32) {\n    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;\n  }\n\n  /** Gets the size of this object in memory. */\n  get size(): usize {\n    return BLOCK_OVERHEAD + (this.mmInfo & ~3);\n  }\n\n  /** Tests if this object is pointerfree. */\n  get isPointerfree(): bool {\n    let rtId = this.rtId;\n    // 0: Object, 1: ArrayBuffer, 2: String\n    return rtId <= idof<string>() || (__typeinfo(rtId) & TypeinfoFlags.POINTERFREE) != 0;\n  }\n\n  /** Unlinks this object from its list. */\n  unlink(): void {\n    let next = this.next;\n    if (next == null) {\n      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);\n      return; // static data not yet linked\n    }\n    let prev = this.prev;\n    if (DEBUG) assert(prev);\n    next.prev = prev;\n    prev.next = next;\n  }\n\n  /** Links this object to the specified list, with the given color. */\n  linkTo(list: Object, withColor: i32): void {\n    let prev = list.prev;\n    this.nextWithColor = changetype<usize>(list) | withColor;\n    this.prev = prev;\n    prev.next = this;\n    list.prev = this;\n  }\n\n  /** Marks this object as gray, that is reachable with unscanned children. */\n  makeGray(): void {\n    if (this == iter) iter = assert(this.prev);\n    this.unlink();\n    this.linkTo(toSpace, this.isPointerfree ? i32(!white) : gray);\n  }\n}\n\n/** Visits all objects considered to be program roots. */\nfunction visitRoots(cookie: u32): void {\n  __visit_globals(cookie);\n  let pn = pinSpace;\n  let iter = pn.next;\n  while (iter != pn) {\n    if (DEBUG) assert(iter.color == transparent);\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, cookie);\n    iter = iter.next;\n  }\n}\n\n/** Visits all objects on the stack. */\nfunction visitStack(cookie: u32): void {\n  let ptr = __stack_pointer;\n  while (ptr < __heap_base) {\n    __visit(load<usize>(ptr), cookie);\n    ptr += sizeof<usize>();\n  }\n}\n\n/** Performs a single step according to the current state. */\nfunction step(): usize {\n  // Magic constants responsible for pause times. Obtained experimentally\n  // using the compiler compiling itself. 2048 budget pro run by default.\n  const MARKCOST = isDefined(ASC_GC_MARKCOST) ? ASC_GC_MARKCOST : 1;\n  const SWEEPCOST = isDefined(ASC_GC_SWEEPCOST) ? ASC_GC_SWEEPCOST : 10;\n  let obj: Object;\n  switch (state) {\n    case STATE_IDLE: {\n      state = STATE_MARK;\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      iter = toSpace;\n      return visitCount * MARKCOST;\n    }\n    case STATE_MARK: {\n      let black = i32(!white);\n      obj = iter.next;\n      while (obj != toSpace) {\n        iter = obj;\n        if (obj.color != black) { // skip already-blacks (pointerfree)\n          obj.color = black;\n          visitCount = 0;\n          __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          return visitCount * MARKCOST;\n        }\n        obj = obj.next;\n      }\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      obj = iter.next;\n      if (obj == toSpace) {\n        visitStack(VISIT_SCAN);\n        obj = iter.next;\n        while (obj != toSpace) {\n          if (obj.color != black) {\n            obj.color = black;\n            __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          }\n          obj = obj.next;\n        }\n        let from = fromSpace;\n        fromSpace = toSpace;\n        toSpace = from;\n        white = black;\n        iter = from.next;\n        state = STATE_SWEEP;\n      }\n      return visitCount * MARKCOST;\n    }\n    case STATE_SWEEP: {\n      obj = iter;\n      if (obj != toSpace) {\n        iter = obj.next;\n        if (DEBUG) assert(obj.color == i32(!white)); // old white\n        free(obj);\n        return SWEEPCOST;\n      }\n      toSpace.nextWithColor = changetype<usize>(toSpace);\n      toSpace.prev = toSpace;\n      state = STATE_IDLE;\n      break;\n    }\n  }\n  return 0;\n}\n\n/** Frees an object. */\nfunction free(obj: Object): void {\n  if (changetype<usize>(obj) < __heap_base) {\n    obj.nextWithColor = 0; // may become linked again\n    obj.prev = changetype<Object>(0);\n  } else {\n    total -= obj.size;\n    if (isDefined(__finalize)) {\n      __finalize(changetype<usize>(obj) + TOTAL_OVERHEAD);\n    }\n    __free(changetype<usize>(obj) + BLOCK_OVERHEAD);\n  }\n}\n\n// Garbage collector interface\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __new(size: usize, id: i32): usize {\n  if (size >= OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  if (total >= threshold) interrupt();\n  let obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);\n  obj.rtId = id;\n  obj.rtSize = <u32>size;\n  obj.linkTo(fromSpace, white); // inits next/prev\n  total += obj.size;\n  let ptr = changetype<usize>(obj) + TOTAL_OVERHEAD;\n  // may be visited before being fully initialized, so must fill\n  memory.fill(ptr, 0, size);\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __renew(oldPtr: usize, size: usize): usize {\n  let oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);\n  // Update object size if its block is large enough\n  if (size <= (oldObj.mmInfo & ~3) - OBJECT_OVERHEAD) {\n    oldObj.rtSize = <u32>size;\n    return oldPtr;\n  }\n  // If not the same object anymore, we have to move it move it due to the\n  // shadow stack potentially still referencing the old object\n  let newPtr = __new(size, oldObj.rtId);\n  memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));\n  return newPtr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // Write barrier is unnecessary if non-incremental\n  if (!childPtr) return;\n  if (DEBUG) assert(parentPtr);\n  let child = changetype<Object>(childPtr - TOTAL_OVERHEAD);\n  if (child.color == white) {\n    let parent = changetype<Object>(parentPtr - TOTAL_OVERHEAD);\n    let parentColor = parent.color;\n    if (parentColor == i32(!white)) {\n      // Maintain the invariant that no black object may point to a white object.\n      if (expectMultiple) {\n        // Move the barrier \"backward\". Suitable for containers receiving multiple stores.\n        // Avoids a barrier for subsequent objects stored into the same container.\n        parent.makeGray();\n      } else {\n        // Move the barrier \"forward\". Suitable for objects receiving isolated stores.\n        child.makeGray();\n      }\n    } else if (parentColor == transparent && state == STATE_MARK) {\n      // Pinned objects are considered 'black' during the mark phase.\n      child.makeGray();\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@lazy let visitCount = 0;\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __visit(ptr: usize, cookie: i32): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (RTRACE) if (!onvisit(obj)) return;\n  if (obj.color == white) {\n    obj.makeGray();\n    ++visitCount;\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  if (ptr) {\n    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n    if (obj.color == transparent) {\n      throw new Error(E_ALREADY_PINNED);\n    }\n    obj.unlink(); // from fromSpace\n    obj.linkTo(pinSpace, transparent);\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (obj.color != transparent) {\n    throw new Error(E_NOT_PINNED);\n  }\n  if (state == STATE_MARK) {\n    // We may be right at the point after marking roots for the second time and\n    // entering the sweep phase, in which case the object would be missed if it\n    // is not only pinned but also a root. Make sure it isn't missed.\n    obj.makeGray();\n  } else {\n    obj.unlink();\n    obj.linkTo(fromSpace, white);\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  if (TRACE) trace(\"GC (full) at\", 1, total);\n  if (state > STATE_IDLE) {\n    // finish current cycle\n    while (state != STATE_IDLE) step();\n  }\n  // perform a full cycle\n  step();\n  while (state != STATE_IDLE) step();\n  threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n  if (TRACE) trace(\"GC (full) done at cur/max\", 2, total, memory.size() << 16);\n  if (RTRACE || PROFILE) oncollect(total);\n}\n\n// Garbage collector automation\n\n/** How often to interrupt. The default of 1024 means \"interrupt each 1024 bytes allocated\". */\n// @ts-ignore: decorator\n@inline const GRANULARITY: usize = isDefined(ASC_GC_GRANULARITY) ? ASC_GC_GRANULARITY : 1024;\n/** How long to interrupt. The default of 200% means \"run at double the speed of allocations\". */\n// @ts-ignore: decorator\n@inline const STEPFACTOR: usize = isDefined(ASC_GC_SWEEPFACTOR) ? ASC_GC_SWEEPFACTOR : 200;\n/** How long to idle. The default of 200% means \"wait for memory to double before kicking in again\". */\n// @ts-ignore: decorator\n@inline const IDLEFACTOR: usize = isDefined(ASC_GC_IDLEFACTOR) ? ASC_GC_IDLEFACTOR : 200;\n\n/** Threshold of memory used by objects to exceed before interrupting again. */\n// @ts-ignore: decorator\n@lazy let threshold: usize = ((<usize>memory.size() << 16) - __heap_base) >> 1;\n\n/** Performs a reasonable amount of incremental GC steps. */\nfunction interrupt(): void {\n  if (PROFILE) oninterrupt(total);\n  if (TRACE) trace(\"GC (auto) at\", 1, total);\n  let budget: isize = GRANULARITY * STEPFACTOR / 100;\n  do {\n    budget -= step();\n    if (state == STATE_IDLE) {\n      if (TRACE) trace(\"└ GC (auto) done at cur/max\", 2, total, memory.size() << 16);\n      threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n      if (PROFILE) onyield(total);\n      return;\n    }\n  } while (budget > 0);\n  if (TRACE) trace(\"└ GC (auto) ongoing at\", 1, total);\n  threshold = total + GRANULARITY * usize(total - threshold < GRANULARITY);\n  if (PROFILE) onyield(total);\n}\n","\nexport const SUCCESS = 0;\n\n","import { memory } from \"../index\"\n\nexport class HttpStdin {\n    static method: string = 'GET'\n    static path: string = '/'\n    static query: Map<string, string> = new Map()\n    static headers: Map<string, string> = new Map()\n    static body: string = ''\n\n    static initalize(): void {\n        const blsStdin = new memory.Stdin().read()\n        const blsStdinString = blsStdin.toString().replaceAll('\\0', '').trim()\n        const blsPathQuerySplit = blsStdinString.split('?')\n\n        const blsEnv = new memory.EnvVars().read()\n        const blsEnvString = blsEnv.toJSON()\n\n        if (blsEnvString.has('BLS_REQUEST_METHOD')) {\n            HttpStdin.method = blsEnvString.get('BLS_REQUEST_METHOD')!.toString()\n        }\n\n        if (blsEnvString.has('BLS_REQUEST_HEADERS')) {\n            const headers = blsEnvString.get('BLS_REQUEST_HEADERS')!.toString().split('&')\n    \n            headers.forEach(h => {\n                const header = h.split('=')\n                HttpStdin.headers.set(header[0].trim(), header.length > 1 ? header[1].trim() : '')\n            })\n        }\n\n        if (blsEnvString.has('BLS_REQUEST_BODY')) {\n            HttpStdin.body = blsEnvString.get('BLS_REQUEST_BODY')!.toString()\n        }\n\n        if (\n            blsEnvString.has('BLS_REQUEST_PATH') && \n            blsEnvString.has('BLS_REQUEST_QUERY')\n        ) {\n            HttpStdin.path = blsEnvString.get('BLS_REQUEST_PATH')!.toString()\n            const queryInput = blsEnvString.get('BLS_REQUEST_QUERY')!.toString().split('&')\n    \n            queryInput.forEach(i => {\n                const pair = i.split('=')\n                HttpStdin.query.set(pair[0].trim(), pair.length > 1 ? pair[1].trim() : '')\n            })\n        } else if (blsPathQuerySplit.length === 2) {\n            HttpStdin.path = blsPathQuerySplit[0]\n            const queryInput = blsPathQuerySplit[1].split('&')\n    \n            queryInput.forEach(i => {\n                const pair = i.split('=')\n                HttpStdin.query.set(pair[0].trim(), pair.length > 1 ? pair[1].trim() : '')\n            })\n        } else if (blsPathQuerySplit.length === 1) {\n            const blsArgumentSplit = blsPathQuerySplit[0].split(' ')\n            HttpStdin.path = blsArgumentSplit[0]\n            blsArgumentSplit.forEach(i => {\n                const pair = i.split('=')\n                HttpStdin.query.set(pair[0].trim(), pair.length > 1 ? pair[1].trim() : '')\n            })\n        }\n    }\n}\n\n","import {\r\n  proc_exit,\r\n  fd_write,\r\n  iovec,\r\n  random_get\r\n} from \"./bindings/wasi_snapshot_preview1\";\r\n\r\n// A WASI-wide reusable temporary buffer to store and work with out values. Must\r\n// be large enough to fit any operation it is used in, i.e. process/writeString.\r\n// @ts-ignore: decorator\r\n@lazy export const tempbuf = memory.data(4 * sizeof<usize>());\r\n\r\nimport {\r\n  MAX_DOUBLE_LENGTH,\r\n  decimalCount32,\r\n  dtoa_buffered\r\n} from \"util/number\";\r\n\r\nexport function wasi_abort(\r\n  message: string | null = null,\r\n  fileName: string | null = null,\r\n  lineNumber: u32 = 0,\r\n  columnNumber: u32 = 0\r\n): void {\r\n  // 0: iov.buf\r\n  // 4: iov.buf_len\r\n  // 8: len\r\n  // 12: buf...\r\n  const iovPtr: usize = 0;\r\n  const lenPtr: usize = iovPtr + offsetof<iovec>();\r\n  const bufPtr: usize = lenPtr + sizeof<usize>();\r\n  changetype<iovec>(iovPtr).buf = bufPtr;\r\n  var ptr = bufPtr;\r\n  store<u64>(ptr, 0x203A74726F6261); ptr += 7; // 'abort: '\r\n  if (message != null) {\r\n    ptr += String.UTF8.encodeUnsafe(changetype<usize>(message), message.length, ptr);\r\n  }\r\n  store<u32>(ptr, 0x206E6920); ptr += 4; // ' in '\r\n  if (fileName != null) {\r\n    ptr += String.UTF8.encodeUnsafe(changetype<usize>(fileName), fileName.length, ptr);\r\n  }\r\n  store<u8>(ptr++, 0x28); // (\r\n  var len = decimalCount32(lineNumber); ptr += len;\r\n  do {\r\n    let t = lineNumber / 10;\r\n    store<u8>(--ptr, 0x30 + lineNumber % 10);\r\n    lineNumber = t;\r\n  } while (lineNumber); ptr += len;\r\n  store<u8>(ptr++, 0x3A); // :\r\n  len = decimalCount32(columnNumber); ptr += len;\r\n  do {\r\n    let t = columnNumber / 10;\r\n    store<u8>(--ptr, 0x30 + columnNumber % 10);\r\n    columnNumber = t;\r\n  } while (columnNumber); ptr += len;\r\n  store<u16>(ptr, 0x0A29); ptr += 2; // )\\n\r\n  changetype<iovec>(iovPtr).buf_len = ptr - bufPtr;\r\n  fd_write(2, iovPtr, 1, lenPtr);\r\n  proc_exit(255);\r\n}\r\n\r\nexport function wasi_trace(\r\n  message: string,\r\n  n: i32 = 0,\r\n  a0: f64 = 0,\r\n  a1: f64 = 0,\r\n  a2: f64 = 0,\r\n  a3: f64 = 0,\r\n  a4: f64 = 0\r\n): void {\r\n  // 0: iov.buf\r\n  // 4: iov.buf_len\r\n  // 8: len\r\n  // 12: buf...\r\n  var iovPtr = __alloc(offsetof<iovec>() + sizeof<usize>() + 1 + <usize>(max(String.UTF8.byteLength(message), MAX_DOUBLE_LENGTH << 1)));\r\n  var lenPtr = iovPtr + offsetof<iovec>();\r\n  var bufPtr = lenPtr + sizeof<usize>();\r\n  changetype<iovec>(iovPtr).buf = bufPtr;\r\n  store<u64>(bufPtr, 0x203A6563617274); // 'trace: '\r\n  changetype<iovec>(iovPtr).buf_len = 7;\r\n  fd_write(2, iovPtr, 1, lenPtr);\r\n  changetype<iovec>(iovPtr).buf_len = String.UTF8.encodeUnsafe(changetype<usize>(message), message.length, bufPtr);\r\n  fd_write(2, iovPtr, 1, lenPtr);\r\n  if (n) {\r\n    store<u8>(bufPtr++, 0x20); // space\r\n    changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a0), bufPtr);\r\n    fd_write(2, iovPtr, 1, lenPtr);\r\n    if (n > 1) {\r\n      changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a1), bufPtr);\r\n      fd_write(2, iovPtr, 1, lenPtr);\r\n      if (n > 2) {\r\n        changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a2), bufPtr);\r\n        fd_write(2, iovPtr, 1, lenPtr);\r\n        if (n > 3) {\r\n          changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a3), bufPtr);\r\n          fd_write(2, iovPtr, 1, lenPtr);\r\n          if (n > 4) {\r\n            changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a4), bufPtr);\r\n            fd_write(2, iovPtr, 1, lenPtr);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    --bufPtr;\r\n  }\r\n  store<u8>(bufPtr, 0x0A); // \\n\r\n  changetype<iovec>(iovPtr).buf_len = 1;\r\n  fd_write(2, iovPtr, 1, lenPtr);\r\n  __free(iovPtr);\r\n}\r\n\r\nexport function wasi_seed(): f64 {\r\n  var rand: u64;\r\n  do {\r\n    random_get(tempbuf, 8);\r\n    rand = load<u64>(tempbuf);\r\n  } while (!rand);\r\n  return reinterpret<f64>(rand);\r\n}\r\n","// Phase: wasi_snapshot_preview1\r\n// See: https://github.com/WebAssembly/WASI/tree/main/phases/snapshot/witx\r\n\r\n// helper types to be more explicit\r\ntype char = u8;\r\ntype ptr<T> = usize; // all pointers are usize'd\r\ntype struct<T> = T;  // structs are references already in AS\r\n\r\n/** Read command-line argument data. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function args_get(\r\n  /** Input: Pointer to a buffer to write the argument pointers. */\r\n  argv: ptr<ptr<char>>,\r\n  /** Input: Pointer to a buffer to write the argument string data. */\r\n  argv_buf: ptr<char>\r\n): errno;\r\n\r\n/** Return command-line argument data sizes. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function args_sizes_get(\r\n  /** Output: Number of arguments. */\r\n  argc: ptr<usize>,\r\n  /** Output: Size of the argument string data. */\r\n  argv_buf_size: ptr<usize>\r\n): errno;\r\n\r\n/** Return the resolution of a clock. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function clock_res_get(\r\n  /** Input: The clock for which to return the resolution. */\r\n  clock: clockid,\r\n  /** Output: The resolution of the clock. */\r\n  resolution: ptr<timestamp>\r\n): errno;\r\n\r\n/** Return the time value of a clock. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function clock_time_get(\r\n  /** Input: Cock for which to return the time. */\r\n  clock: clockid,\r\n  /** Input: Maximum lag (exclusive) that the returned time value may have, compared to its actual value. */\r\n  precision: timestamp,\r\n  /** Output: Time value of the clock. */\r\n  time: ptr<timestamp>\r\n): errno;\r\n\r\n/** Read environment variable data. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function environ_get(\r\n  /** Input: Pointer to a buffer to write the environment variable pointers. */\r\n  environ: ptr<usize>,\r\n  /** Input: Pointer to a buffer to write the environment variable string data. */\r\n  environ_buf: usize\r\n): errno;\r\n\r\n/** Return command-line argument data sizes. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function environ_sizes_get(\r\n  /** Output: The number of environment variables. */\r\n  environ_count: ptr<usize>,\r\n  /** Output: The size of the environment variable string data. */\r\n  environ_buf_size: ptr<usize>\r\n): errno;\r\n\r\n/** Provide file advisory information on a file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_advise(\r\n  /** Input: The file descriptor for the file for which to provide file advisory information. */\r\n  fd: fd,\r\n  /** Input: The offset within the file to which the advisory applies. */\r\n  offset: filesize,\r\n  /** Input: The length of the region to which the advisory applies. */\r\n  len: filesize,\r\n  /** Input: The advice. */\r\n  advice: advice\r\n): errno;\r\n\r\n/** Provide file advisory information on a file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_allocate(\r\n  /** Input: The file descriptor for the file in which to allocate space. */\r\n  fd: fd,\r\n  /** Input: The offset at which to start the allocation. */\r\n  offset: filesize,\r\n  /** Input: The length of the area that is allocated. */\r\n  len: filesize\r\n): errno;\r\n\r\n/** Close a file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_close(\r\n  /** Input: The file descriptor to close. */\r\n  fd: fd\r\n): errno;\r\n\r\n/** Synchronize the data of a file to disk. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_datasync(\r\n  /** Input: The file descriptor of the file to synchronize to disk. */\r\n  fd: fd\r\n): errno;\r\n\r\n/** Get the attributes of a file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_fdstat_get(\r\n  /** Input: The file descriptor to inspect. */\r\n  fd: fd,\r\n  /** Input: The buffer where the file descriptor's attributes are stored. */\r\n  buf: struct<fdstat>\r\n): errno;\r\n\r\n/** Adjust the flags associated with a file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_fdstat_set_flags(\r\n  /** Input: The file descriptor to operate on. */\r\n  fd: fd,\r\n  /** Input: The desired values of the file descriptor flags. */\r\n  flags: fdflags\r\n): errno;\r\n\r\n/** Adjust the rights associated with a file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_fdstat_set_rights(\r\n  /** Input: The file descriptor to operate on. */\r\n  fd: fd,\r\n  /** Input: The desired rights of the file descriptor. */\r\n  fs_rights_base: rights,\r\n  /** Input: The desired rights of the file descriptor. */\r\n  fs_rights_inheriting: rights\r\n): errno;\r\n\r\n/** Return the attributes of an open file. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_filestat_get(\r\n  /** Input: The file descriptor to inspect. */\r\n  fd: fd,\r\n  /** Input: The buffer where the file's attributes are stored. */\r\n  buf: struct<filestat>\r\n): errno;\r\n\r\n/** Adjust the size of an open file. If this increases the file's size, the extra bytes are filled with zeros. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_filestat_set_size(\r\n  /** Input: A file descriptor for the file to adjust. */\r\n  fd: fd,\r\n  /** Input: The desired file size. */\r\n  size: filesize\r\n): errno;\r\n\r\n/** Adjust the timestamps of an open file or directory. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_filestat_set_times(\r\n  /** Input: The file descriptor to operate on. */\r\n  fd: fd,\r\n  /** Input: The desired values of the data access timestamp. */\r\n  st_atim: timestamp,\r\n  /** Input: The desired values of the data modification timestamp. */\r\n  st_mtim: timestamp,\r\n  /** Input: A bitmask indicating which timestamps to adjust. */\r\n  fstflags: fstflags\r\n): errno;\r\n\r\n/** Read from a file descriptor, without using and updating the file descriptor's offset. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_pread(\r\n  /** Input: The file descriptor from which to read data. */\r\n  fd: fd,\r\n  /** Input: List of scatter/gather vectors in which to store data. */\r\n  iovs: ptr<struct<iovec>>,\r\n  /** Input: Length of the list of scatter/gather vectors in which to store data. */\r\n  iovs_len: usize,\r\n  /** Input: The offset within the file at which to read. */\r\n  offset: filesize,\r\n  /** Output: The number of bytes read. */\r\n  nread: ptr<usize>\r\n): errno;\r\n\r\n/** Return a description of the given preopened file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_prestat_get(\r\n  /** Input: The file descriptor about which to retrieve information. */\r\n  fd: fd,\r\n  /** Input: The buffer where the description is stored. */\r\n  buf: struct<prestat>\r\n): errno;\r\n\r\n/** Return a description of the given preopened file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_prestat_dir_name(\r\n  /** Input: The file descriptor about which to retrieve information. */\r\n  fd: fd,\r\n  /** Input: Buffer into which to write the preopened directory name. */\r\n  path: ptr<char>,\r\n  /** Input: Length of the buffer into which to write the preopened directory name. */\r\n  path_len: usize\r\n): errno;\r\n\r\n/** Write to a file descriptor, without using and updating the file descriptor's offset. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_pwrite(\r\n  /** Input: The file descriptor to which to write data. */\r\n  fd: fd,\r\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\r\n  iovs: ptr<struct<iovec>>,\r\n  /** Input: Length of the list of scatter/gather vectors from which to retrieve data. */\r\n  iovs_len: usize,\r\n  /** Input: The offset within the file at which to write. */\r\n  offset: filesize,\r\n  /** Output: The number of bytes written. */\r\n  nwritten: ptr<usize>\r\n): errno;\r\n\r\n/** Read from a file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_read(\r\n  /** Input: The file descriptor from which to read data. */\r\n  fd: fd,\r\n  /** Input: List of scatter/gather vectors to which to store data. */\r\n  iovs: ptr<struct<iovec>>,\r\n  /** Input: Length of the list of scatter/gather vectors to which to store data. */\r\n  iovs_len: usize,\r\n  /** Output: The number of bytes read. */\r\n  nread: ptr<usize>\r\n): errno;\r\n\r\n/** Read directory entries from a directory. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_readdir(\r\n  /** Input: Directory from which to read the directory entries. */\r\n  fd: fd,\r\n  /** Input: Buffer where directory entries are stored. */\r\n  buf: ptr<struct<dirent>>,\r\n  /** Input: Length of the buffer where directory entries are stored. */\r\n  buf_len: usize,\r\n  /** Input: Location within the directory to start reading. */\r\n  cookie: dircookie,\r\n  /** Output: Number of bytes stored in the read buffer. If less than the size of the read buffer, the end of the directory has been reached. */\r\n  buf_used: ptr<usize>\r\n): errno;\r\n\r\n/** Atomically replace a file descriptor by renumbering another file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_renumber(\r\n  /** Input: The file descriptor to renumber. */\r\n  from: fd,\r\n  /** Input: The file descriptor to overwrite. */\r\n  to: fd\r\n): errno;\r\n\r\n/** Move the offset of a file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_seek(\r\n  /** Input: The file descriptor to operate on. */\r\n  fd: fd,\r\n  /** Input: The number of bytes to move. */\r\n  offset: filedelta,\r\n  /** Input: The base from which the offset is relative. */\r\n  whence: whence,\r\n  /** Output: The new offset of the file descriptor, relative to the start of the file. */\r\n  newoffset: ptr<filesize>\r\n): errno;\r\n\r\n/** Synchronize the data and metadata of a file to disk. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_sync(\r\n  /** Input: The file descriptor of the file containing the data and metadata to synchronize to disk. */\r\n  fd: fd\r\n): errno;\r\n\r\n/** Return the current offset of a file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_tell(\r\n  /** Input: The file descriptor to inspect. */\r\n  fd: fd,\r\n  /** Output: The current offset of the file descriptor, relative to the start of the file. */\r\n  newoffset: ptr<filesize>\r\n): errno;\r\n\r\n/** Write to a file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_write(\r\n  /** Input: The file descriptor to which to write data. */\r\n  fd: fd,\r\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\r\n  iovs: ptr<struct<iovec>>,\r\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\r\n  iovs_len: usize,\r\n  /** Output: The number of bytes written. */\r\n  nwritten: ptr<usize>\r\n): errno;\r\n\r\n/* Create a directory. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function path_create_directory(\r\n  /** Input: The working directory at which the resolution of the path starts. */\r\n  fd: fd,\r\n  /** Input: The path at which to create the directory. */\r\n  path: ptr<char>,\r\n  /** Input: The path at which to create the directory. */\r\n  path_len: usize\r\n): errno;\r\n\r\n/** Return the attributes of a file or directory. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function path_filestat_get(\r\n  /** Input: The working directory at which the resolution of the path starts. */\r\n  fd: fd,\r\n  /** Input: Flags determining the method of how the path is resolved. */\r\n  flags: lookupflags,\r\n  /** Input: The path of the file or directory to inspect. */\r\n  path: ptr<char>,\r\n  /** Input: The path of the file or directory to inspect. */\r\n  path_len: usize,\r\n  /** Input: The buffer where the file's attributes are stored. */\r\n  buf: struct<filestat>\r\n): errno;\r\n\r\n/** Adjust the timestamps of a file or directory. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function path_filestat_set_times(\r\n  /** Input: The working directory at which the resolution of the path starts. */\r\n  fd: fd,\r\n  /** Input: Flags determining the method of how the path is resolved. */\r\n  flags: lookupflags,\r\n  /** Input: The path of the file or directory to operate on. */\r\n  path: ptr<char>,\r\n  /** Input: The path of the file or directory to operate on. */\r\n  path_len: usize,\r\n  /** Input: The desired values of the data access timestamp. */\r\n  st_atim: timestamp,\r\n  /** Input: The desired values of the data modification timestamp. */\r\n  st_mtim: timestamp,\r\n  /** Input: A bitmask indicating which timestamps to adjust. */\r\n  fstflags: fstflags\r\n): errno;\r\n\r\n/** Create a hard link. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function path_link(\r\n  /** Input: The working directory at which the resolution of the old path starts. */\r\n  old_fd: fd,\r\n  /** Input: Flags determining the method of how the path is resolved. */\r\n  old_flags: lookupflags,\r\n  /** Input: The source path from which to link. */\r\n  old_path: ptr<char>,\r\n  /** Input: The source path from which to link. */\r\n  old_path_len: usize,\r\n  /** Input: The working directory at which the resolution of the new path starts. */\r\n  new_fd: fd,\r\n  /** Input: The destination path at which to create the hard link. */\r\n  new_path: ptr<char>,\r\n  /** Input: The length of the destination path at which to create the hard link. */\r\n  new_path_len: usize\r\n): errno;\r\n\r\n/** Open a file or directory. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function path_open(\r\n  /** Input: The working directory at which the resolution of the path starts. */\r\n  dirfd: fd,\r\n  /** Input: Flags determining the method of how the path is resolved. */\r\n  dirflags: lookupflags,\r\n  /** Input: The path of the file or directory to open. */\r\n  path: ptr<char>,\r\n  /** Input: The length of the path of the file or directory to open. */\r\n  path_len: usize,\r\n  /** Input: The method by which to open the file. */\r\n  oflags: oflags,\r\n  /** Input: The initial base rights that apply to operations using the file descriptor itself. */\r\n  fs_rights_base: rights,\r\n  /** Input: The initial inheriting rights that apply to file descriptors derived from it. */\r\n  fs_rights_inheriting: rights,\r\n  /** Input: The initial flags of the file descriptor. */\r\n  fs_flags: fdflags,\r\n  /** Output: The file descriptor of the file that has been opened. */\r\n  fd: ptr<fd>\r\n): errno;\r\n\r\n/** Read the contents of a symbolic link. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function path_readlink(\r\n  /** Input: The working directory at which the resolution of the path starts. */\r\n  fd: fd,\r\n  /** Input: The path of the symbolic link from which to read. */\r\n  path: ptr<char>,\r\n  /** Input: The length of the path of the symbolic link from which to read. */\r\n  path_len: usize,\r\n  /** Input: The buffer to which to write the contents of the symbolic link. */\r\n  buf: ptr<char>,\r\n  /** Input: The length of the buffer to which to write the contents of the symbolic link. */\r\n  buf_len: usize,\r\n  /** Output: The number of bytes placed in the buffer. */\r\n  buf_used: ptr<usize>\r\n): errno;\r\n\r\n/** Remove a directory. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function path_remove_directory(\r\n  /** Input: The working directory at which the resolution of the path starts. */\r\n  fd: fd,\r\n  /** Input: The path to a directory to remove. */\r\n  path: ptr<char>,\r\n  /** Input: The length of the path to a directory to remove. */\r\n  path_len: usize\r\n): errno;\r\n\r\n/** Rename a file or directory. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function path_rename(\r\n  /** Input: The working directory at which the resolution of the old path starts. */\r\n  old_fd: fd,\r\n  /** Input: The source path of the file or directory to rename. */\r\n  old_path: ptr<char>,\r\n  /** Input: The length of the source path of the file or directory to rename. */\r\n  old_path_len: usize,\r\n  /** Input: The working directory at which the resolution of the new path starts. */\r\n  new_fd: fd,\r\n  /** Input: The destination path to which to rename the file or directory. */\r\n  new_path: ptr<char>,\r\n  /** Input: The length of the destination path to which to rename the file or directory. */\r\n  new_path_len: usize\r\n): errno;\r\n\r\n/** Create a symbolic link. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function path_symlink(\r\n  /** Input: The contents of the symbolic link. */\r\n  old_path: ptr<char>,\r\n  /** Input: The length of the contents of the symbolic link. */\r\n  old_path_len: usize,\r\n  /** Input: The working directory at which the resolution of the path starts. */\r\n  fd: fd,\r\n  /** Input: The destination path at which to create the symbolic link. */\r\n  new_path: ptr<char>,\r\n  /** Input: The length of the destination path at which to create the symbolic link. */\r\n  new_path_len: usize\r\n): errno;\r\n\r\n/** Unlink a file. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function path_unlink_file(\r\n  /** Input: The working directory at which the resolution of the path starts. */\r\n  fd: fd,\r\n  /** Input: The path to a file to unlink. */\r\n  path: ptr<char>,\r\n  /** Input: The length of the path to a file to unlink. */\r\n  path_len: usize\r\n): errno;\r\n\r\n/** Concurrently poll for the occurrence of a set of events. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function poll_oneoff(\r\n  /** Input: The events to which to subscribe. */\r\n  in_: ptr<struct<subscription>>,\r\n  /** Input: The events that have occurred. */\r\n  out: ptr<struct<event>>,\r\n  /** Input: Both the number of subscriptions and events. */\r\n  nsubscriptions: usize,\r\n  /** Output: The number of events stored. */\r\n  nevents: ptr<usize>\r\n): errno;\r\n\r\n/** Terminate the process normally. An exit code of 0 indicates successful termination of the program. The meanings of other values is dependent on the environment. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function proc_exit(\r\n  /** Input: The exit code returned by the process. */\r\n  rval: u32\r\n): void;\r\n\r\n/** Send a signal to the process of the calling thread. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function proc_raise(\r\n  /** Input: The signal condition to trigger. */\r\n  sig: signal\r\n): errno;\r\n\r\n/** Write high-quality random data into a buffer. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function random_get(\r\n  /** Input: The buffer to fill with random data. */\r\n  buf: usize,\r\n  /** Input: The length of the buffer to fill with random data. */\r\n  buf_len: usize\r\n): errno;\r\n\r\n/** Temporarily yield execution of the calling thread. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function sched_yield(): errno;\r\n\r\n/** Receive a message from a socket. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function sock_recv(\r\n  /** Input: The socket on which to receive data. */\r\n  sock: fd,\r\n  /** Input: List of scatter/gather vectors to which to store data. */\r\n  ri_data: ptr<struct<iovec>>,\r\n  /** Input: The length of the list of scatter/gather vectors to which to store data. */\r\n  ri_data_len: usize,\r\n  /** Input: Message flags. */\r\n  ri_flags: riflags,\r\n  /** Output: Number of bytes stored in `ri_data`. */\r\n  ro_datalen: ptr<usize>,\r\n  /** Output: Message flags. */\r\n  ro_flags: ptr<roflags>\r\n): errno;\r\n\r\n/** Send a message on a socket. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function sock_send(\r\n  /** Input: The socket on which to send data. */\r\n  sock: fd,\r\n  /** Input: List of scatter/gather vectors to which to retrieve data */\r\n  si_data: ptr<struct<iovec>>,\r\n  /** Input: The length of the list of scatter/gather vectors to which to retrieve data */\r\n  si_data_len: usize,\r\n  /** Input: Message flags. */\r\n  si_flags: siflags,\r\n  /** Output: Number of bytes transmitted. */\r\n  so_datalen: ptr<usize>\r\n): errno;\r\n\r\n/** Shut down socket send and receive channels. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function sock_shutdown(\r\n  /** Input: The socket on which to shutdown channels. */\r\n  sock: fd,\r\n  /** Input: Which channels on the socket to shut down. */\r\n  how: sdflags\r\n): errno;\r\n\r\n// === Types ======================================================================================\r\n\r\n/** File or memory access pattern advisory information. */\r\nexport namespace advice {\r\n  /** The application has no advice to give on its behavior with respect to the specified data. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NORMAL: advice = 0;\r\n  /** The application expects to access the specified data sequentially from lower offsets to higher offsets. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SEQUENTIAL : advice = 1;\r\n  /** The application expects to access the specified data in a random order. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const RANDOM: advice = 2;\r\n  /** The application expects to access the specified data in the near future. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const WILLNEED: advice = 3;\r\n  /** The application expects that it will not access the specified data in the near future. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const DONTNEED: advice = 4;\r\n  /** The application expects to access the specified data once and then not reuse it thereafter. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOREUSE: advice = 5;\r\n}\r\nexport type advice = u8;\r\n\r\n/** Identifiers for clocks. */\r\nexport namespace clockid {\r\n  /** The clock measuring real time. Time value zero corresponds with 1970-01-01T00:00:00Z. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const REALTIME: clockid = 0;\r\n  /** The store-wide monotonic clock. Absolute value has no meaning. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const MONOTONIC: clockid = 1;\r\n  /** The CPU-time clock associated with the current process. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PROCESS_CPUTIME_ID: clockid = 2;\r\n  /** The CPU-time clock associated with the current thread. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const THREAD_CPUTIME_ID: clockid = 3;\r\n}\r\nexport type clockid = u32;\r\n\r\n/** Identifier for a device containing a file system. Can be used in combination with `inode` to uniquely identify a file or directory in the filesystem. */\r\nexport type device = u64;\r\n\r\n/** A reference to the offset of a directory entry. The value 0 signifies the start of the directory. */\r\nexport type dircookie = u64;\r\n\r\n/** A directory entry. */\r\n@unmanaged export class dirent {\r\n  /** The offset of the next directory entry stored in this directory. */\r\n  next: dircookie;\r\n  /** The serial number of the file referred to by this directory entry. */\r\n  ino: inode;\r\n  /** The length of the name of the directory entry. */\r\n  namlen: u32;\r\n  /** The type of the file referred to by this directory entry. */\r\n  type: filetype;\r\n  private __padding0: u16;\r\n}\r\n\r\n/** Error codes returned by functions. */\r\nexport namespace errno {\r\n  /** No error occurred. System call completed successfully. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SUCCESS: errno = 0;\r\n  /** Argument list too long. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const TOOBIG: errno = 1;\r\n  /** Permission denied. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ACCES: errno = 2;\r\n  /** Address in use. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ADDRINUSE: errno = 3;\r\n  /** Address not available. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ADDRNOTAVAIL: errno = 4;\r\n  /** Address family not supported. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const AFNOSUPPORT: errno = 5;\r\n  /** Resource unavailable, or operation would block. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const AGAIN: errno = 6;\r\n  /** Connection already in progress. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ALREADY: errno = 7;\r\n  /** Bad file descriptor. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const BADF: errno = 8;\r\n  /** Bad message. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const BADMSG: errno = 9;\r\n  /** Device or resource busy. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const BUSY: errno = 10;\r\n  /** Operation canceled. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const CANCELED: errno = 11;\r\n  /** No child processes. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const CHILD: errno = 12;\r\n  /** Connection aborted. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const CONNABORTED: errno = 13;\r\n  /** Connection refused. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const CONNREFUSED: errno = 14;\r\n  /** Connection reset. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const CONNRESET: errno = 15;\r\n  /** Resource deadlock would occur. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const DEADLK: errno = 16;\r\n  /** Destination address required. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const DESTADDRREQ: errno = 17;\r\n  /** Mathematics argument out of domain of function. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const DOM: errno = 18;\r\n  /** Reserved. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const DQUOT: errno = 19;\r\n  /** File exists. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const EXIST: errno = 20;\r\n  /** Bad address. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FAULT: errno = 21;\r\n  /** File too large. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FBIG: errno = 22;\r\n  /** Host is unreachable. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const HOSTUNREACH: errno = 23;\r\n  /** Identifier removed. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const IDRM: errno = 24;\r\n  /** Illegal byte sequence. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ILSEQ: errno = 25;\r\n  /** Operation in progress. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const INPROGRESS: errno = 26;\r\n  /** Interrupted function. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const INTR: errno = 27;\r\n  /** Invalid argument. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const INVAL: errno = 28;\r\n  /** I/O error. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const IO: errno = 29;\r\n  /** Socket is connected. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ISCONN: errno = 30;\r\n  /** Is a directory. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ISDIR: errno = 31;\r\n  /** Too many levels of symbolic links. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const LOOP: errno = 32;\r\n  /** File descriptor value too large. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const MFILE: errno = 33;\r\n  /** Too many links. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const MLINK: errno = 34;\r\n  /** Message too large. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const MSGSIZE: errno = 35;\r\n  /** Reserved. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const MULTIHOP: errno = 36;\r\n  /** Filename too long. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NAMETOOLONG: errno = 37;\r\n  /** Network is down. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NETDOWN: errno = 38;\r\n  /** Connection aborted by network. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NETRESET: errno = 39;\r\n  /** Network unreachable. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NETUNREACH: errno = 40;\r\n  /** Too many files open in system. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NFILE: errno = 41;\r\n  /** No buffer space available. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOBUFS: errno = 42;\r\n  /** No such device. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NODEV: errno = 43;\r\n  /** No such file or directory. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOENT: errno = 44;\r\n  /** Executable file format error. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOEXEC: errno = 45;\r\n  /** No locks available. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOLCK: errno = 46;\r\n  /** Reserved. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOLINK: errno = 47;\r\n  /** Not enough space. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOMEM: errno = 48;\r\n  /** No message of the desired type. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOMSG: errno = 49;\r\n  /** Protocol not available. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOPROTOOPT: errno = 50;\r\n  /** No space left on device. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOSPC: errno = 51;\r\n  /** Function not supported. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOSYS: errno = 52;\r\n  /** The socket is not connected. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOTCONN: errno = 53;\r\n  /** Not a directory or a symbolic link to a directory. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOTDIR: errno = 54;\r\n  /** Directory not empty. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOTEMPTY: errno = 55;\r\n  /** State not recoverable. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOTRECOVERABLE: errno = 56;\r\n  /** Not a socket. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOTSOCK: errno = 57;\r\n  /** Not supported, or operation not supported on socket. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOTSUP: errno = 58;\r\n  /** Inappropriate I/O control operation. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOTTY: errno = 59;\r\n  /** No such device or address. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NXIO: errno = 60;\r\n  /** Value too large to be stored in data type. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const OVERFLOW: errno = 61;\r\n  /** Previous owner died. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const OWNERDEAD: errno = 62;\r\n  /** Operation not permitted. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PERM: errno = 63;\r\n  /** Broken pipe. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PIPE: errno = 64;\r\n  /** Protocol error. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PROTO: errno = 65;\r\n  /** Protocol not supported. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PROTONOSUPPORT: errno = 66;\r\n  /** Protocol wrong type for socket. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PROTOTYPE: errno = 67;\r\n  /** Result too large. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const RANGE: errno = 68;\r\n  /** Read-only file system. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ROFS: errno = 69;\r\n  /** Invalid seek. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SPIPE: errno = 70;\r\n  /** No such process. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SRCH: errno = 71;\r\n  /** Reserved. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const STALE: errno = 72;\r\n  /** Connection timed out. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const TIMEDOUT: errno = 73;\r\n  /** Text file busy. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const TXTBSY: errno = 74;\r\n  /** Cross-device link. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const XDEV: errno = 75;\r\n  /** Extension: Capabilities insufficient. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOTCAPABLE: errno = 76;\r\n}\r\nexport type errno = u16;\r\n\r\n/** Translates an error code to a string. */\r\nexport function errnoToString(err: errno): string {\r\n  switch (err) {\r\n    case errno.SUCCESS: return \"SUCCESS\";\r\n    case errno.TOOBIG: return \"TOOBIG\";\r\n    case errno.ACCES: return \"ACCES\";\r\n    case errno.ADDRINUSE: return \"ADDRINUSE\";\r\n    case errno.ADDRNOTAVAIL: return \"ADDRNOTAVAIL\";\r\n    case errno.AFNOSUPPORT: return \"AFNOSUPPORT\";\r\n    case errno.AGAIN: return \"AGAIN\";\r\n    case errno.ALREADY: return \"ALREADY\";\r\n    case errno.BADF: return \"BADF\";\r\n    case errno.BADMSG: return \"BADMSG\";\r\n    case errno.BUSY: return \"BUSY\";\r\n    case errno.CANCELED: return \"CANCELED\";\r\n    case errno.CHILD: return \"CHILD\";\r\n    case errno.CONNABORTED: return \"CONNABORTED\";\r\n    case errno.CONNREFUSED: return \"CONNREFUSED\";\r\n    case errno.CONNRESET: return \"CONNRESET\";\r\n    case errno.DEADLK: return \"DEADLK\";\r\n    case errno.DESTADDRREQ: return \"DESTADDRREQ\";\r\n    case errno.DOM: return \"DOM\";\r\n    case errno.DQUOT: return \"DQUOT\";\r\n    case errno.EXIST: return \"EXIST\";\r\n    case errno.FAULT: return \"FAULT\";\r\n    case errno.FBIG: return \"FBIG\";\r\n    case errno.HOSTUNREACH: return \"HOSTUNREACH\";\r\n    case errno.IDRM: return \"IDRM\";\r\n    case errno.ILSEQ: return \"ILSEQ\";\r\n    case errno.INPROGRESS: return \"INPROGRESS\";\r\n    case errno.INTR: return \"INTR\";\r\n    case errno.INVAL: return \"INVAL\";\r\n    case errno.IO: return \"IO\";\r\n    case errno.ISCONN: return \"ISCONN\";\r\n    case errno.ISDIR: return \"ISDIR\";\r\n    case errno.LOOP: return \"LOOP\";\r\n    case errno.MFILE: return \"MFILE\";\r\n    case errno.MLINK: return \"MLINK\";\r\n    case errno.MSGSIZE: return \"MSGSIZE\";\r\n    case errno.MULTIHOP: return \"MULTIHOP\";\r\n    case errno.NAMETOOLONG: return \"NAMETOOLONG\";\r\n    case errno.NETDOWN: return \"NETDOWN\";\r\n    case errno.NETRESET: return \"NETRESET\";\r\n    case errno.NETUNREACH: return \"NETUNREACH\";\r\n    case errno.NFILE: return \"NFILE\";\r\n    case errno.NOBUFS: return \"NOBUFS\";\r\n    case errno.NODEV: return \"NODEV\";\r\n    case errno.NOENT: return \"NOENT\";\r\n    case errno.NOEXEC: return \"NOEXEC\";\r\n    case errno.NOLCK: return \"NOLCK\";\r\n    case errno.NOLINK: return \"NOLINK\";\r\n    case errno.NOMEM: return \"NOMEM\";\r\n    case errno.NOMSG: return \"NOMSG\";\r\n    case errno.NOPROTOOPT: return \"NOPROTOOPT\";\r\n    case errno.NOSPC: return \"NOSPC\";\r\n    case errno.NOSYS: return \"NOSYS\";\r\n    case errno.NOTCONN: return \"NOTCONN\";\r\n    case errno.NOTDIR: return \"NOTDIR\";\r\n    case errno.NOTEMPTY: return \"NOTEMPTY\";\r\n    case errno.NOTRECOVERABLE: return \"NOTRECOVERABLE\";\r\n    case errno.NOTSOCK: return \"NOTSOCK\";\r\n    case errno.NOTSUP: return \"NOTSUP\";\r\n    case errno.NOTTY: return \"NOTTY\";\r\n    case errno.NXIO: return \"NXIO\";\r\n    case errno.OVERFLOW: return \"OVERFLOW\";\r\n    case errno.OWNERDEAD: return \"OWNERDEAD\";\r\n    case errno.PERM: return \"PERM\";\r\n    case errno.PIPE: return \"PIPE\";\r\n    case errno.PROTO: return \"PROTO\";\r\n    case errno.PROTONOSUPPORT: return \"PROTONOSUPPORT\";\r\n    case errno.PROTOTYPE: return \"PROTOTYPE\";\r\n    case errno.RANGE: return \"RANGE\";\r\n    case errno.ROFS: return \"ROFS\";\r\n    case errno.SPIPE: return \"SPIPE\";\r\n    case errno.SRCH: return \"SRCH\";\r\n    case errno.STALE: return \"STALE\";\r\n    case errno.TIMEDOUT: return \"TIMEDOUT\";\r\n    case errno.TXTBSY: return \"TXTBSY\";\r\n    case errno.XDEV: return \"XDEV\";\r\n    case errno.NOTCAPABLE: return \"NOTCAPABLE\";\r\n  }\r\n  return \"UNKNOWN\";\r\n}\r\n\r\n@unmanaged abstract class $event { // size=16/32\r\n  /** User-provided value that got attached to `subscription#userdata`. */\r\n  userdata: userdata;\r\n  /** If non-zero, an error that occurred while processing the subscription request. */\r\n  error: errno;\r\n  /** The type of the event that occurred. */\r\n  type: eventtype;\r\n\r\n  private __padding0: u16;\r\n}\r\n\r\n/** An event that occurred. */\r\n@unmanaged export abstract class event extends $event {\r\n  private __padding1: u64;\r\n  private __padding2: u64;\r\n}\r\n\r\n/** An event that occurred when type is `eventtype.FD_READ` or `eventtype.FD_WRITE`. */\r\n@unmanaged export class event_fd_readwrite extends $event {\r\n  /* The number of bytes available for reading or writing. */\r\n  nbytes: filesize;\r\n  /* The state of the file descriptor. */\r\n  flags: eventrwflags;\r\n\r\n  private __padding1: u32;\r\n}\r\n\r\n/** The state of the file descriptor subscribed to with `eventtype.FD_READ` or `eventtype.FD_WRITE`. */\r\nexport namespace eventrwflags {\r\n  /** The peer of this socket has closed or disconnected. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const HANGUP: eventrwflags = 1;\r\n}\r\nexport type eventrwflags = u16;\r\n\r\n/** Type of a subscription to an event or its occurrence. */\r\nexport namespace eventtype {\r\n  /** The time value of clock has reached the timestamp. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const CLOCK: eventtype = 0;\r\n  /** File descriptor has data available for reading. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_READ: eventtype = 1;\r\n  /** File descriptor has capacity available for writing */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_WRITE: eventtype = 2;\r\n}\r\nexport type eventtype = u8;\r\n\r\n/** Exit code generated by a process when exiting. */\r\nexport type exitcode = u32;\r\n\r\n/** A file descriptor number. */\r\nexport type fd = u32;\r\n\r\n/** File descriptor flags. */\r\nexport namespace fdflags {\r\n  /** Append mode: Data written to the file is always appended to the file's end. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const APPEND: fdflags = 1;\r\n  /** Write according to synchronized I/O data integrity completion. Only the data stored in the file is synchronized. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const DSYNC: fdflags = 2;\r\n  /** Non-blocking mode. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NONBLOCK: fdflags = 4;\r\n  /** Synchronized read I/O operations. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const RSYNC: fdflags = 8;\r\n  /** Write according to synchronized I/O file integrity completion. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SYNC: fdflags = 16;\r\n}\r\nexport type fdflags = u16;\r\n\r\n/** File descriptor attributes. */\r\n@unmanaged export class fdstat {\r\n  /** File type. */\r\n  filetype: filetype;\r\n  /** File descriptor flags. */\r\n  flags: fdflags;\r\n  /** Rights that apply to this file descriptor. */\r\n  rights_base: rights;\r\n  /** Maximum set of rights that may be installed on new file descriptors that are created through this file descriptor, e.g., through `path_open`. */\r\n  rights_inheriting: rights;\r\n}\r\n\r\n/** Relative offset within a file. */\r\nexport type filedelta = i64;\r\n\r\n/** Non-negative file size or length of a region within a file. */\r\nexport type filesize = u64;\r\n\r\n/** File attributes. */\r\n@unmanaged export class filestat {\r\n  /** Device ID of device containing the file. */\r\n  dev: device;\r\n  /** File serial number. */\r\n  ino: inode;\r\n  /** File type. */\r\n  filetype: filetype;\r\n  /** Number of hard links to the file. */\r\n  nlink: linkcount;\r\n  /** For regular files, the file size in bytes. For symbolic links, the length in bytes of the pathname contained in the symbolic link. */\r\n  size: filesize;\r\n  /** Last data access timestamp. */\r\n  atim: timestamp;\r\n  /** Last data modification timestamp. */\r\n  mtim: timestamp;\r\n  /** Last file status change timestamp. */\r\n  ctim: timestamp;\r\n}\r\n\r\n/** The type of a file descriptor or file. */\r\nexport namespace filetype {\r\n  /** The type of the file descriptor or file is unknown or is different from any of the other types specified. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const UNKNOWN: filetype = 0;\r\n  /** The file descriptor or file refers to a block device inode. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const BLOCK_DEVICE: filetype = 1;\r\n  /** The file descriptor or file refers to a character device inode. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const CHARACTER_DEVICE: filetype = 2;\r\n  /** The file descriptor or file refers to a directory inode. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const DIRECTORY: filetype = 3;\r\n  /** The file descriptor or file refers to a regular file inode. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const REGULAR_FILE: filetype = 4;\r\n  /** The file descriptor or file refers to a datagram socket. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SOCKET_DGRAM: filetype = 5;\r\n  /** The file descriptor or file refers to a byte-stream socket. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SOCKET_STREAM: filetype = 6;\r\n  /** The file refers to a symbolic link inode. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SYMBOLIC_LINK: filetype = 7;\r\n}\r\nexport type filetype = u8;\r\n\r\n/** Which file time attributes to adjust. */\r\nexport namespace fstflags {\r\n  /** Adjust the last data access timestamp to the value stored in `filestat#st_atim`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SET_ATIM: fstflags = 1;\r\n  /** Adjust the last data access timestamp to the time of clock `clockid.REALTIME`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SET_ATIM_NOW: fstflags = 2;\r\n  /** Adjust the last data modification timestamp to the value stored in `filestat#st_mtim`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SET_MTIM: fstflags = 4;\r\n  /** Adjust the last data modification timestamp to the time of clock `clockid.REALTIME`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SET_MTIM_NOW: fstflags = 8;\r\n}\r\nexport type fstflags = u16;\r\n\r\n/** File serial number that is unique within its file system. */\r\nexport type inode = u64;\r\n\r\n/** A region of memory for scatter/gather reads. */\r\n@unmanaged export class iovec {\r\n  /** The address of the buffer to be filled. */\r\n  buf: usize;\r\n  /** The length of the buffer to be filled. */\r\n  buf_len: usize;\r\n}\r\n\r\n/** Number of hard links to an inode. */\r\nexport type linkcount = u64;\r\n\r\n/** Flags determining the method of how paths are resolved. */\r\nexport namespace lookupflags {\r\n  /** As long as the resolved path corresponds to a symbolic link, it is expanded. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SYMLINK_FOLLOW: lookupflags = 1;\r\n}\r\nexport type lookupflags = u32;\r\n\r\n/** Open flags. */\r\nexport namespace oflags {\r\n  /** Create file if it does not exist. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const CREAT: oflags = 1;\r\n  /** Fail if not a directory. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const DIRECTORY: oflags = 2;\r\n  /** Fail if file already exists. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const EXCL: oflags = 4;\r\n  /** Truncate file to size 0. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const TRUNC: oflags = 8;\r\n}\r\nexport type oflags = u16;\r\n\r\n/** Identifiers for preopened capabilities. */\r\nexport namespace preopentype {\r\n  /** A pre-opened directory. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const DIR: preopentype = 0;\r\n}\r\nexport type preopentype = u8;\r\n\r\n@unmanaged abstract class $prestat { // WASM32: size=1/8, WASM64: size=1/16\r\n  /* The type of the pre-opened capability. */\r\n  type: preopentype;\r\n}\r\n\r\n/* Information about a pre-opened capability. */\r\n@unmanaged export abstract class prestat extends $prestat {\r\n  private __padding0: usize;\r\n}\r\n\r\n/** The contents of a $prestat when type is `preopentype.DIR`. */\r\n@unmanaged export class prestat_dir extends $prestat {\r\n  /** The length of the directory name for use with `fd_prestat_dir_name`. */\r\n  name_len: usize;\r\n}\r\n\r\n/** Flags provided to `sock_recv`. */\r\nexport namespace riflags {\r\n  /** Returns the message without removing it from the socket's receive queue. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PEEK: riflags = 1;\r\n  /** On byte-stream sockets, block until the full amount of data can be returned. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const WAITALL: riflags = 2;\r\n}\r\nexport type riflags = u16;\r\n\r\n/** File descriptor rights, determining which actions may be performed. */\r\nexport namespace rights {\r\n  /** The right to invoke `fd_datasync`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_DATASYNC: rights = 1;\r\n  /** The right to invoke `fd_read` and `sock_recv`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_READ: rights = 2;\r\n  /** The right to invoke `fd_seek`. This flag implies `rights.FD_TELL`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_SEEK: rights = 4;\r\n  /** The right to invoke `fd_fdstat_set_flags`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_FDSTAT_SET_FLAGS: rights = 8;\r\n  /** The right to invoke `fd_sync`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_SYNC: rights = 16;\r\n  /** The right to invoke `fd_seek` in such a way that the file offset remains unaltered (i.e., `whence.CUR` with offset zero), or to invoke `fd_tell`). */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_TELL: rights = 32;\r\n  /** The right to invoke `fd_write` and `sock_send`. If `rights.FD_SEEK` is set, includes the right to invoke `fd_pwrite`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_WRITE: rights = 64;\r\n  /** The right to invoke `fd_advise`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_ADVISE: rights = 128;\r\n  /** The right to invoke `fd_allocate`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_ALLOCATE: rights = 256;\r\n  /** The right to invoke `path_create_directory`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_CREATE_DIRECTORY: rights = 512;\r\n  /** If `rights.PATH_OPEN` is set, the right to invoke `path_open` with `oflags.CREAT`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_CREATE_FILE: rights = 1024;\r\n  /** The right to invoke `path_link` with the file descriptor as the source directory. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_LINK_SOURCE: rights = 2048;\r\n  /** The right to invoke `path_link` with the file descriptor as the target directory. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_LINK_TARGET: rights = 4096;\r\n  /** The right to invoke `path_open`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_OPEN: rights = 8192;\r\n  /** The right to invoke `fd_readdir`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_READDIR: rights = 16384;\r\n  /** The right to invoke `path_readlink`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_READLINK: rights = 32768;\r\n  /** The right to invoke `path_rename` with the file descriptor as the source directory. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_RENAME_SOURCE: rights = 65536;\r\n  /** The right to invoke `path_rename` with the file descriptor as the target directory. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_RENAME_TARGET: rights = 131072;\r\n  /** The right to invoke `path_filestat_get`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_FILESTAT_GET: rights = 262144;\r\n  /** The right to change a file's size (there is no `path_filestat_set_size`). If `rights.PATH_OPEN` is set, includes the right to invoke `path_open` with `oflags.TRUNC`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_FILESTAT_SET_SIZE: rights = 524288;\r\n  /** The right to invoke `path_filestat_set_times`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_FILESTAT_SET_TIMES: rights = 1048576;\r\n  /** The right to invoke `fd_filestat_get`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_FILESTAT_GET: rights = 2097152;\r\n  /** The right to invoke `fd_filestat_set_size`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_FILESTAT_SET_SIZE: rights = 4194304;\r\n  /** The right to invoke `fd_filestat_set_times`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_FILESTAT_SET_TIMES: rights = 8388608;\r\n  /** The right to invoke `path_symlink`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const RIGHT_PATH_SYMLINK: rights = 16777216;\r\n  /** The right to invoke `path_remove_directory`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_REMOVE_DIRECTORY: rights = 33554432;\r\n  /** The right to invoke `path_unlink_file`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_UNLINK_FILE: rights = 67108864;\r\n  /** If `rights.FD_READ` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_READ`. If `rights.FD_WRITE` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_WRITE`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const POLL_FD_READWRITE: rights = 134217728;\r\n  /** The right to invoke `sock_shutdown`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SOCK_SHUTDOWN: rights = 268435456;\r\n}\r\nexport type rights = u64;\r\n\r\n/** Flags returned by `sock_recv`. */\r\nexport namespace roflags {\r\n  /** Message data has been truncated. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const DATA_TRUNCATED: roflags = 1;\r\n}\r\nexport type roflags = u16;\r\n\r\n/** Which channels on a socket to shut down. */\r\nexport namespace sdflags {\r\n  /** Disables further receive operations. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const RD: sdflags = 1;\r\n  /** Disables further send operations. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const WR: sdflags = 2;\r\n}\r\nexport type sdflags = u8;\r\n\r\n/** Flags provided to `sock_send`. */\r\nexport namespace siflags {\r\n  // As there are currently no flags defined, it must be set to zero.\r\n}\r\nexport type siflags = u16;\r\n\r\n/** Signal condition. */\r\nexport namespace signal {\r\n  /** Hangup. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const HUP: signal = 1;\r\n  /** Terminate interrupt signal. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const INT: signal = 2;\r\n  /** Terminal quit signal. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const QUIT: signal = 3;\r\n  /** Illegal instruction. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ILL: signal = 4;\r\n  /** Trace/breakpoint trap. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const TRAP: signal = 5;\r\n  /** Process abort signal. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ABRT: signal = 6;\r\n  /** Access to an undefined portion of a memory object. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const BUS: signal = 7;\r\n  /** Erroneous arithmetic operation. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FPE: signal = 8;\r\n  /** Kill. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const KILL: signal = 9;\r\n  /** User-defined signal 1. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const USR1: signal = 10;\r\n  /** Invalid memory reference. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SEGV: signal = 11;\r\n  /** User-defined signal 2. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const USR2: signal = 12;\r\n  /** Write on a pipe with no one to read it. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PIPE: signal = 13;\r\n  /** Alarm clock. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ALRM: signal = 14;\r\n  /** Termination signal. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const TERM: signal = 15;\r\n  /** Child process terminated, stopped, or continued. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const CHLD: signal = 16;\r\n  /** Continue executing, if stopped. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const CONT: signal = 17;\r\n  /** Stop executing. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const STOP: signal = 18;\r\n  /** Terminal stop signal. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const TSTP: signal = 19;\r\n  /** Background process attempting read. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const TTIN: signal = 20;\r\n  /** Background process attempting write. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const TTOU: signal = 21;\r\n  /** High bandwidth data is available at a socket. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const URG: signal = 22;\r\n  /** CPU time limit exceeded. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const XCPU: signal = 23;\r\n  /** File size limit exceeded. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const XFSZ: signal = 24;\r\n  /** Virtual timer expired. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const VTALRM: signal = 25;\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PROF: signal = 26;\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const WINCH: signal = 27;\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const POLL: signal = 28;\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PWR: signal = 29;\r\n  /** Bad system call. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SYS: signal = 30;\r\n}\r\nexport type signal = u8;\r\n\r\n/** Flags determining how to interpret the timestamp provided in `subscription_t::u.clock.timeout. */\r\nexport namespace subclockflags {\r\n  /** If set, treat the timestamp provided in `clocksubscription` as an absolute timestamp. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ABSTIME: subclockflags = 1;\r\n}\r\nexport type subclockflags = u16;\r\n\r\n@unmanaged abstract class $subscription { // size=16/48\r\n  /** User-provided value that is attached to the subscription. */\r\n  userdata: userdata;\r\n  /** The type of the event to which to subscribe. */\r\n  type: eventtype;\r\n\r\n  private __padding0: u32;\r\n}\r\n\r\n/** Subscription to an event. */\r\n@unmanaged export abstract class subscription extends $subscription {\r\n  private __padding1: u64;\r\n  private __padding2: u64;\r\n  private __padding3: u64;\r\n  private __padding4: u64;\r\n}\r\n\r\n/* Subscription to an event of type `eventtype.CLOCK`.**/\r\n@unmanaged export class subscription_clock extends $subscription {\r\n  /** The clock against which to compare the timestamp. */\r\n  clock_id: clockid;\r\n  /** The absolute or relative timestamp. */\r\n  timeout: timestamp;\r\n  /** The amount of time that the implementation may wait additionally to coalesce with other events. */\r\n  precision: timestamp;\r\n  /** Flags specifying whether the timeout is absolute or relative. */\r\n  flags: subclockflags;\r\n\r\n  private __padding1: u32;\r\n}\r\n\r\n/* Subscription to an event of type `eventtype.FD_READ` or `eventtype.FD_WRITE`.**/\r\n@unmanaged export class subscription_fd_readwrite extends $subscription {\r\n  /** The file descriptor on which to wait for it to become ready for reading or writing. */\r\n  file_descriptor: fd;\r\n\r\n  private __padding1: u64;\r\n  private __padding2: u64;\r\n  private __padding3: u64;\r\n}\r\n\r\n/** Timestamp in nanoseconds. */\r\nexport type timestamp = u64;\r\n\r\n/** User-provided value that may be attached to objects that is retained when extracted from the implementation. */\r\nexport type userdata = u64;\r\n\r\n/** The position relative to which to set the offset of the file descriptor. */\r\nexport namespace whence {\r\n  /** Seek relative to start-of-file. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SET: whence = 0;\r\n  /** Seek relative to current position. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const CUR: whence = 1;\r\n  /** Seek relative to end-of-file. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const END: whence = 2;\r\n}\r\n\r\nexport type whence = u8;\r\n","//\n// Lookup data for exp2f\n//\n\n// @ts-ignore: decorator\n@inline const EXP2F_TABLE_BITS = 5;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP2F_DATA_TAB = memory.data<u64>([\n  // exp2f_data_tab[i] = uint(2^(i/N)) - (i << 52-BITS)\n  // used for computing 2^(k/N) for an int |k| < 150 N as\n  // double(tab[k%N] + (k << 52-BITS))\n  0x3FF0000000000000, 0x3FEFD9B0D3158574, 0x3FEFB5586CF9890F, 0x3FEF9301D0125B51,\n  0x3FEF72B83C7D517B, 0x3FEF54873168B9AA, 0x3FEF387A6E756238, 0x3FEF1E9DF51FDEE1,\n  0x3FEF06FE0A31B715, 0x3FEEF1A7373AA9CB, 0x3FEEDEA64C123422, 0x3FEECE086061892D,\n  0x3FEEBFDAD5362A27, 0x3FEEB42B569D4F82, 0x3FEEAB07DD485429, 0x3FEEA47EB03A5585,\n  0x3FEEA09E667F3BCD, 0x3FEE9F75E8EC5F74, 0x3FEEA11473EB0187, 0x3FEEA589994CCE13,\n  0x3FEEACE5422AA0DB, 0x3FEEB737B0CDC5E5, 0x3FEEC49182A3F090, 0x3FEED503B23E255D,\n  0x3FEEE89F995AD3AD, 0x3FEEFF76F2FB5E47, 0x3FEF199BDD85529C, 0x3FEF3720DCEF9069,\n  0x3FEF5818DCFBA487, 0x3FEF7C97337B9B5F, 0x3FEFA4AFA2A490DA, 0x3FEFD0765B6E4540\n]);\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)\n// Wrong count: 168353 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function exp2f_lut(x: f32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N, // 0x1.8p+52\n    Ox127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  let xd = <f64>x;\n  let ix = reinterpret<u32>(x);\n  let ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x430) {\n    // |x| >= 128 or x is nan.\n    if (ix == 0xFF800000) return 0; // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;  // x == Inf/NaN -> Inf/NaN\n    if (x > 0) return x * Ox127f;   // x >     0    -> HugeVal (Owerflow)\n    if (x <= -150) return 0;        // x <= -150    -> 0 (Underflow)\n  }\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.\n  let kd = xd + shift;\n  let ki = reinterpret<u64>(kd);\n  let r  = xd - (kd - shift);\n  let t: u64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  y  = C2 * r + 1;\n  y += (C0 * r + C1) * (r  * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)\n// Wrong count: 170635 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function expf_lut(x: f32): f32 {\n  const\n    N        = 1 << EXP2F_TABLE_BITS,\n    N_MASK   = N - 1,\n    shift    = reinterpret<f64>(0x4338000000000000),        // 0x1.8p+52\n    InvLn2N  = reinterpret<f64>(0x3FF71547652B82FE) * N,    // 0x1.71547652b82fep+0\n    Ox1p127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394) / N / N / N, // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3) / N / N,     // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6) / N;         // 0x1.62e42ff0c52d6p-1\n\n  let xd = <f64>x;\n  let ix = reinterpret<u32>(x);\n  let ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x42B) {\n    // |x| >= 88 or x is nan.\n    if (ix == 0xFF800000) return 0;                            // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;                             // x == Inf/NaN -> Inf/NaN\n    if (x > reinterpret<f32>(0x42B17217)) return x * Ox1p127f; // x > log(0x1p128)  ~=  88.72 -> HugeVal (Owerflow)\n    if (x < reinterpret<f32>(0xC2CFF1B4)) return 0;            // x < log(0x1p-150) ~= -103.97 -> 0 (Underflow)\n  }\n\n  // x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.\n  let z = InvLn2N * xd;\n\n  // Round and convert z to int, the result is in [-150*N, 128*N] and\n  // ideally ties-to-even rule is used, otherwise the magnitude of r\n  // can be bigger which gives larger approximation error.\n  let kd = <f64>(z + shift);\n  let ki = reinterpret<u64>(kd);\n  let r  = z - (kd - shift);\n  let s: f64, y: f64, t: u64;\n\n  // exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for log2f\n//\n\n// @ts-ignore: decorator\n@inline const LOG2F_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2F_DATA_TAB = memory.data<f64>([\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFDEFEC65B963019), // 0x1.661ec79f8f3bep+0, -0x1.efec65b963019p-2,\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFDB0B6832D4FCA4), // 0x1.571ed4aaf883dp+0, -0x1.b0b6832d4fca4p-2,\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD7418B0A1FB77B), // 0x1.49539f0f010bp+0 , -0x1.7418b0a1fb77bp-2,\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFD39DE91A6DCF7B), // 0x1.3c995b0b80385p+0, -0x1.39de91a6dcf7bp-2,\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFD01D9BF3F2B631), // 0x1.30d190c8864a5p+0, -0x1.01d9bf3f2b631p-2,\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC97C1D1B3B7AF0), // 0x1.25e227b0b8eap+0 , -0x1.97c1d1b3b7afp-3 ,\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFC2F9E393AF3C9F), // 0x1.1bb4a4a1a343fp+0, -0x1.2f9e393af3c9fp-3,\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB960CBBF788D5C), // 0x1.12358f08ae5bap+0, -0x1.960cbbf788d5cp-4,\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFAA6F9DB6475FCE), // 0x1.0953f419900a7p+0, -0x1.a6f9db6475fcep-5,\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0x0,\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FB338CA9F24F53D), // 0x1.e608cfd9a47acp-1,  0x1.338ca9f24f53dp-4,\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FC476A9543891BA), // 0x1.ca4b31f026aap-1 ,  0x1.476a9543891bap-3,\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FCE840B4AC4E4D2), // 0x1.b2036576afce6p-1,  0x1.e840b4ac4e4d2p-3,\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FD40645F0C6651C), // 0x1.9c2d163a1aa2dp-1,  0x1.40645f0c6651cp-2,\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD88E9C2C1B9FF8), // 0x1.886e6037841edp-1,  0x1.88e9c2c1b9ff8p-2,\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FDCE0A44EB17BCC)  // 0x1.767dcf5534862p-1,  0x1.ce0a44eb17bccp-2\n]);\n\n// ULP error: 0.752 (nearest rounding.)\n// Relative error: 1.9 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function log2f_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOG2F_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    A0 = reinterpret<f64>(0xBFD712B6F70A7E4D), // -0x1.712b6f70a7e4dp-2\n    A1 = reinterpret<f64>(0x3FDECABF496832E0), //  0x1.ecabf496832ep-2\n    A2 = reinterpret<f64>(0xBFE715479FFAE3DE), // -0x1.715479ffae3dep-1\n    A3 = reinterpret<f64>(0x3FF715475F35C8B8); //  0x1.715475f35c8b8p0\n\n  let ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && predict_false(ix == 0x3f800000)) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if (ux * 2 == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log2(inf) == inf.\n    if ((ux >> 31) || ux * 2 >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ux - 0x3F330000;\n  let i    = (tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK;\n  let top  = tmp & 0xFF800000;\n  let iz   = ux - top;\n  let k    = <i32>tmp >> 23;\n\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  let z    = <f64>reinterpret<f32>(iz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  let r  = z * invc - 1;\n  let y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  let y  = A1 * r + A2;\n  let p  = A3 * r + y0;\n  let r2 = r * r;\n  y += A0 * r2;\n  y  = y * r2 + p;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for logf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/logf.c\n//\n\n// @ts-ignore: decorator\n@inline const LOGF_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOGF_DATA_TAB = memory.data<f64>([\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFD57BF7808CAADE), // 0x1.661ec79f8f3bep+0, -0x1.57bf7808caadep-2,\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFD2BEF0A7C06DDB), // 0x1.571ed4aaf883dp+0, -0x1.2bef0a7c06ddbp-2,\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD01EAE7F513A67), // 0x1.49539f0f010bp+0 , -0x1.01eae7f513a67p-2,\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFCB31D8A68224E9), // 0x1.3c995b0b80385p+0, -0x1.b31d8a68224e9p-3,\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFC6574F0AC07758), // 0x1.30d190c8864a5p+0, -0x1.6574f0ac07758p-3,\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC1AA2BC79C8100), // 0x1.25e227b0b8eap+0 , -0x1.1aa2bc79c81p-3  ,\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFBA4E76CE8C0E5E), // 0x1.1bb4a4a1a343fp+0, -0x1.a4e76ce8c0e5ep-4,\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB1973C5A611CCC), // 0x1.12358f08ae5bap+0, -0x1.1973c5a611cccp-4,\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFA252F438E10C1E), // 0x1.0953f419900a7p+0, -0x1.252f438e10c1ep-5,\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0,\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FAAA5AA5DF25984), // 0x1.e608cfd9a47acp-1,  0x1.aa5aa5df25984p-5,\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FBC5E53AA362EB4), // 0x1.ca4b31f026aap-1 ,  0x1.c5e53aa362eb4p-4,\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FC526E57720DB08), // 0x1.b2036576afce6p-1,  0x1.526e57720db08p-3,\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FCBC2860D224770), // 0x1.9c2d163a1aa2dp-1,  0x1.bc2860d22477p-3 ,\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD1058BC8A07EE1), // 0x1.886e6037841edp-1,  0x1.1058bc8a07ee1p-2,\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FD4043057B6EE09)  // 0x1.767dcf5534862p-1,  0x1.4043057b6ee09p-2\n]);\n\n// ULP error: 0.818 (nearest rounding.)\n// Relative error: 1.957 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function logf_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOGF_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    Ln2 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1;\n    A0  = reinterpret<f64>(0xBFD00EA348B88334), // -0x1.00ea348b88334p-2\n    A1  = reinterpret<f64>(0x3FD5575B0BE00B6A), //  0x1.5575b0be00b6ap-2\n    A2  = reinterpret<f64>(0xBFDFFFFEF20A4123); // -0x1.ffffef20a4123p-2\n\n  let ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && ux == 0x3f800000) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if ((ux << 1) == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log(inf) == inf.\n    if ((ux >> 31) || (ux << 1) >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp = ux - 0x3F330000;\n  let i   = (tmp >> (23 - LOGF_TABLE_BITS)) & N_MASK;\n  let k   = <i32>tmp >> 23;\n  let iz  = ux - (tmp & 0x1FF << 23);\n\n  let invc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n\n  let z = <f64>reinterpret<f32>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2\n  let r = z * invc - 1;\n  let y0 = logc + <f64>k * Ln2;\n\n  // Pipelined polynomial evaluation to approximate log1p(r).\n  let r2 = r * r;\n  let y  = A1 * r + A2;\n  y += A0 * r2;\n  y = y * r2 + (y0 + r);\n\n  return <f32>y;\n}\n\n//\n// Lookup data for powf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/powf.c\n//\n\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnanf(ux: u32): bool {\n  return (ux << 1) - 1 >= (<u32>0x7f800000 << 1) - 1;\n}\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkintf(iy: u32): i32 {\n  let e = iy >> 23 & 0xFF;\n  if (e < 0x7F     ) return 0;\n  if (e > 0x7F + 23) return 2;\n  e = 1 << (0x7F + 23 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// Subnormal input is normalized so ix has negative biased exponent.\n// Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.\n// @ts-ignore: decorator\n@inline\nfunction log2f_inline(ux: u32): f64 {\n  const N_MASK = (1 << LOG2F_TABLE_BITS) - 1;\n\n  const\n    A0 = reinterpret<f64>(0x3FD27616C9496E0B), //  0x1.27616c9496e0bp-2\n    A1 = reinterpret<f64>(0xBFD71969A075C67A), // -0x1.71969a075c67ap-2\n    A2 = reinterpret<f64>(0x3FDEC70A6CA7BADD), //  0x1.ec70a6ca7baddp-2\n    A3 = reinterpret<f64>(0xBFE7154748BEF6C8), // -0x1.7154748bef6c8p-1\n    A4 = reinterpret<f64>(0x3FF71547652AB82B); //  0x1.71547652ab82bp+0\n\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ux - 0x3F330000;\n  let i    = usize((tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK);\n  let top  = tmp & 0xFF800000;\n  let uz   = ux - top;\n  let k    = <i32>top >> 23;\n\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  let z    = <f64>reinterpret<f32>(uz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  let r  = z * invc - 1;\n  let y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  let y = A0 * r + A1;\n  let p = A2 * r + A3;\n  let q = A4 * r + y0;\n\n  r *= r;\n  q += p * r;\n  y  = y * (r * r) + q;\n\n  return y;\n}\n\n// The output of log2 and thus the input of exp2 is either scaled by N\n// (in case of fast toint intrinsics) or not.  The unscaled xd must be\n// in [-1021,1023], sign_bias sets the sign of the result.\n// @ts-ignore: decorator\n@inline\nfunction exp2f_inline(xd: f64, signBias: u32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p+52\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)]\n  let kd = <f64>(xd + shift);\n  let ki = reinterpret<u64>(kd);\n  let r  = xd - (kd - shift);\n  let t: u64, z: f64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += (ki + signBias) << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n  return <f32>y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflowf(sign: u32, y: f32): f32 {\n  return select<f32>(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x70000000)); // 0x1p97f\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x10000000)); // 0x1p-95f\n}\n\n// @ts-ignore: decorator\n@inline\nexport function powf_lut(x: f32, y: f32): f32 {\n  const\n    Ox1p23f     = reinterpret<f32>(0x4B000000), // 0x1p23f\n    UPPER_LIMIT = reinterpret<f64>(0x405FFFFFFFD1D571), // 0x1.fffffffd1d571p+6\n    LOWER_LIMIT = -150.0,\n    SIGN_BIAS   = 1 << (EXP2F_TABLE_BITS + 11);\n\n  let signBias: u32 = 0;\n  let ix = reinterpret<u32>(x);\n  let iy = reinterpret<u32>(y);\n  let ny = 0;\n\n  if (i32(ix - 0x00800000 >= 0x7f800000 - 0x00800000) | (ny = i32(zeroinfnanf(iy)))) {\n    // Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).\n    if (ny) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3F800000) return NaN; // original: 1.0\n      if ((ix << 1) > (<u32>0x7F800000 << 1) || (iy << 1) > (<u32>0x7F800000 << 1)) return x + y;\n      if ((ix << 1) == (0x3F800000 << 1)) return NaN; // original: 1.0\n      if (((ix << 1) < (0x3F800000 << 1)) == !(iy >> 31)) return 0; // |x| < 1 && y==inf or |x| > 1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnanf(ix)) {\n      let x2 = x * x;\n      if ((ix >> 31) && checkintf(iy) == 1) x2 = -x2;\n      return <i32>iy < 0 ? 1 / x2 : x2;\n    }\n    // x and y are non-zero finite.\n    if (<i32>ix < 0) {\n      // Finite x < 0.\n      let yint = checkintf(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) signBias = SIGN_BIAS;\n      ix &= 0x7FFFFFFF;\n    }\n    if (ix < 0x00800000) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u32>(x * Ox1p23f);\n      ix &= 0x7FFFFFFF;\n      ix -= 23 << 23;\n    }\n  }\n  let logx = log2f_inline(ix);\n  let ylogx = y * logx; // cannot overflow, y is single prec.\n  if ((reinterpret<u64>(ylogx) >> 47 & 0xFFFF) >= 0x80BF) { // reinterpret<u64>(126.0) >> 47\n    // |y * log(x)| >= 126\n    if (ylogx  > UPPER_LIMIT) return oflowf(signBias); // overflow\n    if (ylogx <= LOWER_LIMIT) return uflowf(signBias); // underflow\n  }\n  return exp2f_inline(ylogx, signBias);\n}\n\n//\n// Lookup data for exp. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp.c\n//\n\n// @ts-ignore: decorator\n@inline const EXP_TABLE_BITS = 7;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_DATA_TAB = memory.data<u64>([\n  0x0000000000000000, 0x3FF0000000000000,\n  0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,\n  0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,\n  0xBC905E7A108766D1, 0x3FEFE315E86E7F85,\n  0x3C8CD2523567F613, 0x3FEFD9B0D3158574,\n  0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,\n  0x3C60F74E61E6C861, 0x3FEFC74518759BC8,\n  0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,\n  0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,\n  0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,\n  0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,\n  0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,\n  0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,\n  0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,\n  0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,\n  0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,\n  0xBC801B15EAA59348, 0x3FEF72B83C7D517B,\n  0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,\n  0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,\n  0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,\n  0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,\n  0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,\n  0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,\n  0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,\n  0x3C968EFDE3A8A894, 0x3FEF387A6E756238,\n  0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,\n  0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,\n  0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,\n  0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,\n  0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,\n  0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,\n  0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,\n  0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,\n  0x3C864201E2AC744C, 0x3FEF0170FC4CD831,\n  0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,\n  0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,\n  0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,\n  0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,\n  0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,\n  0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,\n  0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,\n  0xBC9312607A28698A, 0x3FEEDA4504AC801C,\n  0xBC58A78F4817895B, 0x3FEED60A21F72E2A,\n  0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,\n  0x3C4363ED60C2AC11, 0x3FEECE086061892D,\n  0x3C9666093B0664EF, 0x3FEECA41ED1D0057,\n  0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,\n  0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,\n  0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,\n  0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,\n  0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,\n  0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,\n  0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,\n  0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,\n  0x3C93350518FDD78E, 0x3FEEAF4736B527DA,\n  0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,\n  0x3C9063E1E21C5409, 0x3FEEAB07DD485429,\n  0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,\n  0x3C9432E62B64C035, 0x3FEEA76F15AD2148,\n  0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,\n  0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,\n  0xBC845378892BE9AE, 0x3FEEA34634CCC320,\n  0xBC93CEDD78565858, 0x3FEEA23882552225,\n  0x3C5710AA807E1964, 0x3FEEA155D44CA973,\n  0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,\n  0xBC6A12AD8734B982, 0x3FEEA012750BDABF,\n  0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,\n  0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,\n  0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,\n  0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,\n  0xBC8619321E55E68A, 0x3FEE9FEB564267C9,\n  0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,\n  0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,\n  0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,\n  0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,\n  0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,\n  0xBC9369B6F13B3734, 0x3FEEA589994CCE13,\n  0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,\n  0xBC94D450D872576E, 0x3FEEA8D99B4492ED,\n  0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,\n  0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,\n  0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,\n  0x3C7BF68359F35F44, 0x3FEEB1AE99157736,\n  0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,\n  0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,\n  0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,\n  0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,\n  0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,\n  0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,\n  0x3C6DD235E10A73BB, 0x3FEEC86319E32323,\n  0xBC87C50422622263, 0x3FEECC667B5DE565,\n  0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,\n  0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,\n  0x3C90CC319CEE31D2, 0x3FEED99E1330B358,\n  0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,\n  0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,\n  0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,\n  0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,\n  0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,\n  0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,\n  0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,\n  0xBC91EEE26B588A35, 0x3FEF05B030A1064A,\n  0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,\n  0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,\n  0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,\n  0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,\n  0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,\n  0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,\n  0x3C676B2C6C921968, 0x3FEF3720DCEF9069,\n  0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,\n  0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,\n  0xBC900DAE3875A949, 0x3FEF4F87080D89F2,\n  0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,\n  0xBC82919E2040220F, 0x3FEF60E316C98398,\n  0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,\n  0x3C843A59AC016B4B, 0x3FEF7321F301B460,\n  0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,\n  0xBC892AB93B470DC9, 0x3FEF864614F5A129,\n  0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,\n  0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,\n  0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,\n  0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,\n  0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,\n  0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,\n  0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,\n  0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,\n  0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,\n  0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1\n]);\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding. The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase(tmp: f64, sbits: u64, ki: u64): f64 {\n  const\n    Ox1p_1022 = reinterpret<f64>(0x0010000000000000), // 0x1p-1022\n    Ox1p1009  = reinterpret<f64>(0x7F00000000000000); // 0x1p1009\n\n  let scale: f64;\n  if (!(ki & 0x80000000)) {\n    // k > 0, the exponent of scale might have overflowed by <= 460.\n    sbits -= u64(1009) << 52;\n    scale = reinterpret<f64>(sbits);\n    return Ox1p1009 * (scale + scale * tmp); // 0x1p1009\n  }\n  // k < 0, need special care in the subnormal range.\n  sbits += u64(1022) << 52;\n  // Note: sbits is signed scale.\n  scale = reinterpret<f64>(sbits);\n  let y = scale + scale * tmp;\n  if (abs(y) < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range.  So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let one = copysign(1.0, y);\n    let lo = scale - y + scale * tmp;\n    let hi = one + y;\n    lo = one - hi + y + lo;\n    y  = (hi + lo) - one;\n    // Fix the sign of 0.\n    if (y == 0.0) y = reinterpret<f64>(sbits & 0x8000000000000000);\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52;\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  let ux = reinterpret<u64>(x);\n  let abstop = u32(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) {\n        return 1.0 + x;\n      } else {\n        return select<f64>(0, Infinity, <i64>ux < 0);\n      }\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]\n  let z = InvLn2N * x;\n  // #if TOINT_INTRINSICS\n  // \tkd = roundtoint(z);\n  // \tki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  // \t// z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  // let kd = z + shift;\n  // let ki = reinterpret<u64>(kd) >> 16;\n  // let kd = <f64><i32>ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes.\n  let kd = z + shift;\n  let ki = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  let r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // 2^(k/N) ~= scale * (1 + tail).\n  let idx = usize((ki & N_MASK) << 1);\n  let top = ki << (52 - EXP_TABLE_BITS);\n\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()))); // T[idx]\n  // This is only a valid scale when -1023*N < k < 1024*N\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  let r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.\n  let tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  let scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n//\n// Lookup data for exp2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp2.c\n//\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding.  The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase2(tmp: f64, sbits: u64, ki: u64): f64 {\n  const Ox1p_1022 = reinterpret<f64>(0x10000000000000); // 0x1p-1022\n  let scale: f64;\n  if ((ki & 0x80000000) == 0) {\n    // k > 0, the exponent of scale might have overflowed by 1\n    sbits -= u64(1) << 52;\n    scale = reinterpret<f64>(sbits);\n    return 2 * (scale * tmp + scale);\n  }\n  // k < 0, need special care in the subnormal range\n  sbits += u64(1022) << 52;\n  scale = reinterpret<f64>(sbits);\n  let y = scale * tmp + scale;\n  if (y < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range. So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let hi: f64, lo: f64;\n    lo = scale - y + scale * tmp;\n    hi = 1.0 + y;\n    lo = 1.0 - hi + y + lo;\n    y = (hi + lo) - 1.0;\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp2_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p52\n\n  const\n    C1 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1\n    C2 = reinterpret<f64>(0x3FCEBFBDFF82C424), // 0x1.ebfbdff82c424p-3\n    C3 = reinterpret<f64>(0x3FAC6B08D70CF4B5), // 0x1.c6b08d70cf4b5p-5\n    C4 = reinterpret<f64>(0x3F83B2ABD24650CC), // 0x1.3b2abd24650ccp-7\n    C5 = reinterpret<f64>(0x3F55D7E09B4E3A84); // 0x1.5d7e09b4e3a84p-10\n\n  let ux = reinterpret<u64>(x);\n  let abstop = u32(ux >> 52) & 0x7ff;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1.0;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      if (<i64>ux >= 0) return Infinity;\n      else if (ux >= 0xC090CC0000000000) return 0;\n    }\n    if ((ux << 1) > 0x811A000000000000) abstop = 0; // Large x is special cased below.\n  }\n\n  // exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].\n  // x = k/N + r, with int k and r in [-1/2N, 1/2N]\n  let kd = x + shift;\n  let ki = reinterpret<u64>(kd);\n  kd -= shift; // k/N for int k\n  let r = x - kd;\n  // 2^(k/N) ~= scale * (1 + tail)\n  let idx = usize((ki & N_MASK) << 1);\n  let top = ki << (52 - EXP_TABLE_BITS);\n\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 0 << alignof<u64>())); // T[idx])\n  // This is only a valid scale when -1023*N < k < 1024*N\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution\n  let r2 = r * r;\n  // Without fma the worst case error is 0.5/N ulp larger.\n  // Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.\n  let tmp = tail + r * C1 + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase2(tmp, sbits, ki);\n  let scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there\n  // is no spurious underflow here even without fma.\n  return scale * tmp + scale;\n}\n\n//\n// Lookup data for log2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log2.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG2_TABLE_BITS = 6;\n\n/* Algorithm:\n\n  x = 2^k z\n  log2(x) = k + log2(c) + log2(z/c)\n  log2(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log2(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p10 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-64 and\n  3) the rounding error in (double)log2(c) is minimized (< 0x1p-68).\n\nNote: 1) ensures that k + logc can be computed without rounding error, 2)\nensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to a\nsingle rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log2(x)| < 0x1p-4, this is not enough so that is special cased. */\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB1 = memory.data<f64>([\n  //            invc                  ,                logc\n  reinterpret<f64>(0x3FF724286BB1ACF8), reinterpret<f64>(0xBFE1095FEECDB000),\n  reinterpret<f64>(0x3FF6E1F766D2CCA1), reinterpret<f64>(0xBFE08494BD76D000),\n  reinterpret<f64>(0x3FF6A13D0E30D48A), reinterpret<f64>(0xBFE00143AEE8F800),\n  reinterpret<f64>(0x3FF661EC32D06C85), reinterpret<f64>(0xBFDEFEC5360B4000),\n  reinterpret<f64>(0x3FF623FA951198F8), reinterpret<f64>(0xBFDDFDD91AB7E000),\n  reinterpret<f64>(0x3FF5E75BA4CF026C), reinterpret<f64>(0xBFDCFFAE0CC79000),\n  reinterpret<f64>(0x3FF5AC055A214FB8), reinterpret<f64>(0xBFDC043811FDA000),\n  reinterpret<f64>(0x3FF571ED0F166E1E), reinterpret<f64>(0xBFDB0B67323AE000),\n  reinterpret<f64>(0x3FF53909590BF835), reinterpret<f64>(0xBFDA152F5A2DB000),\n  reinterpret<f64>(0x3FF5014FED61ADDD), reinterpret<f64>(0xBFD9217F5AF86000),\n  reinterpret<f64>(0x3FF4CAB88E487BD0), reinterpret<f64>(0xBFD8304DB0719000),\n  reinterpret<f64>(0x3FF49539B4334FEE), reinterpret<f64>(0xBFD74189F9A9E000),\n  reinterpret<f64>(0x3FF460CBDFAFD569), reinterpret<f64>(0xBFD6552BB5199000),\n  reinterpret<f64>(0x3FF42D664EE4B953), reinterpret<f64>(0xBFD56B23A29B1000),\n  reinterpret<f64>(0x3FF3FB01111DD8A6), reinterpret<f64>(0xBFD483650F5FA000),\n  reinterpret<f64>(0x3FF3C995B70C5836), reinterpret<f64>(0xBFD39DE937F6A000),\n  reinterpret<f64>(0x3FF3991C4AB6FD4A), reinterpret<f64>(0xBFD2BAA1538D6000),\n  reinterpret<f64>(0x3FF3698E0CE099B5), reinterpret<f64>(0xBFD1D98340CA4000),\n  reinterpret<f64>(0x3FF33AE48213E7B2), reinterpret<f64>(0xBFD0FA853A40E000),\n  reinterpret<f64>(0x3FF30D191985BDB1), reinterpret<f64>(0xBFD01D9C32E73000),\n  reinterpret<f64>(0x3FF2E025CAB271D7), reinterpret<f64>(0xBFCE857DA2FA6000),\n  reinterpret<f64>(0x3FF2B404CF13CD82), reinterpret<f64>(0xBFCCD3C8633D8000),\n  reinterpret<f64>(0x3FF288B02C7CCB50), reinterpret<f64>(0xBFCB26034C14A000),\n  reinterpret<f64>(0x3FF25E2263944DE5), reinterpret<f64>(0xBFC97C1C2F4FE000),\n  reinterpret<f64>(0x3FF234563D8615B1), reinterpret<f64>(0xBFC7D6023F800000),\n  reinterpret<f64>(0x3FF20B46E33EAF38), reinterpret<f64>(0xBFC633A71A05E000),\n  reinterpret<f64>(0x3FF1E2EEFDCDA3DD), reinterpret<f64>(0xBFC494F5E9570000),\n  reinterpret<f64>(0x3FF1BB4A580B3930), reinterpret<f64>(0xBFC2F9E424E0A000),\n  reinterpret<f64>(0x3FF19453847F2200), reinterpret<f64>(0xBFC162595AFDC000),\n  reinterpret<f64>(0x3FF16E06C0D5D73C), reinterpret<f64>(0xBFBF9C9A75BD8000),\n  reinterpret<f64>(0x3FF1485F47B7E4C2), reinterpret<f64>(0xBFBC7B575BF9C000),\n  reinterpret<f64>(0x3FF12358AD0085D1), reinterpret<f64>(0xBFB960C60FF48000),\n  reinterpret<f64>(0x3FF0FEF00F532227), reinterpret<f64>(0xBFB64CE247B60000),\n  reinterpret<f64>(0x3FF0DB2077D03A8F), reinterpret<f64>(0xBFB33F78B2014000),\n  reinterpret<f64>(0x3FF0B7E6D65980D9), reinterpret<f64>(0xBFB0387D1A42C000),\n  reinterpret<f64>(0x3FF0953EFE7B408D), reinterpret<f64>(0xBFAA6F9208B50000),\n  reinterpret<f64>(0x3FF07325CAC53B83), reinterpret<f64>(0xBFA47A954F770000),\n  reinterpret<f64>(0x3FF05197E40D1B5C), reinterpret<f64>(0xBF9D23A8C50C0000),\n  reinterpret<f64>(0x3FF03091C1208EA2), reinterpret<f64>(0xBF916A2629780000),\n  reinterpret<f64>(0x3FF0101025B37E21), reinterpret<f64>(0xBF7720F8D8E80000),\n  reinterpret<f64>(0x3FEFC07EF9CAA76B), reinterpret<f64>(0x3F86FE53B1500000),\n  reinterpret<f64>(0x3FEF4465D3F6F184), reinterpret<f64>(0x3FA11CCCE10F8000),\n  reinterpret<f64>(0x3FEECC079F84107F), reinterpret<f64>(0x3FAC4DFC8C8B8000),\n  reinterpret<f64>(0x3FEE573A99975AE8), reinterpret<f64>(0x3FB3AA321E574000),\n  reinterpret<f64>(0x3FEDE5D6F0BD3DE6), reinterpret<f64>(0x3FB918A0D08B8000),\n  reinterpret<f64>(0x3FED77B681FF38B3), reinterpret<f64>(0x3FBE72E9DA044000),\n  reinterpret<f64>(0x3FED0CB5724DE943), reinterpret<f64>(0x3FC1DCD2507F6000),\n  reinterpret<f64>(0x3FECA4B2DC0E7563), reinterpret<f64>(0x3FC476AB03DEA000),\n  reinterpret<f64>(0x3FEC3F8EE8D6CB51), reinterpret<f64>(0x3FC7074377E22000),\n  reinterpret<f64>(0x3FEBDD2B4F020C4C), reinterpret<f64>(0x3FC98EDE8BA94000),\n  reinterpret<f64>(0x3FEB7D6C006015CA), reinterpret<f64>(0x3FCC0DB86AD2E000),\n  reinterpret<f64>(0x3FEB20366E2E338F), reinterpret<f64>(0x3FCE840AAFCEE000),\n  reinterpret<f64>(0x3FEAC57026295039), reinterpret<f64>(0x3FD0790AB4678000),\n  reinterpret<f64>(0x3FEA6D01BC2731DD), reinterpret<f64>(0x3FD1AC056801C000),\n  reinterpret<f64>(0x3FEA16D3BC3FF18B), reinterpret<f64>(0x3FD2DB11D4FEE000),\n  reinterpret<f64>(0x3FE9C2D14967FEAD), reinterpret<f64>(0x3FD406464EC58000),\n  reinterpret<f64>(0x3FE970E4F47C9902), reinterpret<f64>(0x3FD52DBE093AF000),\n  reinterpret<f64>(0x3FE920FB3982BCF2), reinterpret<f64>(0x3FD651902050D000),\n  reinterpret<f64>(0x3FE8D30187F759F1), reinterpret<f64>(0x3FD771D2CDEAF000),\n  reinterpret<f64>(0x3FE886E5EBB9F66D), reinterpret<f64>(0x3FD88E9C857D9000),\n  reinterpret<f64>(0x3FE83C97B658B994), reinterpret<f64>(0x3FD9A80155E16000),\n  reinterpret<f64>(0x3FE7F405FFC61022), reinterpret<f64>(0x3FDABE186ED3D000),\n  reinterpret<f64>(0x3FE7AD22181415CA), reinterpret<f64>(0x3FDBD0F2AEA0E000),\n  reinterpret<f64>(0x3FE767DCF99EFF8C), reinterpret<f64>(0x3FDCE0A43DBF4000)\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB2 = memory.data<f64>([\n  //              chi                 ,                 clo\n  reinterpret<f64>(0x3FE6200012B90A8E), reinterpret<f64>(0x3C8904AB0644B605),\n  reinterpret<f64>(0x3FE66000045734A6), reinterpret<f64>(0x3C61FF9BEA62F7A9),\n  reinterpret<f64>(0x3FE69FFFC325F2C5), reinterpret<f64>(0x3C827ECFCB3C90BA),\n  reinterpret<f64>(0x3FE6E00038B95A04), reinterpret<f64>(0x3C88FF8856739326),\n  reinterpret<f64>(0x3FE71FFFE09994E3), reinterpret<f64>(0x3C8AFD40275F82B1),\n  reinterpret<f64>(0x3FE7600015590E10), reinterpret<f64>(0xBC72FD75B4238341),\n  reinterpret<f64>(0x3FE7A00012655BD5), reinterpret<f64>(0x3C7808E67C242B76),\n  reinterpret<f64>(0x3FE7E0003259E9A6), reinterpret<f64>(0xBC6208E426F622B7),\n  reinterpret<f64>(0x3FE81FFFEDB4B2D2), reinterpret<f64>(0xBC8402461EA5C92F),\n  reinterpret<f64>(0x3FE860002DFAFCC3), reinterpret<f64>(0x3C6DF7F4A2F29A1F),\n  reinterpret<f64>(0x3FE89FFFF78C6B50), reinterpret<f64>(0xBC8E0453094995FD),\n  reinterpret<f64>(0x3FE8E00039671566), reinterpret<f64>(0xBC8A04F3BEC77B45),\n  reinterpret<f64>(0x3FE91FFFE2BF1745), reinterpret<f64>(0xBC77FA34400E203C),\n  reinterpret<f64>(0x3FE95FFFCC5C9FD1), reinterpret<f64>(0xBC76FF8005A0695D),\n  reinterpret<f64>(0x3FE9A0003BBA4767), reinterpret<f64>(0x3C70F8C4C4EC7E03),\n  reinterpret<f64>(0x3FE9DFFFE7B92DA5), reinterpret<f64>(0x3C8E7FD9478C4602),\n  reinterpret<f64>(0x3FEA1FFFD72EFDAF), reinterpret<f64>(0xBC6A0C554DCDAE7E),\n  reinterpret<f64>(0x3FEA5FFFDE04FF95), reinterpret<f64>(0x3C867DA98CE9B26B),\n  reinterpret<f64>(0x3FEA9FFFCA5E8D2B), reinterpret<f64>(0xBC8284C9B54C13DE),\n  reinterpret<f64>(0x3FEADFFFDDAD03EA), reinterpret<f64>(0x3C5812C8EA602E3C),\n  reinterpret<f64>(0x3FEB1FFFF10D3D4D), reinterpret<f64>(0xBC8EFADDAD27789C),\n  reinterpret<f64>(0x3FEB5FFFCE21165A), reinterpret<f64>(0x3C53CB1719C61237),\n  reinterpret<f64>(0x3FEB9FFFD950E674), reinterpret<f64>(0x3C73F7D94194CE00),\n  reinterpret<f64>(0x3FEBE000139CA8AF), reinterpret<f64>(0x3C750AC4215D9BC0),\n  reinterpret<f64>(0x3FEC20005B46DF99), reinterpret<f64>(0x3C6BEEA653E9C1C9),\n  reinterpret<f64>(0x3FEC600040B9F7AE), reinterpret<f64>(0xBC7C079F274A70D6),\n  reinterpret<f64>(0x3FECA0006255FD8A), reinterpret<f64>(0xBC7A0B4076E84C1F),\n  reinterpret<f64>(0x3FECDFFFD94C095D), reinterpret<f64>(0x3C88F933F99AB5D7),\n  reinterpret<f64>(0x3FED1FFFF975D6CF), reinterpret<f64>(0xBC582C08665FE1BE),\n  reinterpret<f64>(0x3FED5FFFA2561C93), reinterpret<f64>(0xBC7B04289BD295F3),\n  reinterpret<f64>(0x3FED9FFF9D228B0C), reinterpret<f64>(0x3C870251340FA236),\n  reinterpret<f64>(0x3FEDE00065BC7E16), reinterpret<f64>(0xBC75011E16A4D80C),\n  reinterpret<f64>(0x3FEE200002F64791), reinterpret<f64>(0x3C89802F09EF62E0),\n  reinterpret<f64>(0x3FEE600057D7A6D8), reinterpret<f64>(0xBC7E0B75580CF7FA),\n  reinterpret<f64>(0x3FEEA00027EDC00C), reinterpret<f64>(0xBC8C848309459811),\n  reinterpret<f64>(0x3FEEE0006CF5CB7C), reinterpret<f64>(0xBC8F8027951576F4),\n  reinterpret<f64>(0x3FEF2000782B7DCC), reinterpret<f64>(0xBC8F81D97274538F),\n  reinterpret<f64>(0x3FEF6000260C450A), reinterpret<f64>(0xBC4071002727FFDC),\n  reinterpret<f64>(0x3FEF9FFFE88CD533), reinterpret<f64>(0xBC581BDCE1FDA8B0),\n  reinterpret<f64>(0x3FEFDFFFD50F8689), reinterpret<f64>(0x3C87F91ACB918E6E),\n  reinterpret<f64>(0x3FF0200004292367), reinterpret<f64>(0x3C9B7FF365324681),\n  reinterpret<f64>(0x3FF05FFFE3E3D668), reinterpret<f64>(0x3C86FA08DDAE957B),\n  reinterpret<f64>(0x3FF0A0000A85A757), reinterpret<f64>(0xBC57E2DE80D3FB91),\n  reinterpret<f64>(0x3FF0E0001A5F3FCC), reinterpret<f64>(0xBC91823305C5F014),\n  reinterpret<f64>(0x3FF11FFFF8AFBAF5), reinterpret<f64>(0xBC8BFABB6680BAC2),\n  reinterpret<f64>(0x3FF15FFFE54D91AD), reinterpret<f64>(0xBC9D7F121737E7EF),\n  reinterpret<f64>(0x3FF1A00011AC36E1), reinterpret<f64>(0x3C9C000A0516F5FF),\n  reinterpret<f64>(0x3FF1E00019C84248), reinterpret<f64>(0xBC9082FBE4DA5DA0),\n  reinterpret<f64>(0x3FF220000FFE5E6E), reinterpret<f64>(0xBC88FDD04C9CFB43),\n  reinterpret<f64>(0x3FF26000269FD891), reinterpret<f64>(0x3C8CFE2A7994D182),\n  reinterpret<f64>(0x3FF2A00029A6E6DA), reinterpret<f64>(0xBC700273715E8BC5),\n  reinterpret<f64>(0x3FF2DFFFE0293E39), reinterpret<f64>(0x3C9B7C39DAB2A6F9),\n  reinterpret<f64>(0x3FF31FFFF7DCF082), reinterpret<f64>(0x3C7DF1336EDC5254),\n  reinterpret<f64>(0x3FF35FFFF05A8B60), reinterpret<f64>(0xBC9E03564CCD31EB),\n  reinterpret<f64>(0x3FF3A0002E0EAECC), reinterpret<f64>(0x3C75F0E74BD3A477),\n  reinterpret<f64>(0x3FF3E000043BB236), reinterpret<f64>(0x3C9C7DCB149D8833),\n  reinterpret<f64>(0x3FF4200002D187FF), reinterpret<f64>(0x3C7E08AFCF2D3D28),\n  reinterpret<f64>(0x3FF460000D387CB1), reinterpret<f64>(0x3C820837856599A6),\n  reinterpret<f64>(0x3FF4A00004569F89), reinterpret<f64>(0xBC89FA5C904FBCD2),\n  reinterpret<f64>(0x3FF4E000043543F3), reinterpret<f64>(0xBC781125ED175329),\n  reinterpret<f64>(0x3FF51FFFCC027F0F), reinterpret<f64>(0x3C9883D8847754DC),\n  reinterpret<f64>(0x3FF55FFFFD87B36F), reinterpret<f64>(0xBC8709E731D02807),\n  reinterpret<f64>(0x3FF59FFFF21DF7BA), reinterpret<f64>(0x3C87F79F68727B02),\n  reinterpret<f64>(0x3FF5DFFFEBFC3481), reinterpret<f64>(0xBC9180902E30E93E)\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log2_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG2_TABLE_BITS) - 1;\n\n  const\n    LO: u64 = 0x3FEEA4AF00000000, // reinterpret<u64>(1.0 - 0x1.5b51p-5)\n    HI: u64 = 0x3FF0B55900000000; // reinterpret<u64>(1.0 + 0x1.6ab2p-5)\n\n  const\n    InvLn2hi = reinterpret<f64>(0x3FF7154765200000), // 0x1.7154765200000p+0\n    InvLn2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 0x1.705fc2eefa200p-33\n    Ox1p52   = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  const\n    B0 = reinterpret<f64>(0xBFE71547652B82FE), // -0x1.71547652b82fep-1\n    B1 = reinterpret<f64>(0x3FDEC709DC3A03F7), //  0x1.ec709dc3a03f7p-2\n    B2 = reinterpret<f64>(0xBFD71547652B7C3F), // -0x1.71547652b7c3fp-2\n    B3 = reinterpret<f64>(0x3FD2776C50F05BE4), //  0x1.2776c50f05be4p-2\n    B4 = reinterpret<f64>(0xBFCEC709DD768FE5), // -0x1.ec709dd768fe5p-3\n    B5 = reinterpret<f64>(0x3FCA61761EC4E736), //  0x1.a61761ec4e736p-3\n    B6 = reinterpret<f64>(0xBFC7153FBC64A79B), // -0x1.7153fbc64a79bp-3\n    B7 = reinterpret<f64>(0x3FC484D154F01B4A), //  0x1.484d154f01b4ap-3\n    B8 = reinterpret<f64>(0xBFC289E4A72C383C), // -0x1.289e4a72c383cp-3\n    B9 = reinterpret<f64>(0x3FC0B32F285AEE66); //  0x1.0b32f285aee66p-3\n\n  const\n    A0 = reinterpret<f64>(0xBFE71547652B8339), // -0x1.71547652b8339p-1\n    A1 = reinterpret<f64>(0x3FDEC709DC3A04BE), //  0x1.ec709dc3a04bep-2\n    A2 = reinterpret<f64>(0xBFD7154764702FFB), // -0x1.7154764702ffbp-2\n    A3 = reinterpret<f64>(0x3FD2776C50034C48), //  0x1.2776c50034c48p-2\n    A4 = reinterpret<f64>(0xBFCEC7B328EA92BC), // -0x1.ec7b328ea92bcp-3\n    A5 = reinterpret<f64>(0x3FCA6225E117F92E); //  0x1.a6225e117f92ep-3\n\n  let ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r = x - 1.0;\n    // #if __FP_FAST_FMA\n    //     hi = r * InvLn2hi;\n    //     lo = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -hi);\n    // #else\n    let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n    let rlo = r - rhi;\n    let hi  = rhi * InvLn2hi;\n    let lo  = rlo * InvLn2hi + r * InvLn2lo;\n    // #endif\n    let r2 = r * r; // rounding error: 0x1p-62\n    let r4 = r2 * r2;\n    // Worst-case error is less than 0.54 ULP (0.55 ULP without fma)\n    let p = r2 * (B0 + r * B1);\n    let y = hi + p;\n    lo += hi - y + p;\n    lo += r4 * (B2 + r * B3 + r2 * (B4 + r * B5) +\n          r4 * (B6 + r * B7 + r2 * (B8 + r * B9)));\n    return y + lo;\n  }\n  let top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7ff0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan.\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == 0x7FF0000000000000) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ix - 0x3FE6000000000000;\n  let i    = <usize>((tmp >> (52 - LOG2_TABLE_BITS)) & N_MASK);\n  let k    = <i64>tmp >> 52;\n  let iz   = ix - (tmp & 0xFFF0000000000000);\n\n  let invc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  let logc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  let z    = reinterpret<f64>(iz);\n  let kd   = <f64>k;\n\n  // log2(x) = log2(z/c) + log2(c) + k.\n  // r ~= z/c - 1, |r| < 1/(2*N).\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N.\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // \tt1 = r * InvLn2hi;\n  // \tt2 = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -t1);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-65.\n  let chi = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].chi;\n  let clo = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].clo;\n\n  let r   = (z - chi - clo) * invc;\n  let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n  let rlo = r - rhi;\n  let t1  = rhi * InvLn2hi;\n  let t2  = rlo * InvLn2hi + r * InvLn2lo;\n  // #endif\n\n  // hi + lo = r/ln2 + log2(c) + k\n  let t3 = kd + logc;\n  let hi = t3 + t1;\n  let lo = t3 - hi + t1 + t2;\n\n  // log2(r+1) = r/ln2 + r^2*poly(r)\n  // Evaluation is optimized assuming superscalar pipelined execution\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).\n  // ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).\n  let p = A0 + r * A1 + r2 * (A2 + r * A3) + (r2 * r2) * (A4 + r * A5);\n  return lo + r2 * p + hi;\n}\n\n//\n// Lookup data for log. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p9 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-66 and\n  3) the rounding error in (double)log(c) is minimized (< 0x1p-66).\n\nNote: 1) ensures that k*ln2hi + logc can be computed without rounding error,\n2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to\na single rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log(x)| < 0x1p-4, this is not enough so that is special cased.*/\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB1 = memory.data<f64>([\n  //              invc                ,                 logc\n  reinterpret<f64>(0x3FF734F0C3E0DE9F), reinterpret<f64>(0xBFD7CC7F79E69000),\n  reinterpret<f64>(0x3FF713786A2CE91F), reinterpret<f64>(0xBFD76FEEC20D0000),\n  reinterpret<f64>(0x3FF6F26008FAB5A0), reinterpret<f64>(0xBFD713E31351E000),\n  reinterpret<f64>(0x3FF6D1A61F138C7D), reinterpret<f64>(0xBFD6B85B38287800),\n  reinterpret<f64>(0x3FF6B1490BC5B4D1), reinterpret<f64>(0xBFD65D5590807800),\n  reinterpret<f64>(0x3FF69147332F0CBA), reinterpret<f64>(0xBFD602D076180000),\n  reinterpret<f64>(0x3FF6719F18224223), reinterpret<f64>(0xBFD5A8CA86909000),\n  reinterpret<f64>(0x3FF6524F99A51ED9), reinterpret<f64>(0xBFD54F4356035000),\n  reinterpret<f64>(0x3FF63356AA8F24C4), reinterpret<f64>(0xBFD4F637C36B4000),\n  reinterpret<f64>(0x3FF614B36B9DDC14), reinterpret<f64>(0xBFD49DA7FDA85000),\n  reinterpret<f64>(0x3FF5F66452C65C4C), reinterpret<f64>(0xBFD445923989A800),\n  reinterpret<f64>(0x3FF5D867B5912C4F), reinterpret<f64>(0xBFD3EDF439B0B800),\n  reinterpret<f64>(0x3FF5BABCCB5B90DE), reinterpret<f64>(0xBFD396CE448F7000),\n  reinterpret<f64>(0x3FF59D61F2D91A78), reinterpret<f64>(0xBFD3401E17BDA000),\n  reinterpret<f64>(0x3FF5805612465687), reinterpret<f64>(0xBFD2E9E2EF468000),\n  reinterpret<f64>(0x3FF56397CEE76BD3), reinterpret<f64>(0xBFD2941B3830E000),\n  reinterpret<f64>(0x3FF54725E2A77F93), reinterpret<f64>(0xBFD23EC58CDA8800),\n  reinterpret<f64>(0x3FF52AFF42064583), reinterpret<f64>(0xBFD1E9E129279000),\n  reinterpret<f64>(0x3FF50F22DBB2BDDF), reinterpret<f64>(0xBFD1956D2B48F800),\n  reinterpret<f64>(0x3FF4F38F4734DED7), reinterpret<f64>(0xBFD141679AB9F800),\n  reinterpret<f64>(0x3FF4D843CFDE2840), reinterpret<f64>(0xBFD0EDD094EF9800),\n  reinterpret<f64>(0x3FF4BD3EC078A3C8), reinterpret<f64>(0xBFD09AA518DB1000),\n  reinterpret<f64>(0x3FF4A27FC3E0258A), reinterpret<f64>(0xBFD047E65263B800),\n  reinterpret<f64>(0x3FF4880524D48434), reinterpret<f64>(0xBFCFEB224586F000),\n  reinterpret<f64>(0x3FF46DCE1B192D0B), reinterpret<f64>(0xBFCF474A7517B000),\n  reinterpret<f64>(0x3FF453D9D3391854), reinterpret<f64>(0xBFCEA4443D103000),\n  reinterpret<f64>(0x3FF43A2744B4845A), reinterpret<f64>(0xBFCE020D44E9B000),\n  reinterpret<f64>(0x3FF420B54115F8FB), reinterpret<f64>(0xBFCD60A22977F000),\n  reinterpret<f64>(0x3FF40782DA3EF4B1), reinterpret<f64>(0xBFCCC00104959000),\n  reinterpret<f64>(0x3FF3EE8F5D57FE8F), reinterpret<f64>(0xBFCC202956891000),\n  reinterpret<f64>(0x3FF3D5D9A00B4CE9), reinterpret<f64>(0xBFCB81178D811000),\n  reinterpret<f64>(0x3FF3BD60C010C12B), reinterpret<f64>(0xBFCAE2C9CCD3D000),\n  reinterpret<f64>(0x3FF3A5242B75DAB8), reinterpret<f64>(0xBFCA45402E129000),\n  reinterpret<f64>(0x3FF38D22CD9FD002), reinterpret<f64>(0xBFC9A877681DF000),\n  reinterpret<f64>(0x3FF3755BC5847A1C), reinterpret<f64>(0xBFC90C6D69483000),\n  reinterpret<f64>(0x3FF35DCE49AD36E2), reinterpret<f64>(0xBFC87120A645C000),\n  reinterpret<f64>(0x3FF34679984DD440), reinterpret<f64>(0xBFC7D68FB4143000),\n  reinterpret<f64>(0x3FF32F5CCEFFCB24), reinterpret<f64>(0xBFC73CB83C627000),\n  reinterpret<f64>(0x3FF3187775A10D49), reinterpret<f64>(0xBFC6A39A9B376000),\n  reinterpret<f64>(0x3FF301C8373E3990), reinterpret<f64>(0xBFC60B3154B7A000),\n  reinterpret<f64>(0x3FF2EB4EBB95F841), reinterpret<f64>(0xBFC5737D76243000),\n  reinterpret<f64>(0x3FF2D50A0219A9D1), reinterpret<f64>(0xBFC4DC7B8FC23000),\n  reinterpret<f64>(0x3FF2BEF9A8B7FD2A), reinterpret<f64>(0xBFC4462C51D20000),\n  reinterpret<f64>(0x3FF2A91C7A0C1BAB), reinterpret<f64>(0xBFC3B08ABC830000),\n  reinterpret<f64>(0x3FF293726014B530), reinterpret<f64>(0xBFC31B996B490000),\n  reinterpret<f64>(0x3FF27DFA5757A1F5), reinterpret<f64>(0xBFC2875490A44000),\n  reinterpret<f64>(0x3FF268B39B1D3BBF), reinterpret<f64>(0xBFC1F3B9F879A000),\n  reinterpret<f64>(0x3FF2539D838FF5BD), reinterpret<f64>(0xBFC160C8252CA000),\n  reinterpret<f64>(0x3FF23EB7AAC9083B), reinterpret<f64>(0xBFC0CE7F57F72000),\n  reinterpret<f64>(0x3FF22A012BA940B6), reinterpret<f64>(0xBFC03CDC49FEA000),\n  reinterpret<f64>(0x3FF2157996CC4132), reinterpret<f64>(0xBFBF57BDBC4B8000),\n  reinterpret<f64>(0x3FF201201DD2FC9B), reinterpret<f64>(0xBFBE370896404000),\n  reinterpret<f64>(0x3FF1ECF4494D480B), reinterpret<f64>(0xBFBD17983EF94000),\n  reinterpret<f64>(0x3FF1D8F5528F6569), reinterpret<f64>(0xBFBBF9674ED8A000),\n  reinterpret<f64>(0x3FF1C52311577E7C), reinterpret<f64>(0xBFBADC79202F6000),\n  reinterpret<f64>(0x3FF1B17C74CB26E9), reinterpret<f64>(0xBFB9C0C3E7288000),\n  reinterpret<f64>(0x3FF19E010C2C1AB6), reinterpret<f64>(0xBFB8A646B372C000),\n  reinterpret<f64>(0x3FF18AB07BB670BD), reinterpret<f64>(0xBFB78D01B3AC0000),\n  reinterpret<f64>(0x3FF1778A25EFBCB6), reinterpret<f64>(0xBFB674F145380000),\n  reinterpret<f64>(0x3FF1648D354C31DA), reinterpret<f64>(0xBFB55E0E6D878000),\n  reinterpret<f64>(0x3FF151B990275FDD), reinterpret<f64>(0xBFB4485CDEA1E000),\n  reinterpret<f64>(0x3FF13F0EA432D24C), reinterpret<f64>(0xBFB333D94D6AA000),\n  reinterpret<f64>(0x3FF12C8B7210F9DA), reinterpret<f64>(0xBFB22079F8C56000),\n  reinterpret<f64>(0x3FF11A3028ECB531), reinterpret<f64>(0xBFB10E4698622000),\n  reinterpret<f64>(0x3FF107FBDA8434AF), reinterpret<f64>(0xBFAFFA6C6AD20000),\n  reinterpret<f64>(0x3FF0F5EE0F4E6BB3), reinterpret<f64>(0xBFADDA8D4A774000),\n  reinterpret<f64>(0x3FF0E4065D2A9FCE), reinterpret<f64>(0xBFABBCECE4850000),\n  reinterpret<f64>(0x3FF0D244632CA521), reinterpret<f64>(0xBFA9A1894012C000),\n  reinterpret<f64>(0x3FF0C0A77CE2981A), reinterpret<f64>(0xBFA788583302C000),\n  reinterpret<f64>(0x3FF0AF2F83C636D1), reinterpret<f64>(0xBFA5715E67D68000),\n  reinterpret<f64>(0x3FF09DDB98A01339), reinterpret<f64>(0xBFA35C8A49658000),\n  reinterpret<f64>(0x3FF08CABAF52E7DF), reinterpret<f64>(0xBFA149E364154000),\n  reinterpret<f64>(0x3FF07B9F2F4E28FB), reinterpret<f64>(0xBF9E72C082EB8000),\n  reinterpret<f64>(0x3FF06AB58C358F19), reinterpret<f64>(0xBF9A55F152528000),\n  reinterpret<f64>(0x3FF059EEA5ECF92C), reinterpret<f64>(0xBF963D62CF818000),\n  reinterpret<f64>(0x3FF04949CDD12C90), reinterpret<f64>(0xBF9228FB8CAA0000),\n  reinterpret<f64>(0x3FF038C6C6F0ADA9), reinterpret<f64>(0xBF8C317B20F90000),\n  reinterpret<f64>(0x3FF02865137932A9), reinterpret<f64>(0xBF8419355DAA0000),\n  reinterpret<f64>(0x3FF0182427EA7348), reinterpret<f64>(0xBF781203C2EC0000),\n  reinterpret<f64>(0x3FF008040614B195), reinterpret<f64>(0xBF60040979240000),\n  reinterpret<f64>(0x3FEFE01FF726FA1A), reinterpret<f64>(0x3F6FEFF384900000),\n  reinterpret<f64>(0x3FEFA11CC261EA74), reinterpret<f64>(0x3F87DC41353D0000),\n  reinterpret<f64>(0x3FEF6310B081992E), reinterpret<f64>(0x3F93CEA3C4C28000),\n  reinterpret<f64>(0x3FEF25F63CEEADCD), reinterpret<f64>(0x3F9B9FC114890000),\n  reinterpret<f64>(0x3FEEE9C8039113E7), reinterpret<f64>(0x3FA1B0D8CE110000),\n  reinterpret<f64>(0x3FEEAE8078CBB1AB), reinterpret<f64>(0x3FA58A5BD001C000),\n  reinterpret<f64>(0x3FEE741AA29D0C9B), reinterpret<f64>(0x3FA95C8340D88000),\n  reinterpret<f64>(0x3FEE3A91830A99B5), reinterpret<f64>(0x3FAD276AEF578000),\n  reinterpret<f64>(0x3FEE01E009609A56), reinterpret<f64>(0x3FB07598E598C000),\n  reinterpret<f64>(0x3FEDCA01E577BB98), reinterpret<f64>(0x3FB253F5E30D2000),\n  reinterpret<f64>(0x3FED92F20B7C9103), reinterpret<f64>(0x3FB42EDD8B380000),\n  reinterpret<f64>(0x3FED5CAC66FB5CCE), reinterpret<f64>(0x3FB606598757C000),\n  reinterpret<f64>(0x3FED272CAA5EDE9D), reinterpret<f64>(0x3FB7DA76356A0000),\n  reinterpret<f64>(0x3FECF26E3E6B2CCD), reinterpret<f64>(0x3FB9AB434E1C6000),\n  reinterpret<f64>(0x3FECBE6DA2A77902), reinterpret<f64>(0x3FBB78C7BB0D6000),\n  reinterpret<f64>(0x3FEC8B266D37086D), reinterpret<f64>(0x3FBD431332E72000),\n  reinterpret<f64>(0x3FEC5894BD5D5804), reinterpret<f64>(0x3FBF0A3171DE6000),\n  reinterpret<f64>(0x3FEC26B533BB9F8C), reinterpret<f64>(0x3FC067152B914000),\n  reinterpret<f64>(0x3FEBF583EEECE73F), reinterpret<f64>(0x3FC147858292B000),\n  reinterpret<f64>(0x3FEBC4FD75DB96C1), reinterpret<f64>(0x3FC2266ECDCA3000),\n  reinterpret<f64>(0x3FEB951E0C864A28), reinterpret<f64>(0x3FC303D7A6C55000),\n  reinterpret<f64>(0x3FEB65E2C5EF3E2C), reinterpret<f64>(0x3FC3DFC33C331000),\n  reinterpret<f64>(0x3FEB374867C9888B), reinterpret<f64>(0x3FC4BA366B7A8000),\n  reinterpret<f64>(0x3FEB094B211D304A), reinterpret<f64>(0x3FC5933928D1F000),\n  reinterpret<f64>(0x3FEADBE885F2EF7E), reinterpret<f64>(0x3FC66ACD2418F000),\n  reinterpret<f64>(0x3FEAAF1D31603DA2), reinterpret<f64>(0x3FC740F8EC669000),\n  reinterpret<f64>(0x3FEA82E63FD358A7), reinterpret<f64>(0x3FC815C0F51AF000),\n  reinterpret<f64>(0x3FEA5740EF09738B), reinterpret<f64>(0x3FC8E92954F68000),\n  reinterpret<f64>(0x3FEA2C2A90AB4B27), reinterpret<f64>(0x3FC9BB3602F84000),\n  reinterpret<f64>(0x3FEA01A01393F2D1), reinterpret<f64>(0x3FCA8BED1C2C0000),\n  reinterpret<f64>(0x3FE9D79F24DB3C1B), reinterpret<f64>(0x3FCB5B515C01D000),\n  reinterpret<f64>(0x3FE9AE2505C7B190), reinterpret<f64>(0x3FCC2967CCBCC000),\n  reinterpret<f64>(0x3FE9852EF297CE2F), reinterpret<f64>(0x3FCCF635D5486000),\n  reinterpret<f64>(0x3FE95CBAEEA44B75), reinterpret<f64>(0x3FCDC1BD3446C000),\n  reinterpret<f64>(0x3FE934C69DE74838), reinterpret<f64>(0x3FCE8C01B8CFE000),\n  reinterpret<f64>(0x3FE90D4F2F6752E6), reinterpret<f64>(0x3FCF5509C0179000),\n  reinterpret<f64>(0x3FE8E6528EFFD79D), reinterpret<f64>(0x3FD00E6C121FB800),\n  reinterpret<f64>(0x3FE8BFCE9FCC007C), reinterpret<f64>(0x3FD071B80E93D000),\n  reinterpret<f64>(0x3FE899C0DABEC30E), reinterpret<f64>(0x3FD0D46B9E867000),\n  reinterpret<f64>(0x3FE87427AA2317FB), reinterpret<f64>(0x3FD13687334BD000),\n  reinterpret<f64>(0x3FE84F00ACB39A08), reinterpret<f64>(0x3FD1980D67234800),\n  reinterpret<f64>(0x3FE82A49E8653E55), reinterpret<f64>(0x3FD1F8FFE0CC8000),\n  reinterpret<f64>(0x3FE8060195F40260), reinterpret<f64>(0x3FD2595FD7636800),\n  reinterpret<f64>(0x3FE7E22563E0A329), reinterpret<f64>(0x3FD2B9300914A800),\n  reinterpret<f64>(0x3FE7BEB377DCB5AD), reinterpret<f64>(0x3FD3187210436000),\n  reinterpret<f64>(0x3FE79BAA679725C2), reinterpret<f64>(0x3FD377266DEC1800),\n  reinterpret<f64>(0x3FE77907F2170657), reinterpret<f64>(0x3FD3D54FFBAF3000),\n  reinterpret<f64>(0x3FE756CADBD6130C), reinterpret<f64>(0x3FD432EEE32FE000)\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB2 = memory.data<f64>([\n  //               chi                ,                  clo\n  reinterpret<f64>(0x3FE61000014FB66B), reinterpret<f64>(0x3C7E026C91425B3C),\n  reinterpret<f64>(0x3FE63000034DB495), reinterpret<f64>(0x3C8DBFEA48005D41),\n  reinterpret<f64>(0x3FE650000D94D478), reinterpret<f64>(0x3C8E7FA786D6A5B7),\n  reinterpret<f64>(0x3FE67000074E6FAD), reinterpret<f64>(0x3C61FCEA6B54254C),\n  reinterpret<f64>(0x3FE68FFFFEDF0FAE), reinterpret<f64>(0xBC7C7E274C590EFD),\n  reinterpret<f64>(0x3FE6B0000763C5BC), reinterpret<f64>(0xBC8AC16848DCDA01),\n  reinterpret<f64>(0x3FE6D0001E5CC1F6), reinterpret<f64>(0x3C833F1C9D499311),\n  reinterpret<f64>(0x3FE6EFFFEB05F63E), reinterpret<f64>(0xBC7E80041AE22D53),\n  reinterpret<f64>(0x3FE710000E869780), reinterpret<f64>(0x3C7BFF6671097952),\n  reinterpret<f64>(0x3FE72FFFFC67E912), reinterpret<f64>(0x3C8C00E226BD8724),\n  reinterpret<f64>(0x3FE74FFFDF81116A), reinterpret<f64>(0xBC6E02916EF101D2),\n  reinterpret<f64>(0x3FE770000F679C90), reinterpret<f64>(0xBC67FC71CD549C74),\n  reinterpret<f64>(0x3FE78FFFFA7EC835), reinterpret<f64>(0x3C81BEC19EF50483),\n  reinterpret<f64>(0x3FE7AFFFFE20C2E6), reinterpret<f64>(0xBC707E1729CC6465),\n  reinterpret<f64>(0x3FE7CFFFED3FC900), reinterpret<f64>(0xBC808072087B8B1C),\n  reinterpret<f64>(0x3FE7EFFFE9261A76), reinterpret<f64>(0x3C8DC0286D9DF9AE),\n  reinterpret<f64>(0x3FE81000049CA3E8), reinterpret<f64>(0x3C897FD251E54C33),\n  reinterpret<f64>(0x3FE8300017932C8F), reinterpret<f64>(0xBC8AFEE9B630F381),\n  reinterpret<f64>(0x3FE850000633739C), reinterpret<f64>(0x3C89BFBF6B6535BC),\n  reinterpret<f64>(0x3FE87000204289C6), reinterpret<f64>(0xBC8BBF65F3117B75),\n  reinterpret<f64>(0x3FE88FFFEBF57904), reinterpret<f64>(0xBC89006EA23DCB57),\n  reinterpret<f64>(0x3FE8B00022BC04DF), reinterpret<f64>(0xBC7D00DF38E04B0A),\n  reinterpret<f64>(0x3FE8CFFFE50C1B8A), reinterpret<f64>(0xBC88007146FF9F05),\n  reinterpret<f64>(0x3FE8EFFFFC918E43), reinterpret<f64>(0x3C83817BD07A7038),\n  reinterpret<f64>(0x3FE910001EFA5FC7), reinterpret<f64>(0x3C893E9176DFB403),\n  reinterpret<f64>(0x3FE9300013467BB9), reinterpret<f64>(0x3C7F804E4B980276),\n  reinterpret<f64>(0x3FE94FFFE6EE076F), reinterpret<f64>(0xBC8F7EF0D9FF622E),\n  reinterpret<f64>(0x3FE96FFFDE3C12D1), reinterpret<f64>(0xBC7082AA962638BA),\n  reinterpret<f64>(0x3FE98FFFF4458A0D), reinterpret<f64>(0xBC87801B9164A8EF),\n  reinterpret<f64>(0x3FE9AFFFDD982E3E), reinterpret<f64>(0xBC8740E08A5A9337),\n  reinterpret<f64>(0x3FE9CFFFED49FB66), reinterpret<f64>(0x3C3FCE08C19BE000),\n  reinterpret<f64>(0x3FE9F00020F19C51), reinterpret<f64>(0xBC8A3FAA27885B0A),\n  reinterpret<f64>(0x3FEA10001145B006), reinterpret<f64>(0x3C74FF489958DA56),\n  reinterpret<f64>(0x3FEA300007BBF6FA), reinterpret<f64>(0x3C8CBEAB8A2B6D18),\n  reinterpret<f64>(0x3FEA500010971D79), reinterpret<f64>(0x3C88FECADD787930),\n  reinterpret<f64>(0x3FEA70001DF52E48), reinterpret<f64>(0xBC8F41763DD8ABDB),\n  reinterpret<f64>(0x3FEA90001C593352), reinterpret<f64>(0xBC8EBF0284C27612),\n  reinterpret<f64>(0x3FEAB0002A4F3E4B), reinterpret<f64>(0xBC69FD043CFF3F5F),\n  reinterpret<f64>(0x3FEACFFFD7AE1ED1), reinterpret<f64>(0xBC823EE7129070B4),\n  reinterpret<f64>(0x3FEAEFFFEE510478), reinterpret<f64>(0x3C6A063EE00EDEA3),\n  reinterpret<f64>(0x3FEB0FFFDB650D5B), reinterpret<f64>(0x3C5A06C8381F0AB9),\n  reinterpret<f64>(0x3FEB2FFFFEAACA57), reinterpret<f64>(0xBC79011E74233C1D),\n  reinterpret<f64>(0x3FEB4FFFD995BADC), reinterpret<f64>(0xBC79FF1068862A9F),\n  reinterpret<f64>(0x3FEB7000249E659C), reinterpret<f64>(0x3C8AFF45D0864F3E),\n  reinterpret<f64>(0x3FEB8FFFF9871640), reinterpret<f64>(0x3C7CFE7796C2C3F9),\n  reinterpret<f64>(0x3FEBAFFFD204CB4F), reinterpret<f64>(0xBC63FF27EEF22BC4),\n  reinterpret<f64>(0x3FEBCFFFD2415C45), reinterpret<f64>(0xBC6CFFB7EE3BEA21),\n  reinterpret<f64>(0x3FEBEFFFF86309DF), reinterpret<f64>(0xBC814103972E0B5C),\n  reinterpret<f64>(0x3FEC0FFFE1B57653), reinterpret<f64>(0x3C8BC16494B76A19),\n  reinterpret<f64>(0x3FEC2FFFF1FA57E3), reinterpret<f64>(0xBC64FEEF8D30C6ED),\n  reinterpret<f64>(0x3FEC4FFFDCBFE424), reinterpret<f64>(0xBC843F68BCEC4775),\n  reinterpret<f64>(0x3FEC6FFFED54B9F7), reinterpret<f64>(0x3C847EA3F053E0EC),\n  reinterpret<f64>(0x3FEC8FFFEB998FD5), reinterpret<f64>(0x3C7383068DF992F1),\n  reinterpret<f64>(0x3FECB0002125219A), reinterpret<f64>(0xBC68FD8E64180E04),\n  reinterpret<f64>(0x3FECCFFFDD94469C), reinterpret<f64>(0x3C8E7EBE1CC7EA72),\n  reinterpret<f64>(0x3FECEFFFEAFDC476), reinterpret<f64>(0x3C8EBE39AD9F88FE),\n  reinterpret<f64>(0x3FED1000169AF82B), reinterpret<f64>(0x3C757D91A8B95A71),\n  reinterpret<f64>(0x3FED30000D0FF71D), reinterpret<f64>(0x3C89C1906970C7DA),\n  reinterpret<f64>(0x3FED4FFFEA790FC4), reinterpret<f64>(0xBC580E37C558FE0C),\n  reinterpret<f64>(0x3FED70002EDC87E5), reinterpret<f64>(0xBC7F80D64DC10F44),\n  reinterpret<f64>(0x3FED900021DC82AA), reinterpret<f64>(0xBC747C8F94FD5C5C),\n  reinterpret<f64>(0x3FEDAFFFD86B0283), reinterpret<f64>(0x3C8C7F1DC521617E),\n  reinterpret<f64>(0x3FEDD000296C4739), reinterpret<f64>(0x3C88019EB2FFB153),\n  reinterpret<f64>(0x3FEDEFFFE54490F5), reinterpret<f64>(0x3C6E00D2C652CC89),\n  reinterpret<f64>(0x3FEE0FFFCDABF694), reinterpret<f64>(0xBC7F8340202D69D2),\n  reinterpret<f64>(0x3FEE2FFFDB52C8DD), reinterpret<f64>(0x3C7B00C1CA1B0864),\n  reinterpret<f64>(0x3FEE4FFFF24216EF), reinterpret<f64>(0x3C72FFA8B094AB51),\n  reinterpret<f64>(0x3FEE6FFFE88A5E11), reinterpret<f64>(0xBC57F673B1EFBE59),\n  reinterpret<f64>(0x3FEE9000119EFF0D), reinterpret<f64>(0xBC84808D5E0BC801),\n  reinterpret<f64>(0x3FEEAFFFDFA51744), reinterpret<f64>(0x3C780006D54320B5),\n  reinterpret<f64>(0x3FEED0001A127FA1), reinterpret<f64>(0xBC5002F860565C92),\n  reinterpret<f64>(0x3FEEF00007BABCC4), reinterpret<f64>(0xBC8540445D35E611),\n  reinterpret<f64>(0x3FEF0FFFF57A8D02), reinterpret<f64>(0xBC4FFB3139EF9105),\n  reinterpret<f64>(0x3FEF30001EE58AC7), reinterpret<f64>(0x3C8A81ACF2731155),\n  reinterpret<f64>(0x3FEF4FFFF5823494), reinterpret<f64>(0x3C8A3F41D4D7C743),\n  reinterpret<f64>(0x3FEF6FFFFCA94C6B), reinterpret<f64>(0xBC6202F41C987875),\n  reinterpret<f64>(0x3FEF8FFFE1F9C441), reinterpret<f64>(0x3C777DD1F477E74B),\n  reinterpret<f64>(0x3FEFAFFFD2E0E37E), reinterpret<f64>(0xBC6F01199A7CA331),\n  reinterpret<f64>(0x3FEFD0001C77E49E), reinterpret<f64>(0x3C7181EE4BCEACB1),\n  reinterpret<f64>(0x3FEFEFFFF7E0C331), reinterpret<f64>(0xBC6E05370170875A),\n  reinterpret<f64>(0x3FF00FFFF465606E), reinterpret<f64>(0xBC8A7EAD491C0ADA),\n  reinterpret<f64>(0x3FF02FFFF3867A58), reinterpret<f64>(0xBC977F69C3FCB2E0),\n  reinterpret<f64>(0x3FF04FFFFDFC0D17), reinterpret<f64>(0x3C97BFFE34CB945B),\n  reinterpret<f64>(0x3FF0700003CD4D82), reinterpret<f64>(0x3C820083C0E456CB),\n  reinterpret<f64>(0x3FF08FFFF9F2CBE8), reinterpret<f64>(0xBC6DFFDFBE37751A),\n  reinterpret<f64>(0x3FF0B000010CDA65), reinterpret<f64>(0xBC913F7FAEE626EB),\n  reinterpret<f64>(0x3FF0D00001A4D338), reinterpret<f64>(0x3C807DFA79489FF7),\n  reinterpret<f64>(0x3FF0EFFFFADAFDFD), reinterpret<f64>(0xBC77040570D66BC0),\n  reinterpret<f64>(0x3FF110000BBAFD96), reinterpret<f64>(0x3C8E80D4846D0B62),\n  reinterpret<f64>(0x3FF12FFFFAE5F45D), reinterpret<f64>(0x3C9DBFFA64FD36EF),\n  reinterpret<f64>(0x3FF150000DD59AD9), reinterpret<f64>(0x3C9A0077701250AE),\n  reinterpret<f64>(0x3FF170000F21559A), reinterpret<f64>(0x3C8DFDF9E2E3DEEE),\n  reinterpret<f64>(0x3FF18FFFFC275426), reinterpret<f64>(0x3C910030DC3B7273),\n  reinterpret<f64>(0x3FF1B000123D3C59), reinterpret<f64>(0x3C997F7980030188),\n  reinterpret<f64>(0x3FF1CFFFF8299EB7), reinterpret<f64>(0xBC65F932AB9F8C67),\n  reinterpret<f64>(0x3FF1EFFFF48AD400), reinterpret<f64>(0x3C937FBF9DA75BEB),\n  reinterpret<f64>(0x3FF210000C8B86A4), reinterpret<f64>(0x3C9F806B91FD5B22),\n  reinterpret<f64>(0x3FF2300003854303), reinterpret<f64>(0x3C93FFC2EB9FBF33),\n  reinterpret<f64>(0x3FF24FFFFFBCF684), reinterpret<f64>(0x3C7601E77E2E2E72),\n  reinterpret<f64>(0x3FF26FFFF52921D9), reinterpret<f64>(0x3C7FFCBB767F0C61),\n  reinterpret<f64>(0x3FF2900014933A3C), reinterpret<f64>(0xBC7202CA3C02412B),\n  reinterpret<f64>(0x3FF2B00014556313), reinterpret<f64>(0xBC92808233F21F02),\n  reinterpret<f64>(0x3FF2CFFFEBFE523B), reinterpret<f64>(0xBC88FF7E384FDCF2),\n  reinterpret<f64>(0x3FF2F0000BB8AD96), reinterpret<f64>(0xBC85FF51503041C5),\n  reinterpret<f64>(0x3FF30FFFFB7AE2AF), reinterpret<f64>(0xBC810071885E289D),\n  reinterpret<f64>(0x3FF32FFFFEAC5F7F), reinterpret<f64>(0xBC91FF5D3FB7B715),\n  reinterpret<f64>(0x3FF350000CA66756), reinterpret<f64>(0x3C957F82228B82BD),\n  reinterpret<f64>(0x3FF3700011FBF721), reinterpret<f64>(0x3C8000BAC40DD5CC),\n  reinterpret<f64>(0x3FF38FFFF9592FB9), reinterpret<f64>(0xBC943F9D2DB2A751),\n  reinterpret<f64>(0x3FF3B00004DDD242), reinterpret<f64>(0x3C857F6B707638E1),\n  reinterpret<f64>(0x3FF3CFFFF5B2C957), reinterpret<f64>(0x3C7A023A10BF1231),\n  reinterpret<f64>(0x3FF3EFFFEAB0B418), reinterpret<f64>(0x3C987F6D66B152B0),\n  reinterpret<f64>(0x3FF410001532AFF4), reinterpret<f64>(0x3C67F8375F198524),\n  reinterpret<f64>(0x3FF4300017478B29), reinterpret<f64>(0x3C8301E672DC5143),\n  reinterpret<f64>(0x3FF44FFFE795B463), reinterpret<f64>(0x3C89FF69B8B2895A),\n  reinterpret<f64>(0x3FF46FFFE80475E0), reinterpret<f64>(0xBC95C0B19BC2F254),\n  reinterpret<f64>(0x3FF48FFFEF6FC1E7), reinterpret<f64>(0x3C9B4009F23A2A72),\n  reinterpret<f64>(0x3FF4AFFFE5BEA704), reinterpret<f64>(0xBC94FFB7BF0D7D45),\n  reinterpret<f64>(0x3FF4D000171027DE), reinterpret<f64>(0xBC99C06471DC6A3D),\n  reinterpret<f64>(0x3FF4F0000FF03EE2), reinterpret<f64>(0x3C977F890B85531C),\n  reinterpret<f64>(0x3FF5100012DC4BD1), reinterpret<f64>(0x3C6004657166A436),\n  reinterpret<f64>(0x3FF530001605277A), reinterpret<f64>(0xBC96BFCECE233209),\n  reinterpret<f64>(0x3FF54FFFECDB704C), reinterpret<f64>(0xBC8902720505A1D7),\n  reinterpret<f64>(0x3FF56FFFEF5F54A9), reinterpret<f64>(0x3C9BBFE60EC96412),\n  reinterpret<f64>(0x3FF5900017E61012), reinterpret<f64>(0x3C887EC581AFEF90),\n  reinterpret<f64>(0x3FF5B00003C93E92), reinterpret<f64>(0xBC9F41080ABF0CC0),\n  reinterpret<f64>(0x3FF5D0001D4919BC), reinterpret<f64>(0xBC98812AFB254729),\n  reinterpret<f64>(0x3FF5EFFFE7B87A89), reinterpret<f64>(0xBC947EB780ED6904)\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG_TABLE_BITS) - 1;\n\n  const\n    B0  = reinterpret<f64>(0xBFE0000000000000), // -0x1p-1\n    B1  = reinterpret<f64>(0x3FD5555555555577), //  0x1.5555555555577p-2\n    B2  = reinterpret<f64>(0xBFCFFFFFFFFFFDCB), // -0x1.ffffffffffdcbp-3\n    B3  = reinterpret<f64>(0x3FC999999995DD0C), //  0x1.999999995dd0cp-3\n    B4  = reinterpret<f64>(0xBFC55555556745A7), // -0x1.55555556745a7p-3\n    B5  = reinterpret<f64>(0x3FC24924A344DE30), //  0x1.24924a344de3p-3\n    B6  = reinterpret<f64>(0xBFBFFFFFA4423D65), // -0x1.fffffa4423d65p-4\n    B7  = reinterpret<f64>(0x3FBC7184282AD6CA), //  0x1.c7184282ad6cap-4\n    B8  = reinterpret<f64>(0xBFB999EB43B068FF), // -0x1.999eb43b068ffp-4\n    B9  = reinterpret<f64>(0x3FB78182F7AFD085), //  0x1.78182f7afd085p-4\n    B10 = reinterpret<f64>(0xBFB5521375D145CD); // -0x1.5521375d145cdp-4\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000001),  // -0x1.0000000000001p-1\n    A1 = reinterpret<f64>(0x3FD555555551305B),  //  0x1.555555551305bp-2\n    A2 = reinterpret<f64>(0xBFCFFFFFFFEB4590),  // -0x1.fffffffeb459p-3\n    A3 = reinterpret<f64>(0x3FC999B324F10111),  //  0x1.999b324f10111p-3\n    A4 = reinterpret<f64>(0xBFC55575E506C89F);  // -0x1.55575e506c89fp-3\n\n  const\n    LO: u64 = 0x3FEE000000000000,\n    HI: u64 = 0x3FF1090000000000;\n\n  const\n    Ln2hi  = reinterpret<f64>(0x3FE62E42FEFA3800), // 0x1.62e42fefa3800p-1\n    Ln2lo  = reinterpret<f64>(0x3D2EF35793C76730), // 0x1.ef35793c76730p-45\n    Ox1p27 = reinterpret<f64>(0x41A0000000000000), // 0x1p27\n    Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  let ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r  = x - 1.0;\n    let r2 = r * r;\n    let r3 = r2 * r;\n    let y =\n      r3 * (B1 + r * B2 + r2 * B3 +\n      r3 * (B4 + r * B5 + r2 * B6 +\n      r3 * (B7 + r * B8 + r2 * B9 + r3 * B10)));\n    // Worst-case error is around 0.507 ULP\n    let w   = r * Ox1p27;\n    let rhi = r + w - w;\n    let rlo = r - rhi;\n    w = rhi * rhi * B0; // B[0] == -0.5\n    let hi = r + w;\n    let lo = r - hi + w;\n    lo += B0 * rlo * (rhi + r);\n    return y + lo + hi;\n  }\n  let top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7FF0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == reinterpret<u64>(Infinity)) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ix - 0x3FE6000000000000;\n  let i    = <usize>((tmp >> (52 - LOG_TABLE_BITS)) & N_MASK);\n  let k    = <i64>tmp >> 52;\n  let iz   = ix - (tmp & (u64(0xFFF) << 52));\n\n  let invc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  let logc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  let z    = reinterpret<f64>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2.\n  // r ~= z/c - 1, |r| < 1/(2*N)\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-66\n  const chi = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T2[i].chi\n  const clo = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T2[i].clo\n  let r = (z - chi - clo) * invc;\n  // #endif\n  let kd = <f64>k;\n\n  // hi + lo = r + log(c) + k*Ln2\n  let w  = kd * Ln2hi + logc;\n  let hi = w + r;\n  let lo = w - hi + r + kd * Ln2lo;\n\n  // log(x) = lo + (log1p(r) - r) + hi\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst case error if |y| > 0x1p-5:\n  // 0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)\n  // Worst case error if |y| > 0x1p-4:\n  // 0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).\n  return lo + r2 * A0 + r * r2 * (A1 + r * A2 + r2 * (A3 + r * A4)) + hi;\n}\n\n//\n// Lookup data for pow. See: https://git.musl-libc.org/cgit/musl/tree/src/math/pow.c\n//\n\n// @ts-ignore: decorator\n@inline const POW_LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals\nand z falls into the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = round(0x1p43*log(c))/0x1p43\n  tab[i].logctail = (double)(log(c) - logc)\n\nwhere c is chosen near the center of the subinterval such that 1/c has only a\nfew precision bits so z/c - 1 is exactly representible as double:\n\n  1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2\n\nNote: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,\nthe last few bits of logc are rounded away so k*ln2hi + logc has no rounding\nerror and the interval for z is selected such that near x == 1, where log(x)\nis tiny, large cancellation error is avoided in logc + poly(z/c - 1). */\n\n// @ts-ignore: decorator\n@lazy @inline const POW_LOG_DATA_TAB = memory.data<f64>([\n  //             invc                 ,pad,               logc                 ,               logctail\n  reinterpret<f64>(0x3FF6A00000000000), 0, reinterpret<f64>(0xBFD62C82F2B9C800), reinterpret<f64>(0x3CFAB42428375680),\n  reinterpret<f64>(0x3FF6800000000000), 0, reinterpret<f64>(0xBFD5D1BDBF580800), reinterpret<f64>(0xBD1CA508D8E0F720),\n  reinterpret<f64>(0x3FF6600000000000), 0, reinterpret<f64>(0xBFD5767717455800), reinterpret<f64>(0xBD2362A4D5B6506D),\n  reinterpret<f64>(0x3FF6400000000000), 0, reinterpret<f64>(0xBFD51AAD872DF800), reinterpret<f64>(0xBCE684E49EB067D5),\n  reinterpret<f64>(0x3FF6200000000000), 0, reinterpret<f64>(0xBFD4BE5F95777800), reinterpret<f64>(0xBD041B6993293EE0),\n  reinterpret<f64>(0x3FF6000000000000), 0, reinterpret<f64>(0xBFD4618BC21C6000), reinterpret<f64>(0x3D13D82F484C84CC),\n  reinterpret<f64>(0x3FF5E00000000000), 0, reinterpret<f64>(0xBFD404308686A800), reinterpret<f64>(0x3CDC42F3ED820B3A),\n  reinterpret<f64>(0x3FF5C00000000000), 0, reinterpret<f64>(0xBFD3A64C55694800), reinterpret<f64>(0x3D20B1C686519460),\n  reinterpret<f64>(0x3FF5A00000000000), 0, reinterpret<f64>(0xBFD347DD9A988000), reinterpret<f64>(0x3D25594DD4C58092),\n  reinterpret<f64>(0x3FF5800000000000), 0, reinterpret<f64>(0xBFD2E8E2BAE12000), reinterpret<f64>(0x3D267B1E99B72BD8),\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\n  reinterpret<f64>(0x3FF5400000000000), 0, reinterpret<f64>(0xBFD22941FBCF7800), reinterpret<f64>(0xBD165A242853DA76),\n  reinterpret<f64>(0x3FF5200000000000), 0, reinterpret<f64>(0xBFD1C898C1699800), reinterpret<f64>(0xBD1FAFBC68E75404),\n  reinterpret<f64>(0x3FF5000000000000), 0, reinterpret<f64>(0xBFD1675CABABA800), reinterpret<f64>(0x3D1F1FC63382A8F0),\n  reinterpret<f64>(0x3FF4E00000000000), 0, reinterpret<f64>(0xBFD1058BF9AE4800), reinterpret<f64>(0xBD26A8C4FD055A66),\n  reinterpret<f64>(0x3FF4C00000000000), 0, reinterpret<f64>(0xBFD0A324E2739000), reinterpret<f64>(0xBD0C6BEE7EF4030E),\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\n  reinterpret<f64>(0x3FF4800000000000), 0, reinterpret<f64>(0xBFCFB9186D5E4000), reinterpret<f64>(0x3D0D572AAB993C87),\n  reinterpret<f64>(0x3FF4600000000000), 0, reinterpret<f64>(0xBFCEF0ADCBDC6000), reinterpret<f64>(0x3D2B26B79C86AF24),\n  reinterpret<f64>(0x3FF4400000000000), 0, reinterpret<f64>(0xBFCE27076E2AF000), reinterpret<f64>(0xBD172F4F543FFF10),\n  reinterpret<f64>(0x3FF4200000000000), 0, reinterpret<f64>(0xBFCD5C216B4FC000), reinterpret<f64>(0x3D21BA91BBCA681B),\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\n  reinterpret<f64>(0x3FF3E00000000000), 0, reinterpret<f64>(0xBFCBC286742D9000), reinterpret<f64>(0x3D194EB0318BB78F),\n  reinterpret<f64>(0x3FF3C00000000000), 0, reinterpret<f64>(0xBFCAF3C94E80C000), reinterpret<f64>(0x3CBA4E633FCD9066),\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\n  reinterpret<f64>(0x3FF3800000000000), 0, reinterpret<f64>(0xBFC9525A9CF45000), reinterpret<f64>(0xBD2AD1D904C1D4E3),\n  reinterpret<f64>(0x3FF3600000000000), 0, reinterpret<f64>(0xBFC87FA06520D000), reinterpret<f64>(0x3D2BBDBF7FDBFA09),\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\n  reinterpret<f64>(0x3FF3200000000000), 0, reinterpret<f64>(0xBFC6D60FE719D000), reinterpret<f64>(0xBD10E46AA3B2E266),\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\n  reinterpret<f64>(0x3FF2E00000000000), 0, reinterpret<f64>(0xBFC526E5E3A1B000), reinterpret<f64>(0xBD20DE8B90075B8F),\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\n  reinterpret<f64>(0x3FF2A00000000000), 0, reinterpret<f64>(0xBFC371FC201E9000), reinterpret<f64>(0x3CF178864D27543A),\n  reinterpret<f64>(0x3FF2800000000000), 0, reinterpret<f64>(0xBFC29552F81FF000), reinterpret<f64>(0xBD248D301771C408),\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\n  reinterpret<f64>(0x3FF2200000000000), 0, reinterpret<f64>(0xBFBFEC9131DBE000), reinterpret<f64>(0xBD2575545CA333F2),\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\n  reinterpret<f64>(0x3FF1E00000000000), 0, reinterpret<f64>(0xBFBC5E548F5BC000), reinterpret<f64>(0xBD1D0C57585FBE06),\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\n  reinterpret<f64>(0x3FF1800000000000), 0, reinterpret<f64>(0xBFB6F0D28AE56000), reinterpret<f64>(0xBD269737C93373DA),\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\n  reinterpret<f64>(0x3FF1200000000000), 0, reinterpret<f64>(0xBFB16536EEA38000), reinterpret<f64>(0x3D147C5E768FA309),\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\n  reinterpret<f64>(0x3FF0600000000000), 0, reinterpret<f64>(0xBF97B91B07D58000), reinterpret<f64>(0xBD288D5493FAA639),\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\n  reinterpret<f64>(0x3FEFC00000000000), 0, reinterpret<f64>(0x3F80101575890000), reinterpret<f64>(0xBD10C76B999D2BE8),\n  reinterpret<f64>(0x3FEF800000000000), 0, reinterpret<f64>(0x3F90205658938000), reinterpret<f64>(0xBD23DC5B06E2F7D2),\n  reinterpret<f64>(0x3FEF400000000000), 0, reinterpret<f64>(0x3F98492528C90000), reinterpret<f64>(0xBD2AA0BA325A0C34),\n  reinterpret<f64>(0x3FEF000000000000), 0, reinterpret<f64>(0x3FA0415D89E74000), reinterpret<f64>(0x3D0111C05CF1D753),\n  reinterpret<f64>(0x3FEEC00000000000), 0, reinterpret<f64>(0x3FA466AED42E0000), reinterpret<f64>(0xBD2C167375BDFD28),\n  reinterpret<f64>(0x3FEE800000000000), 0, reinterpret<f64>(0x3FA894AA149FC000), reinterpret<f64>(0xBD197995D05A267D),\n  reinterpret<f64>(0x3FEE400000000000), 0, reinterpret<f64>(0x3FACCB73CDDDC000), reinterpret<f64>(0xBD1A68F247D82807),\n  reinterpret<f64>(0x3FEE200000000000), 0, reinterpret<f64>(0x3FAEEA31C006C000), reinterpret<f64>(0xBD0E113E4FC93B7B),\n  reinterpret<f64>(0x3FEDE00000000000), 0, reinterpret<f64>(0x3FB1973BD1466000), reinterpret<f64>(0xBD25325D560D9E9B),\n  reinterpret<f64>(0x3FEDA00000000000), 0, reinterpret<f64>(0x3FB3BDF5A7D1E000), reinterpret<f64>(0x3D2CC85EA5DB4ED7),\n  reinterpret<f64>(0x3FED600000000000), 0, reinterpret<f64>(0x3FB5E95A4D97A000), reinterpret<f64>(0xBD2C69063C5D1D1E),\n  reinterpret<f64>(0x3FED400000000000), 0, reinterpret<f64>(0x3FB700D30AEAC000), reinterpret<f64>(0x3CEC1E8DA99DED32),\n  reinterpret<f64>(0x3FED000000000000), 0, reinterpret<f64>(0x3FB9335E5D594000), reinterpret<f64>(0x3D23115C3ABD47DA),\n  reinterpret<f64>(0x3FECC00000000000), 0, reinterpret<f64>(0x3FBB6AC88DAD6000), reinterpret<f64>(0xBD1390802BF768E5),\n  reinterpret<f64>(0x3FECA00000000000), 0, reinterpret<f64>(0x3FBC885801BC4000), reinterpret<f64>(0x3D2646D1C65AACD3),\n  reinterpret<f64>(0x3FEC600000000000), 0, reinterpret<f64>(0x3FBEC739830A2000), reinterpret<f64>(0xBD2DC068AFE645E0),\n  reinterpret<f64>(0x3FEC400000000000), 0, reinterpret<f64>(0x3FBFE89139DBE000), reinterpret<f64>(0xBD2534D64FA10AFD),\n  reinterpret<f64>(0x3FEC000000000000), 0, reinterpret<f64>(0x3FC1178E8227E000), reinterpret<f64>(0x3D21EF78CE2D07F2),\n  reinterpret<f64>(0x3FEBE00000000000), 0, reinterpret<f64>(0x3FC1AA2B7E23F000), reinterpret<f64>(0x3D2CA78E44389934),\n  reinterpret<f64>(0x3FEBA00000000000), 0, reinterpret<f64>(0x3FC2D1610C868000), reinterpret<f64>(0x3D039D6CCB81B4A1),\n  reinterpret<f64>(0x3FEB800000000000), 0, reinterpret<f64>(0x3FC365FCB0159000), reinterpret<f64>(0x3CC62FA8234B7289),\n  reinterpret<f64>(0x3FEB400000000000), 0, reinterpret<f64>(0x3FC4913D8333B000), reinterpret<f64>(0x3D25837954FDB678),\n  reinterpret<f64>(0x3FEB200000000000), 0, reinterpret<f64>(0x3FC527E5E4A1B000), reinterpret<f64>(0x3D2633E8E5697DC7),\n  reinterpret<f64>(0x3FEAE00000000000), 0, reinterpret<f64>(0x3FC6574EBE8C1000), reinterpret<f64>(0x3D19CF8B2C3C2E78),\n  reinterpret<f64>(0x3FEAC00000000000), 0, reinterpret<f64>(0x3FC6F0128B757000), reinterpret<f64>(0xBD25118DE59C21E1),\n  reinterpret<f64>(0x3FEAA00000000000), 0, reinterpret<f64>(0x3FC7898D85445000), reinterpret<f64>(0xBD1C661070914305),\n  reinterpret<f64>(0x3FEA600000000000), 0, reinterpret<f64>(0x3FC8BEAFEB390000), reinterpret<f64>(0xBD073D54AAE92CD1),\n  reinterpret<f64>(0x3FEA400000000000), 0, reinterpret<f64>(0x3FC95A5ADCF70000), reinterpret<f64>(0x3D07F22858A0FF6F),\n  reinterpret<f64>(0x3FEA000000000000), 0, reinterpret<f64>(0x3FCA93ED3C8AE000), reinterpret<f64>(0xBD28724350562169),\n  reinterpret<f64>(0x3FE9E00000000000), 0, reinterpret<f64>(0x3FCB31D8575BD000), reinterpret<f64>(0xBD0C358D4EACE1AA),\n  reinterpret<f64>(0x3FE9C00000000000), 0, reinterpret<f64>(0x3FCBD087383BE000), reinterpret<f64>(0xBD2D4BC4595412B6),\n  reinterpret<f64>(0x3FE9A00000000000), 0, reinterpret<f64>(0x3FCC6FFBC6F01000), reinterpret<f64>(0xBCF1EC72C5962BD2),\n  reinterpret<f64>(0x3FE9600000000000), 0, reinterpret<f64>(0x3FCDB13DB0D49000), reinterpret<f64>(0xBD2AFF2AF715B035),\n  reinterpret<f64>(0x3FE9400000000000), 0, reinterpret<f64>(0x3FCE530EFFE71000), reinterpret<f64>(0x3CC212276041F430),\n  reinterpret<f64>(0x3FE9200000000000), 0, reinterpret<f64>(0x3FCEF5ADE4DD0000), reinterpret<f64>(0xBCCA211565BB8E11),\n  reinterpret<f64>(0x3FE9000000000000), 0, reinterpret<f64>(0x3FCF991C6CB3B000), reinterpret<f64>(0x3D1BCBECCA0CDF30),\n  reinterpret<f64>(0x3FE8C00000000000), 0, reinterpret<f64>(0x3FD07138604D5800), reinterpret<f64>(0x3CF89CDB16ED4E91),\n  reinterpret<f64>(0x3FE8A00000000000), 0, reinterpret<f64>(0x3FD0C42D67616000), reinterpret<f64>(0x3D27188B163CEAE9),\n  reinterpret<f64>(0x3FE8800000000000), 0, reinterpret<f64>(0x3FD1178E8227E800), reinterpret<f64>(0xBD2C210E63A5F01C),\n  reinterpret<f64>(0x3FE8600000000000), 0, reinterpret<f64>(0x3FD16B5CCBACF800), reinterpret<f64>(0x3D2B9ACDF7A51681),\n  reinterpret<f64>(0x3FE8400000000000), 0, reinterpret<f64>(0x3FD1BF99635A6800), reinterpret<f64>(0x3D2CA6ED5147BDB7),\n  reinterpret<f64>(0x3FE8200000000000), 0, reinterpret<f64>(0x3FD214456D0EB800), reinterpret<f64>(0x3D0A87DEBA46BAEA),\n  reinterpret<f64>(0x3FE7E00000000000), 0, reinterpret<f64>(0x3FD2BEF07CDC9000), reinterpret<f64>(0x3D2A9CFA4A5004F4),\n  reinterpret<f64>(0x3FE7C00000000000), 0, reinterpret<f64>(0x3FD314F1E1D36000), reinterpret<f64>(0xBD28E27AD3213CB8),\n  reinterpret<f64>(0x3FE7A00000000000), 0, reinterpret<f64>(0x3FD36B6776BE1000), reinterpret<f64>(0x3D116ECDB0F177C8),\n  reinterpret<f64>(0x3FE7800000000000), 0, reinterpret<f64>(0x3FD3C25277333000), reinterpret<f64>(0x3D183B54B606BD5C),\n  reinterpret<f64>(0x3FE7600000000000), 0, reinterpret<f64>(0x3FD419B423D5E800), reinterpret<f64>(0x3D08E436EC90E09D),\n  reinterpret<f64>(0x3FE7400000000000), 0, reinterpret<f64>(0x3FD4718DC271C800), reinterpret<f64>(0xBD2F27CE0967D675),\n  reinterpret<f64>(0x3FE7200000000000), 0, reinterpret<f64>(0x3FD4C9E09E173000), reinterpret<f64>(0xBD2E20891B0AD8A4),\n  reinterpret<f64>(0x3FE7000000000000), 0, reinterpret<f64>(0x3FD522AE0738A000), reinterpret<f64>(0x3D2EBE708164C759),\n  reinterpret<f64>(0x3FE6E00000000000), 0, reinterpret<f64>(0x3FD57BF753C8D000), reinterpret<f64>(0x3D1FADEDEE5D40EF),\n  reinterpret<f64>(0x3FE6C00000000000), 0, reinterpret<f64>(0x3FD5D5BDDF596000), reinterpret<f64>(0xBD0A0B2A08A465DC)\n]);\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkint(iy: u64): i32 {\n  let e = iy >> 52 & 0x7FF;\n  if (e < 0x3FF     ) return 0;\n  if (e > 0x3FF + 52) return 2;\n  e = u64(1) << (0x3FF + 52 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflow(sign: u32, y: f64): f64 {\n  return select(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x1000000000000000)); // 0x1p-767\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x7000000000000000)); // 0x1p769\n}\n\n// Returns 1 if input is the bit representation of 0, infinity or nan.\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnan(u: u64): bool {\n  return (u << 1) - 1 >= 0xFFE0000000000000 - 1;\n}\n\n// @ts-ignore: decorator\n@lazy let log_tail: f64 = 0;\n\n// Compute y+TAIL = log(x) where the rounded result is y and TAIL has about\n// additional 15 bits precision. IX is the bit representation of x, but\n// normalized in the subnormal range using the sign bit for the exponent.\n// @ts-ignore: decorator\n@inline\nfunction log_inline(ix: u64): f64 {\n  const N = 1 << POW_LOG_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    Ln2hi = reinterpret<f64>(0x3FE62E42FEFA3800),\n    Ln2lo = reinterpret<f64>(0x3D2EF35793C76730);\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000000),\n    A1 = reinterpret<f64>(0xBFE5555555555560),\n    A2 = reinterpret<f64>(0x3FE0000000000006),\n    A3 = reinterpret<f64>(0x3FE999999959554E),\n    A4 = reinterpret<f64>(0xBFE555555529A47A),\n    A5 = reinterpret<f64>(0xBFF2495B9B4845E9),\n    A6 = reinterpret<f64>(0x3FF0002B8B263FC3);\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp = ix - 0x3fE6955500000000;\n  let i   = usize((tmp >> (52 - POW_LOG_TABLE_BITS)) & N_MASK);\n  let k   = <i64>tmp >> 52;\n  let iz  = ix - (tmp & u64(0xFFF) << 52);\n  let z   = reinterpret<f64>(iz);\n  let kd  = <f64>k;\n\n  // log(x) = k*Ln2 + log(c) + log1p(z/c-1).\n  let invc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 0 << alignof<f64>()); // tab[i].invc\n  let logc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 2 << alignof<f64>()); // tab[i].logc\n  let logctail = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 3 << alignof<f64>()); // tab[i].logctail\n\n  // Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and\n  // |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.\n  // Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.\n  let zhi = reinterpret<f64>((iz + u64(0x80000000)) & 0xFFFFFFFF00000000);\n  let zlo = z - zhi;\n  let rhi = zhi * invc - 1.0;\n  let rlo = zlo * invc;\n  let r   = rhi + rlo;\n\n  // k * Ln2 + log(c) + r.\n  let t1  = kd * Ln2hi + logc;\n  let t2  = t1 + r;\n  let lo1 = kd * Ln2lo + logctail;\n  let lo2 = t1 - t2 + r;\n\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  let ar  = A0 * r; // A[0] = -0.5\n  let ar2 = r * ar;\n  let ar3 = r * ar2;\n  // k * Ln2 + log(c) + r + A[0] * r * r.\n  let arhi  = A0  * rhi;\n  let arhi2 = rhi * arhi;\n  let hi    = t2  + arhi2;\n  let lo3   = rlo * (ar + arhi);\n  let lo4   = t2 - hi + arhi2;\n\n  // p = log1p(r) - r - A[0] * r * r.\n  let p  = ar3 * (A1 + r * A2 + ar2 * (A3 + r * A4 + ar2 * (A5 + r * A6)));\n  let lo = lo1 + lo2 + lo3 + lo4 + p;\n  let y  = hi + lo;\n  log_tail = hi - y + lo;\n\n  return y;\n}\n\n// @ts-ignore: decorator\n@inline const SIGN_BIAS = 0x800 << EXP_TABLE_BITS;\n\n// Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.\n// The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.\n// @ts-ignore: decorator\n@inline\nfunction exp_inline(x: f64, xtail: f64, sign_bias: u32): f64 {\n  const N      = 1 << EXP_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  let abstop: u32;\n  let ki: u64, top: u64, sbits: u64;\n  let idx: usize;\n  // double_t for better performance on targets with FLT_EVAL_METHOD==2.\n  let kd: f64, z: f64, r: f64, r2: f64, scale: f64, tail: f64, tmp: f64;\n\n  let ux = reinterpret<u64>(x);\n  abstop = u32(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) {\n      // Avoid spurious underflow for tiny x.\n      // Note: 0 is common input.\n      return select(-1.0, 1.0, sign_bias);\n    }\n    if (abstop >= 0x409) { // top12(1024.0)\n      // Note: inf and nan are already handled.\n      return <i64>ux < 0\n        ? uflow(sign_bias)\n        : oflow(sign_bias);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].\n  z = InvLn2N * x;\n\n  // #if TOINT_INTRINSICS\n  //   kd = roundtoint(z);\n  //   ki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  //   // z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  //   kd = eval_as_double(z + shift);\n  //   ki = asuint64(kd) >> 16;\n  //   kd = (double_t)(int32_t)ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes\n  kd  = z + shift;\n  ki  = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // The code assumes 2^-200 < |xtail| < 2^-8/N\n  r += xtail;\n  // 2^(k/N) ~= scale * (1 + tail)\n  idx = usize((ki & N_MASK) << 1);\n  top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);\n\n  tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>())));\n  // This is only a valid scale when -1023*N < k < 1024*N\n  sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top;\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp\n  tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function pow_lut(x: f64, y: f64): f64 {\n  const Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  let sign_bias: u32 = 0;\n  let ix = reinterpret<u64>(x);\n  let iy = reinterpret<u64>(y);\n  let topx = ix >> 52;\n  let topy = iy >> 52;\n\n  if (topx - 0x001 >= 0x7FF - 0x001 || (topy & 0x7FF) - 0x3BE >= 0x43e - 0x3BE) {\n    // Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0\n    // and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.\n    // Special cases: (x < 0x1p-126 or inf or nan) or\n    // (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).\n    if (zeroinfnan(iy)) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3FF0000000000000) return NaN; // original: 1.0\n      if ((ix << 1) > 0xFFE0000000000000 || (iy << 1) > 0xFFE0000000000000) return x + y;\n      if ((ix << 1) == 0x7FE0000000000000) return NaN; // original: 1.0\n      if (((ix << 1) < 0x7FE0000000000000) == !(iy >> 63)) return 0; // |x|<1 && y==inf or |x|>1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnan(ix)) {\n      let x2 = x * x;\n      if (i32(ix >> 63) && checkint(iy) == 1) x2 = -x2;\n      return <i64>iy < 0 ? 1 / x2 : x2;\n    }\n    // Here x and y are non-zero finite\n    if (<i64>ix < 0) {\n      // Finite x < 0\n      let yint = checkint(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) sign_bias = SIGN_BIAS;\n      ix   &= 0x7FFFFFFFFFFFFFFF;\n      topx &= 0x7FF;\n    }\n    if ((topy & 0x7FF) - 0x3BE >= 0x43E - 0x3BE) {\n      // Note: sign_bias == 0 here because y is not odd.\n      if (ix == 0x3FF0000000000000) return 1;\n      if ((topy & 0x7FF) < 0x3BE)   return 1; // |y| < 2^-65, x^y ~= 1 + y*log(x).\n      return (ix > 0x3FF0000000000000) == (topy < 0x800) ? Infinity : 0;\n    }\n    if (topx == 0) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u64>(x * Ox1p52);\n      ix &= 0x7FFFFFFFFFFFFFFF;\n      ix -= u64(52) << 52;\n    }\n  }\n\n  let hi = log_inline(ix);\n  let lo = log_tail;\n  let ehi: f64, elo: f64;\n  // #if __FP_FAST_FMA\n  //   ehi = y * hi;\n  //   elo = y * lo + __builtin_fma(y, hi, -ehi);\n  // #else\n  let yhi = reinterpret<f64>(iy & 0xFFFFFFFFF8000000);\n  let ylo = y - yhi;\n  let lhi = reinterpret<f64>(reinterpret<u64>(hi) & 0xFFFFFFFFF8000000);\n  let llo = hi - lhi + lo;\n  ehi = yhi * lhi;\n  elo = ylo * lhi + y * llo; // |elo| < |ehi| * 2^-25.\n  // #endif\n  return exp_inline(ehi, elo, sign_bias);\n}\n","import {\n  itoa32,\n  utoa32,\n  itoa64,\n  utoa64,\n  dtoa,\n  itoa_buffered,\n  dtoa_buffered,\n  MAX_DOUBLE_LENGTH\n} from \"./number\";\n\nimport {\n  ipow32\n} from \"../math\";\n\n// All tables are stored as two staged lookup tables (static tries)\n// because the full range of Unicode symbols can't be efficiently\n// represented as-is in memory (see Unicode spec ch 5, p.196):\n// https://www.unicode.org/versions/Unicode12.0.0/ch05.pdf\n// Tables have been generated using these forked musl tools:\n// https://github.com/MaxGraey/musl-chartable-tools/tree/case-ignorable\n\n// Lookup table to check if a character is alphanumeric or not\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/alpha.h\n// size: 3904 bytes\n// @ts-ignore\n@inline @lazy const ALPHA_TABLE = memory.data<u8>([\n  18,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,17,34,35,36,17,37,38,39,40,\n  41,42,43,44,17,45,46,47,16,16,48,16,16,16,16,16,16,16,49,50,51,16,52,53,16,16,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,54,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,55,17,17,17,17,56,17,57,58,59,60,61,62,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,63,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,64,65,17,66,67,\n  68,69,70,71,72,73,74,17,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,\n  93,94,16,95,96,97,98,17,17,17,99,100,101,16,16,16,16,16,16,16,16,16,16,17,17,\n  17,17,102,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,103,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,17,17,104,105,16,16,106,107,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,108,17,17,17,17,109,110,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  17,111,112,16,16,16,16,16,16,16,16,16,113,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,114,115,116,117,16,16,16,16,16,16,16,16,118,\n  119,120,16,16,16,16,16,121,122,16,16,16,16,123,16,16,124,16,16,16,16,16,16,16,\n  16,16,125,16,16,16,\n  16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,254,255,255,7,254,\n  255,255,7,0,0,0,0,0,4,32,4,255,255,127,255,255,255,127,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,195,255,3,0,31,80,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,223,188,64,215,255,255,\n  251,255,255,255,255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,3,252,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,127,2,255,255,255,\n  255,255,1,0,0,0,0,255,191,182,0,255,255,255,135,7,0,0,0,255,7,255,255,255,255,\n  255,255,255,254,255,195,255,255,255,255,255,255,255,255,255,255,255,255,239,\n  31,254,225,255,\n  159,0,0,255,255,255,255,255,255,0,224,255,255,255,255,255,255,255,255,255,255,\n  255,255,3,0,255,255,255,255,255,7,48,4,255,255,255,252,255,31,0,0,255,255,255,\n  1,255,7,0,0,0,0,0,0,255,255,223,255,255,0,240,255,248,3,255,255,255,255,255,\n  255,255,255,255,239,255,223,225,255,207,255,254,255,239,159,249,255,255,253,\n  197,227,159,89,128,176,207,255,3,16,238,135,249,255,255,253,109,195,135,25,2,\n  94,192,255,63,0,238,191,251,255,255,253,237,227,191,27,1,0,207,255,0,30,238,\n  159,249,255,255,253,237,227,159,25,192,176,207,255,2,0,236,199,61,214,24,199,\n  255,195,199,29,129,0,192,255,0,0,239,223,253,255,255,253,255,227,223,29,96,7,\n  207,255,0,0,239,223,253,255,255,253,239,227,223,29,96,64,207,255,6,0,255,223,\n  253,255,255,255,255,231,223,93,240,128,207,255,0,252,238,255,127,252,255,255,\n  251,47,127,128,95,255,192,255,12,0,254,255,255,255,255,127,255,7,63,32,255,3,\n  0,0,0,0,214,247,255,255,175,255,255,59,95,32,255,243,0,0,0,\n  0,1,0,0,0,255,3,0,0,255,254,255,255,255,31,254,255,3,255,255,254,255,255,255,\n  31,0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,249,255,3,255,255,255,255,255,\n  255,255,255,255,63,255,255,255,255,191,32,255,255,255,255,255,247,255,255,255,\n  255,255,255,255,255,255,61,127,61,255,255,255,255,255,61,255,255,255,255,61,\n  127,61,255,127,255,255,255,255,255,255,255,61,255,255,255,255,255,255,255,255,\n  7,0,0,0,0,255,255,0,0,255,255,255,255,255,255,255,255,255,255,63,63,254,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,159,255,255,254,255,255,7,255,255,255,255,255,255,255,255,\n  255,199,255,1,255,223,15,0,255,255,15,0,255,255,15,0,255,223,13,0,255,255,255,\n  255,255,255,207,255,255,1,128,16,255,3,0,0,0,0,255,3,255,255,255,255,255,255,\n  255,255,255,255,255,1,255,255,255,255,255,7,255,255,255,255,255,255,255,255,\n  63,\n  0,255,255,255,127,255,15,255,1,192,255,255,255,255,63,31,0,255,255,255,255,\n  255,15,255,255,255,3,255,3,0,0,0,0,255,255,255,15,255,255,255,255,255,255,255,\n  127,254,255,31,0,255,3,255,3,128,0,0,128,1,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,239,255,239,15,255,3,0,0,0,0,255,255,255,255,255,243,255,255,255,255,255,\n  255,191,255,3,0,255,255,255,255,255,255,127,0,255,227,255,255,255,255,255,63,\n  255,1,255,255,255,255,255,231,0,0,0,0,0,222,111,4,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,\n  128,255,31,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,255,\n  255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,132,252,47,62,80,189,255,243,\n  224,67,0,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,\n  0,255,255,255,255,255,127,255,255,255,255,255,127,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,31,120,12,0,255,255,255,255,191,32,255,\n  255,255,255,255,255,255,128,0,0,255,255,127,0,127,127,127,127,127,127,127,127,\n  255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,224,0,0,0,254,3,62,31,254,255,255,255,255,255,255,255,255,255,127,224,254,\n  255,255,255,255,255,255,255,255,255,255,247,224,255,255,255,255,255,254,255,\n  255,255,255,255,255,255,255,255,255,127,0,0,255,255,255,255,0,0,0,0,0,0,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,\n  31,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,63,255,31,255,255,255,15,0,0,255,255,255,255,\n  255,127,240,143,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,\n  0,128,255,252,255,255,255,255,255,255,255,255,255,255,255,255,249,255,255,255,\n  255,255,255,252,7,0,0,0,0,224,255,191,255,255,255,255,0,0,0,255,255,255,255,\n  255,255,15,0,255,255,255,255,255,255,255,255,47,0,255,3,0,0,252,232,255,255,\n  255,255,255,7,255,255,255,255,7,0,255,255,255,31,255,255,255,255,255,255,247,\n  255,0,128,255,3,255,255,255,127,255,255,255,255,255,255,127,0,255,63,255,3,\n  255,255,127,252,255,255,255,255,255,255,255,127,5,0,0,56,255,255,60,0,126,126,\n  126,0,127,127,255,255,255,255,255,247,255,3,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,7,255,3,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,15,0,255,255,127,248,255,255,255,255,\n  255,\n  15,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,3,0,0,0,0,127,0,248,224,255,253,127,95,219,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,0,0,248,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,0,0,255,255,255,255,255,255,255,255,\n  252,255,255,255,255,255,255,0,0,0,0,0,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,223,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,255,3,\n  254,255,255,7,254,255,255,7,192,255,255,255,255,255,255,255,255,255,255,127,\n  252,252,252,28,0,0,0,0,255,239,255,255,127,255,255,183,255,63,255,63,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,31,255,255,255,255,255,255,1,0,0,0,0,\n  0,255,255,255,255,0,224,255,255,255,7,255,255,255,255,255,7,255,255,255,63,\n  255,255,255,255,15,255,62,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,255,3,255,255,255,255,15,255,255,255,\n  255,15,255,255,255,255,255,0,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,0,255,255,63,0,255,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,63,253,255,255,255,255,191,145,255,255,63,0,255,255,\n  127,0,255,255,255,127,0,0,0,0,0,0,0,0,255,255,55,0,255,255,63,0,255,255,255,3,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,192,0,0,0,0,0,0,0,0,111,240,239,\n  254,255,255,63,0,0,0,0,0,255,255,255,31,255,255,255,31,0,0,0,0,255,254,255,\n  255,31,0,0,0,255,255,255,255,255,255,63,0,255,255,63,0,255,255,7,0,255,255,3,\n  0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,255,255,255,255,255,255,7,\n  0,255,255,255,255,255,255,7,0,255,255,255,255,255,0,255,3,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  255,27,3,0,0,0,0,0,0,0,0,0,255,255,255,31,128,0,255,255,63,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,31,0,0,0,255,255,127,0,255,255,255,255,255,255,255,255,63,0,0,\n  0,192,255,0,0,252,255,255,255,255,255,255,1,0,0,255,255,255,1,255,3,255,255,\n  255,255,255,255,199,255,240,0,255,255,255,255,71,0,255,255,255,255,255,255,\n  255,255,30,192,255,23,0,0,0,0,255,255,251,255,255,255,159,64,0,0,0,0,0,0,0,0,\n  127,189,255,191,255,1,255,255,255,255,255,255,255,1,255,3,239,159,249,255,255,\n  253,237,227,159,25,129,224,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,187,7,255,131,3,0,0,0,255,255,255,255,255,\n  255,255,255,179,0,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  255,255,255,63,127,0,0,0,63,0,0,0,0,255,255,255,255,255,255,255,127,17,0,255,\n  3,0,0,0,0,255,255,255,255,255,255,63,1,255,3,0,0,0,0,0,0,255,255,255,231,255,\n  7,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,3,0,128,\n  127,242,111,255,255,255,191,153,7,0,255,3,0,0,0,0,0,0,0,0,255,252,255,255,255,\n  255,255,252,26,0,0,0,255,255,255,255,255,255,231,127,0,0,255,255,255,255,255,\n  255,255,255,255,32,0,0,0,0,255,255,255,255,255,255,255,1,255,253,255,255,255,\n  255,127,127,1,0,255,3,0,0,252,255,255,255,252,255,255,254,127,0,0,0,0,0,0,0,0,\n  0,127,251,255,255,255,255,127,180,203,0,255,3,191,253,255,255,255,127,123,1,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,127,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,\n  0,255,255,255,255,255,255,255,1,255,255,255,127,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,63,0,0,255,255,255,255,255,255,0,0,15,0,255,3,248,255,255,224,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,135,\n  255,255,255,255,255,255,255,128,255,255,0,0,0,0,0,0,0,0,11,0,3,0,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,0,0,\n  255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  127,0,0,0,0,0,0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,15,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,7,255,31,255,1,255,67,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,255,255,\n  223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,\n  255,123,95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,63,255,255,255,253,255,255,247,255,255,255,\n  247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,255,253,\n  255,255,255,253,255,255,247,207,255,255,255,255,255,255,127,255,255,249,219,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,31,\n  128,63,255,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,15,255,\n  3,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,31,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,143,8,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,239,255,255,255,150,254,247,10,\n  132,234,150,170,150,247,247,94,255,251,255,15,238,251,255,15,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3\n]);\n\n// size: 1568 bytes (compressed to ~1380 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASED = memory.data<u8>([\n  18,19,20,21,22,23,16,16,16,16,16,16,16,16,16,16,\n  24,16,16,25,16,16,16,16,16,16,16,16,26,27,17,28,\n  29,30,16,16,31,16,16,16,16,16,16,16,32,33,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,34,35,16,16,16,36,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,37,16,16,16,38,\n  16,16,16,16,39,16,16,16,16,16,16,16,40,16,16,16,\n  16,16,16,16,16,16,16,16,41,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,42,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,43,44,45,46,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,47,16,16,16,16,16,16,\n  16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,254,255,255,7,254,255,255,7,0,0,0,0,0,4,32,4,\n  255,255,127,255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,247,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,239,255,255,255,255,1,3,0,0,0,31,0,0,0,\n  0,0,0,0,0,0,0,0,32,0,0,0,0,0,207,188,64,215,255,255,251,255,255,255,\n  255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  3,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,\n  255,255,127,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  191,32,255,255,255,255,255,231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,255,255,255,255,255,255,63,63,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,1,255,255,255,255,255,231,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,\n  255,255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,\n  132,252,47,62,80,189,31,242,224,67,0,0,255,255,255,255,24,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,0,255,255,255,255,255,127,255,255,\n  255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,120,12,0,\n  255,255,255,255,191,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,63,0,0,\n  255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,255,255,\n  255,255,255,255,255,255,255,255,255,120,255,255,255,255,255,255,252,7,0,0,0,0,96,7,\n  0,0,0,0,0,0,255,255,255,255,255,247,255,1,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,127,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,7,\n  254,255,255,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,15,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,7,0,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,\n  255,255,255,223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,255,123,\n  95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,\n  253,255,255,247,255,255,255,247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,\n  255,253,255,255,255,253,255,255,247,15,0,0,0,0,0,0,255,255,255,255,255,255,255,255,\n  15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0\n]);\n\n// size: 2976 bytes (compressed to ~2050 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASE_IGNORABLES = memory.data<u8>([\n  18,16,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\n  33,16,16,34,16,16,16,35,36,37,38,39,40,41,16,42,\n  43,16,16,16,16,16,16,16,16,16,16,16,44,45,46,16,\n  47,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  48,16,16,16,49,16,50,51,52,53,54,55,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,56,16,16,57,58,\n  16,59,60,61,16,16,16,16,16,16,62,16,16,63,64,65,\n  66,67,68,69,70,71,72,73,74,75,76,16,77,78,79,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,80,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,81,82,16,16,16,83,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,84,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,85,86,16,16,16,16,16,16,16,87,16,16,16,16,16,\n  88,89,90,16,16,16,16,16,91,92,16,16,16,16,16,16,\n  16,16,16,93,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,128,64,0,4,0,0,0,64,1,0,0,0,0,0,0,0,0,161,144,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,48,4,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0,0,0,\n  0,0,254,255,255,255,255,191,182,0,0,0,0,0,16,0,63,0,255,23,0,0,0,0,\n  1,248,255,255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,255,61,0,0,\n  0,128,2,0,0,0,255,255,255,7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,\n  0,0,0,0,0,248,63,36,0,0,192,255,255,63,0,0,0,0,0,14,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,255,7,0,0,0,0,0,0,20,\n  254,33,254,0,12,0,2,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,64,\n  6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,\n  190,33,0,0,12,0,0,252,2,0,0,0,0,0,0,144,30,32,96,0,12,0,0,0,\n  4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,0,0,0,0,0,0,192,\n  193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,\n  3,0,0,0,0,0,0,24,30,32,0,0,12,0,0,0,2,0,0,0,0,0,0,0,\n  0,4,92,0,0,0,0,0,0,0,0,0,0,0,242,7,192,127,0,0,0,0,0,0,\n  0,0,0,0,0,0,242,31,64,63,0,0,0,0,0,0,0,0,0,3,0,0,160,2,\n  0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,\n  0,0,0,0,0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,\n  0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,\n  0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,143,32,0,0,0,0,\n  0,120,0,0,0,0,0,0,8,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,0,0,\n  0,0,64,127,229,31,248,159,0,0,0,0,128,0,255,255,1,0,0,0,0,0,0,0,\n  15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,\n  0,0,0,0,64,163,3,0,0,0,0,0,0,240,207,0,0,0,0,0,0,0,0,63,\n  0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,3,0,0,0,0,0,240,255,255,\n  255,255,255,255,255,7,0,1,0,0,0,248,255,255,255,255,255,255,255,255,255,255,255,251,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,\n  3,224,0,224,0,224,0,96,0,248,0,3,144,124,0,0,0,0,0,0,223,255,2,128,\n  0,0,255,31,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,60,62,8,\n  0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,0,0,0,0,112,\n  0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,16,0,0,0,0,0,0,\n  0,0,0,0,0,128,247,191,0,0,0,240,0,0,0,0,0,0,0,0,0,0,3,0,\n  255,255,255,255,3,0,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,3,68,8,0,0,96,16,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,\n  128,255,3,0,0,0,0,0,7,0,0,0,0,0,200,51,0,128,0,0,96,0,0,0,\n  0,0,0,0,0,126,102,0,8,16,0,0,0,0,1,16,0,0,0,0,0,0,157,193,\n  2,0,0,32,0,48,88,0,0,0,0,0,0,0,0,0,0,0,0,248,0,14,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,3,0,0,0,0,0,0,0,\n  255,255,8,0,255,255,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,128,128,64,0,4,0,0,0,64,1,0,0,0,0,0,1,0,\n  0,0,0,192,0,0,0,0,0,0,0,0,8,0,0,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,0,0,0,0,135,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,\n  0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  192,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,3,0,0,0,0,0,120,38,\n  0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,\n  3,0,0,0,0,0,192,127,0,158,0,0,0,0,0,0,0,0,0,0,0,128,211,64,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,248,7,0,0,\n  3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,\n  0,0,0,0,0,0,248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,\n  0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,88,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,\n  0,252,127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,\n  0,0,0,0,0,0,0,0,0,0,252,255,255,252,109,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,15,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,128,0,0,0,0,0,0,0,128,255,255,0,0,0,0,0,0,0,0,27,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,\n  231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,\n  0,0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,63,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  240,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,248\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOWER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  91,92,93,94,95,96,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  123,124,125,126,127\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const UPPER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  91,92,93,94,95,96,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  123,124,125,126,127\n]);\n\n// 23 * 8 = 184 bytes\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<f64>([\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n  1e20, 1e21, 1e22\n]);\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PERCENT = 0x25,\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  I = 0x49,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5A,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  u = 0x75,\n  x = 0x78,\n  z = 0x7A\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isAscii(c: u32): bool {\n  return !(c >> 7);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isLower8(c: u32): bool {\n  return c - CharCode.a < 26;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isUpper8(c: u32): bool {\n  return c - CharCode.A < 26;\n}\n\nexport function isSpace(c: u32): bool {\n  if (c < 0x1680) { // < <LS> (1)\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\n    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0\n    return ((c | 0x80) == 0xA0) || (c - 0x09 <= 0x0D - 0x09);\n  }\n  if (c - 0x2000 <= 0x200A - 0x2000) return true;\n  switch (c) {\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202F: // <NNS>\n    case 0x205F: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xFEFF: return true; // <ZWNBSP>\n  }\n  return false;\n}\n\nexport function isAlpha(c: u32): bool {\n  if (isAscii(c)) return (c | 32) - CharCode.a < 26;\n  if (c < 0x20000) {\n    // @ts-ignore: cast\n    return stagedBinaryLookup(ALPHA_TABLE, c);\n  }\n  return c < 0x2FFFE;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCased(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0x1F18A && stagedBinaryLookup(CASED, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCaseIgnorable(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0xE01F0 && stagedBinaryLookup(CASE_IGNORABLES, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isFinalSigma(buffer: usize, index: isize, len: isize): bool {\n  const lookaheadLimit = 30; // max lookahead limit\n  let found = false;\n  let pos = index;\n  let minPos = max(0, pos - lookaheadLimit);\n  while (pos > minPos) {\n    let c = codePointBefore(buffer, pos);\n    if (!isCaseIgnorable(c)) {\n      if (isCased(c)) {\n        found = true;\n      } else {\n        return false;\n      }\n    }\n    pos -= isize(c >= 0x10000) + 1;\n  }\n  if (!found) return false;\n  pos = index + 1;\n  let maxPos = min(pos + lookaheadLimit, len);\n  while (pos < maxPos) {\n    let c = <u32>load<u16>(buffer + (pos << 1));\n    if (u32((c & 0xFC00) == 0xD800) & u32(pos + 1 != len)) {\n      let c1 = <u32>load<u16>(buffer + (pos << 1), 2);\n      if ((c1 & 0xFC00) == 0xDC00) {\n        c = (c - 0xD800 << 10) + (c1 - 0xDC00) + 0x10000;\n      }\n    }\n    if (!isCaseIgnorable(c)) {\n      return !isCased(c);\n    }\n    pos += isize(c >= 0x10000) + 1;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction codePointBefore(buffer: usize, index: isize): i32 {\n  if (index <= 0) return -1;\n  let c = <u32>load<u16>(buffer + (index - 1 << 1));\n  if (u32((c & 0xFC00) == 0xDC00) & u32(index - 2 >= 0)) {\n    let c1 = <u32>load<u16>(buffer + (index - 2 << 1));\n    if ((c1 & 0xFC00) == 0xD800) {\n      return ((c1 & 0x3FF) << 10) + (c & 0x3FF) + 0x10000;\n    }\n  }\n  return (c & 0xF800) == 0xD800 ? 0xFFFD : c;\n}\n\n// Search routine for two-staged lookup tables\nfunction stagedBinaryLookup(table: usize, c: u32): bool {\n  return <bool>((load<u8>(table + (<u32>load<u8>(table + (c >>> 8)) << 5) + ((c & 255) >> 3)) >>> (c & 7)) & 1);\n}\n\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  let ptr1 = changetype<usize>(str1) + (index1 << 1);\n  let ptr2 = changetype<usize>(str2) + (index2 << 1);\n  if (ASC_SHRINK_LEVEL < 2) {\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\n      do {\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\n        ptr1 += 8;\n        ptr2 += 8;\n        len  -= 4;\n      } while (len >= 4);\n    }\n  }\n  while (len--) {\n    let a = <i32>load<u16>(ptr1);\n    let b = <i32>load<u16>(ptr2);\n    if (a != b) return a - b;\n    ptr1 += 2;\n    ptr2 += 2;\n  }\n  return 0;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toLower8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c | u32(isUpper8(c)) << 5;\n  } else {\n    return <u32>load<u8>(LOWER127 + c);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toUpper8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c & ~(u32(isLower8(c)) << 5);\n  } else {\n    return <u32>load<u8>(UPPER127 + c);\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  let len = str.length;\n  if (!len) {\n    if (isFloat<T>()) {\n      // @ts-ignore: cast\n      return <T>NaN;\n    } else {\n      // @ts-ignore: cast\n      return <T>0;\n    }\n  }\n\n  let ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  let code = <u32>load<u16>(ptr);\n\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  // determine sign\n  // @ts-ignore\n  let sign: T = 1;\n  if (code == CharCode.MINUS || code == CharCode.PLUS) {\n    if (!--len) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    if (code == CharCode.MINUS) {\n      // @ts-ignore: type\n      sign = -1;\n    }\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // See https://tc39.es/ecma262/#sec-parseint-string-radix\n  if (radix) {\n    if (radix < 2 || radix > 36) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    // handle case as parseInt(\"0xFF\", 16) by spec\n    if (radix == 16) {\n      if (\n        len > 2 &&\n        code == CharCode._0 &&\n        (<u32>load<u16>(ptr, 2) | 32) == CharCode.x\n      ) {\n        ptr += 4; len -= 2;\n      }\n    }\n  } else {\n    // determine radix by literal prefix\n    if (code == CharCode._0 && len > 2) {\n      switch (<u32>load<u16>(ptr, 2) | 32) {\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n      }\n    }\n    if (!radix) radix = 10;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  let num: T = 0;\n  let initial = len - 1;\n  while (len--) {\n    code = <u32>load<u16>(ptr);\n    if (code - CharCode._0 < 10) {\n      code -= CharCode._0;\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\n      code -= CharCode.A - 10;\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\n      code -= CharCode.a - 10;\n    }\n    if (code >= <u32>radix) {\n      if (initial == len) {\n        if (isFloat<T>()) {\n          // @ts-ignore: cast\n          return <T>NaN;\n        } else {\n          // @ts-ignore: cast\n          return <T>0;\n        }\n      }\n      break;\n    }\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\nexport function strtod(str: string): f64 {\n  let len = str.length;\n  if (!len) return NaN;\n\n  let ptr  = changetype<usize>(str);\n  let code = <u32>load<u16>(ptr);\n\n  let sign = 1.0;\n  // skip white spaces\n  while (len && isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (!len) return NaN;\n\n  // try parse '-' or '+'\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // try parse Infinity\n  if (len >= 8 && code == CharCode.I) {\n    if (\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\n    ) {\n      return Infinity * sign;\n    }\n    return NaN;\n  }\n  // validate next symbol\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\n    return NaN;\n  }\n  let savedPtr = ptr;\n  // skip zeros\n  while (code == CharCode._0) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (len <= 0) return 0.0 * sign;\n  const capacity = 19; // int(64 * 0.3010)\n  let pointed = false;\n  let consumed = 0;\n  let position = 0;\n  let x: u64 = 0;\n  if (code == CharCode.DOT) {\n    let noDigits = !(savedPtr - ptr);\n    ptr += 2; --len;\n    if (!len && noDigits) return NaN;\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\n    if (len <= 0) return 0.0 * sign;\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\n  }\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\n    if (digit < 10) {\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\n      ++consumed;\n    } else {\n      position = consumed;\n      pointed = true;\n    }\n    if (!--len) break;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  if (!pointed) position = consumed;\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\n}\n\nexport function strtob(str: string): bool {\n  let size: usize = str.length << 1;\n  let offset: usize = 0;\n  if (size > 8) {\n    // try trim end whitespaces first\n    while (size && isSpace(load<u16>(changetype<usize>(str) + size - 2))) size -= 2;\n    if (size > 8) {\n      // trim start whitespaces\n      while (offset < size && isSpace(load<u16>(changetype<usize>(str) + offset))) offset += 2;\n      size -= offset;\n    }\n  }\n  if (size != 8) return false;\n  // \"true\" represents as \\00\\e\\00\\u\\00\\e\\00\\t (00 65 00 75 00 72 00 74)\n  return load<u64>(changetype<usize>(str) + offset) == 0x0065_0075_0072_0074;\n}\n\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\n\n  let sepLen = separator.length;\n  let valueLen = 5; // max possible length of element len(\"false\")\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: bool;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<bool>(dataStart + i);\n    valueLen = 4 + i32(!value);\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(select(\"true\", \"false\", value)),\n      <usize>valueLen << 1\n    );\n    offset += valueLen;\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<bool>(dataStart + <usize>lastIndex);\n  valueLen = 4 + i32(!value);\n  memory.copy(\n    changetype<usize>(result) + (<usize>offset << 1),\n    changetype<usize>(select(\"true\", \"false\", value)),\n    valueLen << 1\n  );\n  offset += valueLen;\n\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    let value = load<T>(dataStart);\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(itoa32(<i32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(itoa64(<i32>value, 10));\n      }\n    } else {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(utoa32(<u32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(utoa64(<u64>value, 10));\n      }\n    }\n  }\n\n  let sepLen = separator.length;\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    return changetype<string>(dtoa(\n      // @ts-ignore: type\n      load<T>(dataStart))\n    );\n  }\n\n  const valueLen = MAX_DOUBLE_LENGTH;\n  let sepLen = separator.length;\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    // @ts-ignore: type\n    return load<string>(dataStart) || \"\";\n  }\n  let estLen = 0;\n  let value: string;\n  for (let i = 0; i < length; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) estLen += value.length;\n  }\n  let offset = 0;\n  let sepLen = separator.length;\n  let result = changetype<string>(__new((estLen + sepLen * lastIndex) << 1, idof<string>()));\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) {\n      let valueLen = value.length;\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(value),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n    }\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\n  if (changetype<usize>(value) != 0) {\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(value),\n      <usize>value.length << 1\n    );\n  }\n  return result;\n}\n\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  let value: T;\n  if (!lastIndex) {\n    value = load<T>(dataStart);\n    // @ts-ignore: type\n    return value != null ? value.toString() : \"\";\n  }\n  let result = \"\";\n  let sepLen = separator.length;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    if (value != null) result += value.toString();\n    if (sepLen) result += separator;\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  if (value != null) result += value.toString();\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction scientific(significand: u64, exp: i32): f64 {\n  if (!significand || exp < -342) return 0;\n  if (exp > 308) return Infinity;\n  // Try use fast path\n  // Use fast path for string-to-double conversion if possible\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\n  // Simple integer\n  let significandf = <f64>significand;\n  if (!exp) return significandf;\n  if (exp > 22 && exp <= 22 + 15) {\n    significandf *= pow10(exp - 22);\n    exp = 22;\n  }\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\n    if (exp > 0) return significandf * pow10(exp);\n    return significandf / pow10(-exp);\n  } else if (exp < 0) {\n    return scaledown(significand, exp);\n  } else {\n    return scaleup(significand, exp);\n  }\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaledown(significand: u64, exp: i32): f64 {\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\n\n  let shift = clz(significand);\n  significand <<= shift;\n  shift = exp - shift;\n\n  for (; exp <= -14; exp += 14) {\n    let q = significand / denom;\n    let r = significand % denom;\n    let s = clz(q);\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\n    shift -= s;\n  }\n  let b = <u64>ipow32(5, -exp);\n  let q = significand / b;\n  let r = significand % b;\n  let s = clz(q);\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\n  shift -= s;\n\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaleup(significand: u64, exp: i32): f64 {\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\n  let shift = ctz(significand);\n  significand >>= shift;\n  shift += exp;\n\n  __fixmulShift = shift;\n  for (; exp >= 13; exp -= 13) {\n    significand = fixmul(significand, coeff);\n  }\n  significand = fixmul(significand, <u32>ipow32(5, exp));\n  shift = __fixmulShift;\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction parseExp(ptr: usize, len: i32): i32 {\n  let sign = 1, magnitude = 0;\n  let code = <u32>load<u16>(ptr);\n  // check code is 'e' or 'E'\n  if ((code | 32) != CharCode.e) return 0;\n\n  if (!--len) return 0;\n  code = <u32>load<u16>(ptr += 2);\n  if (code == CharCode.MINUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  // skip zeros\n  while (code == CharCode._0) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\n    if (magnitude >= 3200) return sign * 3200;\n    magnitude = 10 * magnitude + digit;\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  return sign * magnitude;\n}\n\n// @ts-ignore: decorator\n@lazy let __fixmulShift: u64 = 0;\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction fixmul(a: u64, b: u32): u64 {\n  let low  = (a & 0xFFFFFFFF) * b;\n  let high = (a >> 32) * b + (low >> 32);\n  let overflow = <u32>(high >> 32);\n  let space = clz(overflow);\n  let revspace: u64 = 32 - space;\n  __fixmulShift += revspace;\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pow10(n: i32): f64 {\n  // argument `n` should bounds in [0, 22] range\n  return load<f64>(POWERS10 + (n << alignof<f64>()));\n}\n","/// <reference path=\"../rt/index.d.ts\" />\n\nimport { idof } from \"../builtins\";\nimport { CharCode } from \"./string\";\n\n// @ts-ignore: decorator\n@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<u32>([\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n]);\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n// @ts-ignore: decorator\n@lazy @inline const DIGITS = memory.data<u32>([\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n]);\n\n// Lookup table for pairwise char codes in range [0x00-0xFF]\n// @ts-ignore: decorator\n@lazy @inline const HEX_DIGITS =\n\"000102030405060708090a0b0c0d0e0f\\\n101112131415161718191a1b1c1d1e1f\\\n202122232425262728292a2b2c2d2e2f\\\n303132333435363738393a3b3c3d3e3f\\\n404142434445464748494a4b4c4d4e4f\\\n505152535455565758595a5b5c5d5e5f\\\n606162636465666768696a6b6c6d6e6f\\\n707172737475767778797a7b7c7d7e7f\\\n808182838485868788898a8b8c8d8e8f\\\n909192939495969798999a9b9c9d9e9f\\\na0a1a2a3a4a5a6a7a8a9aaabacadaeaf\\\nb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\\\nc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\\\nd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\\\ne0e1e2e3e4e5e6e7e8e9eaebecedeeef\\\nf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\";\n\n// @ts-ignore: decorator\n@lazy @inline const ANY_DIGITS = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_POWERS = memory.data<i16>([/* eslint-disable indent */\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n/* eslint-enable indent */]);\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\n@lazy @inline const FRC_POWERS = memory.data<u64>([\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function isPowerOf2<T extends number>(value: T): bool {\n  return popcnt<T>(value) == 1;\n}\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return 1 + u32(value >= 10);\n    } else {\n      return 3 + u32(value >= 10000) + u32(value >= 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return 6 + u32(value >= 1000000);\n    } else {\n      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64High(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);\n    } else {\n      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return 16 + u32(value >= 10000000000000000);\n    } else {\n      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);\n    }\n  }\n}\n\nfunction ulog_base(num: u64, base: i32): u32 {\n  if (isPowerOf2(base)) {\n    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;\n  }\n  let b64 = u64(base), b = b64, e: u32 = 1;\n  while (num >= b) {\n    num /= b;\n    b *= b;\n    e <<= 1;\n  }\n  while (num >= 1) {\n    num /= b64;\n    e++;\n  }\n  return e - 1;\n}\n\nfunction utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(DIGITS + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(DIGITS + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_dec_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {\n  const lut = changetype<usize>(HEX_DIGITS);\n  while (offset >= 2) {\n    offset -= 2;\n    store<u32>(\n      buffer + (offset << 1),\n      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))\n    );\n    num >>= 8;\n  }\n  if (offset & 1) {\n    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));\n  }\n}\n\nfunction utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset--;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\nfunction utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let d = num & 0x0F | CharCode._0;\n    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);\n    offset--;\n    store<u16>(buffer + (offset << 1), d);\n    // @ts-ignore: type\n    num >>= 4;\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u32>(buffer, num, offset);\n  } else {\n    utoa32_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u32>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u64>(buffer, num, offset);\n  } else {\n    utoa64_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u64>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\nfunction utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {\n  const lut = changetype<usize>(ANY_DIGITS);\n  let base = u64(radix);\n  if ((radix & (radix - 1)) == 0) { // for radix which pow of two\n    let shift = u64(ctz(radix) & 7);\n    let mask = base - 1;\n    do {\n      offset--;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));\n      num >>= shift;\n    } while (num);\n  } else {\n    do {\n      offset--;\n      let q = num / base;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));\n      num = q;\n    } while (num);\n  }\n}\n\nexport function utoa32(value: u32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  let out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa32(value: i32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  let sign = (value >>> 31) << 1;\n  if (sign) value = -value;\n  let out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out) + sign, value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out) + sign, value, decimals);\n  } else {\n    let val32 = u32(value);\n    let decimals = ulog_base(val32, radix);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_any_core(changetype<usize>(out) + sign, val32, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\nexport function utoa64(value: u64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  let out: String;\n\n  if (radix == 10) {\n    if (value <= u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa64(value: i64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  let sign = u32(value >>> 63) << 1;\n  if (sign) value = -value;\n  let out: String;\n\n  if (radix == 10) {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out) + sign, val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out) + sign, value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out) + sign, value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_any_core(changetype<usize>(out) + sign, value, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\n// @ts-ignore: decorator\n@lazy let _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// let _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_plus:  u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  let u0 = u & 0xFFFFFFFF;\n  let v0 = v & 0xFFFFFFFF;\n\n  let u1 = u >> 32;\n  let v1 = v >> 32;\n\n  let l = u0 * v0;\n  let t = u1 * v0 + (l >> 32);\n  let w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  let frc = (f << 1) + 1;\n  let exp = e - 1;\n  let off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  let m = 1 + i32(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  let lastp = buffer + ((len - 1) << 1);\n  let digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  let dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  let k = <i32>dk;\n  k += i32(k != dk); // conversion with ceil\n\n  let index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = load<u64>(FRC_POWERS + (<usize>index << alignof<u64>()));\n  _exp_pow = load<i16>(EXP_POWERS + (<usize>index << alignof<i16>()));\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  let uv  = reinterpret<u64>(value);\n  let exp = i32((uv & 0x7FF0000000000000) >>> 52);\n  let sid = uv & 0x000FFFFFFFFFFFFF;\n  let frc = (u64(exp != 0) << 52) + sid;\n  exp = select<i32>(exp, 1, exp) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  let off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  let frc_pow = _frc_pow;\n  let exp_pow = _exp_pow;\n\n  let w_frc = umul64f(frc, frc_pow);\n  let w_exp = umul64e(exp, exp_pow);\n\n  let wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  let wp_exp = umul64e(_exp, exp_pow);\n\n  let wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  let delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  let one_exp = -mp_exp;\n  let one_frc = (<u64>1) << one_exp;\n  let mask    = one_frc - 1;\n\n  let wp_w_frc = mp_frc - w_frc;\n\n  let p1 = u32(mp_frc >> one_exp);\n  let p2 = mp_frc & mask;\n\n  let kappa = <i32>decimalCount32(p1);\n  let len = sign;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(POWERS10 + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (true) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(POWERS10 + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  let sign = k < 0;\n  if (sign) k = -k;\n  let decimals = decimalCount32(k) + 1;\n  utoa32_dec_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  let kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nfunction dtoa_core(buffer: usize, value: f64): i32 {\n  let sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  let len = grisu2(value, buffer, sign);\n  len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\n// @ts-ignore: decorator\n@lazy @inline const dtoa_buf = memory.data(MAX_DOUBLE_LENGTH << 1);\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite(value)) {\n    if (isNaN(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  let size = dtoa_core(dtoa_buf, value) << 1;\n  let result = changetype<String>(__new(size, idof<String>()));\n  memory.copy(changetype<usize>(result), dtoa_buf, size);\n  return result;\n}\n\nexport function itoa_buffered<T extends number>(buffer: usize, value: T): u32 {\n  let sign: u32 = 0;\n  if (isSigned<T>()) {\n    sign = u32(value < 0);\n    if (sign) {\n      if (sizeof<T>() == 1) {\n        if (value == -0x80) {\n          // -0x80  ->  -128\n          store<u64>(buffer,\n            <u64>CharCode.MINUS |\n            <u64>(CharCode._0 + 1) << 16 |\n            <u64>(CharCode._0 + 2) << 32 |\n            <u64>(CharCode._0 + 8) << 48\n          );\n          return 4;\n        }\n      }\n      if (sizeof<T>() == 2) {\n        if (value == -0x8000) {\n          // -0x8000  ->  -32768\n          store<u64>(buffer,\n            <u64>CharCode.MINUS |\n            <u64>(CharCode._0 + 3) << 16 |\n            <u64>(CharCode._0 + 2) << 32 |\n            <u64>(CharCode._0 + 7) << 48\n          ); // -327\n          store<u32>(buffer + 8,\n            (CharCode._0 + 6) << 0 |\n            (CharCode._0 + 8) << 16\n          ); // 68\n          return 6;\n        }\n      }\n      store<u16>(buffer, CharCode.MINUS);\n      // @ts-ignore\n      value = -value;\n    }\n  }\n  let dest = buffer + (sign << 1);\n  if (ASC_SHRINK_LEVEL <= 1) {\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        if (<u32>value < 10) {\n          store<u16>(dest, value | CharCode._0);\n          return 1 + sign;\n        }\n      } else {\n        if (<u64>value < 10) {\n          store<u16>(dest, value | CharCode._0);\n          return 1 + sign;\n        }\n      }\n    } else {\n      if (value < 10) {\n        store<u16>(buffer, value | CharCode._0);\n        return 1;\n      }\n    }\n  }\n  let decimals: u32 = 0;\n  if (sizeof<T>() <= 4) {\n    let val32 = <u32>value;\n    decimals = decimalCount32(val32);\n    utoa32_dec_core(dest, val32, decimals);\n  } else {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32 = <u32>value;\n      decimals = decimalCount32(val32);\n      utoa32_dec_core(dest, val32, decimals);\n    } else {\n      let val64 = <u64>value;\n      decimals = decimalCount64High(val64);\n      utoa64_dec_core(dest, val64, decimals);\n    }\n  }\n  return sign + decimals;\n}\n\nexport function dtoa_buffered(buffer: usize, value: f64): u32 {\n  if (value == 0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite(value)) {\n    if (isNaN(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = value < 0;\n      if (sign) {\n        store<u16>(buffer, CharCode.MINUS); // -\n        buffer += 2;\n      }\n      store<u64>(buffer, 0x690066006E0049, 0); // ifnI\n      store<u64>(buffer, 0x7900740069006E, 8); // ytin\n      return 8 + u32(sign);\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n","// This file is shared with the compiler and must remain portable\n\n/** Runtime types. */\nexport enum Runtime {\n  /** Simple bump allocator without GC. */\n  Stub = 0,\n  /** Stop the world semi-automatic GC. */\n  Minimal = 1,\n  /** incremental GC. */\n  Incremental = 2,\n}\n","import { compareImpl } from \"./string\";\n\ntype Comparator<T> = (a: T, b: T) => i32;\n\n// @ts-ignore: decorator\n@lazy @inline const EMPTY = u32.MAX_VALUE;\n// @ts-ignore: decorator\n@inline const INSERTION_SORT_THRESHOLD = 48;\n// @ts-ignore: decorator\n@inline const MIN_RUN_LENGTH = 32;\n\n// @ts-ignore: decorator\n@inline\nfunction log2u(n: u32): u32 {\n  return 31 - clz(n);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function COMPARATOR<T>(): Comparator<T> {\n  if (isInteger<T>()) {\n    if (isSigned<T>() && sizeof<T>() <= 4) {\n      return (a, b) => i32(a) - i32(b);\n    } else {\n      return (a, b) => i32(a > b) - i32(a < b);\n    }\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) {\n      return (a, b) => {\n        let ia = reinterpret<i32>(f32(a));\n        let ib = reinterpret<i32>(f32(b));\n        ia ^= ia >> 31 >>> 1;\n        ib ^= ib >> 31 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    } else {\n      return (a, b) => {\n        let ia = reinterpret<i64>(f64(a));\n        let ib = reinterpret<i64>(f64(b));\n        ia ^= ia >> 63 >>> 1;\n        ib ^= ib >> 63 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    }\n  } else if (isString<T>()) {\n    return (a, b) => {\n      if (\n        changetype<usize>(a) == changetype<usize>(b) ||\n        changetype<usize>(a) == 0 ||\n        changetype<usize>(b) == 0\n      ) return 0;\n      let alen = changetype<string>(a).length;\n      let blen = changetype<string>(b).length;\n      if (!(alen | blen)) return 0;\n      if (!alen) return -1;\n      if (!blen) return  1;\n      let res = compareImpl(\n        changetype<string>(a), 0,\n        changetype<string>(b), 0,\n        <usize>min(alen, blen)\n      );\n      return res ? res : alen - blen;\n    };\n  } else {\n    return (a, b) => i32(a > b) - i32(a < b);\n  }\n}\n\n// Power Sort implementation (stable) from paper \"Nearly-Optimal Mergesorts\"\n// https://arxiv.org/pdf/1805.04154.pdf\n// This method usually outperform TimSort.\n// TODO: refactor c >>> 31 to c < 0 when binaryen will support this opt\nexport function SORT<T>(\n  ptr: usize,\n  len: i32,\n  comparator: Comparator<T>\n): void {\n  if (len <= INSERTION_SORT_THRESHOLD) {\n    if (len <= 1) return;\n    if (ASC_SHRINK_LEVEL < 1) {\n      switch (len) {\n        case 3: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          a = select<T>(a, b, c);\n          b = load<T>(ptr, 2 << alignof<T>());\n          c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 1 << alignof<T>());\n          store<T>(ptr, select<T>(a, b, c), 2 << alignof<T>());\n        }\n        case 2: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          store<T>(ptr, select<T>(a, b, c), 1 << alignof<T>());\n          return;\n        }\n      }\n    }\n    insertionSort<T>(ptr, 0, len - 1, 0, comparator);\n    return;\n  }\n\n  let lgPlus2         = log2u(len) + 2;\n  let lgPlus2Size     = lgPlus2 << alignof<u32>();\n  let leftRunStartBuf = __alloc(lgPlus2Size << 1);\n  let leftRunEndBuf   = leftRunStartBuf + lgPlus2Size;\n\n  for (let i: u32 = 0; i < lgPlus2; ++i) {\n    store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n  }\n\n  let buffer = __alloc(len << alignof<T>());\n\n  let hi   = len - 1;\n  let endA = extendRunRight<T>(ptr, 0, hi, comparator);\n  let lenA = endA + 1;\n\n  if (lenA < MIN_RUN_LENGTH) {\n    endA = min(hi, MIN_RUN_LENGTH - 1);\n    insertionSort<T>(ptr, 0, endA, lenA, comparator);\n  }\n\n  let top: u32 = 0, startA = 0;\n  while (endA < hi) {\n    let startB = endA + 1;\n    let endB = extendRunRight<T>(ptr, startB, hi, comparator);\n    let lenB = endB - startB + 1;\n\n    if (lenB < MIN_RUN_LENGTH) {\n      endB = min(hi, startB + MIN_RUN_LENGTH - 1);\n      insertionSort<T>(ptr, startB, endB, lenB, comparator);\n    }\n\n    let k = nodePower(0, hi, startA, startB, endB);\n\n    for (let i = top; i > k; --i) {\n      let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n      if (start != EMPTY) {\n        mergeRuns<T>(\n          ptr,\n          start,\n          load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n          endA,\n          buffer,\n          comparator\n        );\n        startA = start;\n        store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n      }\n    }\n\n    store<u32>(leftRunStartBuf + (<usize>k << alignof<u32>()), startA);\n    store<u32>(leftRunEndBuf   + (<usize>k << alignof<u32>()), endA);\n    startA = startB;\n    endA = endB;\n    top = k;\n  }\n\n  for (let i = top; i != 0; --i) {\n    let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n    if (start != EMPTY) {\n      mergeRuns<T>(\n        ptr,\n        start,\n        load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n        hi,\n        buffer,\n        comparator\n      );\n    }\n  }\n  // dealloc aux buffers\n  __free(buffer);\n  __free(leftRunStartBuf);\n}\n\nfunction insertionSort<T>(\n  ptr: usize,\n  left: i32,\n  right: i32,\n  presorted: i32,\n  comparator: Comparator<T>\n): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    // slightly improved original insertion sort\n    for (let i = left + presorted; i <= right; ++i) {\n      let j = i - 1;\n      let a = load<T>(ptr + (<usize>i << alignof<T>()));\n      while (j >= left) {\n        let b = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, b) < 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), b, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>());\n    }\n  } else {\n    // even-odd two-way insertion sort which allow increase minRunLen\n    let range = right - left + 1;\n    let i = left + select(range & 1, presorted - ((range - presorted) & 1), presorted == 0);\n    for (; i <= right; i += 2) {\n      let a = load<T>(ptr + (<usize>i << alignof<T>()), 0);\n      let b = load<T>(ptr + (<usize>i << alignof<T>()), 1 << alignof<T>());\n      let min = b, max = a;\n      if (comparator(a, b) <= 0) {\n        min = a, max = b;\n      }\n      let j = i - 1;\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, max) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 2 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), max, 2 << alignof<T>());\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, min) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), min, 1 << alignof<T>());\n    }\n  }\n}\n\nfunction nodePower(left: u32, right: u32, startA: u32, startB: u32, endB: u32): u32 {\n  let n: u64 = right - left + 1;\n  let s = startB - (left << 1);\n  let l = startA + s;\n  let r = endB   + s + 1;\n  let a = (<u64>l << 30) / n;\n  let b = (<u64>r << 30) / n;\n  return clz(<u32>(a ^ b));\n}\n\nfunction extendRunRight<T>(\n  ptr: usize,\n  i: i32,\n  right: i32,\n  comparator: Comparator<T>\n): i32 {\n  if (i == right) return i;\n  let j = i;\n  if (comparator(\n    load<T>(ptr + (<usize>  j << alignof<T>())),\n    load<T>(ptr + (<usize>++j << alignof<T>()))\n  ) > 0) {\n    while (\n      j < right &&\n      (comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >>> 31) // < 0\n    ) ++j;\n    // reverse\n    let k = j;\n    while (i < k) {\n      let tmp = load<T>(ptr + (<usize>i << alignof<T>()));\n      store<T>(ptr + (<usize>i << alignof<T>()), load<T>(ptr + (<usize>k << alignof<T>()))); ++i;\n      store<T>(ptr + (<usize>k << alignof<T>()), tmp); --k;\n    }\n  } else {\n    while (\n      j < right &&\n      comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >= 0\n    ) ++j;\n  }\n  return j;\n}\n\n// Merges arr[l..m - 1] and arr[m..r]\nfunction mergeRuns<T>(\n  ptr: usize,\n  l: i32,\n  m: i32,\n  r: i32,\n  buffer: usize,\n  comparator: Comparator<T>\n): void {\n  --m;\n  let i: i32, j: i32, t = r + m;\n  for (i = m + 1; i > l; --i) {\n    store<T>(\n      buffer + (<usize>(i - 1) << alignof<T>()),\n      load<T>(ptr + (<usize>(i - 1) << alignof<T>()))\n    );\n  }\n  for (j = m; j < r; ++j) {\n    store<T>(\n      buffer + (<usize>(t - j) << alignof<T>()),\n      load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>())\n    );\n  }\n  for (let k = l; k <= r; ++k) {\n    let a = load<T>(buffer + (<usize>j << alignof<T>()));\n    let b = load<T>(buffer + (<usize>i << alignof<T>()));\n    if (comparator(a, b) < 0) {\n      store<T>(ptr + (<usize>k << alignof<T>()), a);\n      --j;\n    } else {\n      store<T>(ptr + (<usize>k << alignof<T>()), b);\n      ++i;\n    }\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { compareImpl, strtol, strtod, isSpace, isAscii, isFinalSigma, toLower8, toUpper8 } from \"./util/string\";\nimport { SPECIALS_UPPER, casemap, bsearch } from \"./util/casemap\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_UNPAIRED_SURROGATE } from \"./util/error\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\n\n@final export abstract class String {\n\n  @lazy static readonly MAX_LENGTH: i32 = <i32>(BLOCK_MAXSIZE >>> alignof<u16>());\n\n  static fromCharCode(unit: i32, surr: i32 = -1): String {\n    let hasSur = surr > 0;\n    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    store<u16>(changetype<usize>(out), <u16>unit);\n    if (hasSur) store<u16>(changetype<usize>(out), <u16>surr, 2);\n    return out;\n  }\n\n  static fromCharCodes(units: Array<i32>): String {\n    let length = units.length;\n    let out = changetype<String>(__new(<usize>length << 1, idof<String>()));\n    let ptr = units.dataStart;\n    for (let i = 0; i < length; ++i) {\n      store<u16>(changetype<usize>(out) + (<usize>i << 1), load<i32>(ptr + (<usize>i << 2)));\n    }\n    return out;\n  }\n\n  static fromCodePoint(code: i32): String {\n    let hasSur = <u32>code > 0xFFFF;\n    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    if (!hasSur) {\n      store<u16>(changetype<usize>(out), <u16>code);\n    } else {\n      // Checks valid code point range\n      assert(<u32>code <= 0x10FFFF);\n      code -= 0x10000;\n      let hi = (code & 0x03FF) | 0xDC00;\n      let lo = code >>> 10 | 0xD800;\n      store<u32>(changetype<usize>(out), lo | hi << 16);\n    }\n    return out;\n  }\n\n  @builtin static raw(parts: TemplateStringsArray, ...args: unknown[]): string { return unreachable(); }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >> 1;\n  }\n\n  at(pos: i32): String {\n    let len = this.length;\n    pos += select(0, len, pos >= 0);\n    if (<u32>pos >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let out = __new(2, idof<String>());\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return changetype<String>(out); // retains\n  }\n\n  @operator(\"[]\") charAt(pos: i32): String {\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n    let out = changetype<String>(__new(2, idof<String>()));\n    store<u16>(changetype<usize>(out), load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n  }\n\n  codePointAt(pos: i32): i32 {\n    let len = this.length;\n    if (<u32>pos >= <u32>len) return -1; // (undefined)\n    let first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n    if ((first & 0xFC00) != 0xD800 || pos + 1 == len) return first;\n    let second = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1), 2);\n    if ((second & 0xFC00) != 0xDC00) return first;\n    return (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\") private static __concat(left: String, right: String): String {\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    let thisSize: isize = this.length << 1;\n    let otherSize: isize = other.length << 1;\n    let outSize: usize = thisSize + otherSize;\n    if (outSize == 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(outSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\n    return out;\n  }\n\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\n    end = min(max(end, 0), this.length);\n    let searchLength = <isize>search.length;\n    let searchStart = <isize>end - searchLength;\n    if (searchStart < 0) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  @operator(\"==\") private static __eq(left: String | null, right: String | null): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return true;\n    if (changetype<usize>(left) == 0 || changetype<usize>(right) == 0) return false;\n    let leftLength = changetype<string>(left).length;\n    if (leftLength != changetype<string>(right).length) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String | null): bool {\n    return changetype<usize>(str) == 0 || !changetype<string>(str).length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String | null, right: String | null): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\") private static __gt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    let leftLength  = left.length;\n    if (!leftLength) return false;\n    let rightLength = right.length;\n    if (!rightLength) return true;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res > 0 : leftLength > rightLength;\n  }\n\n  @operator(\">=\") private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\") private static __lt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    let rightLength = right.length;\n    if (!rightLength) return false;\n    let leftLength  = left.length;\n    if (!leftLength) return true;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res < 0 : leftLength < rightLength;\n  }\n\n  @operator(\"<=\") private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  includes(search: String, start: i32 = 0): bool {\n    return this.indexOf(search, start) != -1;\n  }\n\n  indexOf(search: String, start: i32 = 0): i32 {\n    let searchLen = <isize>search.length;\n    if (!searchLen) return 0;\n    let len = <isize>this.length;\n    if (!len) return -1;\n    let searchStart = min(max(<isize>start, 0), len);\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\n    let searchLen = <isize>search.length;\n    if (!searchLen) return this.length;\n    let len = this.length;\n    if (!len) return -1;\n    let searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\n    for (; searchStart >= 0; --searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  // TODO: implement full locale comparison with locales and Collator options\n  localeCompare(other: String): i32 {\n    if (changetype<usize>(other) == changetype<usize>(this)) return 0;\n    let alen = this.length;\n    let blen = other.length;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(this, 0, other, 0, <usize>min(alen, blen));\n    res = res ? res : alen - blen;\n    // normalize to [-1, 1] range\n    return i32(res > 0) - i32(res < 0);\n  }\n\n  startsWith(search: String, start: i32 = 0): bool {\n    let len = <isize>this.length;\n    let searchStart = min(max(<isize>start, 0), len);\n    let searchLength = <isize>search.length;\n    if (searchLength + searchStart > len) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\n    let intStart: isize = start;\n    let end: isize = length;\n    let len: isize = this.length;\n    if (intStart < 0) intStart = max(len + intStart, 0);\n    let size = min(max(end, 0), len - intStart) << 1;\n    if (size <= 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (intStart << 1), size);\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    let len: isize = this.length;\n    let finalStart = min<isize>(max(start, 0), len);\n    let finalEnd = min<isize>(max(end, 0), len);\n    let fromPos = min<isize>(finalStart, finalEnd) << 1;\n    let toPos = max<isize>(finalStart, finalEnd) << 1;\n    let size = toPos - fromPos;\n    if (!size) return changetype<String>(\"\");\n    if (!fromPos && toPos == len << 1) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + fromPos, size);\n    return out;\n  }\n\n  trim(): String {\n    let len = this.length;\n    let size: usize = len << 1;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    let offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2; size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (!offset && size == len << 1) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    let size = <usize>this.length << 1;\n    let offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2;\n    }\n    if (!offset) return this;\n    size -= offset;\n    if (!size) return changetype<String>(\"\");\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  trimEnd(): String {\n    let originalSize = <usize>this.length << 1;\n    let size = originalSize;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (size == originalSize) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), size);\n    return out;\n  }\n\n  padStart(length: i32, pad: string = \" \"): String {\n    let thisSize = <usize>this.length << 1;\n    let targetSize = <usize>length << 1;\n    let padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    let prependSize = targetSize - thisSize;\n    let out = changetype<String>(__new(targetSize, idof<String>()));\n    if (prependSize > padSize) {\n      let repeatCount = (prependSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = prependSize - restBase;\n      memory.repeat(changetype<usize>(out), changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out), changetype<usize>(pad), prependSize);\n    }\n    memory.copy(changetype<usize>(out) + prependSize, changetype<usize>(this), thisSize);\n    return out;\n  }\n\n  padEnd(length: i32, pad: string = \" \"): String {\n    let thisSize = <usize>this.length << 1;\n    let targetSize = <usize>length << 1;\n    let padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    let appendSize = targetSize - thisSize;\n    let out = changetype<String>(__new(targetSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    if (appendSize > padSize) {\n      let repeatCount = (appendSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = appendSize - restBase;\n      memory.repeat(changetype<usize>(out) + thisSize, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + thisSize + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(pad), appendSize);\n    }\n    return out;\n  }\n\n  repeat(count: i32 = 0): String {\n    let length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || <u64>length * count > (1 << 28)) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n    let out = changetype<String>(__new((length * count) << 1, idof<String>()));\n    memory.repeat(changetype<usize>(out), changetype<usize>(this), <usize>length << 1, count);\n    return out;\n  }\n\n  replace(search: String, replacement: String): String {\n    let len: usize = this.length;\n    let slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    let index: isize = this.indexOf(search);\n    if (~index) {\n      let rlen: usize = replacement.length;\n      len -= slen;\n      let olen = len + rlen;\n      if (olen) {\n        let out = changetype<String>(__new(olen << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this), index << 1);\n        memory.copy(\n          changetype<usize>(out) + (index << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        memory.copy(\n          changetype<usize>(out) + ((index + rlen) << 1),\n          changetype<usize>(this) + ((index + slen) << 1),\n          (len - index) << 1\n        );\n        return out;\n      }\n    }\n    return this;\n  }\n\n  replaceAll(search: String, replacement: String): String {\n    let thisLen: usize = this.length;\n    let searchLen: usize = search.length;\n    if (thisLen <= searchLen) {\n      return thisLen < searchLen\n        ? this\n        : select<String>(replacement, this, search == this);\n    }\n    let replaceLen: usize = replacement.length;\n    if (!searchLen) {\n      if (!replaceLen) return this;\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\n      let out = changetype<String>(__new((thisLen + (thisLen + 1) * replaceLen) << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(replacement), replaceLen << 1);\n      let offset = replaceLen;\n      for (let i: usize = 0; i < thisLen; ++i) {\n        store<u16>(\n          changetype<usize>(out) + (offset++ << 1),\n          load<u16>(changetype<usize>(this) + (i << 1))\n        );\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(replacement),\n          replaceLen << 1\n        );\n        offset += replaceLen;\n      }\n      return out;\n    }\n    let prev: isize = 0, next: isize = 0;\n    if (searchLen == replaceLen) {\n      // Fast path when search and replacement have same length\n      let outSize = thisLen << 1;\n      let out = changetype<String>(__new(outSize, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this), outSize);\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n        memory.copy(changetype<usize>(out) + (next << 1), changetype<usize>(replacement), replaceLen << 1);\n        prev = next + searchLen;\n      }\n      return out;\n    }\n    let out: String | null = null, offset: usize = 0, outSize = thisLen;\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n      if (!out) out = changetype<String>(__new(thisLen << 1, idof<String>()));\n      let chunk = next - prev;\n      if (offset + chunk + replaceLen > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(this) + (prev << 1),\n        chunk << 1\n      );\n      offset += chunk;\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(replacement),\n        replaceLen << 1\n      );\n      offset += replaceLen;\n      prev = next + searchLen;\n    }\n    if (out) {\n      let rest = thisLen - prev;\n      if (offset + rest > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      if (rest) {\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(this) + (prev << 1),\n          rest << 1\n        );\n      }\n      rest += offset;\n      if (outSize > rest) {\n        out = changetype<String>(__renew(changetype<usize>(out), rest << 1));\n      }\n      return out;\n    }\n    return this;\n  }\n\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\n    let len = this.length;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\n    len   = end - start;\n    if (len <= 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(len << 1, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n    return out;\n  }\n\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\n    if (!limit) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    if (changetype<usize>(separator) == 0) return [ this ];\n    let length: isize = this.length;\n    let sepLen = changetype<string>(separator).length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = changetype<String[]>(__newArray(<i32>length, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      let resultStart = result.dataStart as usize;\n      for (let i: isize = 0; i < length; ++i) {\n        let charStr = changetype<String>(__new(2, idof<String>()));\n        store<u16>(changetype<usize>(charStr), load<u16>(changetype<usize>(this) + (<usize>i << 1)));\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), changetype<usize>(charStr)); // result[i] = charStr\n        __link(changetype<usize>(result), changetype<usize>(charStr), true);\n      }\n      return result;\n    } else if (!length) {\n      let result = changetype<String[]>(__newArray(1, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      store<usize>(result.dataStart as usize, changetype<usize>(\"\")); // static \"\"\n      return result;\n    }\n    let result = changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    let end = 0, start = 0, i = 0;\n    while (~(end = this.indexOf(changetype<string>(separator), start))) {\n      let len = end - start;\n      if (len > 0) {\n        let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n        result.push(out);\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) { // also means: loop above didn't do anything\n      result.push(this);\n      return result;\n    }\n    let len = length - start;\n    if (len > 0) {\n      let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n      result.push(out);\n    } else {\n      result.push(changetype<String>(\"\")); // static \"\"\n    }\n    return result;\n  }\n\n  toLowerCase(): String {\n    let len = <usize>this.length;\n    if (!len) return this;\n    let codes = changetype<String>(__new(len * 2 * 2, idof<String>()));\n    let j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toLower8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // check special casing for lower table. It has one ently so instead lookup we just inline this.\n        if (c == 0x0130) {\n          // 0x0130 -> [0x0069, 0x0307]\n          store<u32>(changetype<usize>(codes) + (j << 1), (0x0307 << 16) | 0x0069);\n          ++j;\n        } else if (c == 0x03A3) { // 'Σ'\n          // Σ maps to σ but except at the end of a word where it maps to ς\n          let sigma = 0x03C3; // σ\n          if (len > 1 && isFinalSigma(changetype<usize>(this), i, len)) {\n            sigma = 0x03C2; // ς\n          }\n          store<u16>(changetype<usize>(codes) + (j << 1), sigma);\n        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {\n          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling\n          store<u16>(changetype<usize>(codes) + (j << 1), c + 26);\n        } else {\n          let code = casemap(c, 0) & 0x1FFFFF;\n          if (code < 0x10000) {\n            store<u16>(changetype<usize>(codes) + (j << 1), code);\n          } else {\n            // store as surrogare pair\n            code -= 0x10000;\n            let lo = (code >>> 10) | 0xD800;\n            let hi = (code & 0x03FF) | 0xDC00;\n            store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n            ++j;\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toUpperCase(): String {\n    let len = <usize>this.length;\n    if (!len) return this;\n    let codes = changetype<String>(__new(len * 3 * 2, idof<String>()));\n    let specialsPtr = changetype<usize>(SPECIALS_UPPER);\n    let specialsLen = SPECIALS_UPPER.length;\n    let j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toUpper8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling\n        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {\n          // monkey patch\n          store<u16>(changetype<usize>(codes) + (j << 1), c - 26);\n        } else {\n          let index: usize = -1;\n          // Fast range check. See first and last rows in specialsUpper table\n          if (c - 0x00DF <= 0xFB17 - 0x00DF) {\n            index = <usize>bsearch(c, specialsPtr, specialsLen);\n          }\n          if (~index) {\n            // load next 3 code points from row with `index` offset for specialsUpper table\n            let ab = load<u32>(specialsPtr + (index << 1), 2);\n            let cc = load<u16>(specialsPtr + (index << 1), 6);\n            store<u32>(changetype<usize>(codes) + (j << 1), ab, 0);\n            store<u16>(changetype<usize>(codes) + (j << 1), cc, 4);\n            j += 1 + usize(cc != 0);\n          } else {\n            let code = casemap(c, 1) & 0x1FFFFF;\n            if (code < 0x10000) {\n              store<u16>(changetype<usize>(codes) + (j << 1), code);\n            } else {\n              // store as surrogare pair\n              code -= 0x10000;\n              let lo = (code >>> 10) | 0xD800;\n              let hi = (code & 0x03FF) | 0xDC00;\n              store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n              ++j;\n            }\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toString(): String {\n    return this;\n  }\n}\n\n// @ts-ignore: nolib\nexport type string = String;\n\nexport function parseInt(str: string, radix: i32 = 0): f64 {\n  return strtol<f64>(str, radix);\n}\n\nexport function parseFloat(str: string): f64 {\n  return strtod(str);\n}\n\n// Encoding helpers\nexport namespace String {\n\n  export namespace UTF8 {\n\n    export const enum ErrorMode {\n      WTF8,\n      REPLACE,\n      ERROR\n    }\n\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\n      let strOff = changetype<usize>(str);\n      let strEnd = strOff + <usize>changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n      let bufLen = i32(nullTerminated);\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) break;\n          bufLen += 1;\n        } else if (c1 < 2048) {\n          bufLen += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\n              bufLen += 4; strOff += 4;\n              continue;\n            }\n          }\n          bufLen += 3;\n        }\n        strOff += 2;\n      }\n      return bufLen;\n    }\n\n    export function encode(str: string, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): ArrayBuffer {\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str, nullTerminated), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf), nullTerminated, errorMode);\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): usize {\n      let strEnd = str + (<usize>len << 1);\n      let bufOff = buf;\n      while (str < strEnd) {\n        let c1 = <u32>load<u16>(str);\n        if (c1 < 128) {\n          store<u8>(bufOff, c1);\n          bufOff++;\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) return bufOff - buf;\n        } else if (c1 < 2048) {\n          let b0 = c1 >> 6 | 192;\n          let b1 = c1 & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          bufOff += 2;\n        } else {\n          // D800: 11011 0 0000000000 Lead\n          // DBFF: 11011 0 1111111111\n          // DC00: 11011 1 0000000000 Trail\n          // DFFF: 11011 1 1111111111\n          // F800: 11111 0 0000000000 Mask\n          // FC00: 11111 1 0000000000\n          if ((c1 & 0xF800) == 0xD800) {\n            if (c1 < 0xDC00 && str + 2 < strEnd) {\n              let c2 = <u32>load<u16>(str, 2);\n              if ((c2 & 0xFC00) == 0xDC00) {\n                c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);\n                let b0 = c1 >> 18 | 240;\n                let b1 = c1 >> 12 & 63 | 128;\n                let b2 = c1 >> 6  & 63 | 128;\n                let b3 = c1       & 63 | 128;\n                store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);\n                bufOff += 4; str += 4;\n                continue;\n              }\n            }\n            if (errorMode != ErrorMode.WTF8) { // unlikely\n              if (errorMode == ErrorMode.ERROR) throw new Error(E_UNPAIRED_SURROGATE);\n              c1 = 0xFFFD;\n            }\n          }\n          let b0 = c1 >> 12 | 224;\n          let b1 = c1 >> 6  & 63 | 128;\n          let b2 = c1       & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          store<u8>(bufOff, b2, 2);\n          bufOff += 3;\n        }\n        str += 2;\n      }\n      if (nullTerminated) {\n        store<u8>(bufOff++, 0);\n      }\n      return bufOff - buf;\n    }\n\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {\n      let bufOff = buf;\n      let bufEnd = buf + len;\n      assert(bufEnd >= bufOff); // guard wraparound\n      let str = changetype<String>(__new(len << 1, idof<String>())); // max is one u16 char per u8 byte\n      let strOff = changetype<usize>(str);\n      while (bufOff < bufEnd) {\n        let u0 = <u32>load<u8>(bufOff); ++bufOff;\n        if (!(u0 & 128)) {\n          // @ts-ignore: cast\n          if (nullTerminated & !u0) break;\n          store<u16>(strOff, u0);\n        } else {\n          if (bufEnd == bufOff) break;\n          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n          if ((u0 & 224) == 192) {\n            store<u16>(strOff, (u0 & 31) << 6 | u1);\n          } else {\n            if (bufEnd == bufOff) break;\n            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n            if ((u0 & 240) == 224) {\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n            } else {\n              if (bufEnd == bufOff) break;\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;\n              ++bufOff;\n            }\n            if (u0 < 0x10000) {\n              store<u16>(strOff, u0);\n            } else {\n              u0 -= 0x10000;\n              let lo = u0 >> 10 | 0xD800;\n              let hi = (u0 & 0x03FF) | 0xDC00;\n              store<u32>(strOff, lo | (hi << 16));\n              strOff += 2;\n            }\n          }\n        }\n        strOff += 2;\n      }\n      return changetype<String>(__renew(changetype<usize>(str), strOff - changetype<usize>(str)));\n    }\n  }\n\n  export namespace UTF16 {\n\n    export function byteLength(str: string): i32 {\n      return changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n    }\n\n    export function encode(str: string): ArrayBuffer {\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf));\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize {\n      let size = <usize>len << 1;\n      memory.copy(buf, changetype<usize>(str), size);\n      return size;\n    }\n\n    export function decode(buf: ArrayBuffer): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize): String {\n      let str = changetype<String>(__new(len &= ~1, idof<String>()));\n      memory.copy(changetype<usize>(str), buf, len);\n      return str;\n    }\n  }\n}\n\nexport class TemplateStringsArray extends Array<string> {\n  readonly raw: string[];\n}\n","// Common error messages for use across the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_VALUEOUTOFRANGE: string = \"Value out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALLOCATION_TOO_LARGE: string = \"Allocation too large\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALREADY_PINNED: string = \"Object already pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOT_PINNED: string = \"Object is not pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_URI_MALFORMED: string = \"URI malformed\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDDATE: string = \"Invalid Date\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_UNPAIRED_SURROGATE: string = \"Unpaired surrogate\";\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __rtti_base: usize;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_globals(cookie: u32): void;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_members(ref: usize, cookie: u32): void;\n\n// @ts-ignore: decorator\n@unsafe\nexport function __typeinfo(id: u32): TypeinfoFlags {\n  let ptr = __rtti_base;\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newBuffer(size: usize, id: u32, data: usize = 0): usize {\n  let buffer = __new(size, id);\n  if (data) memory.copy(buffer, data, size);\n  return buffer;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\n  let bufferSize = <usize>length << alignLog2;\n  // make sure `buffer` is tracked by the shadow stack\n  let buffer = changetype<ArrayBuffer>(__newBuffer(bufferSize, idof<ArrayBuffer>(), data));\n  // ...since allocating the array may trigger GC steps\n  let array = __new(offsetof<i32[]>(), id);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"buffer\"));\n  __link(array, changetype<usize>(buffer), false);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"dataStart\"));\n  store<i32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\n  store<i32>(array, length, offsetof<i32[]>(\"length_\"));\n  return array;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __tostack(ptr: usize): usize { // eslint-disable-line\n  return ptr;\n}\n\n// These are provided by the respective implementation, included as another entry file by asc:\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __alloc(size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __realloc(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __free(ptr: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __new(size: usize, id: u32): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __renew(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __collect(): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __visit(ptr: usize, cookie: u32): void;\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let buffer = changetype<ArrayBuffer>(__new(length = length << alignLog2, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = length;\n  }\n}\n\n@final export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (isNullable<T>()) {\n      if (changetype<usize>(value) == 0) return false;\n    }\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Float32Array) return true;\n    if (value instanceof Float64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    let buffer = changetype<ArrayBuffer>(__new(<usize>length, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    return buffer;\n  }\n\n  get byteLength(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    let length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    let outSize = <usize>max(end - begin, 0);\n    let out = changetype<ArrayBuffer>(__new(outSize, idof<ArrayBuffer>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + <usize>begin, outSize);\n    return out;\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","export function HASH<T>(key: T): u32 {\n  if (isString<T>()) {\n    return hashStr(changetype<string>(key));\n  } else if (isReference<T>()) {\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(f32(key)));\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(f64(key)));\n  } else {\n    if (sizeof<T>() <= 4) return hash32(u32(key), sizeof<T>());\n    if (sizeof<T>() == 8) return hash64(u64(key));\n  }\n  return unreachable();\n}\n\n// XXHash 32-bit as a starting point, see: https://cyan4973.github.io/xxHash\n\n// primes\n// @ts-ignore: decorator\n@inline const XXH32_P1: u32 = 2654435761;\n// @ts-ignore: decorator\n@inline const XXH32_P2: u32 = 2246822519;\n// @ts-ignore: decorator\n@inline const XXH32_P3: u32 = 3266489917;\n// @ts-ignore: decorator\n@inline const XXH32_P4: u32 = 668265263;\n// @ts-ignore: decorator\n@inline const XXH32_P5: u32 = 374761393;\n// @ts-ignore: decorator\n@inline const XXH32_SEED: u32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction hash32(key: u32, len: u32 = 4): u32 {\n  let h: u32 = XXH32_SEED + XXH32_P5 + len;\n  h += key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hash64(key: u64): u32 {\n  let h: u32 = XXH32_SEED + XXH32_P5 + 8;\n  h += <u32>key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h += <u32>(key >> 32) * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction mix(h: u32, key: u32): u32 {\n  return rotl(h + key * XXH32_P2, 13) * XXH32_P1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hashStr(key: string): u32 {\n  if (changetype<usize>(key) == 0) return XXH32_SEED;\n\n  let h: u32 = key.length << 1;\n  let len: usize = h;\n  let pos = changetype<usize>(key);\n\n  if (len >= 16) {\n    let s1 = XXH32_SEED + XXH32_P1 + XXH32_P2;\n    let s2 = XXH32_SEED + XXH32_P2;\n    let s3 = XXH32_SEED;\n    let s4 = XXH32_SEED - XXH32_P1;\n\n    let end = len + pos - 16;\n    while (pos <= end) {\n      s1 = mix(s1, load<u32>(pos    ));\n      s2 = mix(s2, load<u32>(pos,  4));\n      s3 = mix(s3, load<u32>(pos,  8));\n      s4 = mix(s4, load<u32>(pos, 12));\n      pos += 16;\n    }\n    h += rotl(s1, 1) + rotl(s2, 7) + rotl(s3, 12) + rotl(s4, 18);\n  } else {\n    h += XXH32_SEED + XXH32_P5;\n  }\n\n  let end = changetype<usize>(key) + len - 4;\n  while (pos <= end) {\n    h += load<u32>(pos) * XXH32_P3;\n    h = rotl(h, 17) * XXH32_P4;\n    pos += 4;\n  }\n\n  end = changetype<usize>(key) + len;\n  while (pos < end) {\n    h += <u32>load<u8>(pos) * XXH32_P5;\n    h = rotl(h, 11) * XXH32_P1;\n    pos++;\n  }\n\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { HASH } from \"./util/hash\";\nimport { E_KEYNOTFOUND } from \"./util/error\";\n\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\n\n// @ts-ignore: decorator\n@inline const INITIAL_CAPACITY = 4;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_N = 8;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_D = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_N = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_D = 4;\n\n/** Structure of a map entry. */\n@unmanaged class MapEntry<K,V> {\n  key: K;\n  value: V;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n// @ts-ignore: decorator\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n// @ts-ignore: decorator\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_ALIGN<K,V>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_SIZE<K,V>(): usize {\n  const align = ENTRY_ALIGN<K,V>();\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\n  return size;\n}\n\nexport class Map<K,V> {\n\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\n\n  // entries in insertion order, MapEntry<K,V>[entriesCapacity]\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\n  private entriesOffset: i32 = 0;\n  private entriesCount: i32 = 0;\n\n  constructor() {\n    /* nop */\n  }\n\n  get size(): i32 {\n    return this.entriesCount;\n  }\n\n  clear(): void {\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\n    let entry = load<MapEntry<K,V>>( // unmanaged!\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\n    );\n    while (entry) {\n      let taggedNext = entry.taggedNext;\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<MapEntry<K,V>>(taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    return this.find(key, HASH<K>(key)) != null;\n  }\n\n  @operator(\"[]\")\n  get(key: K): V {\n    let entry = this.find(key, HASH<K>(key));\n    if (!entry) throw new Error(E_KEYNOTFOUND); // cannot represent `undefined`\n    return entry.value;\n  }\n\n  @operator(\"[]=\")\n  set(key: K, value: V): this {\n    let hashCode = HASH<K>(key);\n    let entry = this.find(key, hashCode); // unmanaged!\n    if (entry) {\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      let entries = this.entries;\n      entry = changetype<MapEntry<K,V>>(changetype<usize>(entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<K,V>());\n      // link with the map\n      entry.key = key;\n      if (isManaged<K>()) {\n        __link(changetype<usize>(this), changetype<usize>(key), true);\n      }\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase);\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\n    }\n    return this;\n  }\n\n  delete(key: K): bool {\n    let entry = this.find(key, HASH<K>(key));\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    let halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    let newBucketsCapacity = <i32>(newBucketsMask + 1);\n    let newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    let newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\n    let newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>());\n\n    // copy old entries to new entries\n    let oldPtr = changetype<usize>(this.entries);\n    let oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n    let newPtr = changetype<usize>(newEntries);\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\n        let oldEntryKey = oldEntry.key;\n        newEntry.key = oldEntryKey;\n        newEntry.value = oldEntry.value;\n        let newBucketIndex = HASH<K>(oldEntryKey) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\n        store<usize>(newBucketPtrBase, newPtr);\n        newPtr += ENTRY_SIZE<K,V>();\n      }\n      oldPtr += ENTRY_SIZE<K,V>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  keys(): K[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    let start = changetype<usize>(this.entries);\n    let size = this.entriesOffset;\n    let keys = new Array<K>(size);\n    let length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        unchecked(keys[length++] = entry.key);\n      }\n    }\n    keys.length = length;\n    return keys;\n  }\n\n  values(): V[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    let start = changetype<usize>(this.entries);\n    let size = this.entriesOffset;\n    let values = new Array<V>(size);\n    let length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        unchecked(values[length++] = entry.value);\n      }\n    }\n    values.length = length;\n    return values;\n  }\n\n  toString(): string {\n    return \"[object Map]\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    __visit(changetype<usize>(this.buckets), cookie);\n    let entries = changetype<usize>(this.entries);\n    if (isManaged<K>() || isManaged<V>()) {\n      let cur = entries;\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n      while (cur < end) {\n        let entry = changetype<MapEntry<K,V>>(cur);\n        if (!(entry.taggedNext & EMPTY)) {\n          if (isManaged<K>()) {\n            let val = changetype<usize>(entry.key);\n            if (isNullable<K>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n          if (isManaged<V>()) {\n            let val = changetype<usize>(entry.value);\n            if (isNullable<V>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n        }\n        cur += ENTRY_SIZE<K,V>();\n      }\n    }\n    __visit(entries, cookie);\n  }\n}\n","import {errno, handle, ptr, StatusCode} from \"../types\";\nimport {SUCCESS} from \"../error\";\nimport { JSON } from \"../json\";\n\n@external(\"blockless_memory\", \"memory_read\")\ndeclare function memory_read(buf: ptr<u32>, len: u32, num: ptr<u32>): errno\n\n@external(\"blockless_memory\", \"env_var_read\")\ndeclare function env_var_read(buf: ptr<u32>, len: u32, num: ptr<u32>): errno\n\nfunction readStdin(buf: Array<u8>): i32 {\n    let num_buf = memory.data(8);\n    let buffer_ptr = changetype<usize>(new ArrayBuffer(buf.length));\n    let rs = memory_read(buffer_ptr, buf.length, num_buf);\n    let num = load<u32>(num_buf);\n    if (rs == SUCCESS) {\n        if (num != 0) {\n            for(let i = 0; i < buf.length; i += 1)\n                buf[i] = load<u8>(buffer_ptr + i);\n            return num;\n        } else {\n            return 0;\n        }\n    }\n    return -1;\n}\n\nfunction readEnvVars(buf: Array<u8>): i32 {\n  let num_buf = memory.data(8);\n  let buffer_ptr = changetype<usize>(new ArrayBuffer(buf.length));\n  let rs = env_var_read(buffer_ptr, buf.length, num_buf);\n  let num = load<u32>(num_buf);\n  if (rs == SUCCESS) {\n      if (num != 0) {\n          for(let i = 0; i < buf.length; i += 1)\n              buf[i] = load<u8>(buffer_ptr + i);\n          return num;\n      } else {\n          return 0;\n      }\n  }\n  return -1;\n}\n\nexport class Stdin {\n    buf: u8[] = new Array(1024);\n    constructor() {\n\n    }\n\n    read(): Stdin {\n        let tbuf: u8[] = new Array(1024);\n        let bs = readStdin(tbuf);\n        this.buf = tbuf;\n        return this;\n    }\n\n    toString(): string {\n      let string = \"\";\n\n      if(this.buf != null) {\n        string = String.UTF8.decodeUnsafe(this.buf.dataStart, this.buf.length);\n       }\n\n      return string\n    }\n\n    toJSON(): JSON.Obj {\n      let string = \"{}\";\n    \n      if(this.buf != null) {\n        string = String.UTF8.decodeUnsafe(this.buf.dataStart, this.buf.length);\n      }\n\n      let jsonObj: JSON.Obj = <JSON.Obj>(JSON.parse(string));\n\n      return jsonObj;\n    }\n}\n\nexport class EnvVars {\n  buf: u8[] = new Array(1024);\n  private static vars: Map<string, string> | null = null;\n\n  constructor() {}\n\n  read(): EnvVars {\n    let tbuf: u8[] = new Array(1024);\n    let bs = readEnvVars(tbuf);\n    this.buf = tbuf;\n    return this;\n  }\n\n  toString(): string {\n    let string = \"\";\n\n    if(this.buf != null) {\n      string = String.UTF8.decodeUnsafe(this.buf.dataStart, this.buf.length);\n     }\n\n    return string\n  }\n\n  toJSON(): JSON.Obj {\n    let string = \"{}\";\n  \n    if(this.buf != null) {\n      string = String.UTF8.decodeUnsafe(this.buf.dataStart, this.buf.length);\n    }\n\n    let jsonObj: JSON.Obj = <JSON.Obj>(JSON.parse(string));\n\n    return jsonObj;\n  }\n\n  static initalize(): void {\n    EnvVars.vars = new Map<string, string>();\n    const blsEnv = new EnvVars().read().toJSON()\n\n    if (blsEnv.keys.length > 0) {\n      for (let i = 0; i < blsEnv.keys.length; i++) {\n        const key = blsEnv.keys[i];\n\n        if (blsEnv.has(key)) {\n          EnvVars.vars!.set(key, blsEnv.getString(key)!._str);\n        }\n      }\n    }\n  }\n\n  static get(key: string): string {\n    if (EnvVars.vars === null) {\n      EnvVars.initalize();\n    }\n\n    return EnvVars.vars!.has(key) ? EnvVars.vars!.get(key) : '';\n  }\n}","\n  import { http } from \"@blockless/sdk/assembly\"\n  const assets = new Map<string,string>()\n  \n  assets.set(\"/404.html\", \"data:text/html;base64,PCFET0NUWVBFIGh0bWw+PGh0bWw+PGhlYWQ+PG1ldGEgY2hhclNldD0idXRmLTgiLz48bWV0YSBuYW1lPSJ2aWV3cG9ydCIgY29udGVudD0id2lkdGg9ZGV2aWNlLXdpZHRoIi8+PHRpdGxlPjQwNDogVGhpcyBwYWdlIGNvdWxkIG5vdCBiZSBmb3VuZDwvdGl0bGU+PG1ldGEgbmFtZT0ibmV4dC1oZWFkLWNvdW50IiBjb250ZW50PSIzIi8+PG5vc2NyaXB0IGRhdGEtbi1jc3M9IiI+PC9ub3NjcmlwdD48c2NyaXB0IGRlZmVyPSIiIG5vbW9kdWxlPSIiIHNyYz0iL19uZXh0L3N0YXRpYy9jaHVua3MvcG9seWZpbGxzLTc4YzkyZmFjN2FhOGZkZDguanMiPjwvc2NyaXB0PjxzY3JpcHQgc3JjPSIvX25leHQvc3RhdGljL2NodW5rcy93ZWJwYWNrLTc2ZmQ4YjM5ZmU5MTRjMjkuanMiIGRlZmVyPSIiPjwvc2NyaXB0PjxzY3JpcHQgc3JjPSIvX25leHQvc3RhdGljL2NodW5rcy9mcmFtZXdvcmstODg4M2QxZTliZTcwYzNkYS5qcyIgZGVmZXI9IiI+PC9zY3JpcHQ+PHNjcmlwdCBzcmM9Ii9fbmV4dC9zdGF0aWMvY2h1bmtzL21haW4tYTE5NzEyYTYwM2NmZjAxZS5qcyIgZGVmZXI9IiI+PC9zY3JpcHQ+PHNjcmlwdCBzcmM9Ii9fbmV4dC9zdGF0aWMvY2h1bmtzL3BhZ2VzL19hcHAtNTI5MjQ1MjRmOTkwOTRhYi5qcyIgZGVmZXI9IiI+PC9zY3JpcHQ+PHNjcmlwdCBzcmM9Ii9fbmV4dC9zdGF0aWMvY2h1bmtzL3BhZ2VzL19lcnJvci1jOTJkNWM0YmIyYjQ5OTI2LmpzIiBkZWZlcj0iIj48L3NjcmlwdD48c2NyaXB0IHNyYz0iL19uZXh0L3N0YXRpYy96UXpHSEo2LXVrTlAzYmVwT2hla1AvX2J1aWxkTWFuaWZlc3QuanMiIGRlZmVyPSIiPjwvc2NyaXB0PjxzY3JpcHQgc3JjPSIvX25leHQvc3RhdGljL3pRekdISjYtdWtOUDNiZXBPaGVrUC9fc3NnTWFuaWZlc3QuanMiIGRlZmVyPSIiPjwvc2NyaXB0PjwvaGVhZD48Ym9keT48ZGl2IGlkPSJfX25leHQiPjxkaXYgc3R5bGU9ImZvbnQtZmFtaWx5OnN5c3RlbS11aSwmcXVvdDtTZWdvZSBVSSZxdW90OyxSb2JvdG8sSGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWYsJnF1b3Q7QXBwbGUgQ29sb3IgRW1vamkmcXVvdDssJnF1b3Q7U2Vnb2UgVUkgRW1vamkmcXVvdDs7aGVpZ2h0OjEwMHZoO3RleHQtYWxpZ246Y2VudGVyO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXIiPjxkaXYgc3R5bGU9ImxpbmUtaGVpZ2h0OjQ4cHgiPjxzdHlsZT5ib2R5e2NvbG9yOiMwMDA7YmFja2dyb3VuZDojZmZmO21hcmdpbjowfS5uZXh0LWVycm9yLWgxe2JvcmRlci1yaWdodDoxcHggc29saWQgcmdiYSgwLDAsMCwuMyl9QG1lZGlhIChwcmVmZXJzLWNvbG9yLXNjaGVtZTpkYXJrKXtib2R5e2NvbG9yOiNmZmY7YmFja2dyb3VuZDojMDAwfS5uZXh0LWVycm9yLWgxe2JvcmRlci1yaWdodDoxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwuMyl9fTwvc3R5bGU+PGgxIGNsYXNzPSJuZXh0LWVycm9yLWgxIiBzdHlsZT0iZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luOjAgMjBweCAwIDA7cGFkZGluZy1yaWdodDoyM3B4O2ZvbnQtc2l6ZToyNHB4O2ZvbnQtd2VpZ2h0OjUwMDt2ZXJ0aWNhbC1hbGlnbjp0b3AiPjQwNDwvaDE+PGRpdiBzdHlsZT0iZGlzcGxheTppbmxpbmUtYmxvY2siPjxoMiBzdHlsZT0iZm9udC1zaXplOjE0cHg7Zm9udC13ZWlnaHQ6NDAwO2xpbmUtaGVpZ2h0OjI4cHgiPlRoaXMgcGFnZSBjb3VsZCBub3QgYmUgZm91bmQ8IS0tIC0tPi48L2gyPjwvZGl2PjwvZGl2PjwvZGl2PjwvZGl2PjxzY3JpcHQgaWQ9Il9fTkVYVF9EQVRBX18iIHR5cGU9ImFwcGxpY2F0aW9uL2pzb24iPnsicHJvcHMiOnsicGFnZVByb3BzIjp7InN0YXR1c0NvZGUiOjQwNH19LCJwYWdlIjoiL19lcnJvciIsInF1ZXJ5Ijp7fSwiYnVpbGRJZCI6InpRekdISjYtdWtOUDNiZXBPaGVrUCIsIm5leHRFeHBvcnQiOnRydWUsImlzRmFsbGJhY2siOmZhbHNlLCJnaXAiOnRydWUsInNjcmlwdExvYWRlciI6W119PC9zY3JpcHQ+PC9ib2R5PjwvaHRtbD4=\")\nassets.set(\"/_next/static/chunks/961-e6437325a155ddfa.js\", \"data:application/javascript;base64,KHNlbGYud2VicGFja0NodW5rX05fRT1zZWxmLndlYnBhY2tDaHVua19OX0V8fFtdKS5wdXNoKFtbOTYxXSx7MzY0NDpmdW5jdGlvbigpeyJ0cmltU3RhcnQiaW4gU3RyaW5nLnByb3RvdHlwZXx8KFN0cmluZy5wcm90b3R5cGUudHJpbVN0YXJ0PVN0cmluZy5wcm90b3R5cGUudHJpbUxlZnQpLCJ0cmltRW5kImluIFN0cmluZy5wcm90b3R5cGV8fChTdHJpbmcucHJvdG90eXBlLnRyaW1FbmQ9U3RyaW5nLnByb3RvdHlwZS50cmltUmlnaHQpLCJkZXNjcmlwdGlvbiJpbiBTeW1ib2wucHJvdG90eXBlfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoU3ltYm9sLnByb3RvdHlwZSwiZGVzY3JpcHRpb24iLHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7dmFyIGU9L1woKC4qKVwpLy5leGVjKHRoaXMudG9TdHJpbmcoKSk7cmV0dXJuIGU/ZVsxXTp2b2lkIDB9fSksQXJyYXkucHJvdG90eXBlLmZsYXR8fChBcnJheS5wcm90b3R5cGUuZmxhdD1mdW5jdGlvbihlLHQpe3JldHVybiB0PXRoaXMuY29uY2F0LmFwcGx5KFtdLHRoaXMpLGU+MSYmdC5zb21lKEFycmF5LmlzQXJyYXkpP3QuZmxhdChlLTEpOnR9LEFycmF5LnByb3RvdHlwZS5mbGF0TWFwPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMubWFwKGUsdCkuZmxhdCgpfSksUHJvbWlzZS5wcm90b3R5cGUuZmluYWxseXx8KFByb21pc2UucHJvdG90eXBlLmZpbmFsbHk9ZnVuY3Rpb24oZSl7aWYoImZ1bmN0aW9uIiE9dHlwZW9mIGUpcmV0dXJuIHRoaXMudGhlbihlLGUpO3ZhciB0PXRoaXMuY29uc3RydWN0b3J8fFByb21pc2U7cmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbihyKXtyZXR1cm4gdC5yZXNvbHZlKGUoKSkudGhlbihmdW5jdGlvbigpe3JldHVybiByfSl9LGZ1bmN0aW9uKHIpe3JldHVybiB0LnJlc29sdmUoZSgpKS50aGVuKGZ1bmN0aW9uKCl7dGhyb3cgcn0pfSl9KSxPYmplY3QuZnJvbUVudHJpZXN8fChPYmplY3QuZnJvbUVudHJpZXM9ZnVuY3Rpb24oZSl7cmV0dXJuIEFycmF5LmZyb20oZSkucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbdFswXV09dFsxXSxlfSx7fSl9KX0sNTg4NDpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiYWRkQmFzZVBhdGgiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBvfX0pO2xldCBuPXIoNDMzMSksdT1yKDIxNTgpO2Z1bmN0aW9uIG8oZSx0KXtyZXR1cm4oMCx1Lm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKSgoMCxuLmFkZFBhdGhQcmVmaXgpKGUsIiIpKX0oImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSwyNTcxOmZ1bmN0aW9uKGUsdCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHIoZSl7dmFyIHQscjt0PXNlbGYuX19uZXh0X3Mscj0oKT0+e2UoKX0sdCYmdC5sZW5ndGg/dC5yZWR1Y2UoKGUsdCk9PntsZXRbcixuXT10O3JldHVybiBlLnRoZW4oKCk9Pm5ldyBQcm9taXNlKChlLHQpPT57bGV0IHU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic2NyaXB0Iik7aWYobilmb3IobGV0IGUgaW4gbikiY2hpbGRyZW4iIT09ZSYmdS5zZXRBdHRyaWJ1dGUoZSxuW2VdKTtyPyh1LnNyYz1yLHUub25sb2FkPSgpPT5lKCksdS5vbmVycm9yPXQpOm4mJih1LmlubmVySFRNTD1uLmNoaWxkcmVuLHNldFRpbWVvdXQoZSkpLGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodSl9KSl9LFByb21pc2UucmVzb2x2ZSgpKS5jYXRjaChlPT57Y29uc29sZS5lcnJvcihlKX0pLnRoZW4oKCk9PntyKCl9KTpyKCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJhcHBCb290c3RyYXAiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiByfX0pLHdpbmRvdy5uZXh0PXt2ZXJzaW9uOiIxMy40LjEwIixhcHBEaXI6ITB9LCgiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDU2MDA6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImNhbGxTZXJ2ZXIiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB1fX0pO2xldCBuPXIoODA5NSk7YXN5bmMgZnVuY3Rpb24gdShlLHQpe2xldCByPSgwLG4uZ2V0U2VydmVyQWN0aW9uRGlzcGF0Y2hlcikoKTtpZighcil0aHJvdyBFcnJvcigiSW52YXJpYW50OiBtaXNzaW5nIGFjdGlvbiBkaXNwYXRjaGVyLiIpO3JldHVybiBuZXcgUHJvbWlzZSgobix1KT0+e3Ioe2FjdGlvbklkOmUsYWN0aW9uQXJnczp0LHJlc29sdmU6bixyZWplY3Q6dX0pfSl9KCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sODMzNDpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO2xldCBuLHU7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJoeWRyYXRlIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gTn19KTtsZXQgbz1yKDY5MjcpLGw9cig1OTA5KTtyKDM2NDQpO2xldCBhPW8uXyhyKDMxOTQpKSxpPWwuXyhyKDYwMDYpKSxjPXIoNTQ1Nikscz1yKDU3Nyk7cigzMDkzKTtsZXQgZj1vLl8ocig1MDIpKSxkPXIoNTYwMCkscD1yKDQ1NzkpLGg9d2luZG93LmNvbnNvbGUuZXJyb3I7d2luZG93LmNvbnNvbGUuZXJyb3I9ZnVuY3Rpb24oKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCx0PUFycmF5KGUpLHI9MDtyPGU7cisrKXRbcl09YXJndW1lbnRzW3JdOygwLHAuaXNOZXh0Um91dGVyRXJyb3IpKHRbMF0pfHxoLmFwcGx5KHdpbmRvdy5jb25zb2xlLHQpfSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigiZXJyb3IiLGU9PntpZigoMCxwLmlzTmV4dFJvdXRlckVycm9yKShlLmVycm9yKSl7ZS5wcmV2ZW50RGVmYXVsdCgpO3JldHVybn19KTtsZXQgXz1lPT50PT5lKHQpKyIiLHk9ci51LGI9e307ci51PV8oZT0+ZW5jb2RlVVJJKGJbZV18fHkoZSkpKTtsZXQgdj1yLms7ci5rPV8odik7bGV0IG09ci5taW5pQ3NzRjtyLm1pbmlDc3NGPV8obSksc2VsZi5fX25leHRfcmVxdWlyZV9fPXIsc2VsZi5fX25leHRfY2h1bmtfbG9hZF9fPWU9PntpZighZSlyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7bGV0W3Qsbl09ZS5zcGxpdCgiOiIpO3JldHVybiBiW3RdPW4sci5lKHQpfTtsZXQgZz1kb2N1bWVudCxPPSgpPT57bGV0e3BhdGhuYW1lOmUsc2VhcmNoOnR9PWxvY2F0aW9uO3JldHVybiBlK3R9LFA9bmV3IFRleHRFbmNvZGVyLEU9ITEsUj0hMTtmdW5jdGlvbiBqKGUpe2lmKDA9PT1lWzBdKW49W107ZWxzZXtpZighbil0aHJvdyBFcnJvcigiVW5leHBlY3RlZCBzZXJ2ZXIgZGF0YTogbWlzc2luZyBib290c3RyYXAgc2NyaXB0LiIpO3U/dS5lbnF1ZXVlKFAuZW5jb2RlKGVbMV0pKTpuLnB1c2goZVsxXSl9fWxldCBTPWZ1bmN0aW9uKCl7dSYmIVImJih1LmNsb3NlKCksUj0hMCxuPXZvaWQgMCksRT0hMH07ImxvYWRpbmciPT09ZG9jdW1lbnQucmVhZHlTdGF0ZT9kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCJET01Db250ZW50TG9hZGVkIixTLCExKTpTKCk7bGV0IFQ9c2VsZi5fX25leHRfZj1zZWxmLl9fbmV4dF9mfHxbXTtULmZvckVhY2goaiksVC5wdXNoPWo7bGV0IE09bmV3IE1hcDtmdW5jdGlvbiB3KGUpe2xldHtjYWNoZUtleTp0fT1lO2kuZGVmYXVsdC51c2VFZmZlY3QoKCk9PntNLmRlbGV0ZSh0KX0pO2xldCByPWZ1bmN0aW9uKGUpe2xldCB0PU0uZ2V0KGUpO2lmKHQpcmV0dXJuIHQ7bGV0IHI9bmV3IFJlYWRhYmxlU3RyZWFtKHtzdGFydChlKXtuJiYobi5mb3JFYWNoKHQ9PntlLmVucXVldWUoUC5lbmNvZGUodCkpfSksRSYmIVImJihlLmNsb3NlKCksUj0hMCxuPXZvaWQgMCkpLHU9ZX19KSxvPSgwLGMuY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtKShyLHtjYWxsU2VydmVyOmQuY2FsbFNlcnZlcn0pO3JldHVybiBNLnNldChlLG8pLG99KHQpLG89KDAsaS51c2UpKHIpO3JldHVybiBvfWxldCBDPWkuZGVmYXVsdC5GcmFnbWVudDtmdW5jdGlvbiB4KGUpe2xldHtjaGlsZHJlbjp0fT1lO3JldHVybiB0fWZ1bmN0aW9uIEEoZSl7cmV0dXJuIGkuZGVmYXVsdC5jcmVhdGVFbGVtZW50KHcsey4uLmUsY2FjaGVLZXk6TygpfSl9ZnVuY3Rpb24gTigpe2xldCBlPWkuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEMsbnVsbCxpLmRlZmF1bHQuY3JlYXRlRWxlbWVudChzLkhlYWRNYW5hZ2VyQ29udGV4dC5Qcm92aWRlcix7dmFsdWU6e2FwcERpcjohMH19LGkuZGVmYXVsdC5jcmVhdGVFbGVtZW50KHgsbnVsbCxpLmRlZmF1bHQuY3JlYXRlRWxlbWVudChBLG51bGwpKSkpLHQ9e29uUmVjb3ZlcmFibGVFcnJvcjpmLmRlZmF1bHR9LHI9Il9fbmV4dF9lcnJvcl9fIj09PWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5pZDtyP2EuZGVmYXVsdC5jcmVhdGVSb290KGcsdCkucmVuZGVyKGUpOmkuZGVmYXVsdC5zdGFydFRyYW5zaXRpb24oKCk9PmEuZGVmYXVsdC5oeWRyYXRlUm9vdChnLGUsdCkpfSgiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDIxNzQ6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7bGV0IG49cigyNTcxKTsoMCxuLmFwcEJvb3RzdHJhcCkoKCk9PntyKDgwOTUpLHIoMzQ2Nik7bGV0e2h5ZHJhdGU6ZX09cig4MzM0KTtlKCl9KSwoImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSw0MTY0OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJBcHBSb3V0ZXJBbm5vdW5jZXIiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBsfX0pO2xldCBuPXIoNjAwNiksdT1yKDg0MzEpLG89Im5leHQtcm91dGUtYW5ub3VuY2VyIjtmdW5jdGlvbiBsKGUpe2xldHt0cmVlOnR9PWUsW3IsbF09KDAsbi51c2VTdGF0ZSkobnVsbCk7KDAsbi51c2VFZmZlY3QpKCgpPT57bGV0IGU9ZnVuY3Rpb24oKXt2YXIgZTtsZXQgdD1kb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShvKVswXTtpZihudWxsPT10P3ZvaWQgMDpudWxsPT0oZT10LnNoYWRvd1Jvb3QpP3ZvaWQgMDplLmNoaWxkTm9kZXNbMF0pcmV0dXJuIHQuc2hhZG93Um9vdC5jaGlsZE5vZGVzWzBdO3tsZXQgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KG8pO2Uuc3R5bGUuY3NzVGV4dD0icG9zaXRpb246YWJzb2x1dGUiO2xldCB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO3QuYXJpYUxpdmU9ImFzc2VydGl2ZSIsdC5pZD0iX19uZXh0LXJvdXRlLWFubm91bmNlcl9fIix0LnJvbGU9ImFsZXJ0Iix0LnN0eWxlLmNzc1RleHQ9InBvc2l0aW9uOmFic29sdXRlO2JvcmRlcjowO2hlaWdodDoxcHg7bWFyZ2luOi0xcHg7cGFkZGluZzowO3dpZHRoOjFweDtjbGlwOnJlY3QoMCAwIDAgMCk7b3ZlcmZsb3c6aGlkZGVuO3doaXRlLXNwYWNlOm5vd3JhcDt3b3JkLXdyYXA6bm9ybWFsIjtsZXQgcj1lLmF0dGFjaFNoYWRvdyh7bW9kZToib3BlbiJ9KTtyZXR1cm4gci5hcHBlbmRDaGlsZCh0KSxkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGUpLHR9fSgpO3JldHVybiBsKGUpLCgpPT57bGV0IGU9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUobylbMF07KG51bGw9PWU/dm9pZCAwOmUuaXNDb25uZWN0ZWQpJiZkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGUpfX0sW10pO2xldFthLGldPSgwLG4udXNlU3RhdGUpKCIiKSxjPSgwLG4udXNlUmVmKSgpO3JldHVybigwLG4udXNlRWZmZWN0KSgoKT0+e2xldCBlPSIiO2lmKGRvY3VtZW50LnRpdGxlKWU9ZG9jdW1lbnQudGl0bGU7ZWxzZXtsZXQgdD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCJoMSIpO3QmJihlPXQuaW5uZXJUZXh0fHx0LnRleHRDb250ZW50fHwiIil9dm9pZCAwIT09Yy5jdXJyZW50JiZpKGUpLGMuY3VycmVudD1lfSxbdF0pLHI/KDAsdS5jcmVhdGVQb3J0YWwpKGEscik6bnVsbH0oImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSw5NDM4OmZ1bmN0aW9uKGUsdCl7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ITAsZ2V0OnRbcl19KX0odCx7UlNDOmZ1bmN0aW9uKCl7cmV0dXJuIHJ9LEFDVElPTjpmdW5jdGlvbigpe3JldHVybiBufSxORVhUX1JPVVRFUl9TVEFURV9UUkVFOmZ1bmN0aW9uKCl7cmV0dXJuIHV9LE5FWFRfUk9VVEVSX1BSRUZFVENIOmZ1bmN0aW9uKCl7cmV0dXJuIG99LE5FWFRfVVJMOmZ1bmN0aW9uKCl7cmV0dXJuIGx9LEZFVENIX0NBQ0hFX0hFQURFUjpmdW5jdGlvbigpe3JldHVybiBhfSxSU0NfQ09OVEVOVF9UWVBFX0hFQURFUjpmdW5jdGlvbigpe3JldHVybiBpfSxSU0NfVkFSWV9IRUFERVI6ZnVuY3Rpb24oKXtyZXR1cm4gY30sRkxJR0hUX1BBUkFNRVRFUlM6ZnVuY3Rpb24oKXtyZXR1cm4gc30sTkVYVF9SU0NfVU5JT05fUVVFUlk6ZnVuY3Rpb24oKXtyZXR1cm4gZn19KTtsZXQgcj0iUlNDIixuPSJOZXh0LUFjdGlvbiIsdT0iTmV4dC1Sb3V0ZXItU3RhdGUtVHJlZSIsbz0iTmV4dC1Sb3V0ZXItUHJlZmV0Y2giLGw9Ik5leHQtVXJsIixhPSJ4LXZlcmNlbC1zYy1oZWFkZXJzIixpPSJ0ZXh0L3gtY29tcG9uZW50IixjPXIrIiwgIit1KyIsICIrbyxzPVtbcl0sW3VdLFtvXV0sZj0iX3JzYyI7KCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sODA5NTpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ITAsZ2V0OnRbcl19KX0odCx7Z2V0U2VydmVyQWN0aW9uRGlzcGF0Y2hlcjpmdW5jdGlvbigpe3JldHVybiBFfSx1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXI6ZnVuY3Rpb24oKXtyZXR1cm4gUn0sZGVmYXVsdDpmdW5jdGlvbigpe3JldHVybiB3fX0pO2xldCBuPXIoNTkwOSksdT1uLl8ocig2MDA2KSksbz1yKDMwOTMpLGw9cig1Mjk3KSxhPXIoODc0KSxpPXIoMjI3OCksYz1yKDgzNDUpLHM9cig1MjUzKSxmPXIoMTIyMyksZD1yKDYwNCkscD1yKDkzMTUpLGg9cig1ODg0KSxfPXIoNDE2NCkseT1yKDIyNSksYj1yKDk4MjcpLHY9cigyODk0KSxtPXIoNDg3NCksZz1yKDk0MzgpLE89bmV3IE1hcCxQPW51bGw7ZnVuY3Rpb24gRSgpe3JldHVybiBQfWZ1bmN0aW9uIFIoZSl7bGV0IHQ9bmV3IFVSTChlLGxvY2F0aW9uLm9yaWdpbik7cmV0dXJuIHQuc2VhcmNoUGFyYW1zLmRlbGV0ZShnLk5FWFRfUlNDX1VOSU9OX1FVRVJZKSx0LnBhdGhuYW1lLmVuZHNXaXRoKCIvaW5kZXgudHh0Iik/dC5wYXRobmFtZT10LnBhdGhuYW1lLnNsaWNlKDAsLTEwKTp0LnBhdGhuYW1lPXQucGF0aG5hbWUuc2xpY2UoMCwtNCksdH1mdW5jdGlvbiBqKGUpe3JldHVybiBlLm9yaWdpbiE9PXdpbmRvdy5sb2NhdGlvbi5vcmlnaW59ZnVuY3Rpb24gUyhlKXtsZXR7dHJlZTp0LHB1c2hSZWY6cixjYW5vbmljYWxVcmw6bixzeW5jOm99PWU7cmV0dXJuKDAsdS51c2VJbnNlcnRpb25FZmZlY3QpKCgpPT57bGV0IGU9e19fTkE6ITAsdHJlZTp0fTtyLnBlbmRpbmdQdXNoJiYoMCxpLmNyZWF0ZUhyZWZGcm9tVXJsKShuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKSkhPT1uPyhyLnBlbmRpbmdQdXNoPSExLHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShlLCIiLG4pKTp3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoZSwiIixuKSxvKCl9LFt0LHIsbixvXSksbnVsbH1sZXQgVD0oKT0+KHtzdGF0dXM6by5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVELGRhdGE6bnVsbCxzdWJUcmVlRGF0YTpudWxsLHBhcmFsbGVsUm91dGVzOm5ldyBNYXB9KTtmdW5jdGlvbiBNKGUpe2xldHtidWlsZElkOnQsaW5pdGlhbEhlYWQ6cixpbml0aWFsVHJlZTpuLGluaXRpYWxDYW5vbmljYWxVcmw6aSxjaGlsZHJlbjpmLGFzc2V0UHJlZml4Omcsbm90Rm91bmQ6RSxhc05vdEZvdW5kOlJ9PWUsTT0oMCx1LnVzZU1lbW8pKCgpPT4oMCxkLmNyZWF0ZUluaXRpYWxSb3V0ZXJTdGF0ZSkoe2J1aWxkSWQ6dCxjaGlsZHJlbjpmLGluaXRpYWxDYW5vbmljYWxVcmw6aSxpbml0aWFsVHJlZTpuLGluaXRpYWxQYXJhbGxlbFJvdXRlczpPLGlzU2VydmVyOiExLGxvY2F0aW9uOndpbmRvdy5sb2NhdGlvbixpbml0aWFsSGVhZDpyfSksW3QsZixpLG4scl0pLFt7dHJlZTp3LGNhY2hlOkMscHJlZmV0Y2hDYWNoZTp4LHB1c2hSZWY6QSxmb2N1c0FuZFNjcm9sbFJlZjpOLGNhbm9uaWNhbFVybDpJLG5leHRVcmw6RH0sayxGXT0oMCxzLnVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29scykobC5yZWR1Y2VyLE0pOygwLHUudXNlRWZmZWN0KSgoKT0+e089bnVsbH0sW10pO2xldHtzZWFyY2hQYXJhbXM6VSxwYXRobmFtZTpMfT0oMCx1LnVzZU1lbW8pKCgpPT57bGV0IGU9bmV3IFVSTChJLHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtyZXR1cm57c2VhcmNoUGFyYW1zOmUuc2VhcmNoUGFyYW1zLHBhdGhuYW1lOmUucGF0aG5hbWV9fSxbSV0pLEg9KDAsdS51c2VDYWxsYmFjaykoKGUsdCxyKT0+eygwLHUuc3RhcnRUcmFuc2l0aW9uKSgoKT0+e2soe3R5cGU6YS5BQ1RJT05fU0VSVkVSX1BBVENILGZsaWdodERhdGE6dCxwcmV2aW91c1RyZWU6ZSxvdmVycmlkZUNhbm9uaWNhbFVybDpyLGNhY2hlOlQoKSxtdXRhYmxlOnt9fSl9KX0sW2tdKSwkPSgwLHUudXNlQ2FsbGJhY2spKChlLHQscixuKT0+e2xldCB1PW5ldyBVUkwoKDAsaC5hZGRCYXNlUGF0aCkoZSksbG9jYXRpb24uaHJlZik7cmV0dXJuIGsoe3R5cGU6YS5BQ1RJT05fTkFWSUdBVEUsdXJsOnUsaXNFeHRlcm5hbFVybDpqKHUpLGxvY2F0aW9uU2VhcmNoOmxvY2F0aW9uLnNlYXJjaCxmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uOnIsc2hvdWxkU2Nyb2xsOm51bGw9PW58fG4sbmF2aWdhdGVUeXBlOnQsY2FjaGU6VCgpLG11dGFibGU6e319KX0sW2tdKTshZnVuY3Rpb24oZSx0LHIpe2xldCBuPSgwLHUudXNlQ2FsbGJhY2spKG49PnsoMCx1LnN0YXJ0VHJhbnNpdGlvbikoKCk9Pnt0KHsuLi5uLHR5cGU6YS5BQ1RJT05fU0VSVkVSX0FDVElPTixtdXRhYmxlOnt9LG5hdmlnYXRlOnIsY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZTplfSl9KX0sW2UsdCxyXSk7UD1ufShILGssJCk7bGV0IFc9KDAsdS51c2VNZW1vKSgoKT0+e2xldCBlPXtiYWNrOigpPT53aW5kb3cuaGlzdG9yeS5iYWNrKCksZm9yd2FyZDooKT0+d2luZG93Lmhpc3RvcnkuZm9yd2FyZCgpLHByZWZldGNoOihlLHQpPT57aWYoKDAscC5pc0JvdCkod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpKXJldHVybjtsZXQgcj1uZXcgVVJMKCgwLGguYWRkQmFzZVBhdGgpKGUpLGxvY2F0aW9uLmhyZWYpO2oocil8fCgwLHUuc3RhcnRUcmFuc2l0aW9uKSgoKT0+e3ZhciBlO2soe3R5cGU6YS5BQ1RJT05fUFJFRkVUQ0gsdXJsOnIsa2luZDpudWxsIT0oZT1udWxsPT10P3ZvaWQgMDp0LmtpbmQpP2U6YS5QcmVmZXRjaEtpbmQuRlVMTH0pfSl9LHJlcGxhY2U6KGUsdCk9Pnt2b2lkIDA9PT10JiYodD17fSksKDAsdS5zdGFydFRyYW5zaXRpb24pKCgpPT57dmFyIHI7JChlLCJyZXBsYWNlIiwhIXQuZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbixudWxsPT0ocj10LnNjcm9sbCl8fHIpfSl9LHB1c2g6KGUsdCk9Pnt2b2lkIDA9PT10JiYodD17fSksKDAsdS5zdGFydFRyYW5zaXRpb24pKCgpPT57dmFyIHI7JChlLCJwdXNoIiwhIXQuZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbixudWxsPT0ocj10LnNjcm9sbCl8fHIpfSl9LHJlZnJlc2g6KCk9PnsoMCx1LnN0YXJ0VHJhbnNpdGlvbikoKCk9PntrKHt0eXBlOmEuQUNUSU9OX1JFRlJFU0gsY2FjaGU6VCgpLG11dGFibGU6e30sb3JpZ2luOndpbmRvdy5sb2NhdGlvbi5vcmlnaW59KX0pfSxmYXN0UmVmcmVzaDooKT0+e3Rocm93IEVycm9yKCJmYXN0UmVmcmVzaCBjYW4gb25seSBiZSB1c2VkIGluIGRldmVsb3BtZW50IG1vZGUuIFBsZWFzZSB1c2UgcmVmcmVzaCBpbnN0ZWFkLiIpfX07cmV0dXJuIGV9LFtrLCRdKTtpZigoMCx1LnVzZUVmZmVjdCkoKCk9Pnt3aW5kb3cubmV4dCYmKHdpbmRvdy5uZXh0LnJvdXRlcj1XKX0sW1ddKSxBLm1wYU5hdmlnYXRpb24pe2xldCBlPXdpbmRvdy5sb2NhdGlvbjtBLnBlbmRpbmdQdXNoP2UuYXNzaWduKEkpOmUucmVwbGFjZShJKSwoMCx1LnVzZSkoKDAsbS5jcmVhdGVJbmZpbml0ZVByb21pc2UpKCkpfWxldCBCPSgwLHUudXNlQ2FsbGJhY2spKGU9PntsZXR7c3RhdGU6dH09ZTtpZih0KXtpZighdC5fX05BKXt3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7cmV0dXJufSgwLHUuc3RhcnRUcmFuc2l0aW9uKSgoKT0+e2soe3R5cGU6YS5BQ1RJT05fUkVTVE9SRSx1cmw6bmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZiksdHJlZTp0LnRyZWV9KX0pfX0sW2tdKTsoMCx1LnVzZUVmZmVjdCkoKCk9Pih3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigicG9wc3RhdGUiLEIpLCgpPT57d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoInBvcHN0YXRlIixCKX0pLFtCXSk7bGV0IFk9KDAsdS51c2VNZW1vKSgoKT0+KDAsdi5maW5kSGVhZEluQ2FjaGUpKEMsd1sxXSksW0Msd10pLFY9dS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoeS5SZWRpcmVjdEJvdW5kYXJ5LG51bGwsWSxDLnN1YlRyZWVEYXRhLHUuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF8uQXBwUm91dGVyQW5ub3VuY2VyLHt0cmVlOnd9KSk7cmV0dXJuIHUuZGVmYXVsdC5jcmVhdGVFbGVtZW50KHUuZGVmYXVsdC5GcmFnbWVudCxudWxsLHUuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFMse3RyZWU6dyxwdXNoUmVmOkEsY2Fub25pY2FsVXJsOkksc3luYzpGfSksdS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoYy5QYXRobmFtZUNvbnRleHQuUHJvdmlkZXIse3ZhbHVlOkx9LHUuZGVmYXVsdC5jcmVhdGVFbGVtZW50KGMuU2VhcmNoUGFyYW1zQ29udGV4dC5Qcm92aWRlcix7dmFsdWU6VX0sdS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoby5HbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLHt2YWx1ZTp7YnVpbGRJZDp0LGNoYW5nZUJ5U2VydmVyUmVzcG9uc2U6SCx0cmVlOncsZm9jdXNBbmRTY3JvbGxSZWY6TixuZXh0VXJsOkR9fSx1LmRlZmF1bHQuY3JlYXRlRWxlbWVudChvLkFwcFJvdXRlckNvbnRleHQuUHJvdmlkZXIse3ZhbHVlOld9LHUuZGVmYXVsdC5jcmVhdGVFbGVtZW50KG8uTGF5b3V0Um91dGVyQ29udGV4dC5Qcm92aWRlcix7dmFsdWU6e2NoaWxkTm9kZXM6Qy5wYXJhbGxlbFJvdXRlcyx0cmVlOncsdXJsOkl9fSx1LmRlZmF1bHQuY3JlYXRlRWxlbWVudChiLk5vdEZvdW5kQm91bmRhcnkse25vdEZvdW5kOkUsYXNOb3RGb3VuZDpSfSxWKSkpKSkpKX1mdW5jdGlvbiB3KGUpe2xldHtnbG9iYWxFcnJvckNvbXBvbmVudDp0LC4uLnJ9PWU7cmV0dXJuIHUuZGVmYXVsdC5jcmVhdGVFbGVtZW50KGYuRXJyb3JCb3VuZGFyeSx7ZXJyb3JDb21wb25lbnQ6dH0sdS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTSxyKSl9KCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sNDc5NDpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIG4oZSl7fU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiY2xpZW50SG9va0luU2VydmVyQ29tcG9uZW50RXJyb3IiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBufX0pLHIoNjkyNykscig2MDA2KSwoImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSwxMjIzOmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIHQpT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscix7ZW51bWVyYWJsZTohMCxnZXQ6dFtyXX0pfSh0LHtFcnJvckJvdW5kYXJ5SGFuZGxlcjpmdW5jdGlvbigpe3JldHVybiBhfSxHbG9iYWxFcnJvcjpmdW5jdGlvbigpe3JldHVybiBpfSxFcnJvckJvdW5kYXJ5OmZ1bmN0aW9uKCl7cmV0dXJuIGN9fSk7bGV0IG49cig2OTI3KSx1PW4uXyhyKDYwMDYpKSxvPXIoODE3MCksbD17ZXJyb3I6e2ZvbnRGYW1pbHk6J3N5c3RlbS11aSwiU2Vnb2UgVUkiLFJvYm90byxIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZiwiQXBwbGUgQ29sb3IgRW1vamkiLCJTZWdvZSBVSSBFbW9qaSInLGhlaWdodDoiMTAwdmgiLHRleHRBbGlnbjoiY2VudGVyIixkaXNwbGF5OiJmbGV4IixmbGV4RGlyZWN0aW9uOiJjb2x1bW4iLGFsaWduSXRlbXM6ImNlbnRlciIsanVzdGlmeUNvbnRlbnQ6ImNlbnRlciJ9LHRleHQ6e2ZvbnRTaXplOiIxNHB4Iixmb250V2VpZ2h0OjQwMCxsaW5lSGVpZ2h0OiIyOHB4IixtYXJnaW46IjAgOHB4In19O2NsYXNzIGEgZXh0ZW5kcyB1LmRlZmF1bHQuQ29tcG9uZW50e3N0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZSl7cmV0dXJue2Vycm9yOmV9fXN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoZSx0KXtyZXR1cm4gZS5wYXRobmFtZSE9PXQucHJldmlvdXNQYXRobmFtZSYmdC5lcnJvcj97ZXJyb3I6bnVsbCxwcmV2aW91c1BhdGhuYW1lOmUucGF0aG5hbWV9OntlcnJvcjp0LmVycm9yLHByZXZpb3VzUGF0aG5hbWU6ZS5wYXRobmFtZX19cmVuZGVyKCl7cmV0dXJuIHRoaXMuc3RhdGUuZXJyb3I/dS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQodS5kZWZhdWx0LkZyYWdtZW50LG51bGwsdGhpcy5wcm9wcy5lcnJvclN0eWxlcyx1LmRlZmF1bHQuY3JlYXRlRWxlbWVudCh0aGlzLnByb3BzLmVycm9yQ29tcG9uZW50LHtlcnJvcjp0aGlzLnN0YXRlLmVycm9yLHJlc2V0OnRoaXMucmVzZXR9KSk6dGhpcy5wcm9wcy5jaGlsZHJlbn1jb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLnJlc2V0PSgpPT57dGhpcy5zZXRTdGF0ZSh7ZXJyb3I6bnVsbH0pfSx0aGlzLnN0YXRlPXtlcnJvcjpudWxsLHByZXZpb3VzUGF0aG5hbWU6dGhpcy5wcm9wcy5wYXRobmFtZX19fWZ1bmN0aW9uIGkoZSl7bGV0e2Vycm9yOnR9PWUscj1udWxsPT10P3ZvaWQgMDp0LmRpZ2VzdDtyZXR1cm4gdS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoImh0bWwiLHtpZDoiX19uZXh0X2Vycm9yX18ifSx1LmRlZmF1bHQuY3JlYXRlRWxlbWVudCgiaGVhZCIsbnVsbCksdS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoImJvZHkiLG51bGwsdS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoImRpdiIse3N0eWxlOmwuZXJyb3J9LHUuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCJkaXYiLG51bGwsdS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoImgyIix7c3R5bGU6bC50ZXh0fSwiQXBwbGljYXRpb24gZXJyb3I6IGEgIisocj8ic2VydmVyIjoiY2xpZW50IikrIi1zaWRlIGV4Y2VwdGlvbiBoYXMgb2NjdXJyZWQgKHNlZSB0aGUgIisocj8ic2VydmVyIGxvZ3MiOiJicm93c2VyIGNvbnNvbGUiKSsiIGZvciBtb3JlIGluZm9ybWF0aW9uKS4iKSxyP3UuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCJwIix7c3R5bGU6bC50ZXh0fSwiRGlnZXN0OiAiK3IpOm51bGwpKSkpfWZ1bmN0aW9uIGMoZSl7bGV0e2Vycm9yQ29tcG9uZW50OnQsZXJyb3JTdHlsZXM6cixjaGlsZHJlbjpufT1lLGw9KDAsby51c2VQYXRobmFtZSkoKTtyZXR1cm4gdD91LmRlZmF1bHQuY3JlYXRlRWxlbWVudChhLHtwYXRobmFtZTpsLGVycm9yQ29tcG9uZW50OnQsZXJyb3JTdHlsZXM6cn0sbik6dS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQodS5kZWZhdWx0LkZyYWdtZW50LG51bGwsbil9KCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sOTU3MTpmdW5jdGlvbihlLHQpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gdClPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLHtlbnVtZXJhYmxlOiEwLGdldDp0W3JdfSl9KHQse0RZTkFNSUNfRVJST1JfQ09ERTpmdW5jdGlvbigpe3JldHVybiByfSxEeW5hbWljU2VydmVyRXJyb3I6ZnVuY3Rpb24oKXtyZXR1cm4gbn19KTtsZXQgcj0iRFlOQU1JQ19TRVJWRVJfVVNBR0UiO2NsYXNzIG4gZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihlKXtzdXBlcigiRHluYW1pYyBzZXJ2ZXIgdXNhZ2U6ICIrZSksdGhpcy5kaWdlc3Q9cn19KCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sNDg3NDpmdW5jdGlvbihlLHQpeyJ1c2Ugc3RyaWN0IjtsZXQgcjtmdW5jdGlvbiBuKCl7cmV0dXJuIHJ8fChyPW5ldyBQcm9taXNlKCgpPT57fSkpLHJ9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJjcmVhdGVJbmZpbml0ZVByb21pc2UiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBufX0pLCgiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDQ1Nzk6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImlzTmV4dFJvdXRlckVycm9yIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gb319KTtsZXQgbj1yKDMyNTYpLHU9cigzODA4KTtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLmRpZ2VzdCYmKCgwLHUuaXNSZWRpcmVjdEVycm9yKShlKXx8KDAsbi5pc05vdEZvdW5kRXJyb3IpKGUpKX0oImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSwzNDY2OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJkZWZhdWx0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gRX19KTtsZXQgbj1yKDY5MjcpLHU9cig1OTA5KSxvPXUuXyhyKDYwMDYpKSxsPW4uXyhyKDg0MzEpKSxhPXIoMzA5MyksaT1yKDYzNzMpLGM9cig0ODc0KSxzPXIoMTIyMyksZj1yKDk0MCksZD1yKDEyNTgpLHA9cigyMjUpLGg9cig5ODI3KSxfPXIoNTg4MCkseT1yKDk2NDMpLGI9WyJib3R0b20iLCJoZWlnaHQiLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJ3aWR0aCIsIngiLCJ5Il07ZnVuY3Rpb24gdihlLHQpe2xldCByPWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJuIHIudG9wPj0wJiZyLnRvcDw9dH1jbGFzcyBtIGV4dGVuZHMgby5kZWZhdWx0LkNvbXBvbmVudHtjb21wb25lbnREaWRNb3VudCgpe3RoaXMuaGFuZGxlUG90ZW50aWFsU2Nyb2xsKCl9Y29tcG9uZW50RGlkVXBkYXRlKCl7dGhpcy5wcm9wcy5mb2N1c0FuZFNjcm9sbFJlZi5hcHBseSYmdGhpcy5oYW5kbGVQb3RlbnRpYWxTY3JvbGwoKX1yZW5kZXIoKXtyZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbn1jb25zdHJ1Y3RvciguLi5lKXtzdXBlciguLi5lKSx0aGlzLmhhbmRsZVBvdGVudGlhbFNjcm9sbD0oKT0+e2xldHtmb2N1c0FuZFNjcm9sbFJlZjplLHNlZ21lbnRQYXRoOnR9PXRoaXMucHJvcHM7aWYoZS5hcHBseSl7dmFyIHI7aWYoMCE9PWUuc2VnbWVudFBhdGhzLmxlbmd0aCYmIWUuc2VnbWVudFBhdGhzLnNvbWUoZT0+dC5ldmVyeSgodCxyKT0+KDAsZi5tYXRjaFNlZ21lbnQpKHQsZVtyXSkpKSlyZXR1cm47bGV0IG49bnVsbCx1PWUuaGFzaEZyYWdtZW50O2lmKHUmJihuPSJ0b3AiPT09dT9kb2N1bWVudC5ib2R5Om51bGwhPShyPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHUpKT9yOmRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKHUpWzBdKSxufHwobj1sLmRlZmF1bHQuZmluZERPTU5vZGUodGhpcykpLCEobiBpbnN0YW5jZW9mIEVsZW1lbnQpKXJldHVybjtmb3IoOyEobiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KXx8ZnVuY3Rpb24oZSl7bGV0IHQ9ZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm4gYi5ldmVyeShlPT4wPT09dFtlXSl9KG4pOyl7aWYobnVsbD09PW4ubmV4dEVsZW1lbnRTaWJsaW5nKXJldHVybjtuPW4ubmV4dEVsZW1lbnRTaWJsaW5nfWUuYXBwbHk9ITEsZS5oYXNoRnJhZ21lbnQ9bnVsbCxlLnNlZ21lbnRQYXRocz1bXSwoMCxkLmhhbmRsZVNtb290aFNjcm9sbCkoKCk9PntpZih1KXtuLnNjcm9sbEludG9WaWV3KCk7cmV0dXJufWxldCBlPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudCx0PWUuY2xpZW50SGVpZ2h0OyF2KG4sdCkmJihlLnNjcm9sbFRvcD0wLHYobix0KXx8bi5zY3JvbGxJbnRvVmlldygpKX0se2RvbnRGb3JjZUxheW91dDohMH0pLG4uZm9jdXMoKX19fX1mdW5jdGlvbiBnKGUpe2xldHtzZWdtZW50UGF0aDp0LGNoaWxkcmVuOnJ9PWUsbj0oMCxvLnVzZUNvbnRleHQpKGEuR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCk7aWYoIW4pdGhyb3cgRXJyb3IoImludmFyaWFudCBnbG9iYWwgbGF5b3V0IHJvdXRlciBub3QgbW91bnRlZCIpO3JldHVybiBvLmRlZmF1bHQuY3JlYXRlRWxlbWVudChtLHtzZWdtZW50UGF0aDp0LGZvY3VzQW5kU2Nyb2xsUmVmOm4uZm9jdXNBbmRTY3JvbGxSZWZ9LHIpfWZ1bmN0aW9uIE8oZSl7bGV0e3BhcmFsbGVsUm91dGVyS2V5OnQsdXJsOnIsY2hpbGROb2RlczpuLGNoaWxkUHJvcDp1LHNlZ21lbnRQYXRoOmwsdHJlZTpzLGNhY2hlS2V5OmR9PWUscD0oMCxvLnVzZUNvbnRleHQpKGEuR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCk7aWYoIXApdGhyb3cgRXJyb3IoImludmFyaWFudCBnbG9iYWwgbGF5b3V0IHJvdXRlciBub3QgbW91bnRlZCIpO2xldHtidWlsZElkOmgsY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZTpfLHRyZWU6eX09cCxiPW4uZ2V0KGQpO2lmKHUmJm51bGwhPT11LmN1cnJlbnQmJihiP2Iuc3RhdHVzPT09YS5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVEJiYoYi5zdGF0dXM9YS5DYWNoZVN0YXRlcy5SRUFEWSxiLnN1YlRyZWVEYXRhPXUuY3VycmVudCk6KGI9e3N0YXR1czphLkNhY2hlU3RhdGVzLlJFQURZLGRhdGE6bnVsbCxzdWJUcmVlRGF0YTp1LmN1cnJlbnQscGFyYWxsZWxSb3V0ZXM6bmV3IE1hcH0sbi5zZXQoZCxiKSkpLCFifHxiLnN0YXR1cz09PWEuQ2FjaGVTdGF0ZXMuTEFaWV9JTklUSUFMSVpFRCl7bGV0IGU9ZnVuY3Rpb24gZSh0LHIpe2lmKHQpe2xldFtuLHVdPXQsbz0yPT09dC5sZW5ndGg7aWYoKDAsZi5tYXRjaFNlZ21lbnQpKHJbMF0sbikmJnJbMV0uaGFzT3duUHJvcGVydHkodSkpe2lmKG8pe2xldCB0PWUodm9pZCAwLHJbMV1bdV0pO3JldHVybltyWzBdLHsuLi5yWzFdLFt1XTpbdFswXSx0WzFdLHRbMl0sInJlZmV0Y2giXX1dfXJldHVybltyWzBdLHsuLi5yWzFdLFt1XTplKHQuc2xpY2UoMiksclsxXVt1XSl9XX19cmV0dXJuIHJ9KFsiIiwuLi5sXSx5KTtiPXtzdGF0dXM6YS5DYWNoZVN0YXRlcy5EQVRBX0ZFVENILGRhdGE6KDAsaS5mZXRjaFNlcnZlclJlc3BvbnNlKShuZXcgVVJMKHIsbG9jYXRpb24ub3JpZ2luKSxlLHAubmV4dFVybCxoKSxzdWJUcmVlRGF0YTpudWxsLGhlYWQ6YiYmYi5zdGF0dXM9PT1hLkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQ/Yi5oZWFkOnZvaWQgMCxwYXJhbGxlbFJvdXRlczpiJiZiLnN0YXR1cz09PWEuQ2FjaGVTdGF0ZXMuTEFaWV9JTklUSUFMSVpFRD9iLnBhcmFsbGVsUm91dGVzOm5ldyBNYXB9LG4uc2V0KGQsYil9aWYoIWIpdGhyb3cgRXJyb3IoIkNoaWxkIG5vZGUgc2hvdWxkIGFsd2F5cyBleGlzdCIpO2lmKGIuc3ViVHJlZURhdGEmJmIuZGF0YSl0aHJvdyBFcnJvcigiQ2hpbGQgbm9kZSBzaG91bGQgbm90IGhhdmUgYm90aCBzdWJUcmVlRGF0YSBhbmQgZGF0YSIpO2lmKGIuZGF0YSl7bGV0W2UsdF09KDAsby51c2UpKGIuZGF0YSk7Yi5kYXRhPW51bGwsc2V0VGltZW91dCgoKT0+eygwLG8uc3RhcnRUcmFuc2l0aW9uKSgoKT0+e18oeSxlLHQpfSl9KSwoMCxvLnVzZSkoKDAsYy5jcmVhdGVJbmZpbml0ZVByb21pc2UpKCkpfWIuc3ViVHJlZURhdGF8fCgwLG8udXNlKSgoMCxjLmNyZWF0ZUluZmluaXRlUHJvbWlzZSkoKSk7bGV0IHY9by5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoYS5MYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLHt2YWx1ZTp7dHJlZTpzWzFdW3RdLGNoaWxkTm9kZXM6Yi5wYXJhbGxlbFJvdXRlcyx1cmw6cn19LGIuc3ViVHJlZURhdGEpO3JldHVybiB2fWZ1bmN0aW9uIFAoZSl7bGV0e2NoaWxkcmVuOnQsbG9hZGluZzpyLGxvYWRpbmdTdHlsZXM6bixoYXNMb2FkaW5nOnV9PWU7cmV0dXJuIHU/by5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoby5TdXNwZW5zZSx7ZmFsbGJhY2s6by5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoby5kZWZhdWx0LkZyYWdtZW50LG51bGwsbixyKX0sdCk6by5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoby5kZWZhdWx0LkZyYWdtZW50LG51bGwsdCl9ZnVuY3Rpb24gRShlKXtsZXR7cGFyYWxsZWxSb3V0ZXJLZXk6dCxzZWdtZW50UGF0aDpyLGNoaWxkUHJvcDpuLGVycm9yOnUsZXJyb3JTdHlsZXM6bCx0ZW1wbGF0ZVN0eWxlczppLGxvYWRpbmc6Yyxsb2FkaW5nU3R5bGVzOmQsaGFzTG9hZGluZzpiLHRlbXBsYXRlOnYsbm90Rm91bmQ6bSxub3RGb3VuZFN0eWxlczpFLGFzTm90Rm91bmQ6UixzdHlsZXM6an09ZSxTPSgwLG8udXNlQ29udGV4dCkoYS5MYXlvdXRSb3V0ZXJDb250ZXh0KTtpZighUyl0aHJvdyBFcnJvcigiaW52YXJpYW50IGV4cGVjdGVkIGxheW91dCByb3V0ZXIgdG8gYmUgbW91bnRlZCIpO2xldHtjaGlsZE5vZGVzOlQsdHJlZTpNLHVybDp3fT1TLEM9VC5nZXQodCk7Q3x8KEM9bmV3IE1hcCxULnNldCh0LEMpKTtsZXQgeD1NWzFdW3RdWzBdLEE9bi5zZWdtZW50LE49KDAsXy5nZXRTZWdtZW50VmFsdWUpKHgpLEk9W3hdO3JldHVybiBvLmRlZmF1bHQuY3JlYXRlRWxlbWVudChvLmRlZmF1bHQuRnJhZ21lbnQsbnVsbCxqLEkubWFwKGU9PntsZXQgaj0oMCxmLm1hdGNoU2VnbWVudCkoZSxBKSxTPSgwLF8uZ2V0U2VnbWVudFZhbHVlKShlKSxUPSgwLHkuY3JlYXRlUm91dGVyQ2FjaGVLZXkpKGUpO3JldHVybiBvLmRlZmF1bHQuY3JlYXRlRWxlbWVudChhLlRlbXBsYXRlQ29udGV4dC5Qcm92aWRlcix7a2V5OigwLHkuY3JlYXRlUm91dGVyQ2FjaGVLZXkpKGUsITApLHZhbHVlOm8uZGVmYXVsdC5jcmVhdGVFbGVtZW50KGcse3NlZ21lbnRQYXRoOnJ9LG8uZGVmYXVsdC5jcmVhdGVFbGVtZW50KHMuRXJyb3JCb3VuZGFyeSx7ZXJyb3JDb21wb25lbnQ6dSxlcnJvclN0eWxlczpsfSxvLmRlZmF1bHQuY3JlYXRlRWxlbWVudChQLHtoYXNMb2FkaW5nOmIsbG9hZGluZzpjLGxvYWRpbmdTdHlsZXM6ZH0sby5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoaC5Ob3RGb3VuZEJvdW5kYXJ5LHtub3RGb3VuZDptLG5vdEZvdW5kU3R5bGVzOkUsYXNOb3RGb3VuZDpSfSxvLmRlZmF1bHQuY3JlYXRlRWxlbWVudChwLlJlZGlyZWN0Qm91bmRhcnksbnVsbCxvLmRlZmF1bHQuY3JlYXRlRWxlbWVudChPLHtwYXJhbGxlbFJvdXRlcktleTp0LHVybDp3LHRyZWU6TSxjaGlsZE5vZGVzOkMsY2hpbGRQcm9wOmo/bjpudWxsLHNlZ21lbnRQYXRoOnIsY2FjaGVLZXk6VCxpc0FjdGl2ZTpOPT09U30pKSkpKSl9LGksdil9KSl9KCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sOTQwOmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIHQpT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscix7ZW51bWVyYWJsZTohMCxnZXQ6dFtyXX0pfSh0LHttYXRjaFNlZ21lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdX0sY2FuU2VnbWVudEJlT3ZlcnJpZGRlbjpmdW5jdGlvbigpe3JldHVybiBvfX0pO2xldCBuPXIoNDc3OCksdT0oZSx0KT0+InN0cmluZyI9PXR5cGVvZiBlPyJzdHJpbmciPT10eXBlb2YgdCYmZT09PXQ6InN0cmluZyIhPXR5cGVvZiB0JiZlWzBdPT09dFswXSYmZVsxXT09PXRbMV0sbz0oZSx0KT0+e3ZhciByO3JldHVybiFBcnJheS5pc0FycmF5KGUpJiYhIUFycmF5LmlzQXJyYXkodCkmJihudWxsPT0ocj0oMCxuLmdldFNlZ21lbnRQYXJhbSkoZSkpP3ZvaWQgMDpyLnBhcmFtKT09PXRbMF19OygiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDgxNzA6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gdClPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLHtlbnVtZXJhYmxlOiEwLGdldDp0W3JdfSl9KHQse1JlYWRvbmx5VVJMU2VhcmNoUGFyYW1zOmZ1bmN0aW9uKCl7cmV0dXJuIHB9LHVzZVNlYXJjaFBhcmFtczpmdW5jdGlvbigpe3JldHVybiBofSx1c2VQYXRobmFtZTpmdW5jdGlvbigpe3JldHVybiBffSxTZXJ2ZXJJbnNlcnRlZEhUTUxDb250ZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIGkuU2VydmVySW5zZXJ0ZWRIVE1MQ29udGV4dH0sdXNlU2VydmVySW5zZXJ0ZWRIVE1MOmZ1bmN0aW9uKCl7cmV0dXJuIGkudXNlU2VydmVySW5zZXJ0ZWRIVE1MfSx1c2VSb3V0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4geX0sdXNlUGFyYW1zOmZ1bmN0aW9uKCl7cmV0dXJuIGJ9LHVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudHM6ZnVuY3Rpb24oKXtyZXR1cm4gdn0sdXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIG19LHJlZGlyZWN0OmZ1bmN0aW9uKCl7cmV0dXJuIGMucmVkaXJlY3R9LG5vdEZvdW5kOmZ1bmN0aW9uKCl7cmV0dXJuIHMubm90Rm91bmR9fSk7bGV0IG49cig2MDA2KSx1PXIoMzA5Myksbz1yKDgzNDUpLGw9cig0Nzk0KSxhPXIoNTg4MCksaT1yKDc0MDMpLGM9cigzODA4KSxzPXIoMzI1NiksZj1TeW1ib2woImludGVybmFsIGZvciB1cmxzZWFyY2hwYXJhbXMgcmVhZG9ubHkiKTtmdW5jdGlvbiBkKCl7cmV0dXJuIEVycm9yKCJSZWFkb25seVVSTFNlYXJjaFBhcmFtcyBjYW5ub3QgYmUgbW9kaWZpZWQiKX1jbGFzcyBwe1tTeW1ib2wuaXRlcmF0b3JdKCl7cmV0dXJuIHRoaXNbZl1bU3ltYm9sLml0ZXJhdG9yXSgpfWFwcGVuZCgpe3Rocm93IGQoKX1kZWxldGUoKXt0aHJvdyBkKCl9c2V0KCl7dGhyb3cgZCgpfXNvcnQoKXt0aHJvdyBkKCl9Y29uc3RydWN0b3IoZSl7dGhpc1tmXT1lLHRoaXMuZW50cmllcz1lLmVudHJpZXMuYmluZChlKSx0aGlzLmZvckVhY2g9ZS5mb3JFYWNoLmJpbmQoZSksdGhpcy5nZXQ9ZS5nZXQuYmluZChlKSx0aGlzLmdldEFsbD1lLmdldEFsbC5iaW5kKGUpLHRoaXMuaGFzPWUuaGFzLmJpbmQoZSksdGhpcy5rZXlzPWUua2V5cy5iaW5kKGUpLHRoaXMudmFsdWVzPWUudmFsdWVzLmJpbmQoZSksdGhpcy50b1N0cmluZz1lLnRvU3RyaW5nLmJpbmQoZSl9fWZ1bmN0aW9uIGgoKXsoMCxsLmNsaWVudEhvb2tJblNlcnZlckNvbXBvbmVudEVycm9yKSgidXNlU2VhcmNoUGFyYW1zIik7bGV0IGU9KDAsbi51c2VDb250ZXh0KShvLlNlYXJjaFBhcmFtc0NvbnRleHQpLHQ9KDAsbi51c2VNZW1vKSgoKT0+ZT9uZXcgcChlKTpudWxsLFtlXSk7cmV0dXJuIHR9ZnVuY3Rpb24gXygpe3JldHVybigwLGwuY2xpZW50SG9va0luU2VydmVyQ29tcG9uZW50RXJyb3IpKCJ1c2VQYXRobmFtZSIpLCgwLG4udXNlQ29udGV4dCkoby5QYXRobmFtZUNvbnRleHQpfWZ1bmN0aW9uIHkoKXsoMCxsLmNsaWVudEhvb2tJblNlcnZlckNvbXBvbmVudEVycm9yKSgidXNlUm91dGVyIik7bGV0IGU9KDAsbi51c2VDb250ZXh0KSh1LkFwcFJvdXRlckNvbnRleHQpO2lmKG51bGw9PT1lKXRocm93IEVycm9yKCJpbnZhcmlhbnQgZXhwZWN0ZWQgYXBwIHJvdXRlciB0byBiZSBtb3VudGVkIik7cmV0dXJuIGV9ZnVuY3Rpb24gYigpeygwLGwuY2xpZW50SG9va0luU2VydmVyQ29tcG9uZW50RXJyb3IpKCJ1c2VQYXJhbXMiKTtsZXQgZT0oMCxuLnVzZUNvbnRleHQpKHUuR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCk7cmV0dXJuIGU/ZnVuY3Rpb24gZSh0LHIpe3ZvaWQgMD09PXImJihyPXt9KTtsZXQgbj10WzFdO2ZvcihsZXQgdCBvZiBPYmplY3QudmFsdWVzKG4pKXtsZXQgbj10WzBdLHU9QXJyYXkuaXNBcnJheShuKSxvPXU/blsxXTpuO2lmKCFvfHxvLnN0YXJ0c1dpdGgoIl9fUEFHRV9fIikpY29udGludWU7bGV0IGw9dSYmKCJjIj09PW5bMl18fCJvYyI9PT1uWzJdKTtsP3JbblswXV09blsxXS5zcGxpdCgiLyIpOnUmJihyW25bMF1dPW5bMV0pLHI9ZSh0LHIpfXJldHVybiByfShlLnRyZWUpOm51bGx9ZnVuY3Rpb24gdihlKXt2b2lkIDA9PT1lJiYoZT0iY2hpbGRyZW4iKSwoMCxsLmNsaWVudEhvb2tJblNlcnZlckNvbXBvbmVudEVycm9yKSgidXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50cyIpO2xldHt0cmVlOnR9PSgwLG4udXNlQ29udGV4dCkodS5MYXlvdXRSb3V0ZXJDb250ZXh0KTtyZXR1cm4gZnVuY3Rpb24gZSh0LHIsbix1KXtsZXQgbztpZih2b2lkIDA9PT1uJiYobj0hMCksdm9pZCAwPT09dSYmKHU9W10pLG4pbz10WzFdW3JdO2Vsc2V7dmFyIGw7bGV0IGU9dFsxXTtvPW51bGwhPShsPWUuY2hpbGRyZW4pP2w6T2JqZWN0LnZhbHVlcyhlKVswXX1pZighbylyZXR1cm4gdTtsZXQgaT1vWzBdLGM9KDAsYS5nZXRTZWdtZW50VmFsdWUpKGkpO3JldHVybiFjfHxjLnN0YXJ0c1dpdGgoIl9fUEFHRV9fIik/dToodS5wdXNoKGMpLGUobyxyLCExLHUpKX0odCxlKX1mdW5jdGlvbiBtKGUpe3ZvaWQgMD09PWUmJihlPSJjaGlsZHJlbiIpLCgwLGwuY2xpZW50SG9va0luU2VydmVyQ29tcG9uZW50RXJyb3IpKCJ1c2VTZWxlY3RlZExheW91dFNlZ21lbnQiKTtsZXQgdD12KGUpO3JldHVybiAwPT09dC5sZW5ndGg/bnVsbDp0WzBdfSgiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDk4Mjc6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIk5vdEZvdW5kQm91bmRhcnkiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBhfX0pO2xldCBuPXIoNjkyNyksdT1uLl8ocig2MDA2KSksbz1yKDgxNzApO2NsYXNzIGwgZXh0ZW5kcyB1LmRlZmF1bHQuQ29tcG9uZW50e3N0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZSl7aWYoKG51bGw9PWU/dm9pZCAwOmUuZGlnZXN0KT09PSJORVhUX05PVF9GT1VORCIpcmV0dXJue25vdEZvdW5kVHJpZ2dlcmVkOiEwfTt0aHJvdyBlfXN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoZSx0KXtyZXR1cm4gZS5wYXRobmFtZSE9PXQucHJldmlvdXNQYXRobmFtZSYmdC5ub3RGb3VuZFRyaWdnZXJlZD97bm90Rm91bmRUcmlnZ2VyZWQ6ITEscHJldmlvdXNQYXRobmFtZTplLnBhdGhuYW1lfTp7bm90Rm91bmRUcmlnZ2VyZWQ6dC5ub3RGb3VuZFRyaWdnZXJlZCxwcmV2aW91c1BhdGhuYW1lOmUucGF0aG5hbWV9fXJlbmRlcigpe3JldHVybiB0aGlzLnN0YXRlLm5vdEZvdW5kVHJpZ2dlcmVkP3UuZGVmYXVsdC5jcmVhdGVFbGVtZW50KHUuZGVmYXVsdC5GcmFnbWVudCxudWxsLHUuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCJtZXRhIix7bmFtZToicm9ib3RzIixjb250ZW50OiJub2luZGV4In0pLHRoaXMucHJvcHMubm90Rm91bmRTdHlsZXMsdGhpcy5wcm9wcy5ub3RGb3VuZCk6dGhpcy5wcm9wcy5jaGlsZHJlbn1jb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLnN0YXRlPXtub3RGb3VuZFRyaWdnZXJlZDohIWUuYXNOb3RGb3VuZCxwcmV2aW91c1BhdGhuYW1lOmUucGF0aG5hbWV9fX1mdW5jdGlvbiBhKGUpe2xldHtub3RGb3VuZDp0LG5vdEZvdW5kU3R5bGVzOnIsYXNOb3RGb3VuZDpuLGNoaWxkcmVuOmF9PWUsaT0oMCxvLnVzZVBhdGhuYW1lKSgpO3JldHVybiB0P3UuZGVmYXVsdC5jcmVhdGVFbGVtZW50KGwse3BhdGhuYW1lOmksbm90Rm91bmQ6dCxub3RGb3VuZFN0eWxlczpyLGFzTm90Rm91bmQ6bn0sYSk6dS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQodS5kZWZhdWx0LkZyYWdtZW50LG51bGwsYSl9KCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sMzI1NjpmdW5jdGlvbihlLHQpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gdClPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLHtlbnVtZXJhYmxlOiEwLGdldDp0W3JdfSl9KHQse25vdEZvdW5kOmZ1bmN0aW9uKCl7cmV0dXJuIG59LGlzTm90Rm91bmRFcnJvcjpmdW5jdGlvbigpe3JldHVybiB1fX0pO2xldCByPSJORVhUX05PVF9GT1VORCI7ZnVuY3Rpb24gbigpe2xldCBlPUVycm9yKHIpO3Rocm93IGUuZGlnZXN0PXIsZX1mdW5jdGlvbiB1KGUpe3JldHVybihudWxsPT1lP3ZvaWQgMDplLmRpZ2VzdCk9PT1yfSgiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDIyNTpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ITAsZ2V0OnRbcl19KX0odCx7UmVkaXJlY3RFcnJvckJvdW5kYXJ5OmZ1bmN0aW9uKCl7cmV0dXJuIGl9LFJlZGlyZWN0Qm91bmRhcnk6ZnVuY3Rpb24oKXtyZXR1cm4gY319KTtsZXQgbj1yKDU5MDkpLHU9bi5fKHIoNjAwNikpLG89cig4MTcwKSxsPXIoMzgwOCk7ZnVuY3Rpb24gYShlKXtsZXR7cmVkaXJlY3Q6dCxyZXNldDpyLHJlZGlyZWN0VHlwZTpufT1lLGE9KDAsby51c2VSb3V0ZXIpKCk7cmV0dXJuKDAsdS51c2VFZmZlY3QpKCgpPT57dS5kZWZhdWx0LnN0YXJ0VHJhbnNpdGlvbigoKT0+e249PT1sLlJlZGlyZWN0VHlwZS5wdXNoP2EucHVzaCh0LHt9KTphLnJlcGxhY2UodCx7fSkscigpfSl9LFt0LG4scixhXSksbnVsbH1jbGFzcyBpIGV4dGVuZHMgdS5kZWZhdWx0LkNvbXBvbmVudHtzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGUpe2lmKCgwLGwuaXNSZWRpcmVjdEVycm9yKShlKSl7bGV0IHQ9KDAsbC5nZXRVUkxGcm9tUmVkaXJlY3RFcnJvcikoZSkscj0oMCxsLmdldFJlZGlyZWN0VHlwZUZyb21FcnJvcikoZSk7cmV0dXJue3JlZGlyZWN0OnQscmVkaXJlY3RUeXBlOnJ9fXRocm93IGV9cmVuZGVyKCl7bGV0e3JlZGlyZWN0OmUscmVkaXJlY3RUeXBlOnR9PXRoaXMuc3RhdGU7cmV0dXJuIG51bGwhPT1lJiZudWxsIT09dD91LmRlZmF1bHQuY3JlYXRlRWxlbWVudChhLHtyZWRpcmVjdDplLHJlZGlyZWN0VHlwZTp0LHJlc2V0OigpPT50aGlzLnNldFN0YXRlKHtyZWRpcmVjdDpudWxsfSl9KTp0aGlzLnByb3BzLmNoaWxkcmVufWNvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLHRoaXMuc3RhdGU9e3JlZGlyZWN0Om51bGwscmVkaXJlY3RUeXBlOm51bGx9fX1mdW5jdGlvbiBjKGUpe2xldHtjaGlsZHJlbjp0fT1lLHI9KDAsby51c2VSb3V0ZXIpKCk7cmV0dXJuIHUuZGVmYXVsdC5jcmVhdGVFbGVtZW50KGkse3JvdXRlcjpyfSx0KX0oImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSwzODA4OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7dmFyIG4sdTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gdClPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLHtlbnVtZXJhYmxlOiEwLGdldDp0W3JdfSl9KHQse1JlZGlyZWN0VHlwZTpmdW5jdGlvbigpe3JldHVybiBufSxnZXRSZWRpcmVjdEVycm9yOmZ1bmN0aW9uKCl7cmV0dXJuIGF9LHJlZGlyZWN0OmZ1bmN0aW9uKCl7cmV0dXJuIGl9LGlzUmVkaXJlY3RFcnJvcjpmdW5jdGlvbigpe3JldHVybiBjfSxnZXRVUkxGcm9tUmVkaXJlY3RFcnJvcjpmdW5jdGlvbigpe3JldHVybiBzfSxnZXRSZWRpcmVjdFR5cGVGcm9tRXJyb3I6ZnVuY3Rpb24oKXtyZXR1cm4gZn19KTtsZXQgbz1yKDM0NzQpLGw9Ik5FWFRfUkVESVJFQ1QiO2Z1bmN0aW9uIGEoZSx0KXtsZXQgcj1FcnJvcihsKTtyLmRpZ2VzdD1sKyI7Iit0KyI7IitlO2xldCBuPW8ucmVxdWVzdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpO3JldHVybiBuJiYoci5tdXRhYmxlQ29va2llcz1uLm11dGFibGVDb29raWVzKSxyfWZ1bmN0aW9uIGkoZSx0KXt0aHJvdyB2b2lkIDA9PT10JiYodD0icmVwbGFjZSIpLGEoZSx0KX1mdW5jdGlvbiBjKGUpe2lmKCJzdHJpbmciIT10eXBlb2YobnVsbD09ZT92b2lkIDA6ZS5kaWdlc3QpKXJldHVybiExO2xldFt0LHIsbl09ZS5kaWdlc3Quc3BsaXQoIjsiLDMpO3JldHVybiB0PT09bCYmKCJyZXBsYWNlIj09PXJ8fCJwdXNoIj09PXIpJiYic3RyaW5nIj09dHlwZW9mIG59ZnVuY3Rpb24gcyhlKXtyZXR1cm4gYyhlKT9lLmRpZ2VzdC5zcGxpdCgiOyIsMylbMl06bnVsbH1mdW5jdGlvbiBmKGUpe2lmKCFjKGUpKXRocm93IEVycm9yKCJOb3QgYSByZWRpcmVjdCBlcnJvciIpO3JldHVybiBlLmRpZ2VzdC5zcGxpdCgiOyIsMylbMV19KHU9bnx8KG49e30pKS5wdXNoPSJwdXNoIix1LnJlcGxhY2U9InJlcGxhY2UiLCgiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDM3MjpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiZGVmYXVsdCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGx9fSk7bGV0IG49cig1OTA5KSx1PW4uXyhyKDYwMDYpKSxvPXIoMzA5Myk7ZnVuY3Rpb24gbCgpe2xldCBlPSgwLHUudXNlQ29udGV4dCkoby5UZW1wbGF0ZUNvbnRleHQpO3JldHVybiB1LmRlZmF1bHQuY3JlYXRlRWxlbWVudCh1LmRlZmF1bHQuRnJhZ21lbnQsbnVsbCxlKX0oImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSw0OTEwOmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJhcHBseUZsaWdodERhdGEiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBsfX0pO2xldCBuPXIoMzA5MyksdT1yKDIzNTApLG89cigyMDk1KTtmdW5jdGlvbiBsKGUsdCxyLGwpe3ZvaWQgMD09PWwmJihsPSExKTtsZXRbYSxpLGNdPXIuc2xpY2UoLTMpO3JldHVybiBudWxsIT09aSYmKDM9PT1yLmxlbmd0aD8odC5zdGF0dXM9bi5DYWNoZVN0YXRlcy5SRUFEWSx0LnN1YlRyZWVEYXRhPWksKDAsdS5maWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCkodCxlLGEsYyxsKSk6KHQuc3RhdHVzPW4uQ2FjaGVTdGF0ZXMuUkVBRFksdC5zdWJUcmVlRGF0YT1lLnN1YlRyZWVEYXRhLHQucGFyYWxsZWxSb3V0ZXM9bmV3IE1hcChlLnBhcmFsbGVsUm91dGVzKSwoMCxvLmZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YSkodCxlLHIsbCkpLCEwKX0oImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSw2MjIzOmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbiBlKHQscixvKXtsZXQgbDtsZXRbYSxpLCwsY109cjtpZigxPT09dC5sZW5ndGgpe2xldCBlPXUocixvKTtyZXR1cm4gZX1sZXRbcyxmXT10O2lmKCEoMCxuLm1hdGNoU2VnbWVudCkocyxhKSlyZXR1cm4gbnVsbDtsZXQgZD0yPT09dC5sZW5ndGg7aWYoZClsPXUoaVtmXSxvKTtlbHNlIGlmKG51bGw9PT0obD1lKHQuc2xpY2UoMiksaVtmXSxvKSkpcmV0dXJuIG51bGw7bGV0IHA9W3RbMF0sey4uLmksW2ZdOmx9XTtyZXR1cm4gYyYmKHBbNF09ITApLHB9fX0pO2xldCBuPXIoOTQwKTtmdW5jdGlvbiB1KGUsdCl7bGV0W3Isb109ZSxbbCxhXT10O2lmKCJfX0RFRkFVTFRfXyI9PT1sJiYiX19ERUZBVUxUX18iIT09cilyZXR1cm4gZTtpZigoMCxuLm1hdGNoU2VnbWVudCkocixsKSl7bGV0IHQ9e307Zm9yKGxldCBlIGluIG8pe2xldCByPXZvaWQgMCE9PWFbZV07cj90W2VdPXUob1tlXSxhW2VdKTp0W2VdPW9bZV19Zm9yKGxldCBlIGluIGEpdFtlXXx8KHRbZV09YVtlXSk7bGV0IG49W3IsdF07cmV0dXJuIGVbMl0mJihuWzJdPWVbMl0pLGVbM10mJihuWzNdPWVbM10pLGVbNF0mJihuWzRdPWVbNF0pLG59cmV0dXJuIHR9KCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sMzAxODpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ITAsZ2V0OnRbcl19KX0odCx7ZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gYX0sY29tcHV0ZUNoYW5nZWRQYXRoOmZ1bmN0aW9uKCl7cmV0dXJuIGl9fSk7bGV0IG49cig3Mzk5KSx1PXIoOTQwKSxvPWU9PiJzdHJpbmciPT10eXBlb2YgZT9lOmVbMV07ZnVuY3Rpb24gbChlKXtyZXR1cm4gZS5zcGxpdCgiLyIpLnJlZHVjZSgoZSx0KT0+IiI9PT10fHx0LnN0YXJ0c1dpdGgoIigiKSYmdC5lbmRzV2l0aCgiKSIpP2U6ZSsiLyIrdCwiIil8fCIvIn1mdW5jdGlvbiBhKGUpe3ZhciB0O2xldCByPUFycmF5LmlzQXJyYXkoZVswXSk/ZVswXVsxXTplWzBdO2lmKCJfX0RFRkFVTFRfXyI9PT1yfHxuLklOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTLnNvbWUoZT0+ci5zdGFydHNXaXRoKGUpKSlyZXR1cm47aWYoci5zdGFydHNXaXRoKCJfX1BBR0VfXyIpKXJldHVybiIiO2xldCB1PVtyXSxvPW51bGwhPSh0PWVbMV0pP3Q6e30saT1vLmNoaWxkcmVuP2Eoby5jaGlsZHJlbik6dm9pZCAwO2lmKHZvaWQgMCE9PWkpdS5wdXNoKGkpO2Vsc2UgZm9yKGxldFtlLHRdb2YgT2JqZWN0LmVudHJpZXMobykpe2lmKCJjaGlsZHJlbiI9PT1lKWNvbnRpbnVlO2xldCByPWEodCk7dm9pZCAwIT09ciYmdS5wdXNoKHIpfXJldHVybiBsKHUuam9pbigiLyIpKX1mdW5jdGlvbiBpKGUsdCl7bGV0IHI9ZnVuY3Rpb24gZSh0LHIpe2xldFtsLGldPXQsW2Msc109cixmPW8obCksZD1vKGMpO2lmKG4uSU5URVJDRVBUSU9OX1JPVVRFX01BUktFUlMuc29tZShlPT5mLnN0YXJ0c1dpdGgoZSl8fGQuc3RhcnRzV2l0aChlKSkpcmV0dXJuIiI7aWYoISgwLHUubWF0Y2hTZWdtZW50KShsLGMpKXt2YXIgcDtyZXR1cm4gbnVsbCE9KHA9YShyKSk/cDoiIn1mb3IobGV0IHQgaW4gaSlpZihzW3RdKXtsZXQgcj1lKGlbdF0sc1t0XSk7aWYobnVsbCE9PXIpcmV0dXJuIG8oYykrIi8iK3J9cmV0dXJuIG51bGx9KGUsdCk7cmV0dXJuIG51bGw9PXJ8fCIvIj09PXI/cjpsKHIpfSgiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDIyNzg6ZnVuY3Rpb24oZSx0KXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcihlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0hMCksZS5wYXRobmFtZStlLnNlYXJjaCsodD9lLmhhc2g6IiIpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiY3JlYXRlSHJlZkZyb21VcmwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiByfX0pLCgiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDYwNDpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiY3JlYXRlSW5pdGlhbFJvdXRlclN0YXRlIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYX19KTtsZXQgbj1yKDMwOTMpLHU9cigyMjc4KSxvPXIoMjM1MCksbD1yKDMwMTgpO2Z1bmN0aW9uIGEoZSl7dmFyIHQ7bGV0e2J1aWxkSWQ6cixpbml0aWFsVHJlZTphLGNoaWxkcmVuOmksaW5pdGlhbENhbm9uaWNhbFVybDpjLGluaXRpYWxQYXJhbGxlbFJvdXRlczpzLGlzU2VydmVyOmYsbG9jYXRpb246ZCxpbml0aWFsSGVhZDpwfT1lLGg9e3N0YXR1czpuLkNhY2hlU3RhdGVzLlJFQURZLGRhdGE6bnVsbCxzdWJUcmVlRGF0YTppLHBhcmFsbGVsUm91dGVzOmY/bmV3IE1hcDpzfTtyZXR1cm4obnVsbD09PXN8fDA9PT1zLnNpemUpJiYoMCxvLmZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKShoLHZvaWQgMCxhLHApLHtidWlsZElkOnIsdHJlZTphLGNhY2hlOmgscHJlZmV0Y2hDYWNoZTpuZXcgTWFwLHB1c2hSZWY6e3BlbmRpbmdQdXNoOiExLG1wYU5hdmlnYXRpb246ITF9LGZvY3VzQW5kU2Nyb2xsUmVmOnthcHBseTohMSxoYXNoRnJhZ21lbnQ6bnVsbCxzZWdtZW50UGF0aHM6W119LGNhbm9uaWNhbFVybDpkPygwLHUuY3JlYXRlSHJlZkZyb21VcmwpKGQpOmMsbmV4dFVybDpudWxsIT0odD0oMCxsLmV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlKShhKXx8KG51bGw9PWQ/dm9pZCAwOmQucGF0aG5hbWUpKT90Om51bGx9fSgiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDkyMDpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiY3JlYXRlT3B0aW1pc3RpY1RyZWUiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbiBlKHQscix1KXtsZXQgbztsZXRbbCxhLGksYyxzXT1yfHxbbnVsbCx7fV0sZj10WzBdLGQ9MT09PXQubGVuZ3RoLHA9bnVsbCE9PWwmJigwLG4ubWF0Y2hTZWdtZW50KShsLGYpLGg9T2JqZWN0LmtleXMoYSkubGVuZ3RoPjEsXz0hcnx8IXB8fGgseT17fTtpZihudWxsIT09bCYmcCYmKHk9YSksIWQmJiFoKXtsZXQgcj1lKHQuc2xpY2UoMSkseT95LmNoaWxkcmVuOm51bGwsdXx8Xyk7bz1yfWxldCBiPVtmLHsuLi55LC4uLm8/e2NoaWxkcmVuOm99Ont9fV07cmV0dXJuIGkmJihiWzJdPWkpLCF1JiZfP2JbM109InJlZmV0Y2giOnAmJmMmJihiWzNdPWMpLHAmJnMmJihiWzRdPXMpLGJ9fX0pO2xldCBuPXIoOTQwKTsoImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSw3NDpmdW5jdGlvbihlLHQpeyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiByKGUpe3JldHVybiBlLnN0YXR1cz0icGVuZGluZyIsZS50aGVuKHQ9PnsicGVuZGluZyI9PT1lLnN0YXR1cyYmKGUuc3RhdHVzPSJmdWxmaWxsZWQiLGUudmFsdWU9dCl9LHQ9PnsicGVuZGluZyI9PT1lLnN0YXR1cyYmKGUuc3RhdHVzPSJyZWplY3RlZCIsZS52YWx1ZT10KX0pLGV9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJjcmVhdGVSZWNvcmRGcm9tVGhlbmFibGUiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiByfX0pLCgiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDk2NDM6ZnVuY3Rpb24oZSx0KXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcihlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0hMSksQXJyYXkuaXNBcnJheShlKT9lWzBdKyJ8IitlWzFdKyJ8IitlWzJdOnQmJmUuc3RhcnRzV2l0aCgiX19QQUdFX18iKT8iX19QQUdFX18iOmV9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJjcmVhdGVSb3V0ZXJDYWNoZUtleSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHJ9fSksKCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sNjM3MzpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHN9fSk7bGV0IG49cig1NDU2KSx1PXIoOTQzOCksbz1yKDgwOTUpLGw9cig1NjAwKSxhPXIoODc0KSxpPXIoODYzNCk7ZnVuY3Rpb24gYyhlKXtyZXR1cm5bKDAsby51cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIpKGUpLnRvU3RyaW5nKCksdm9pZCAwXX1hc3luYyBmdW5jdGlvbiBzKGUsdCxyLHMsZil7bGV0IGQ9e1t1LlJTQ106IjEiLFt1Lk5FWFRfUk9VVEVSX1NUQVRFX1RSRUVdOmVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeSh0KSl9O2Y9PT1hLlByZWZldGNoS2luZC5BVVRPJiYoZFt1Lk5FWFRfUk9VVEVSX1BSRUZFVENIXT0iMSIpLHImJihkW3UuTkVYVF9VUkxdPXIpO2xldCBwPSgwLGkuaGV4SGFzaCkoW2RbdS5ORVhUX1JPVVRFUl9QUkVGRVRDSF18fCIwIixkW3UuTkVYVF9ST1VURVJfU1RBVEVfVFJFRV1dLmpvaW4oIiwiKSk7dHJ5e2xldCB0PW5ldyBVUkwoZSk7dC5wYXRobmFtZS5lbmRzV2l0aCgiLyIpP3QucGF0aG5hbWUrPSJpbmRleC50eHQiOnQucGF0aG5hbWUrPSIudHh0Iix0LnNlYXJjaFBhcmFtcy5zZXQodS5ORVhUX1JTQ19VTklPTl9RVUVSWSxwKTtsZXQgcj1hd2FpdCBmZXRjaCh0LHtjcmVkZW50aWFsczoic2FtZS1vcmlnaW4iLGhlYWRlcnM6ZH0pLGE9KDAsby51cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIpKHIudXJsKSxpPXIucmVkaXJlY3RlZD9hOnZvaWQgMCxmPXIuaGVhZGVycy5nZXQoImNvbnRlbnQtdHlwZSIpfHwiIixoPWY9PT11LlJTQ19DT05URU5UX1RZUEVfSEVBREVSO2lmKGh8fChoPWYuc3RhcnRzV2l0aCgidGV4dC9wbGFpbiIpKSwhaHx8IXIub2spcmV0dXJuIGMoYS50b1N0cmluZygpKTtsZXRbXyx5XT1hd2FpdCAoMCxuLmNyZWF0ZUZyb21GZXRjaCkoUHJvbWlzZS5yZXNvbHZlKHIpLHtjYWxsU2VydmVyOmwuY2FsbFNlcnZlcn0pO2lmKHMhPT1fKXJldHVybiBjKHIudXJsKTtyZXR1cm5beSxpXX1jYXRjaCh0KXtyZXR1cm4gY29uc29sZS5lcnJvcigiRmFpbGVkIHRvIGZldGNoIFJTQyBwYXlsb2FkLiBGYWxsaW5nIGJhY2sgdG8gYnJvd3NlciBuYXZpZ2F0aW9uLiIsdCksW2UudG9TdHJpbmcoKSx2b2lkIDBdfX0oImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSwyMzM3OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJmaWxsQ2FjaGVXaXRoRGF0YVByb3BlcnR5Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24gZSh0LHIsbyxsLGEpe3ZvaWQgMD09PWEmJihhPSExKTtsZXQgaT1vLmxlbmd0aDw9MixbYyxzXT1vLGY9KDAsdS5jcmVhdGVSb3V0ZXJDYWNoZUtleSkocyksZD1yLnBhcmFsbGVsUm91dGVzLmdldChjKTtpZighZHx8YSYmci5wYXJhbGxlbFJvdXRlcy5zaXplPjEpcmV0dXJue2JhaWxPcHRpbWlzdGljOiEwfTtsZXQgcD10LnBhcmFsbGVsUm91dGVzLmdldChjKTtwJiZwIT09ZHx8KHA9bmV3IE1hcChkKSx0LnBhcmFsbGVsUm91dGVzLnNldChjLHApKTtsZXQgaD1kLmdldChmKSxfPXAuZ2V0KGYpO2lmKGkpe18mJl8uZGF0YSYmXyE9PWh8fHAuc2V0KGYse3N0YXR1czpuLkNhY2hlU3RhdGVzLkRBVEFfRkVUQ0gsZGF0YTpsKCksc3ViVHJlZURhdGE6bnVsbCxwYXJhbGxlbFJvdXRlczpuZXcgTWFwfSk7cmV0dXJufWlmKCFffHwhaCl7X3x8cC5zZXQoZix7c3RhdHVzOm4uQ2FjaGVTdGF0ZXMuREFUQV9GRVRDSCxkYXRhOmwoKSxzdWJUcmVlRGF0YTpudWxsLHBhcmFsbGVsUm91dGVzOm5ldyBNYXB9KTtyZXR1cm59cmV0dXJuIF89PT1oJiYoXz17c3RhdHVzOl8uc3RhdHVzLGRhdGE6Xy5kYXRhLHN1YlRyZWVEYXRhOl8uc3ViVHJlZURhdGEscGFyYWxsZWxSb3V0ZXM6bmV3IE1hcChfLnBhcmFsbGVsUm91dGVzKX0scC5zZXQoZixfKSksZShfLGgsby5zbGljZSgyKSxsKX19fSk7bGV0IG49cigzMDkzKSx1PXIoOTY0Myk7KCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sMjA5NTpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24gZSh0LHIsYSxpKXtsZXQgYz1hLmxlbmd0aDw9NSxbcyxmXT1hLGQ9KDAsbC5jcmVhdGVSb3V0ZXJDYWNoZUtleSkoZikscD1yLnBhcmFsbGVsUm91dGVzLmdldChzKTtpZighcClyZXR1cm47bGV0IGg9dC5wYXJhbGxlbFJvdXRlcy5nZXQocyk7aCYmaCE9PXB8fChoPW5ldyBNYXAocCksdC5wYXJhbGxlbFJvdXRlcy5zZXQocyxoKSk7bGV0IF89cC5nZXQoZCkseT1oLmdldChkKTtpZihjKXt5JiZ5LmRhdGEmJnkhPT1ffHwoeT17c3RhdHVzOm4uQ2FjaGVTdGF0ZXMuUkVBRFksZGF0YTpudWxsLHN1YlRyZWVEYXRhOmFbM10scGFyYWxsZWxSb3V0ZXM6Xz9uZXcgTWFwKF8ucGFyYWxsZWxSb3V0ZXMpOm5ldyBNYXB9LF8mJigwLHUuaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZSkoeSxfLGFbMl0pLCgwLG8uZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQpKHksXyxhWzJdLGFbNF0saSksaC5zZXQoZCx5KSk7cmV0dXJufXkmJl8mJih5PT09XyYmKHk9e3N0YXR1czp5LnN0YXR1cyxkYXRhOnkuZGF0YSxzdWJUcmVlRGF0YTp5LnN1YlRyZWVEYXRhLHBhcmFsbGVsUm91dGVzOm5ldyBNYXAoeS5wYXJhbGxlbFJvdXRlcyl9LGguc2V0KGQseSkpLGUoeSxfLGEuc2xpY2UoMiksaSkpfX19KTtsZXQgbj1yKDMwOTMpLHU9cig1Nzg3KSxvPXIoMjM1MCksbD1yKDk2NDMpOygiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDIzNTA6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24gZSh0LHIsbyxsLGEpe2xldCBpPTA9PT1PYmplY3Qua2V5cyhvWzFdKS5sZW5ndGg7aWYoaSl7dC5oZWFkPWw7cmV0dXJufWZvcihsZXQgaSBpbiBvWzFdKXtsZXQgYz1vWzFdW2ldLHM9Y1swXSxmPSgwLHUuY3JlYXRlUm91dGVyQ2FjaGVLZXkpKHMpO2lmKHIpe2xldCB1PXIucGFyYWxsZWxSb3V0ZXMuZ2V0KGkpO2lmKHUpe2xldCByPW5ldyBNYXAodSksbz1yLmdldChmKSxzPWEmJm8/e3N0YXR1czpvLnN0YXR1cyxkYXRhOm8uZGF0YSxzdWJUcmVlRGF0YTpvLnN1YlRyZWVEYXRhLHBhcmFsbGVsUm91dGVzOm5ldyBNYXAoby5wYXJhbGxlbFJvdXRlcyl9OntzdGF0dXM6bi5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVELGRhdGE6bnVsbCxzdWJUcmVlRGF0YTpudWxsLHBhcmFsbGVsUm91dGVzOm5ldyBNYXAobnVsbD09bz92b2lkIDA6by5wYXJhbGxlbFJvdXRlcyl9O3Iuc2V0KGYscyksZShzLG8sYyxsLGEpLHQucGFyYWxsZWxSb3V0ZXMuc2V0KGkscik7Y29udGludWV9fWxldCBkPXtzdGF0dXM6bi5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVELGRhdGE6bnVsbCxzdWJUcmVlRGF0YTpudWxsLHBhcmFsbGVsUm91dGVzOm5ldyBNYXB9LHA9dC5wYXJhbGxlbFJvdXRlcy5nZXQoaSk7cD9wLnNldChmLGQpOnQucGFyYWxsZWxSb3V0ZXMuc2V0KGksbmV3IE1hcChbW2YsZF1dKSksZShkLHZvaWQgMCxjLGwsYSl9fX19KTtsZXQgbj1yKDMwOTMpLHU9cig5NjQzKTsoImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSw0MDg6ZnVuY3Rpb24oZSx0KXsidXNlIHN0cmljdCI7dmFyIHIsbjtmdW5jdGlvbiB1KGUpe2xldHtraW5kOnQscHJlZmV0Y2hUaW1lOnIsbGFzdFVzZWRUaW1lOm59PWU7cmV0dXJuIERhdGUubm93KCk8KG51bGwhPW4/bjpyKSszZTQ/bj8icmV1c2FibGUiOiJmcmVzaCI6ImF1dG8iPT09dCYmRGF0ZS5ub3coKTxyKzNlNT8ic3RhbGUiOiJmdWxsIj09PXQmJkRhdGUubm93KCk8ciszZTU/InJldXNhYmxlIjoiZXhwaXJlZCJ9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIHQpT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscix7ZW51bWVyYWJsZTohMCxnZXQ6dFtyXX0pfSh0LHtQcmVmZXRjaENhY2hlRW50cnlTdGF0dXM6ZnVuY3Rpb24oKXtyZXR1cm4gcn0sZ2V0UHJlZmV0Y2hFbnRyeUNhY2hlU3RhdHVzOmZ1bmN0aW9uKCl7cmV0dXJuIHV9fSksKG49cnx8KHI9e30pKS5mcmVzaD0iZnJlc2giLG4ucmV1c2FibGU9InJldXNhYmxlIixuLmV4cGlyZWQ9ImV4cGlyZWQiLG4uc3RhbGU9InN0YWxlIiwoImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSw4ODg5OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJoYW5kbGVNdXRhYmxlIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdX19KTtsZXQgbj1yKDMwMTgpO2Z1bmN0aW9uIHUoZSx0KXt2YXIgcix1LG87bGV0IGw9bnVsbD09KHI9dC5zaG91bGRTY3JvbGwpfHxyO3JldHVybntidWlsZElkOmUuYnVpbGRJZCxjYW5vbmljYWxVcmw6bnVsbCE9dC5jYW5vbmljYWxVcmw/dC5jYW5vbmljYWxVcmw9PT1lLmNhbm9uaWNhbFVybD9lLmNhbm9uaWNhbFVybDp0LmNhbm9uaWNhbFVybDplLmNhbm9uaWNhbFVybCxwdXNoUmVmOntwZW5kaW5nUHVzaDpudWxsIT10LnBlbmRpbmdQdXNoP3QucGVuZGluZ1B1c2g6ZS5wdXNoUmVmLnBlbmRpbmdQdXNoLG1wYU5hdmlnYXRpb246bnVsbCE9dC5tcGFOYXZpZ2F0aW9uP3QubXBhTmF2aWdhdGlvbjplLnB1c2hSZWYubXBhTmF2aWdhdGlvbn0sZm9jdXNBbmRTY3JvbGxSZWY6e2FwcGx5OiEhbCYmKChudWxsPT10P3ZvaWQgMDp0LnNjcm9sbGFibGVTZWdtZW50cykhPT12b2lkIDB8fGUuZm9jdXNBbmRTY3JvbGxSZWYuYXBwbHkpLGhhc2hGcmFnbWVudDpsP3QuaGFzaEZyYWdtZW50JiYiIiE9PXQuaGFzaEZyYWdtZW50P2RlY29kZVVSSUNvbXBvbmVudCh0Lmhhc2hGcmFnbWVudC5zbGljZSgxKSk6ZS5mb2N1c0FuZFNjcm9sbFJlZi5oYXNoRnJhZ21lbnQ6bnVsbCxzZWdtZW50UGF0aHM6bD9udWxsIT0odT1udWxsPT10P3ZvaWQgMDp0LnNjcm9sbGFibGVTZWdtZW50cyk/dTplLmZvY3VzQW5kU2Nyb2xsUmVmLnNlZ21lbnRQYXRoczpbXX0sY2FjaGU6dC5jYWNoZT90LmNhY2hlOmUuY2FjaGUscHJlZmV0Y2hDYWNoZTp0LnByZWZldGNoQ2FjaGU/dC5wcmVmZXRjaENhY2hlOmUucHJlZmV0Y2hDYWNoZSx0cmVlOnZvaWQgMCE9PXQucGF0Y2hlZFRyZWU/dC5wYXRjaGVkVHJlZTplLnRyZWUsbmV4dFVybDp2b2lkIDAhPT10LnBhdGNoZWRUcmVlP251bGwhPShvPSgwLG4uY29tcHV0ZUNoYW5nZWRQYXRoKShlLnRyZWUsdC5wYXRjaGVkVHJlZSkpP286ZS5jYW5vbmljYWxVcmw6ZS5uZXh0VXJsfX0oImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSwyNzc2OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24gZSh0LHIsdSl7bGV0IG89dS5sZW5ndGg8PTIsW2wsYV09dSxpPSgwLG4uY3JlYXRlUm91dGVyQ2FjaGVLZXkpKGEpLGM9ci5wYXJhbGxlbFJvdXRlcy5nZXQobCk7aWYoIWMpcmV0dXJuO2xldCBzPXQucGFyYWxsZWxSb3V0ZXMuZ2V0KGwpO2lmKHMmJnMhPT1jfHwocz1uZXcgTWFwKGMpLHQucGFyYWxsZWxSb3V0ZXMuc2V0KGwscykpLG8pe3MuZGVsZXRlKGkpO3JldHVybn1sZXQgZj1jLmdldChpKSxkPXMuZ2V0KGkpO2QmJmYmJihkPT09ZiYmKGQ9e3N0YXR1czpkLnN0YXR1cyxkYXRhOmQuZGF0YSxzdWJUcmVlRGF0YTpkLnN1YlRyZWVEYXRhLHBhcmFsbGVsUm91dGVzOm5ldyBNYXAoZC5wYXJhbGxlbFJvdXRlcyl9LHMuc2V0KGksZCkpLGUoZCxmLHUuc2xpY2UoMikpKX19fSk7bGV0IG49cig5NjQzKTsoImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSw1Nzg3OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJpbnZhbGlkYXRlQ2FjaGVCeVJvdXRlclN0YXRlIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdX19KTtsZXQgbj1yKDk2NDMpO2Z1bmN0aW9uIHUoZSx0LHIpe2ZvcihsZXQgdSBpbiByWzFdKXtsZXQgbz1yWzFdW3VdWzBdLGw9KDAsbi5jcmVhdGVSb3V0ZXJDYWNoZUtleSkobyksYT10LnBhcmFsbGVsUm91dGVzLmdldCh1KTtpZihhKXtsZXQgdD1uZXcgTWFwKGEpO3QuZGVsZXRlKGwpLGUucGFyYWxsZWxSb3V0ZXMuc2V0KHUsdCl9fX0oImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSwxODk0OmZ1bmN0aW9uKGUsdCl7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24gZSh0LHIpe2xldCBuPXRbMF0sdT1yWzBdO2lmKEFycmF5LmlzQXJyYXkobikmJkFycmF5LmlzQXJyYXkodSkpe2lmKG5bMF0hPT11WzBdfHxuWzJdIT09dVsyXSlyZXR1cm4hMH1lbHNlIGlmKG4hPT11KXJldHVybiEwO2lmKHRbNF0pcmV0dXJuIXJbNF07aWYocls0XSlyZXR1cm4hMDtsZXQgbz1PYmplY3QudmFsdWVzKHRbMV0pWzBdLGw9T2JqZWN0LnZhbHVlcyhyWzFdKVswXTtyZXR1cm4hb3x8IWx8fGUobyxsKX19fSksKCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sODY2ODpmdW5jdGlvbihlLHQpeyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiByKGUpe2lmKCJmdWxmaWxsZWQiPT09ZS5zdGF0dXMpcmV0dXJuIGUudmFsdWU7dGhyb3cgZX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsInJlYWRSZWNvcmRWYWx1ZSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHJ9fSksKCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sNzE4MjpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiZmFzdFJlZnJlc2hSZWR1Y2VyIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbn19KSxyKDYzNzMpLHIoNzQpLHIoODY2OCkscigyMjc4KSxyKDYyMjMpLHIoMTg5NCkscigzNTgpLHIoODg4OSkscig0OTEwKTtsZXQgbj1mdW5jdGlvbihlLHQpe3JldHVybiBlfTsoImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSwyODk0OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJmaW5kSGVhZEluQ2FjaGUiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbiBlKHQscil7bGV0IHU9MD09PU9iamVjdC5rZXlzKHIpLmxlbmd0aDtpZih1KXJldHVybiB0LmhlYWQ7Zm9yKGxldCB1IGluIHIpe2xldFtvLGxdPXJbdV0sYT10LnBhcmFsbGVsUm91dGVzLmdldCh1KTtpZighYSljb250aW51ZTtsZXQgaT0oMCxuLmNyZWF0ZVJvdXRlckNhY2hlS2V5KShvKSxjPWEuZ2V0KGkpO2lmKCFjKWNvbnRpbnVlO2xldCBzPWUoYyxsKTtpZihzKXJldHVybiBzfX19fSk7bGV0IG49cig5NjQzKTsoImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSw1ODgwOmZ1bmN0aW9uKGUsdCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/ZVsxXTplfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiZ2V0U2VnbWVudFZhbHVlIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcn19KSwoImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSwzNTg6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gdClPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLHtlbnVtZXJhYmxlOiEwLGdldDp0W3JdfSl9KHQse2hhbmRsZUV4dGVybmFsVXJsOmZ1bmN0aW9uKCl7cmV0dXJuIG19LG5hdmlnYXRlUmVkdWNlcjpmdW5jdGlvbigpe3JldHVybiBPfX0pO2xldCBuPXIoMzA5MyksdT1yKDYzNzMpLG89cig3NCksbD1yKDg2NjgpLGE9cigyMjc4KSxpPXIoMjc3NiksYz1yKDIzMzcpLHM9cig5MjApLGY9cig2MjIzKSxkPXIoNjI2MikscD1yKDE4OTQpLGg9cig4NzQpLF89cig4ODg5KSx5PXIoNDkxMCksYj1yKDQwOCksdj1yKDY3ODEpO2Z1bmN0aW9uIG0oZSx0LHIsbil7cmV0dXJuIHQucHJldmlvdXNUcmVlPWUudHJlZSx0Lm1wYU5hdmlnYXRpb249ITAsdC5jYW5vbmljYWxVcmw9cix0LnBlbmRpbmdQdXNoPW4sdC5zY3JvbGxhYmxlU2VnbWVudHM9dm9pZCAwLCgwLF8uaGFuZGxlTXV0YWJsZSkoZSx0KX1mdW5jdGlvbiBnKGUpe2xldCB0PVtdLFtyLG5dPWU7aWYoMD09PU9iamVjdC5rZXlzKG4pLmxlbmd0aClyZXR1cm5bW3JdXTtmb3IobGV0W2UsdV1vZiBPYmplY3QuZW50cmllcyhuKSlmb3IobGV0IG4gb2YgZyh1KSkiIj09PXI/dC5wdXNoKFtlLC4uLm5dKTp0LnB1c2goW3IsZSwuLi5uXSk7cmV0dXJuIHR9ZnVuY3Rpb24gTyhlLHQpe2xldHt1cmw6cixpc0V4dGVybmFsVXJsOk8sbmF2aWdhdGVUeXBlOlAsY2FjaGU6RSxtdXRhYmxlOlIsZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbjpqLHNob3VsZFNjcm9sbDpTfT10LHtwYXRobmFtZTpULGhhc2g6TX09cix3PSgwLGEuY3JlYXRlSHJlZkZyb21VcmwpKHIpLEM9InB1c2giPT09UDsoMCx2LnBydW5lUHJlZmV0Y2hDYWNoZSkoZS5wcmVmZXRjaENhY2hlKTtsZXQgeD1KU09OLnN0cmluZ2lmeShSLnByZXZpb3VzVHJlZSk9PT1KU09OLnN0cmluZ2lmeShlLnRyZWUpO2lmKHgpcmV0dXJuKDAsXy5oYW5kbGVNdXRhYmxlKShlLFIpO2lmKE8pcmV0dXJuIG0oZSxSLHIudG9TdHJpbmcoKSxDKTtsZXQgQT1lLnByZWZldGNoQ2FjaGUuZ2V0KCgwLGEuY3JlYXRlSHJlZkZyb21VcmwpKHIsITEpKTtpZihqJiYobnVsbD09QT92b2lkIDA6QS5raW5kKSE9PWguUHJlZmV0Y2hLaW5kLlRFTVBPUkFSWSl7bGV0IHQ7bGV0IGw9VC5zcGxpdCgiLyIpO2wucHVzaCgiX19QQUdFX18iKTtsZXQgaT0oMCxzLmNyZWF0ZU9wdGltaXN0aWNUcmVlKShsLGUudHJlZSwhMSksZj17Li4uRX07Zi5zdGF0dXM9bi5DYWNoZVN0YXRlcy5SRUFEWSxmLnN1YlRyZWVEYXRhPWUuY2FjaGUuc3ViVHJlZURhdGEsZi5wYXJhbGxlbFJvdXRlcz1uZXcgTWFwKGUuY2FjaGUucGFyYWxsZWxSb3V0ZXMpO2xldCBkPWwuc2xpY2UoMSkubWFwKGU9PlsiY2hpbGRyZW4iLGVdKS5mbGF0KCkscD0oMCxjLmZpbGxDYWNoZVdpdGhEYXRhUHJvcGVydHkpKGYsZS5jYWNoZSxkLCgpPT4odHx8KHQ9KDAsby5jcmVhdGVSZWNvcmRGcm9tVGhlbmFibGUpKCgwLHUuZmV0Y2hTZXJ2ZXJSZXNwb25zZSkocixpLGUubmV4dFVybCxlLmJ1aWxkSWQpKSksdCksITApO2lmKCEobnVsbD09cD92b2lkIDA6cC5iYWlsT3B0aW1pc3RpYykpcmV0dXJuIFIucHJldmlvdXNUcmVlPWUudHJlZSxSLnBhdGNoZWRUcmVlPWksUi5wZW5kaW5nUHVzaD1DLFIuaGFzaEZyYWdtZW50PU0sUi5zaG91bGRTY3JvbGw9UyxSLnNjcm9sbGFibGVTZWdtZW50cz1bXSxSLmNhY2hlPWYsUi5jYW5vbmljYWxVcmw9dyxlLnByZWZldGNoQ2FjaGUuc2V0KCgwLGEuY3JlYXRlSHJlZkZyb21VcmwpKHIsITEpLHtkYXRhOlByb21pc2UucmVzb2x2ZSh0KSxraW5kOmguUHJlZmV0Y2hLaW5kLlRFTVBPUkFSWSxwcmVmZXRjaFRpbWU6RGF0ZS5ub3coKSx0cmVlQXRUaW1lT2ZQcmVmZXRjaDplLnRyZWUsbGFzdFVzZWRUaW1lOkRhdGUubm93KCl9KSwoMCxfLmhhbmRsZU11dGFibGUpKGUsUil9aWYoIUEpe2xldCB0PSgwLG8uY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlKSgoMCx1LmZldGNoU2VydmVyUmVzcG9uc2UpKHIsZS50cmVlLGUubmV4dFVybCxlLmJ1aWxkSWQsdm9pZCAwKSksbj17ZGF0YTpQcm9taXNlLnJlc29sdmUodCksa2luZDpoLlByZWZldGNoS2luZC5URU1QT1JBUlkscHJlZmV0Y2hUaW1lOkRhdGUubm93KCksdHJlZUF0VGltZU9mUHJlZmV0Y2g6ZS50cmVlLGxhc3RVc2VkVGltZTpudWxsfTtlLnByZWZldGNoQ2FjaGUuc2V0KCgwLGEuY3JlYXRlSHJlZkZyb21VcmwpKHIsITEpLG4pLEE9bn1sZXQgTj0oMCxiLmdldFByZWZldGNoRW50cnlDYWNoZVN0YXR1cykoQSkse3RyZWVBdFRpbWVPZlByZWZldGNoOkksZGF0YTpEfT1BLFtrLEZdPSgwLGwucmVhZFJlY29yZFZhbHVlKShEKTtpZihBLmxhc3RVc2VkVGltZT1EYXRlLm5vdygpLCJzdHJpbmciPT10eXBlb2YgaylyZXR1cm4gbShlLFIsayxDKTtsZXQgVT1lLnRyZWUsTD1lLmNhY2hlLEg9W107Zm9yKGxldCB0IG9mIGspe2xldCBvPXQuc2xpY2UoMCwtNCksbD10LnNsaWNlKC0zKVswXSxhPVsiIiwuLi5vXSxzPSgwLGYuYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKShhLFUsbCk7aWYobnVsbD09PXMmJihzPSgwLGYuYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKShhLEksbCkpLG51bGwhPT1zKXtpZigoMCxwLmlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCkoVSxzKSlyZXR1cm4gbShlLFIsdyxDKTtsZXQgZj0oMCx5LmFwcGx5RmxpZ2h0RGF0YSkoTCxFLHQsImF1dG8iPT09QS5raW5kJiZOPT09Yi5QcmVmZXRjaENhY2hlRW50cnlTdGF0dXMucmV1c2FibGUpO2Z8fE4hPT1iLlByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5zdGFsZXx8KGY9ZnVuY3Rpb24oZSx0LHIsdSxvKXtsZXQgbD0hMTtlLnN0YXR1cz1uLkNhY2hlU3RhdGVzLlJFQURZLGUuc3ViVHJlZURhdGE9dC5zdWJUcmVlRGF0YSxlLnBhcmFsbGVsUm91dGVzPW5ldyBNYXAodC5wYXJhbGxlbFJvdXRlcyk7bGV0IGE9Zyh1KS5tYXAoZT0+Wy4uLnIsLi4uZV0pO2ZvcihsZXQgciBvZiBhKXtsZXQgbj0oMCxjLmZpbGxDYWNoZVdpdGhEYXRhUHJvcGVydHkpKGUsdCxyLG8pOyhudWxsPT1uP3ZvaWQgMDpuLmJhaWxPcHRpbWlzdGljKXx8KGw9ITApfXJldHVybiBsfShFLEwsbyxsLCgpPT4oMCx1LmZldGNoU2VydmVyUmVzcG9uc2UpKHIsVSxlLm5leHRVcmwsZS5idWlsZElkKSkpO2xldCBoPSgwLGQuc2hvdWxkSGFyZE5hdmlnYXRlKShhLFUpO2ZvcihsZXQgZSBvZihoPyhFLnN0YXR1cz1uLkNhY2hlU3RhdGVzLlJFQURZLEUuc3ViVHJlZURhdGE9TC5zdWJUcmVlRGF0YSwoMCxpLmludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgpKEUsTCxvKSxSLmNhY2hlPUUpOmYmJihSLmNhY2hlPUUpLEw9RSxVPXMsZyhsKSkpe2xldCB0PVsuLi5vLC4uLmVdOyJfX0RFRkFVTFRfXyIhPT10W3QubGVuZ3RoLTFdJiZILnB1c2godCl9fX1yZXR1cm4gUi5wcmV2aW91c1RyZWU9ZS50cmVlLFIucGF0Y2hlZFRyZWU9VSxSLmNhbm9uaWNhbFVybD1GPygwLGEuY3JlYXRlSHJlZkZyb21VcmwpKEYpOncsUi5wZW5kaW5nUHVzaD1DLFIuc2Nyb2xsYWJsZVNlZ21lbnRzPUgsUi5oYXNoRnJhZ21lbnQ9TSxSLnNob3VsZFNjcm9sbD1TLCgwLF8uaGFuZGxlTXV0YWJsZSkoZSxSKX0oImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSw4MDM6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsInByZWZldGNoUmVkdWNlciIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGN9fSk7bGV0IG49cigyMjc4KSx1PXIoNjM3Myksbz1yKDg3NCksbD1yKDc0KSxhPXIoNjc4MSksaT1yKDk0MzgpO2Z1bmN0aW9uIGMoZSx0KXsoMCxhLnBydW5lUHJlZmV0Y2hDYWNoZSkoZS5wcmVmZXRjaENhY2hlKTtsZXR7dXJsOnJ9PXQ7ci5zZWFyY2hQYXJhbXMuZGVsZXRlKGkuTkVYVF9SU0NfVU5JT05fUVVFUlkpO2xldCBjPSgwLG4uY3JlYXRlSHJlZkZyb21VcmwpKHIsITEpLHM9ZS5wcmVmZXRjaENhY2hlLmdldChjKTtpZihzJiYocy5raW5kPT09by5QcmVmZXRjaEtpbmQuVEVNUE9SQVJZJiZlLnByZWZldGNoQ2FjaGUuc2V0KGMsey4uLnMsa2luZDp0LmtpbmR9KSwhKHMua2luZD09PW8uUHJlZmV0Y2hLaW5kLkFVVE8mJnQua2luZD09PW8uUHJlZmV0Y2hLaW5kLkZVTEwpKSlyZXR1cm4gZTtsZXQgZj0oMCxsLmNyZWF0ZVJlY29yZEZyb21UaGVuYWJsZSkoKDAsdS5mZXRjaFNlcnZlclJlc3BvbnNlKShyLGUudHJlZSxlLm5leHRVcmwsZS5idWlsZElkLHQua2luZCkpO3JldHVybiBlLnByZWZldGNoQ2FjaGUuc2V0KGMse3RyZWVBdFRpbWVPZlByZWZldGNoOmUudHJlZSxkYXRhOmYsa2luZDp0LmtpbmQscHJlZmV0Y2hUaW1lOkRhdGUubm93KCksbGFzdFVzZWRUaW1lOm51bGx9KSxlfSgiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDY3ODE6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsInBydW5lUHJlZmV0Y2hDYWNoZSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHV9fSk7bGV0IG49cig0MDgpO2Z1bmN0aW9uIHUoZSl7Zm9yKGxldFt0LHJdb2YgZSkoMCxuLmdldFByZWZldGNoRW50cnlDYWNoZVN0YXR1cykocik9PT1uLlByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5leHBpcmVkJiZlLmRlbGV0ZSh0KX0oImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSw2NDg0OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJyZWZyZXNoUmVkdWNlciIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHB9fSk7bGV0IG49cig2MzczKSx1PXIoNzQpLG89cig4NjY4KSxsPXIoMjI3OCksYT1yKDYyMjMpLGk9cigxODk0KSxjPXIoMzU4KSxzPXIoODg4OSksZj1yKDMwOTMpLGQ9cigyMzUwKTtmdW5jdGlvbiBwKGUsdCl7bGV0e2NhY2hlOnIsbXV0YWJsZTpwLG9yaWdpbjpofT10LF89ZS5jYW5vbmljYWxVcmwseT1lLnRyZWUsYj1KU09OLnN0cmluZ2lmeShwLnByZXZpb3VzVHJlZSk9PT1KU09OLnN0cmluZ2lmeSh5KTtpZihiKXJldHVybigwLHMuaGFuZGxlTXV0YWJsZSkoZSxwKTtyLmRhdGF8fChyLmRhdGE9KDAsdS5jcmVhdGVSZWNvcmRGcm9tVGhlbmFibGUpKCgwLG4uZmV0Y2hTZXJ2ZXJSZXNwb25zZSkobmV3IFVSTChfLGgpLFt5WzBdLHlbMV0seVsyXSwicmVmZXRjaCJdLGUubmV4dFVybCxlLmJ1aWxkSWQpKSk7bGV0W3YsbV09KDAsby5yZWFkUmVjb3JkVmFsdWUpKHIuZGF0YSk7aWYoInN0cmluZyI9PXR5cGVvZiB2KXJldHVybigwLGMuaGFuZGxlRXh0ZXJuYWxVcmwpKGUscCx2LGUucHVzaFJlZi5wZW5kaW5nUHVzaCk7Zm9yKGxldCB0IG9mKHIuZGF0YT1udWxsLHYpKXtpZigzIT09dC5sZW5ndGgpcmV0dXJuIGNvbnNvbGUubG9nKCJSRUZSRVNIIEZBSUxFRCIpLGU7bGV0W25dPXQsdT0oMCxhLmFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSkoWyIiXSx5LG4pO2lmKG51bGw9PT11KXRocm93IEVycm9yKCJTRUdNRU5UIE1JU01BVENIIik7aWYoKDAsaS5pc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQpKHksdSkpcmV0dXJuKDAsYy5oYW5kbGVFeHRlcm5hbFVybCkoZSxwLF8sZS5wdXNoUmVmLnBlbmRpbmdQdXNoKTtsZXQgbz1tPygwLGwuY3JlYXRlSHJlZkZyb21VcmwpKG0pOnZvaWQgMDttJiYocC5jYW5vbmljYWxVcmw9byk7bGV0W3MsaF09dC5zbGljZSgtMik7bnVsbCE9PXMmJihyLnN0YXR1cz1mLkNhY2hlU3RhdGVzLlJFQURZLHIuc3ViVHJlZURhdGE9cywoMCxkLmZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKShyLHZvaWQgMCxuLGgpLHAuY2FjaGU9cixwLnByZWZldGNoQ2FjaGU9bmV3IE1hcCkscC5wcmV2aW91c1RyZWU9eSxwLnBhdGNoZWRUcmVlPXUscC5jYW5vbmljYWxVcmw9Xyx5PXV9cmV0dXJuKDAscy5oYW5kbGVNdXRhYmxlKShlLHApfSgiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDQ1Njc6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsInJlc3RvcmVSZWR1Y2VyIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdX19KTtsZXQgbj1yKDIyNzgpO2Z1bmN0aW9uIHUoZSx0KXtsZXR7dXJsOnIsdHJlZTp1fT10LG89KDAsbi5jcmVhdGVIcmVmRnJvbVVybCkocik7cmV0dXJue2J1aWxkSWQ6ZS5idWlsZElkLGNhbm9uaWNhbFVybDpvLHB1c2hSZWY6ZS5wdXNoUmVmLGZvY3VzQW5kU2Nyb2xsUmVmOmUuZm9jdXNBbmRTY3JvbGxSZWYsY2FjaGU6ZS5jYWNoZSxwcmVmZXRjaENhY2hlOmUucHJlZmV0Y2hDYWNoZSx0cmVlOnUsbmV4dFVybDpyLnBhdGhuYW1lfX0oImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSw1MTg0OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJzZXJ2ZXJBY3Rpb25SZWR1Y2VyIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcH19KTtsZXQgbj1yKDU2MDApLHU9cig5NDM4KSxvPXIoNzQpLGw9cig4NjY4KSxhPXIoNTQ1NiksaT1yKDg3NCksYz1yKDU4ODQpLHM9cigyMjc4KSxmPXIoMzgwOCk7YXN5bmMgZnVuY3Rpb24gZChlLHQpe2xldCByLHthY3Rpb25JZDpvLGFjdGlvbkFyZ3M6bH09dCxpPWF3YWl0ICgwLGEuZW5jb2RlUmVwbHkpKGwpLHM9YXdhaXQgZmV0Y2goIiIse21ldGhvZDoiUE9TVCIsaGVhZGVyczp7QWNjZXB0OnUuUlNDX0NPTlRFTlRfVFlQRV9IRUFERVIsIk5leHQtQWN0aW9uIjpvLFt1Lk5FWFRfUk9VVEVSX1NUQVRFX1RSRUVdOkpTT04uc3RyaW5naWZ5KGUudHJlZSksLi4uZS5uZXh0VXJsP3tbdS5ORVhUX1VSTF06ZS5uZXh0VXJsfTp7fX0sYm9keTppfSksZj1zLmhlYWRlcnMuZ2V0KCJ4LWFjdGlvbi1yZWRpcmVjdCIpO3RyeXtsZXQgZT1KU09OLnBhcnNlKHMuaGVhZGVycy5nZXQoIngtYWN0aW9uLXJldmFsaWRhdGVkIil8fCJbW10sMCwwXSIpO3I9e3BhdGhzOmVbMF18fFtdLHRhZzohIWVbMV0sY29va2llOmVbMl19fWNhdGNoKGUpe3I9e3BhdGhzOltdLHRhZzohMSxjb29raWU6ITF9fWxldCBkPWY/bmV3IFVSTCgoMCxjLmFkZEJhc2VQYXRoKShmKSx3aW5kb3cubG9jYXRpb24ub3JpZ2luKTp2b2lkIDA7aWYocy5oZWFkZXJzLmdldCgiY29udGVudC10eXBlIik9PT11LlJTQ19DT05URU5UX1RZUEVfSEVBREVSKXtsZXQgZT1hd2FpdCAoMCxhLmNyZWF0ZUZyb21GZXRjaCkoUHJvbWlzZS5yZXNvbHZlKHMpLHtjYWxsU2VydmVyOm4uY2FsbFNlcnZlcn0pO2lmKGYpe2xldFssdF09ZTtyZXR1cm57YWN0aW9uRmxpZ2h0RGF0YTpudWxsPT10P3ZvaWQgMDp0WzFdLHJlZGlyZWN0TG9jYXRpb246ZCxyZXZhbGlkYXRlZFBhcnRzOnJ9fXtsZXRbdCxbLG5dXT1udWxsIT1lP2U6W107cmV0dXJue2FjdGlvblJlc3VsdDp0LGFjdGlvbkZsaWdodERhdGE6bixyZWRpcmVjdExvY2F0aW9uOmQscmV2YWxpZGF0ZWRQYXJ0czpyfX19cmV0dXJue3JlZGlyZWN0TG9jYXRpb246ZCxyZXZhbGlkYXRlZFBhcnRzOnJ9fWZ1bmN0aW9uIHAoZSx0KXtpZih0Lm11dGFibGUuc2VydmVyQWN0aW9uQXBwbGllZClyZXR1cm4gZTt0Lm11dGFibGUuaW5GbGlnaHRTZXJ2ZXJBY3Rpb258fCh0Lm11dGFibGUucHJldmlvdXNUcmVlPWUudHJlZSx0Lm11dGFibGUucHJldmlvdXNVcmw9ZS5jYW5vbmljYWxVcmwsdC5tdXRhYmxlLmluRmxpZ2h0U2VydmVyQWN0aW9uPSgwLG8uY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlKShkKGUsdCkpKTt0cnl7dmFyIHIsbjtsZXR7YWN0aW9uUmVzdWx0OnUsYWN0aW9uRmxpZ2h0RGF0YTphLHJlZGlyZWN0TG9jYXRpb246YyxyZXZhbGlkYXRlZFBhcnRzOmR9PSgwLGwucmVhZFJlY29yZFZhbHVlKSh0Lm11dGFibGUuaW5GbGlnaHRTZXJ2ZXJBY3Rpb24pO2lmKGQudGFnfHxkLmNvb2tpZT9lLnByZWZldGNoQ2FjaGUuY2xlYXIoKTpkLnBhdGhzLmxlbmd0aD4wJiZlLnByZWZldGNoQ2FjaGUuY2xlYXIoKSxjKXtpZihhKXtsZXQgbj0oMCxzLmNyZWF0ZUhyZWZGcm9tVXJsKShjLCExKSx1PWUucHJlZmV0Y2hDYWNoZS5nZXQobik7ZS5wcmVmZXRjaENhY2hlLnNldChuLHtkYXRhOigwLG8uY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlKShQcm9taXNlLnJlc29sdmUoW2Esdm9pZCAwXSkpLGtpbmQ6bnVsbCE9KHI9bnVsbD09dT92b2lkIDA6dS5raW5kKT9yOmkuUHJlZmV0Y2hLaW5kLlRFTVBPUkFSWSxwcmVmZXRjaFRpbWU6RGF0ZS5ub3coKSx0cmVlQXRUaW1lT2ZQcmVmZXRjaDp0Lm11dGFibGUucHJldmlvdXNUcmVlLGxhc3RVc2VkVGltZTpudWxsfSl9dC5yZWplY3QoKDAsZi5nZXRSZWRpcmVjdEVycm9yKShjLnRvU3RyaW5nKCksZi5SZWRpcmVjdFR5cGUucHVzaCkpfWVsc2V7aWYoYSl7bGV0IHI9KDAscy5jcmVhdGVIcmVmRnJvbVVybCkobmV3IFVSTCh0Lm11dGFibGUucHJldmlvdXNVcmwsd2luZG93LmxvY2F0aW9uLm9yaWdpbiksITEpLHU9ZS5wcmVmZXRjaENhY2hlLmdldChyKTtlLnByZWZldGNoQ2FjaGUuc2V0KCgwLHMuY3JlYXRlSHJlZkZyb21VcmwpKG5ldyBVUkwodC5tdXRhYmxlLnByZXZpb3VzVXJsLHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pLCExKSx7ZGF0YTooMCxvLmNyZWF0ZVJlY29yZEZyb21UaGVuYWJsZSkoUHJvbWlzZS5yZXNvbHZlKFthLHZvaWQgMF0pKSxraW5kOm51bGwhPShuPW51bGw9PXU/dm9pZCAwOnUua2luZCk/bjppLlByZWZldGNoS2luZC5URU1QT1JBUlkscHJlZmV0Y2hUaW1lOkRhdGUubm93KCksdHJlZUF0VGltZU9mUHJlZmV0Y2g6dC5tdXRhYmxlLnByZXZpb3VzVHJlZSxsYXN0VXNlZFRpbWU6bnVsbH0pLHNldFRpbWVvdXQoKCk9Pnt0LmNoYW5nZUJ5U2VydmVyUmVzcG9uc2UodC5tdXRhYmxlLnByZXZpb3VzVHJlZSxhLHZvaWQgMCl9KX10LnJlc29sdmUodSl9fWNhdGNoKGUpe2lmKCJyZWplY3RlZCI9PT1lLnN0YXR1cyl0LnJlamVjdChlLnZhbHVlKTtlbHNlIHRocm93IGV9cmV0dXJuIHQubXV0YWJsZS5zZXJ2ZXJBY3Rpb25BcHBsaWVkPSEwLGV9KCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sNDU4OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJzZXJ2ZXJQYXRjaFJlZHVjZXIiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBjfX0pO2xldCBuPXIoMjI3OCksdT1yKDYyMjMpLG89cigxODk0KSxsPXIoMzU4KSxhPXIoNDkxMCksaT1yKDg4ODkpO2Z1bmN0aW9uIGMoZSx0KXtsZXR7ZmxpZ2h0RGF0YTpyLHByZXZpb3VzVHJlZTpjLG92ZXJyaWRlQ2Fub25pY2FsVXJsOnMsY2FjaGU6ZixtdXRhYmxlOmR9PXQscD1KU09OLnN0cmluZ2lmeShjKT09PUpTT04uc3RyaW5naWZ5KGUudHJlZSk7aWYoIXApcmV0dXJuIGNvbnNvbGUubG9nKCJUUkVFIE1JU01BVENIIiksZTtpZihkLnByZXZpb3VzVHJlZSlyZXR1cm4oMCxpLmhhbmRsZU11dGFibGUpKGUsZCk7aWYoInN0cmluZyI9PXR5cGVvZiByKXJldHVybigwLGwuaGFuZGxlRXh0ZXJuYWxVcmwpKGUsZCxyLGUucHVzaFJlZi5wZW5kaW5nUHVzaCk7bGV0IGg9ZS50cmVlLF89ZS5jYWNoZTtmb3IobGV0IHQgb2Ygcil7bGV0IHI9dC5zbGljZSgwLC00KSxbaV09dC5zbGljZSgtMywtMiksYz0oMCx1LmFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSkoWyIiLC4uLnJdLGgsaSk7aWYobnVsbD09PWMpdGhyb3cgRXJyb3IoIlNFR01FTlQgTUlTTUFUQ0giKTtpZigoMCxvLmlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCkoaCxjKSlyZXR1cm4oMCxsLmhhbmRsZUV4dGVybmFsVXJsKShlLGQsZS5jYW5vbmljYWxVcmwsZS5wdXNoUmVmLnBlbmRpbmdQdXNoKTtsZXQgcD1zPygwLG4uY3JlYXRlSHJlZkZyb21VcmwpKHMpOnZvaWQgMDtwJiYoZC5jYW5vbmljYWxVcmw9cCksKDAsYS5hcHBseUZsaWdodERhdGEpKF8sZix0KSxkLnByZXZpb3VzVHJlZT1oLGQucGF0Y2hlZFRyZWU9YyxkLmNhY2hlPWYsXz1mLGg9Y31yZXR1cm4oMCxpLmhhbmRsZU11dGFibGUpKGUsZCl9KCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sODc0OmZ1bmN0aW9uKGUsdCl7InVzZSBzdHJpY3QiO3ZhciByLG47T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIHQpT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscix7ZW51bWVyYWJsZTohMCxnZXQ6dFtyXX0pfSh0LHtQcmVmZXRjaEtpbmQ6ZnVuY3Rpb24oKXtyZXR1cm4gcn0sQUNUSU9OX1JFRlJFU0g6ZnVuY3Rpb24oKXtyZXR1cm4gdX0sQUNUSU9OX05BVklHQVRFOmZ1bmN0aW9uKCl7cmV0dXJuIG99LEFDVElPTl9SRVNUT1JFOmZ1bmN0aW9uKCl7cmV0dXJuIGx9LEFDVElPTl9TRVJWRVJfUEFUQ0g6ZnVuY3Rpb24oKXtyZXR1cm4gYX0sQUNUSU9OX1BSRUZFVENIOmZ1bmN0aW9uKCl7cmV0dXJuIGl9LEFDVElPTl9GQVNUX1JFRlJFU0g6ZnVuY3Rpb24oKXtyZXR1cm4gY30sQUNUSU9OX1NFUlZFUl9BQ1RJT046ZnVuY3Rpb24oKXtyZXR1cm4gc319KTtsZXQgdT0icmVmcmVzaCIsbz0ibmF2aWdhdGUiLGw9InJlc3RvcmUiLGE9InNlcnZlci1wYXRjaCIsaT0icHJlZmV0Y2giLGM9ImZhc3QtcmVmcmVzaCIscz0ic2VydmVyLWFjdGlvbiI7KG49cnx8KHI9e30pKS5BVVRPPSJhdXRvIixuLkZVTEw9ImZ1bGwiLG4uVEVNUE9SQVJZPSJ0ZW1wb3JhcnkiLCgiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDUyOTc6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsInJlZHVjZXIiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBmfX0pO2xldCBuPXIoODc0KSx1PXIoMzU4KSxvPXIoNDU4KSxsPXIoNDU2NyksYT1yKDY0ODQpLGk9cig4MDMpLGM9cig3MTgyKSxzPXIoNTE4NCksZj1mdW5jdGlvbihlLHQpe3N3aXRjaCh0LnR5cGUpe2Nhc2Ugbi5BQ1RJT05fTkFWSUdBVEU6cmV0dXJuKDAsdS5uYXZpZ2F0ZVJlZHVjZXIpKGUsdCk7Y2FzZSBuLkFDVElPTl9TRVJWRVJfUEFUQ0g6cmV0dXJuKDAsby5zZXJ2ZXJQYXRjaFJlZHVjZXIpKGUsdCk7Y2FzZSBuLkFDVElPTl9SRVNUT1JFOnJldHVybigwLGwucmVzdG9yZVJlZHVjZXIpKGUsdCk7Y2FzZSBuLkFDVElPTl9SRUZSRVNIOnJldHVybigwLGEucmVmcmVzaFJlZHVjZXIpKGUsdCk7Y2FzZSBuLkFDVElPTl9GQVNUX1JFRlJFU0g6cmV0dXJuKDAsYy5mYXN0UmVmcmVzaFJlZHVjZXIpKGUsdCk7Y2FzZSBuLkFDVElPTl9QUkVGRVRDSDpyZXR1cm4oMCxpLnByZWZldGNoUmVkdWNlcikoZSx0KTtjYXNlIG4uQUNUSU9OX1NFUlZFUl9BQ1RJT046cmV0dXJuKDAscy5zZXJ2ZXJBY3Rpb25SZWR1Y2VyKShlLHQpO2RlZmF1bHQ6dGhyb3cgRXJyb3IoIlVua25vd24gYWN0aW9uIil9fTsoImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSw2MjYyOmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJzaG91bGRIYXJkTmF2aWdhdGUiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbiBlKHQscil7bGV0W3Usb109cixbbCxhXT10O2lmKCEoMCxuLm1hdGNoU2VnbWVudCkobCx1KSlyZXR1cm4hIUFycmF5LmlzQXJyYXkobCk7bGV0IGk9dC5sZW5ndGg8PTI7cmV0dXJuIWkmJmUodC5zbGljZSgyKSxvW2FdKX19fSk7bGV0IG49cig5NDApOygiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDcyMTpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiY3JlYXRlU2VhcmNoUGFyYW1zQmFpbG91dFByb3h5Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdX19KTtsZXQgbj1yKDMzNik7ZnVuY3Rpb24gdSgpe3JldHVybiBuZXcgUHJveHkoe30se2dldChlLHQpeyJzdHJpbmciPT10eXBlb2YgdCYmKDAsbi5zdGF0aWNHZW5lcmF0aW9uQmFpbG91dCkoInNlYXJjaFBhcmFtcy4iK3QpfX0pfSgiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDMzNjpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwic3RhdGljR2VuZXJhdGlvbkJhaWxvdXQiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBsfX0pO2xldCBuPXIoOTU3MSksdT1yKDEwNjIpO2NsYXNzIG8gZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvciguLi5lKXtzdXBlciguLi5lKSx0aGlzLmNvZGU9Ik5FWFRfU1RBVElDX0dFTl9CQUlMT1VUIn19bGV0IGw9KGUsdCk9PntsZXQgcj11LnN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKTtpZihudWxsPT1yP3ZvaWQgMDpyLmZvcmNlU3RhdGljKXJldHVybiEwO2lmKG51bGw9PXI/dm9pZCAwOnIuZHluYW1pY1Nob3VsZEVycm9yKXtsZXR7ZHluYW1pYzpyPSJlcnJvciIsbGluazpufT10fHx7fTt0aHJvdyBuZXcgbygnUGFnZSB3aXRoIGBkeW5hbWljID0gIicrcisiXCJgIGNvdWxkbid0IGJlIHJlbmRlcmVkIHN0YXRpY2FsbHkgYmVjYXVzZSBpdCB1c2VkIGAiK2UrImAuIisobj8iIFNlZSBtb3JlIGluZm8gaGVyZTogIituOiIiKSl9aWYociYmKHIucmV2YWxpZGF0ZT0wKSxudWxsPT1yP3ZvaWQgMDpyLmlzU3RhdGljR2VuZXJhdGlvbil7bGV0IHQ9bmV3IG4uRHluYW1pY1NlcnZlckVycm9yKGUpO3Rocm93IHIuZHluYW1pY1VzYWdlRGVzY3JpcHRpb249ZSxyLmR5bmFtaWNVc2FnZVN0YWNrPXQuc3RhY2ssdH1yZXR1cm4hMX07KCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sNTcyMTpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiZGVmYXVsdCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGx9fSk7bGV0IG49cig2OTI3KSx1PW4uXyhyKDYwMDYpKSxvPXIoNzIxKTtmdW5jdGlvbiBsKGUpe2xldHtDb21wb25lbnQ6dCxwcm9wc0ZvckNvbXBvbmVudDpyfT1lLG49KDAsby5jcmVhdGVTZWFyY2hQYXJhbXNCYWlsb3V0UHJveHkpKCk7cmV0dXJuIHUuZGVmYXVsdC5jcmVhdGVFbGVtZW50KHQse3NlYXJjaFBhcmFtczpuLC4uLnJ9KX0oImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSw1MjUzOmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJ1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHMiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBvfX0pO2xldCBuPXIoNjAwNik7ZnVuY3Rpb24gdShlKXtpZihlIGluc3RhbmNlb2YgTWFwKXtsZXQgdD17fTtmb3IobGV0W3Isbl1vZiBlLmVudHJpZXMoKSl7aWYoImZ1bmN0aW9uIj09dHlwZW9mIG4pe3Rbcl09ImZuKCkiO2NvbnRpbnVlfWlmKCJvYmplY3QiPT10eXBlb2YgbiYmbnVsbCE9PW4pe2lmKG4uJCR0eXBlb2Ype3Rbcl09bi4kJHR5cGVvZi50b1N0cmluZygpO2NvbnRpbnVlfWlmKG4uX2J1bmRsZXJDb25maWcpe3Rbcl09IkZsaWdodERhdGEiO2NvbnRpbnVlfX10W3JdPXUobil9cmV0dXJuIHR9aWYoIm9iamVjdCI9PXR5cGVvZiBlJiZudWxsIT09ZSl7bGV0IHQ9e307Zm9yKGxldCByIGluIGUpe2xldCBuPWVbcl07aWYoImZ1bmN0aW9uIj09dHlwZW9mIG4pe3Rbcl09ImZuKCkiO2NvbnRpbnVlfWlmKCJvYmplY3QiPT10eXBlb2YgbiYmbnVsbCE9PW4pe2lmKG4uJCR0eXBlb2Ype3Rbcl09bi4kJHR5cGVvZi50b1N0cmluZygpO2NvbnRpbnVlfWlmKG4uaGFzT3duUHJvcGVydHkoIl9idW5kbGVyQ29uZmlnIikpe3Rbcl09IkZsaWdodERhdGEiO2NvbnRpbnVlfX10W3JdPXUobil9cmV0dXJuIHR9cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/ZS5tYXAodSk6ZX1sZXQgbz1mdW5jdGlvbihlLHQpe2xldCByPSgwLG4udXNlUmVmKSgpLG89KDAsbi51c2VSZWYpKCk7KDAsbi51c2VFZmZlY3QpKCgpPT57aWYoIXIuY3VycmVudCYmITEhPT1vLmN1cnJlbnQpe2lmKHZvaWQgMD09PW8uY3VycmVudCYmdm9pZCAwPT09d2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18pe28uY3VycmVudD0hMTtyZXR1cm59cmV0dXJuIHIuY3VycmVudD13aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXy5jb25uZWN0KHtpbnN0YW5jZUlkOjhlMyxuYW1lOiJuZXh0LXJvdXRlciJ9KSxyLmN1cnJlbnQmJnIuY3VycmVudC5pbml0KHUodCkpLCgpPT57ci5jdXJyZW50PXZvaWQgMH19fSxbdF0pO2xldFtsLGFdPSgwLG4udXNlUmVkdWNlcikoKHQsbik9PntsZXQgbz1lKHQsbik7cmV0dXJuIHIuY3VycmVudCYmci5jdXJyZW50LnNlbmQobix1KG8pKSxvfSx0KSxpPSgwLG4udXNlQ2FsbGJhY2spKCgpPT57ci5jdXJyZW50JiZyLmN1cnJlbnQuc2VuZCh7dHlwZToiUkVOREVSX1NZTkMifSx1KGwpKX0sW2xdKTtyZXR1cm5bbCxhLGldfTsoImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSwyMTU4OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG99fSk7bGV0IG49cig5Nzc5KSx1PXIoODE2OSksbz1lPT57aWYoIWUuc3RhcnRzV2l0aCgiLyIpKXJldHVybiBlO2xldHtwYXRobmFtZTp0LHF1ZXJ5OnIsaGFzaDpvfT0oMCx1LnBhcnNlUGF0aCkoZSk7cmV0dXJuIiIrKDAsbi5yZW1vdmVUcmFpbGluZ1NsYXNoKSh0KStyK299OygiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDUwMjpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiZGVmYXVsdCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHV9fSk7bGV0IG49cigzNDQ2KTtmdW5jdGlvbiB1KGUpe2xldCB0PSJmdW5jdGlvbiI9PXR5cGVvZiByZXBvcnRFcnJvcj9yZXBvcnRFcnJvcjplPT57d2luZG93LmNvbnNvbGUuZXJyb3IoZSl9O2UuZGlnZXN0IT09bi5ORVhUX0RZTkFNSUNfTk9fU1NSX0NPREUmJnQoZSl9KCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sMzA5MzpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO3ZhciBuLHU7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIHQpT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscix7ZW51bWVyYWJsZTohMCxnZXQ6dFtyXX0pfSh0LHtDYWNoZVN0YXRlczpmdW5jdGlvbigpe3JldHVybiBufSxBcHBSb3V0ZXJDb250ZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIGF9LExheW91dFJvdXRlckNvbnRleHQ6ZnVuY3Rpb24oKXtyZXR1cm4gaX0sR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dDpmdW5jdGlvbigpe3JldHVybiBjfSxUZW1wbGF0ZUNvbnRleHQ6ZnVuY3Rpb24oKXtyZXR1cm4gc319KTtsZXQgbz1yKDY5MjcpLGw9by5fKHIoNjAwNikpOyh1PW58fChuPXt9KSkuTEFaWV9JTklUSUFMSVpFRD0iTEFaWUlOSVRJQUxJWkVEIix1LkRBVEFfRkVUQ0g9IkRBVEFGRVRDSCIsdS5SRUFEWT0iUkVBRFkiO2xldCBhPWwuZGVmYXVsdC5jcmVhdGVDb250ZXh0KG51bGwpLGk9bC5kZWZhdWx0LmNyZWF0ZUNvbnRleHQobnVsbCksYz1sLmRlZmF1bHQuY3JlYXRlQ29udGV4dChudWxsKSxzPWwuZGVmYXVsdC5jcmVhdGVDb250ZXh0KG51bGwpfSw4NjM0OmZ1bmN0aW9uKGUsdCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHIoZSl7bGV0IHQ9NTM4MTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7bGV0IG49ZS5jaGFyQ29kZUF0KHIpO3Q9KHQ8PDUpK3Qrbn1yZXR1cm4gTWF0aC5hYnModCl9ZnVuY3Rpb24gbihlKXtyZXR1cm4gcihlKS50b1N0cmluZygzNikuc2xpY2UoMCw1KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gdClPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLHtlbnVtZXJhYmxlOiEwLGdldDp0W3JdfSl9KHQse2RqYjJIYXNoOmZ1bmN0aW9uKCl7cmV0dXJuIHJ9LGhleEhhc2g6ZnVuY3Rpb24oKXtyZXR1cm4gbn19KX0sNTc3OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJIZWFkTWFuYWdlckNvbnRleHQiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBvfX0pO2xldCBuPXIoNjkyNyksdT1uLl8ocig2MDA2KSksbz11LmRlZmF1bHQuY3JlYXRlQ29udGV4dCh7fSl9LDgzNDU6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gdClPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLHtlbnVtZXJhYmxlOiEwLGdldDp0W3JdfSl9KHQse1NlYXJjaFBhcmFtc0NvbnRleHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdX0sUGF0aG5hbWVDb250ZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIG99fSk7bGV0IG49cig2MDA2KSx1PSgwLG4uY3JlYXRlQ29udGV4dCkobnVsbCksbz0oMCxuLmNyZWF0ZUNvbnRleHQpKG51bGwpfSwzNDQ2OmZ1bmN0aW9uKGUsdCl7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiTkVYVF9EWU5BTUlDX05PX1NTUl9DT0RFIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcn19KTtsZXQgcj0iTkVYVF9EWU5BTUlDX05PX1NTUl9DT0RFIn0sNDU1NDpmdW5jdGlvbihlLHQpeyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiByKGUpe3JldHVybiBlLnN0YXJ0c1dpdGgoIi8iKT9lOiIvIitlfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiZW5zdXJlTGVhZGluZ1NsYXNoIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcn19KX0sNDMzMTpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiYWRkUGF0aFByZWZpeCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHV9fSk7bGV0IG49cig4MTY5KTtmdW5jdGlvbiB1KGUsdCl7aWYoIWUuc3RhcnRzV2l0aCgiLyIpfHwhdClyZXR1cm4gZTtsZXR7cGF0aG5hbWU6cixxdWVyeTp1LGhhc2g6b309KDAsbi5wYXJzZVBhdGgpKGUpO3JldHVybiIiK3Qrcit1K299fSwzMDc0OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIHQpT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscix7ZW51bWVyYWJsZTohMCxnZXQ6dFtyXX0pfSh0LHtub3JtYWxpemVBcHBQYXRoOmZ1bmN0aW9uKCl7cmV0dXJuIHV9LG5vcm1hbGl6ZVJzY1BhdGg6ZnVuY3Rpb24oKXtyZXR1cm4gb319KTtsZXQgbj1yKDQ1NTQpO2Z1bmN0aW9uIHUoZSl7cmV0dXJuKDAsbi5lbnN1cmVMZWFkaW5nU2xhc2gpKGUuc3BsaXQoIi8iKS5yZWR1Y2UoKGUsdCxyLG4pPT4hdHx8IigiPT09dFswXSYmdC5lbmRzV2l0aCgiKSIpfHwiQCI9PT10WzBdfHwoInBhZ2UiPT09dHx8InJvdXRlIj09PXQpJiZyPT09bi5sZW5ndGgtMT9lOmUrIi8iK3QsIiIpKX1mdW5jdGlvbiBvKGUsdCl7cmV0dXJuIHQ/ZS5yZXBsYWNlKC9cLnJzYygkfFw/KS8sIiQxIik6ZX19LDEyNTg6ZnVuY3Rpb24oZSx0KXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcihlLHQpe3ZvaWQgMD09PXQmJih0PXt9KTtsZXQgcj1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsbj1yLnN0eWxlLnNjcm9sbEJlaGF2aW9yO3Iuc3R5bGUuc2Nyb2xsQmVoYXZpb3I9ImF1dG8iLHQuZG9udEZvcmNlTGF5b3V0fHxyLmdldENsaWVudFJlY3RzKCksZSgpLHIuc3R5bGUuc2Nyb2xsQmVoYXZpb3I9bn1PYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImhhbmRsZVNtb290aFNjcm9sbCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHJ9fSl9LDkzMTU6ZnVuY3Rpb24oZSx0KXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4vR29vZ2xlYm90fE1lZGlhcGFydG5lcnMtR29vZ2xlfEFkc0JvdC1Hb29nbGV8Z29vZ2xld2VibGlnaHR8U3RvcmVib3QtR29vZ2xlfEdvb2dsZS1QYWdlUmVuZGVyZXJ8QmluZ2JvdHxCaW5nUHJldmlld3xTbHVycHxEdWNrRHVja0JvdHxiYWlkdXNwaWRlcnx5YW5kZXh8c29nb3V8TGlua2VkSW5Cb3R8Yml0bHlib3R8dHVtYmxyfHZrU2hhcmV8cXVvcmEgbGluayBwcmV2aWV3fGZhY2Vib29rZXh0ZXJuYWxoaXR8ZmFjZWJvb2tjYXRhbG9nfFR3aXR0ZXJib3R8YXBwbGVib3R8cmVkZGl0Ym90fFNsYWNrYm90fERpc2NvcmRib3R8V2hhdHNBcHB8U2t5cGVVcmlQcmV2aWV3fGlhX2FyY2hpdmVyL2kudGVzdChlKX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImlzQm90Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcn19KX0sODE2OTpmdW5jdGlvbihlLHQpeyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiByKGUpe2xldCB0PWUuaW5kZXhPZigiIyIpLHI9ZS5pbmRleE9mKCI/Iiksbj1yPi0xJiYodDwwfHxyPHQpO3JldHVybiBufHx0Pi0xP3twYXRobmFtZTplLnN1YnN0cmluZygwLG4/cjp0KSxxdWVyeTpuP2Uuc3Vic3RyaW5nKHIsdD4tMT90OnZvaWQgMCk6IiIsaGFzaDp0Pi0xP2Uuc2xpY2UodCk6IiJ9OntwYXRobmFtZTplLHF1ZXJ5OiIiLGhhc2g6IiJ9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwicGFyc2VQYXRoIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcn19KX0sOTc3OTpmdW5jdGlvbihlLHQpeyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiByKGUpe3JldHVybiBlLnJlcGxhY2UoL1wvJC8sIiIpfHwiLyJ9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJyZW1vdmVUcmFpbGluZ1NsYXNoIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcn19KX0sNzQwMzpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ITAsZ2V0OnRbcl19KX0odCx7U2VydmVySW5zZXJ0ZWRIVE1MQ29udGV4dDpmdW5jdGlvbigpe3JldHVybiBvfSx1c2VTZXJ2ZXJJbnNlcnRlZEhUTUw6ZnVuY3Rpb24oKXtyZXR1cm4gbH19KTtsZXQgbj1yKDU5MDkpLHU9bi5fKHIoNjAwNikpLG89dS5kZWZhdWx0LmNyZWF0ZUNvbnRleHQobnVsbCk7ZnVuY3Rpb24gbChlKXtsZXQgdD0oMCx1LnVzZUNvbnRleHQpKG8pO3QmJnQoZSl9fSwxMTU1OmZ1bmN0aW9uKGUsdCl7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiY3JlYXRlQXN5bmNMb2NhbFN0b3JhZ2UiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBvfX0pO2xldCByPUVycm9yKCJJbnZhcmlhbnQ6IEFzeW5jTG9jYWxTdG9yYWdlIGFjY2Vzc2VkIGluIHJ1bnRpbWUgd2hlcmUgaXQgaXMgbm90IGF2YWlsYWJsZSIpO2NsYXNzIG57ZGlzYWJsZSgpe3Rocm93IHJ9Z2V0U3RvcmUoKXt9cnVuKCl7dGhyb3cgcn1leGl0KCl7dGhyb3cgcn1lbnRlcldpdGgoKXt0aHJvdyByfX1sZXQgdT1nbG9iYWxUaGlzLkFzeW5jTG9jYWxTdG9yYWdlO2Z1bmN0aW9uIG8oKXtyZXR1cm4gdT9uZXcgdTpuZXcgbn0oImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSwzNDc0OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJyZXF1ZXN0QXN5bmNTdG9yYWdlIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdX19KTtsZXQgbj1yKDExNTUpLHU9KDAsbi5jcmVhdGVBc3luY0xvY2FsU3RvcmFnZSkoKTsoImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSwxMDYyOmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdX19KTtsZXQgbj1yKDExNTUpLHU9KDAsbi5jcmVhdGVBc3luY0xvY2FsU3RvcmFnZSkoKTsoImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSwzMTk0OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7dmFyIG49cig4NDMxKTt0LmNyZWF0ZVJvb3Q9bi5jcmVhdGVSb290LHQuaHlkcmF0ZVJvb3Q9bi5oeWRyYXRlUm9vdH0sODQzMTpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiOyFmdW5jdGlvbiBlKCl7aWYoInVuZGVmaW5lZCIhPXR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18mJiJmdW5jdGlvbiI9PXR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UpdHJ5e19fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRShlKX1jYXRjaChlKXtjb25zb2xlLmVycm9yKGUpfX0oKSxlLmV4cG9ydHM9cigyNjE0KX0sMjY3MjpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiOy8qKgogKiBAbGljZW5zZSBSZWFjdAogKiByZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2stY2xpZW50LmJyb3dzZXIucHJvZHVjdGlvbi5taW4uanMKICoKICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy4KICoKICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlCiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4KICovdmFyIG49cig4NDMxKSx1PXIoNjAwNiksbz17c3RyZWFtOiEwfSxsPW5ldyBNYXA7ZnVuY3Rpb24gYShlKXt2YXIgdD1nbG9iYWxUaGlzLl9fbmV4dF9yZXF1aXJlX18oZSk7cmV0dXJuImZ1bmN0aW9uIiE9dHlwZW9mIHQudGhlbnx8ImZ1bGZpbGxlZCI9PT10LnN0YXR1cz9udWxsOih0LnRoZW4oZnVuY3Rpb24oZSl7dC5zdGF0dXM9ImZ1bGZpbGxlZCIsdC52YWx1ZT1lfSxmdW5jdGlvbihlKXt0LnN0YXR1cz0icmVqZWN0ZWQiLHQucmVhc29uPWV9KSx0KX1mdW5jdGlvbiBpKCl7fXZhciBjPW4uX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQuRGlzcGF0Y2hlcixzPVN5bWJvbC5mb3IoInJlYWN0LmVsZW1lbnQiKSxmPVN5bWJvbC5mb3IoInJlYWN0LmxhenkiKSxkPVN5bWJvbC5mb3IoInJlYWN0LmRlZmF1bHRfdmFsdWUiKSxwPVN5bWJvbC5pdGVyYXRvcixoPUFycmF5LmlzQXJyYXksXz1uZXcgV2Vha01hcCx5PXUuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQuQ29udGV4dFJlZ2lzdHJ5O2Z1bmN0aW9uIGIoZSx0LHIsbil7dGhpcy5zdGF0dXM9ZSx0aGlzLnZhbHVlPXQsdGhpcy5yZWFzb249cix0aGlzLl9yZXNwb25zZT1ufWZ1bmN0aW9uIHYoZSl7c3dpdGNoKGUuc3RhdHVzKXtjYXNlInJlc29sdmVkX21vZGVsIjpqKGUpO2JyZWFrO2Nhc2UicmVzb2x2ZWRfbW9kdWxlIjpTKGUpfXN3aXRjaChlLnN0YXR1cyl7Y2FzZSJmdWxmaWxsZWQiOnJldHVybiBlLnZhbHVlO2Nhc2UicGVuZGluZyI6Y2FzZSJibG9ja2VkIjp0aHJvdyBlO2RlZmF1bHQ6dGhyb3cgZS5yZWFzb259fWZ1bmN0aW9uIG0oZSx0KXtmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKykoMCxlW3JdKSh0KX1mdW5jdGlvbiBnKGUsdCxyKXtzd2l0Y2goZS5zdGF0dXMpe2Nhc2UiZnVsZmlsbGVkIjptKHQsZS52YWx1ZSk7YnJlYWs7Y2FzZSJwZW5kaW5nIjpjYXNlImJsb2NrZWQiOmUudmFsdWU9dCxlLnJlYXNvbj1yO2JyZWFrO2Nhc2UicmVqZWN0ZWQiOnImJm0ocixlLnJlYXNvbil9fWZ1bmN0aW9uIE8oZSx0KXtpZigicGVuZGluZyI9PT1lLnN0YXR1c3x8ImJsb2NrZWQiPT09ZS5zdGF0dXMpe3ZhciByPWUucmVhc29uO2Uuc3RhdHVzPSJyZWplY3RlZCIsZS5yZWFzb249dCxudWxsIT09ciYmbShyLHQpfX1mdW5jdGlvbiBQKGUsdCl7aWYoInBlbmRpbmciPT09ZS5zdGF0dXN8fCJibG9ja2VkIj09PWUuc3RhdHVzKXt2YXIgcj1lLnZhbHVlLG49ZS5yZWFzb247ZS5zdGF0dXM9InJlc29sdmVkX21vZHVsZSIsZS52YWx1ZT10LG51bGwhPT1yJiYoUyhlKSxnKGUscixuKSl9fWIucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoUHJvbWlzZS5wcm90b3R5cGUpLGIucHJvdG90eXBlLnRoZW49ZnVuY3Rpb24oZSx0KXtzd2l0Y2godGhpcy5zdGF0dXMpe2Nhc2UicmVzb2x2ZWRfbW9kZWwiOmoodGhpcyk7YnJlYWs7Y2FzZSJyZXNvbHZlZF9tb2R1bGUiOlModGhpcyl9c3dpdGNoKHRoaXMuc3RhdHVzKXtjYXNlImZ1bGZpbGxlZCI6ZSh0aGlzLnZhbHVlKTticmVhaztjYXNlInBlbmRpbmciOmNhc2UiYmxvY2tlZCI6ZSYmKG51bGw9PT10aGlzLnZhbHVlJiYodGhpcy52YWx1ZT1bXSksdGhpcy52YWx1ZS5wdXNoKGUpKSx0JiYobnVsbD09PXRoaXMucmVhc29uJiYodGhpcy5yZWFzb249W10pLHRoaXMucmVhc29uLnB1c2godCkpO2JyZWFrO2RlZmF1bHQ6dCh0aGlzLnJlYXNvbil9fTt2YXIgRT1udWxsLFI9bnVsbDtmdW5jdGlvbiBqKGUpe3ZhciB0PUUscj1SO0U9ZSxSPW51bGw7dHJ5e3ZhciBuPUpTT04ucGFyc2UoZS52YWx1ZSxlLl9yZXNwb25zZS5fZnJvbUpTT04pO251bGwhPT1SJiYwPFIuZGVwcz8oUi52YWx1ZT1uLGUuc3RhdHVzPSJibG9ja2VkIixlLnZhbHVlPW51bGwsZS5yZWFzb249bnVsbCk6KGUuc3RhdHVzPSJmdWxmaWxsZWQiLGUudmFsdWU9bil9Y2F0Y2godCl7ZS5zdGF0dXM9InJlamVjdGVkIixlLnJlYXNvbj10fWZpbmFsbHl7RT10LFI9cn19ZnVuY3Rpb24gUyhlKXt0cnl7dmFyIHQ9ZS52YWx1ZSxyPWdsb2JhbFRoaXMuX19uZXh0X3JlcXVpcmVfXyh0LmlkKTtpZih0LmFzeW5jJiYiZnVuY3Rpb24iPT10eXBlb2Ygci50aGVuKXtpZigiZnVsZmlsbGVkIj09PXIuc3RhdHVzKXI9ci52YWx1ZTtlbHNlIHRocm93IHIucmVhc29ufXZhciBuPSIqIj09PXQubmFtZT9yOiIiPT09dC5uYW1lP3IuX19lc01vZHVsZT9yLmRlZmF1bHQ6cjpyW3QubmFtZV07ZS5zdGF0dXM9ImZ1bGZpbGxlZCIsZS52YWx1ZT1ufWNhdGNoKHQpe2Uuc3RhdHVzPSJyZWplY3RlZCIsZS5yZWFzb249dH19ZnVuY3Rpb24gVChlLHQpe2UuX2NodW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGUpeyJwZW5kaW5nIj09PWUuc3RhdHVzJiZPKGUsdCl9KX1mdW5jdGlvbiBNKGUsdCl7dmFyIHI9ZS5fY2h1bmtzLG49ci5nZXQodCk7cmV0dXJuIG58fChuPW5ldyBiKCJwZW5kaW5nIixudWxsLG51bGwsZSksci5zZXQodCxuKSksbn1mdW5jdGlvbiB3KGUsdCl7aWYoInJlc29sdmVkX21vZGVsIj09PShlPU0oZSx0KSkuc3RhdHVzJiZqKGUpLCJmdWxmaWxsZWQiPT09ZS5zdGF0dXMpcmV0dXJuIGUudmFsdWU7dGhyb3cgZS5yZWFzb259ZnVuY3Rpb24gQygpe3Rocm93IEVycm9yKCdUcnlpbmcgdG8gY2FsbCBhIGZ1bmN0aW9uIGZyb20gInVzZSBzZXJ2ZXIiIGJ1dCB0aGUgY2FsbFNlcnZlciBvcHRpb24gd2FzIG5vdCBpbXBsZW1lbnRlZCBpbiB5b3VyIHJvdXRlciBydW50aW1lLicpfWZ1bmN0aW9uIHgoZSx0KXt2YXIgcjtyZXR1cm4oZT17X2J1bmRsZXJDb25maWc6ZSxfY2FsbFNlcnZlcjp2b2lkIDAhPT10P3Q6QyxfY2h1bmtzOm5ldyBNYXAsX3N0cmluZ0RlY29kZXI6bmV3IFRleHREZWNvZGVyLF9mcm9tSlNPTjpudWxsLF9yb3dTdGF0ZTowLF9yb3dJRDowLF9yb3dUYWc6MCxfcm93TGVuZ3RoOjAsX2J1ZmZlcjpbXX0pLl9mcm9tSlNPTj0ocj1lLGZ1bmN0aW9uKGUsdCl7cmV0dXJuInN0cmluZyI9PXR5cGVvZiB0P2Z1bmN0aW9uKGUsdCxyLG4pe2lmKCIkIj09PW5bMF0pe2lmKCIkIj09PW4pcmV0dXJuIHM7c3dpdGNoKG5bMV0pe2Nhc2UiJCI6cmV0dXJuIG4uc2xpY2UoMSk7Y2FzZSJMIjpyZXR1cm57JCR0eXBlb2Y6ZixfcGF5bG9hZDplPU0oZSx0PXBhcnNlSW50KG4uc2xpY2UoMiksMTYpKSxfaW5pdDp2fTtjYXNlIkAiOnJldHVybiBNKGUsdD1wYXJzZUludChuLnNsaWNlKDIpLDE2KSk7Y2FzZSJTIjpyZXR1cm4gU3ltYm9sLmZvcihuLnNsaWNlKDIpKTtjYXNlIlAiOnJldHVybiB5W2U9bi5zbGljZSgyKV18fCh5W2VdPXUuY3JlYXRlU2VydmVyQ29udGV4dChlLGQpKSx5W2VdLlByb3ZpZGVyO2Nhc2UiRiI6cmV0dXJuIHQ9dyhlLHQ9cGFyc2VJbnQobi5zbGljZSgyKSwxNikpLGZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gcigpe3ZhciBlPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykscj10LmJvdW5kO3JldHVybiByPyJmdWxmaWxsZWQiPT09ci5zdGF0dXM/bih0LmlkLHIudmFsdWUuY29uY2F0KGUpKTpQcm9taXNlLnJlc29sdmUocikudGhlbihmdW5jdGlvbihyKXtyZXR1cm4gbih0LmlkLHIuY29uY2F0KGUpKX0pOm4odC5pZCxlKX12YXIgbj1lLl9jYWxsU2VydmVyO3JldHVybiBfLnNldChyLHQpLHJ9KGUsdCk7Y2FzZSJRIjpyZXR1cm4gZT13KGUsdD1wYXJzZUludChuLnNsaWNlKDIpLDE2KSksbmV3IE1hcChlKTtjYXNlIlciOnJldHVybiBlPXcoZSx0PXBhcnNlSW50KG4uc2xpY2UoMiksMTYpKSxuZXcgU2V0KGUpO2Nhc2UiSSI6cmV0dXJuIDEvMDtjYXNlIi0iOnJldHVybiIkLTAiPT09bj8tMDotMS8wO2Nhc2UiTiI6cmV0dXJuIE5hTjtjYXNlInUiOnJldHVybjtjYXNlIkQiOnJldHVybiBuZXcgRGF0ZShEYXRlLnBhcnNlKG4uc2xpY2UoMikpKTtjYXNlIm4iOnJldHVybiBCaWdJbnQobi5zbGljZSgyKSk7ZGVmYXVsdDpzd2l0Y2goKGU9TShlLG49cGFyc2VJbnQobi5zbGljZSgxKSwxNikpKS5zdGF0dXMpe2Nhc2UicmVzb2x2ZWRfbW9kZWwiOmooZSk7YnJlYWs7Y2FzZSJyZXNvbHZlZF9tb2R1bGUiOlMoZSl9c3dpdGNoKGUuc3RhdHVzKXtjYXNlImZ1bGZpbGxlZCI6cmV0dXJuIGUudmFsdWU7Y2FzZSJwZW5kaW5nIjpjYXNlImJsb2NrZWQiOnZhciBvO3JldHVybiBuPUUsZS50aGVuKGZ1bmN0aW9uKGUsdCxyKXtpZihSKXt2YXIgbj1SO24uZGVwcysrfWVsc2Ugbj1SPXtkZXBzOjEsdmFsdWU6bnVsbH07cmV0dXJuIGZ1bmN0aW9uKHUpe3Rbcl09dSxuLmRlcHMtLSwwPT09bi5kZXBzJiYiYmxvY2tlZCI9PT1lLnN0YXR1cyYmKHU9ZS52YWx1ZSxlLnN0YXR1cz0iZnVsZmlsbGVkIixlLnZhbHVlPW4udmFsdWUsbnVsbCE9PXUmJm0odSxuLnZhbHVlKSl9fShuLHQsciksKG89bixmdW5jdGlvbihlKXtyZXR1cm4gTyhvLGUpfSkpLG51bGw7ZGVmYXVsdDp0aHJvdyBlLnJlYXNvbn19fXJldHVybiBufShyLHRoaXMsZSx0KToib2JqZWN0Ij09dHlwZW9mIHQmJm51bGwhPT10P2U9dFswXT09PXM/eyQkdHlwZW9mOnMsdHlwZTp0WzFdLGtleTp0WzJdLHJlZjpudWxsLHByb3BzOnRbM10sX293bmVyOm51bGx9OnQ6dH0pLGV9ZnVuY3Rpb24gQShlLHQpe2Z1bmN0aW9uIHIodCl7VChlLHQpfXZhciBuPXQuZ2V0UmVhZGVyKCk7bi5yZWFkKCkudGhlbihmdW5jdGlvbiB0KHUpe3ZhciBzPXUudmFsdWU7aWYodS5kb25lKVQoZSxFcnJvcigiQ29ubmVjdGlvbiBjbG9zZWQuIikpO2Vsc2V7dmFyIGY9MCxkPWUuX3Jvd1N0YXRlLHA9ZS5fcm93SUQsaD1lLl9yb3dUYWcsXz1lLl9yb3dMZW5ndGg7dT1lLl9idWZmZXI7Zm9yKHZhciB5PXMubGVuZ3RoO2Y8eTspe3ZhciB2PS0xO3N3aXRjaChkKXtjYXNlIDA6NTg9PT0odj1zW2YrK10pP2Q9MTpwPXA8PDR8KDk2PHY/di04Nzp2LTQ4KTtjb250aW51ZTtjYXNlIDE6ODQ9PT0oZD1zW2ZdKT8oaD1kLGQ9MixmKyspOjY0PGQmJjkxPmQ/KGg9ZCxkPTMsZisrKTooaD0wLGQ9Myk7Y29udGludWU7Y2FzZSAyOjQ0PT09KHY9c1tmKytdKT9kPTQ6Xz1fPDw0fCg5Njx2P3YtODc6di00OCk7Y29udGludWU7Y2FzZSAzOnY9cy5pbmRleE9mKDEwLGYpO2JyZWFrO2Nhc2UgNDoodj1mK18pPnMubGVuZ3RoJiYodj0tMSl9dmFyIG09cy5ieXRlT2Zmc2V0K2Y7aWYoLTE8dil7Zj1uZXcgVWludDhBcnJheShzLmJ1ZmZlcixtLHYtZiksXz1lLG09aDt2YXIgRT1fLl9zdHJpbmdEZWNvZGVyO2g9IiI7Zm9yKHZhciBSPTA7Ujx1Lmxlbmd0aDtSKyspaCs9RS5kZWNvZGUodVtSXSxvKTtzd2l0Y2goaCs9RS5kZWNvZGUoZiksbSl7Y2FzZSA3MzohZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWUuX2NodW5rcyx1PW4uZ2V0KHQpO3I9SlNPTi5wYXJzZShyLGUuX2Zyb21KU09OKTt2YXIgbz1mdW5jdGlvbihlLHQpe2lmKGUpe3ZhciByPWVbdC5pZF07aWYoZT1yW3QubmFtZV0pcj1lLm5hbWU7ZWxzZXtpZighKGU9clsiKiJdKSl0aHJvdyBFcnJvcignQ291bGQgbm90IGZpbmQgdGhlIG1vZHVsZSAiJyt0LmlkKyciIGluIHRoZSBSZWFjdCBTU1IgTWFuaWZlc3QuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gdGhlIFJlYWN0IFNlcnZlciBDb21wb25lbnRzIGJ1bmRsZXIuJyk7cj10Lm5hbWV9cmV0dXJue2lkOmUuaWQsY2h1bmtzOmUuY2h1bmtzLG5hbWU6cixhc3luYzohIXQuYXN5bmN9fXJldHVybiB0fShlLl9idW5kbGVyQ29uZmlnLHIpO2lmKHI9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWUuY2h1bmtzLHI9W10sbj0wO248dC5sZW5ndGg7bisrKXt2YXIgdT10W25dLG89bC5nZXQodSk7aWYodm9pZCAwPT09byl7bz1nbG9iYWxUaGlzLl9fbmV4dF9jaHVua19sb2FkX18odSksci5wdXNoKG8pO3ZhciBjPWwuc2V0LmJpbmQobCx1LG51bGwpO28udGhlbihjLGkpLGwuc2V0KHUsbyl9ZWxzZSBudWxsIT09byYmci5wdXNoKG8pfXJldHVybiBlLmFzeW5jPzA9PT1yLmxlbmd0aD9hKGUuaWQpOlByb21pc2UuYWxsKHIpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYShlLmlkKX0pOjA8ci5sZW5ndGg/UHJvbWlzZS5hbGwocik6bnVsbH0obykpe2lmKHUpe3ZhciBjPXU7Yy5zdGF0dXM9ImJsb2NrZWQifWVsc2UgYz1uZXcgYigiYmxvY2tlZCIsbnVsbCxudWxsLGUpLG4uc2V0KHQsYyk7ci50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIFAoYyxvKX0sZnVuY3Rpb24oZSl7cmV0dXJuIE8oYyxlKX0pfWVsc2UgdT9QKHUsbyk6bi5zZXQodCxuZXcgYigicmVzb2x2ZWRfbW9kdWxlIixvLG51bGwsZSkpfShfLHAsaCk7YnJlYWs7Y2FzZSA3MjppZihwPWhbMF0sXz1KU09OLnBhcnNlKGg9aC5zbGljZSgxKSxfLl9mcm9tSlNPTiksaD12b2lkIDAsbT1jLmN1cnJlbnQpc3dpdGNoKCJzdHJpbmciPT10eXBlb2YgXz9mPV86KGY9X1swXSxoPV9bMV0pLHApe2Nhc2UiRCI6bS5wcmVmZXRjaEROUyhmLGgpO2JyZWFrO2Nhc2UiQyI6bS5wcmVjb25uZWN0KGYsaCk7YnJlYWs7Y2FzZSJMIjptLnByZWxvYWQoZixoKTticmVhaztjYXNlIkkiOm0ucHJlaW5pdChmLGgpfWJyZWFrO2Nhc2UgNjk6Zj0oaD1KU09OLnBhcnNlKGgpKS5kaWdlc3QsKGg9RXJyb3IoIkFuIGVycm9yIG9jY3VycmVkIGluIHRoZSBTZXJ2ZXIgQ29tcG9uZW50cyByZW5kZXIuIFRoZSBzcGVjaWZpYyBtZXNzYWdlIGlzIG9taXR0ZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMgdG8gYXZvaWQgbGVha2luZyBzZW5zaXRpdmUgZGV0YWlscy4gQSBkaWdlc3QgcHJvcGVydHkgaXMgaW5jbHVkZWQgb24gdGhpcyBlcnJvciBpbnN0YW5jZSB3aGljaCBtYXkgcHJvdmlkZSBhZGRpdGlvbmFsIGRldGFpbHMgYWJvdXQgdGhlIG5hdHVyZSBvZiB0aGUgZXJyb3IuIikpLnN0YWNrPSJFcnJvcjogIitoLm1lc3NhZ2UsaC5kaWdlc3Q9ZiwobT0oZj1fLl9jaHVua3MpLmdldChwKSk/TyhtLGgpOmYuc2V0KHAsbmV3IGIoInJlamVjdGVkIixudWxsLGgsXykpO2JyZWFrO2Nhc2UgODQ6Xy5fY2h1bmtzLnNldChwLG5ldyBiKCJmdWxmaWxsZWQiLGgsbnVsbCxfKSk7YnJlYWs7ZGVmYXVsdDoobT0oZj1fLl9jaHVua3MpLmdldChwKSk/KF89bSxwPWgsInBlbmRpbmciPT09Xy5zdGF0dXMmJihoPV8udmFsdWUsZj1fLnJlYXNvbixfLnN0YXR1cz0icmVzb2x2ZWRfbW9kZWwiLF8udmFsdWU9cCxudWxsIT09aCYmKGooXyksZyhfLGgsZikpKSk6Zi5zZXQocCxuZXcgYigicmVzb2x2ZWRfbW9kZWwiLGgsbnVsbCxfKSl9Zj12LDM9PT1kJiZmKyssXz1wPWg9ZD0wLHUubGVuZ3RoPTB9ZWxzZXtzPW5ldyBVaW50OEFycmF5KHMuYnVmZmVyLG0scy5ieXRlTGVuZ3RoLWYpLHUucHVzaChzKSxfLT1zLmJ5dGVMZW5ndGg7YnJlYWt9fXJldHVybiBlLl9yb3dTdGF0ZT1kLGUuX3Jvd0lEPXAsZS5fcm93VGFnPWgsZS5fcm93TGVuZ3RoPV8sbi5yZWFkKCkudGhlbih0KS5jYXRjaChyKX19KS5jYXRjaChyKX10LmNyZWF0ZUZyb21GZXRjaD1mdW5jdGlvbihlLHQpe3ZhciByPXgobnVsbCx0JiZ0LmNhbGxTZXJ2ZXI/dC5jYWxsU2VydmVyOnZvaWQgMCk7cmV0dXJuIGUudGhlbihmdW5jdGlvbihlKXtBKHIsZS5ib2R5KX0sZnVuY3Rpb24oZSl7VChyLGUpfSksTShyLDApfSx0LmNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbT1mdW5jdGlvbihlLHQpe3JldHVybiBBKHQ9eChudWxsLHQmJnQuY2FsbFNlcnZlcj90LmNhbGxTZXJ2ZXI6dm9pZCAwKSxlKSxNKHQsMCl9LHQuY3JlYXRlU2VydmVyUmVmZXJlbmNlPWZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gcigpe3ZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7cmV0dXJuIHQoZSxyKX1yZXR1cm4gXy5zZXQocix7aWQ6ZSxib3VuZDpudWxsfSkscn0sdC5lbmNvZGVSZXBseT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24odCxyKXt2YXIgbix1LG8sbDt1PTEsbz0wLGw9bnVsbCxuPUpTT04uc3RyaW5naWZ5KG49ZSxmdW5jdGlvbiBlKG4sYSl7aWYobnVsbD09PWEpcmV0dXJuIG51bGw7aWYoIm9iamVjdCI9PXR5cGVvZiBhKXtpZigiZnVuY3Rpb24iPT10eXBlb2YgYS50aGVuKXtudWxsPT09bCYmKGw9bmV3IEZvcm1EYXRhKSxvKys7dmFyIGksYyxzPXUrKztyZXR1cm4gYS50aGVuKGZ1bmN0aW9uKHIpe3I9SlNPTi5zdHJpbmdpZnkocixlKTt2YXIgbj1sO24uYXBwZW5kKCIiK3MsciksMD09LS1vJiZ0KG4pfSxmdW5jdGlvbihlKXtyKGUpfSksIiRAIitzLnRvU3RyaW5nKDE2KX1pZihhIGluc3RhbmNlb2YgRm9ybURhdGEpe251bGw9PT1sJiYobD1uZXcgRm9ybURhdGEpO3ZhciBmPWwsZD0iIisobj11KyspKyJfIjtyZXR1cm4gYS5mb3JFYWNoKGZ1bmN0aW9uKGUsdCl7Zi5hcHBlbmQoZCt0LGUpfSksIiRLIituLnRvU3RyaW5nKDE2KX1yZXR1cm4gYSBpbnN0YW5jZW9mIE1hcD8oYT1KU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKGEpLGUpLG51bGw9PT1sJiYobD1uZXcgRm9ybURhdGEpLG49dSsrLGwuYXBwZW5kKCIiK24sYSksIiRRIituLnRvU3RyaW5nKDE2KSk6YSBpbnN0YW5jZW9mIFNldD8oYT1KU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKGEpLGUpLG51bGw9PT1sJiYobD1uZXcgRm9ybURhdGEpLG49dSsrLGwuYXBwZW5kKCIiK24sYSksIiRXIituLnRvU3RyaW5nKDE2KSk6IWgoYSkmJihudWxsPT09KGM9YSl8fCJvYmplY3QiIT10eXBlb2YgYz9udWxsOiJmdW5jdGlvbiI9PXR5cGVvZihjPXAmJmNbcF18fGNbIkBAaXRlcmF0b3IiXSk/YzpudWxsKT9BcnJheS5mcm9tKGEpOmF9aWYoInN0cmluZyI9PXR5cGVvZiBhKXJldHVybiJaIj09PWFbYS5sZW5ndGgtMV0mJnRoaXNbbl1pbnN0YW5jZW9mIERhdGU/IiREIithOmE9IiQiPT09YVswXT8iJCIrYTphO2lmKCJib29sZWFuIj09dHlwZW9mIGEpcmV0dXJuIGE7aWYoIm51bWJlciI9PXR5cGVvZiBhKXJldHVybiBOdW1iZXIuaXNGaW5pdGUoaT1hKT8wPT09aSYmLTEvMD09MS9pPyIkLTAiOmk6MS8wPT09aT8iJEluZmluaXR5IjotMS8wPT09aT8iJC1JbmZpbml0eSI6IiROYU4iO2lmKHZvaWQgMD09PWEpcmV0dXJuIiR1bmRlZmluZWQiO2lmKCJmdW5jdGlvbiI9PXR5cGVvZiBhKXtpZih2b2lkIDAhPT0oYT1fLmdldChhKSkpcmV0dXJuIGE9SlNPTi5zdHJpbmdpZnkoYSxlKSxudWxsPT09bCYmKGw9bmV3IEZvcm1EYXRhKSxuPXUrKyxsLnNldCgiIituLGEpLCIkRiIrbi50b1N0cmluZygxNik7dGhyb3cgRXJyb3IoIkNsaWVudCBGdW5jdGlvbnMgY2Fubm90IGJlIHBhc3NlZCBkaXJlY3RseSB0byBTZXJ2ZXIgRnVuY3Rpb25zLiBPbmx5IEZ1bmN0aW9ucyBwYXNzZWQgZnJvbSB0aGUgU2VydmVyIGNhbiBiZSBwYXNzZWQgYmFjayBhZ2Fpbi4iKX1pZigic3ltYm9sIj09dHlwZW9mIGEpe2lmKFN5bWJvbC5mb3Iobj1hLmRlc2NyaXB0aW9uKSE9PWEpdGhyb3cgRXJyb3IoIk9ubHkgZ2xvYmFsIHN5bWJvbHMgcmVjZWl2ZWQgZnJvbSBTeW1ib2wuZm9yKC4uLikgY2FuIGJlIHBhc3NlZCB0byBTZXJ2ZXIgRnVuY3Rpb25zLiBUaGUgc3ltYm9sIFN5bWJvbC5mb3IoIithLmRlc2NyaXB0aW9uKyIpIGNhbm5vdCBiZSBmb3VuZCBhbW9uZyBnbG9iYWwgc3ltYm9scy4iKTtyZXR1cm4iJFMiK259aWYoImJpZ2ludCI9PXR5cGVvZiBhKXJldHVybiIkbiIrYS50b1N0cmluZygxMCk7dGhyb3cgRXJyb3IoIlR5cGUgIit0eXBlb2YgYSsiIGlzIG5vdCBzdXBwb3J0ZWQgYXMgYW4gYXJndW1lbnQgdG8gYSBTZXJ2ZXIgRnVuY3Rpb24uIil9KSxudWxsPT09bD90KG4pOihsLnNldCgiMCIsbiksMD09PW8mJnQobCkpfSl9fSwzNDg4OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7ZS5leHBvcnRzPXIoMjY3Mil9LDU0NTY6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtlLmV4cG9ydHM9cigzNDg4KX0sODExMDpmdW5jdGlvbihlLHQpeyJ1c2Ugc3RyaWN0IjsvKioKICogQGxpY2Vuc2UgUmVhY3QKICogcmVhY3QucHJvZHVjdGlvbi5taW4uanMKICoKICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy4KICoKICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlCiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4KICovdmFyIHI9U3ltYm9sLmZvcigicmVhY3QuZWxlbWVudCIpLG49U3ltYm9sLmZvcigicmVhY3QucG9ydGFsIiksdT1TeW1ib2wuZm9yKCJyZWFjdC5mcmFnbWVudCIpLG89U3ltYm9sLmZvcigicmVhY3Quc3RyaWN0X21vZGUiKSxsPVN5bWJvbC5mb3IoInJlYWN0LnByb2ZpbGVyIiksYT1TeW1ib2wuZm9yKCJyZWFjdC5wcm92aWRlciIpLGk9U3ltYm9sLmZvcigicmVhY3QuY29udGV4dCIpLGM9U3ltYm9sLmZvcigicmVhY3Quc2VydmVyX2NvbnRleHQiKSxzPVN5bWJvbC5mb3IoInJlYWN0LmZvcndhcmRfcmVmIiksZj1TeW1ib2wuZm9yKCJyZWFjdC5zdXNwZW5zZSIpLGQ9U3ltYm9sLmZvcigicmVhY3QubWVtbyIpLHA9U3ltYm9sLmZvcigicmVhY3QubGF6eSIpLGg9U3ltYm9sLmZvcigicmVhY3QuZGVmYXVsdF92YWx1ZSIpLF89U3ltYm9sLml0ZXJhdG9yLHk9e2lzTW91bnRlZDpmdW5jdGlvbigpe3JldHVybiExfSxlbnF1ZXVlRm9yY2VVcGRhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVSZXBsYWNlU3RhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbigpe319LGI9T2JqZWN0LmFzc2lnbix2PXt9O2Z1bmN0aW9uIG0oZSx0LHIpe3RoaXMucHJvcHM9ZSx0aGlzLmNvbnRleHQ9dCx0aGlzLnJlZnM9dix0aGlzLnVwZGF0ZXI9cnx8eX1mdW5jdGlvbiBnKCl7fWZ1bmN0aW9uIE8oZSx0LHIpe3RoaXMucHJvcHM9ZSx0aGlzLmNvbnRleHQ9dCx0aGlzLnJlZnM9dix0aGlzLnVwZGF0ZXI9cnx8eX1tLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50PXt9LG0ucHJvdG90eXBlLnNldFN0YXRlPWZ1bmN0aW9uKGUsdCl7aWYoIm9iamVjdCIhPXR5cGVvZiBlJiYiZnVuY3Rpb24iIT10eXBlb2YgZSYmbnVsbCE9ZSl0aHJvdyBFcnJvcigic2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuIik7dGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLGUsdCwic2V0U3RhdGUiKX0sbS5wcm90b3R5cGUuZm9yY2VVcGRhdGU9ZnVuY3Rpb24oZSl7dGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLGUsImZvcmNlVXBkYXRlIil9LGcucHJvdG90eXBlPW0ucHJvdG90eXBlO3ZhciBQPU8ucHJvdG90eXBlPW5ldyBnO1AuY29uc3RydWN0b3I9TyxiKFAsbS5wcm90b3R5cGUpLFAuaXNQdXJlUmVhY3RDb21wb25lbnQ9ITA7dmFyIEU9QXJyYXkuaXNBcnJheSxSPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksaj17Y3VycmVudDpudWxsfSxTPXtrZXk6ITAscmVmOiEwLF9fc2VsZjohMCxfX3NvdXJjZTohMH07ZnVuY3Rpb24gVChlLHQsbil7dmFyIHUsbz17fSxsPW51bGwsYT1udWxsO2lmKG51bGwhPXQpZm9yKHUgaW4gdm9pZCAwIT09dC5yZWYmJihhPXQucmVmKSx2b2lkIDAhPT10LmtleSYmKGw9IiIrdC5rZXkpLHQpUi5jYWxsKHQsdSkmJiFTLmhhc093blByb3BlcnR5KHUpJiYob1t1XT10W3VdKTt2YXIgaT1hcmd1bWVudHMubGVuZ3RoLTI7aWYoMT09PWkpby5jaGlsZHJlbj1uO2Vsc2UgaWYoMTxpKXtmb3IodmFyIGM9QXJyYXkoaSkscz0wO3M8aTtzKyspY1tzXT1hcmd1bWVudHNbcysyXTtvLmNoaWxkcmVuPWN9aWYoZSYmZS5kZWZhdWx0UHJvcHMpZm9yKHUgaW4gaT1lLmRlZmF1bHRQcm9wcyl2b2lkIDA9PT1vW3VdJiYob1t1XT1pW3VdKTtyZXR1cm57JCR0eXBlb2Y6cix0eXBlOmUsa2V5OmwscmVmOmEscHJvcHM6byxfb3duZXI6ai5jdXJyZW50fX1mdW5jdGlvbiBNKGUpe3JldHVybiJvYmplY3QiPT10eXBlb2YgZSYmbnVsbCE9PWUmJmUuJCR0eXBlb2Y9PT1yfXZhciB3PS9cLysvZztmdW5jdGlvbiBDKGUsdCl7dmFyIHIsbjtyZXR1cm4ib2JqZWN0Ij09dHlwZW9mIGUmJm51bGwhPT1lJiZudWxsIT1lLmtleT8ocj0iIitlLmtleSxuPXsiPSI6Ij0wIiwiOiI6Ij0yIn0sIiQiK3IucmVwbGFjZSgvWz06XS9nLGZ1bmN0aW9uKGUpe3JldHVybiBuW2VdfSkpOnQudG9TdHJpbmcoMzYpfWZ1bmN0aW9uIHgoZSx0LHUpe2lmKG51bGw9PWUpcmV0dXJuIGU7dmFyIG89W10sbD0wO3JldHVybiFmdW5jdGlvbiBlKHQsdSxvLGwsYSl7dmFyIGksYyxzLGY9dHlwZW9mIHQ7KCJ1bmRlZmluZWQiPT09Znx8ImJvb2xlYW4iPT09ZikmJih0PW51bGwpO3ZhciBkPSExO2lmKG51bGw9PT10KWQ9ITA7ZWxzZSBzd2l0Y2goZil7Y2FzZSJzdHJpbmciOmNhc2UibnVtYmVyIjpkPSEwO2JyZWFrO2Nhc2Uib2JqZWN0Ijpzd2l0Y2godC4kJHR5cGVvZil7Y2FzZSByOmNhc2UgbjpkPSEwfX1pZihkKXJldHVybiBhPWEoZD10KSx0PSIiPT09bD8iLiIrQyhkLDApOmwsRShhKT8obz0iIixudWxsIT10JiYobz10LnJlcGxhY2UodywiJCYvIikrIi8iKSxlKGEsdSxvLCIiLGZ1bmN0aW9uKGUpe3JldHVybiBlfSkpOm51bGwhPWEmJihNKGEpJiYoaT1hLGM9bysoIWEua2V5fHxkJiZkLmtleT09PWEua2V5PyIiOigiIithLmtleSkucmVwbGFjZSh3LCIkJi8iKSsiLyIpK3QsYT17JCR0eXBlb2Y6cix0eXBlOmkudHlwZSxrZXk6YyxyZWY6aS5yZWYscHJvcHM6aS5wcm9wcyxfb3duZXI6aS5fb3duZXJ9KSx1LnB1c2goYSkpLDE7aWYoZD0wLGw9IiI9PT1sPyIuIjpsKyI6IixFKHQpKWZvcih2YXIgcD0wO3A8dC5sZW5ndGg7cCsrKXtmPXRbcF07dmFyIGg9bCtDKGYscCk7ZCs9ZShmLHUsbyxoLGEpfWVsc2UgaWYoImZ1bmN0aW9uIj09dHlwZW9mKGg9bnVsbD09PShzPXQpfHwib2JqZWN0IiE9dHlwZW9mIHM/bnVsbDoiZnVuY3Rpb24iPT10eXBlb2Yocz1fJiZzW19dfHxzWyJAQGl0ZXJhdG9yIl0pP3M6bnVsbCkpZm9yKHQ9aC5jYWxsKHQpLHA9MDshKGY9dC5uZXh0KCkpLmRvbmU7KWg9bCtDKGY9Zi52YWx1ZSxwKyspLGQrPWUoZix1LG8saCxhKTtlbHNlIGlmKCJvYmplY3QiPT09Zil0aHJvdyBFcnJvcigiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAiKygiW29iamVjdCBPYmplY3RdIj09PSh1PVN0cmluZyh0KSk/Im9iamVjdCB3aXRoIGtleXMgeyIrT2JqZWN0LmtleXModCkuam9pbigiLCAiKSsifSI6dSkrIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC4iKTtyZXR1cm4gZH0oZSxvLCIiLCIiLGZ1bmN0aW9uKGUpe3JldHVybiB0LmNhbGwodSxlLGwrKyl9KSxvfWZ1bmN0aW9uIEEoZSl7aWYoLTE9PT1lLl9zdGF0dXMpe3ZhciB0PWUuX3Jlc3VsdDsodD10KCkpLnRoZW4oZnVuY3Rpb24odCl7KDA9PT1lLl9zdGF0dXN8fC0xPT09ZS5fc3RhdHVzKSYmKGUuX3N0YXR1cz0xLGUuX3Jlc3VsdD10KX0sZnVuY3Rpb24odCl7KDA9PT1lLl9zdGF0dXN8fC0xPT09ZS5fc3RhdHVzKSYmKGUuX3N0YXR1cz0yLGUuX3Jlc3VsdD10KX0pLC0xPT09ZS5fc3RhdHVzJiYoZS5fc3RhdHVzPTAsZS5fcmVzdWx0PXQpfWlmKDE9PT1lLl9zdGF0dXMpcmV0dXJuIGUuX3Jlc3VsdC5kZWZhdWx0O3Rocm93IGUuX3Jlc3VsdH12YXIgTj17Y3VycmVudDpudWxsfTtmdW5jdGlvbiBJKCl7cmV0dXJuIG5ldyBXZWFrTWFwfWZ1bmN0aW9uIEQoKXtyZXR1cm57czowLHY6dm9pZCAwLG86bnVsbCxwOm51bGx9fXZhciBrPXtjdXJyZW50Om51bGx9LEY9e3RyYW5zaXRpb246bnVsbH0sVT17UmVhY3RDdXJyZW50RGlzcGF0Y2hlcjprLFJlYWN0Q3VycmVudENhY2hlOk4sUmVhY3RDdXJyZW50QmF0Y2hDb25maWc6RixSZWFjdEN1cnJlbnRPd25lcjpqLENvbnRleHRSZWdpc3RyeTp7fX0sTD1VLkNvbnRleHRSZWdpc3RyeTt0LkNoaWxkcmVuPXttYXA6eCxmb3JFYWNoOmZ1bmN0aW9uKGUsdCxyKXt4KGUsZnVuY3Rpb24oKXt0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0scil9LGNvdW50OmZ1bmN0aW9uKGUpe3ZhciB0PTA7cmV0dXJuIHgoZSxmdW5jdGlvbigpe3QrK30pLHR9LHRvQXJyYXk6ZnVuY3Rpb24oZSl7cmV0dXJuIHgoZSxmdW5jdGlvbihlKXtyZXR1cm4gZX0pfHxbXX0sb25seTpmdW5jdGlvbihlKXtpZighTShlKSl0aHJvdyBFcnJvcigiUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuIik7cmV0dXJuIGV9fSx0LkNvbXBvbmVudD1tLHQuRnJhZ21lbnQ9dSx0LlByb2ZpbGVyPWwsdC5QdXJlQ29tcG9uZW50PU8sdC5TdHJpY3RNb2RlPW8sdC5TdXNwZW5zZT1mLHQuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ9VSx0LmNhY2hlPWZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbigpe3ZhciB0PU4uY3VycmVudDtpZighdClyZXR1cm4gZS5hcHBseShudWxsLGFyZ3VtZW50cyk7dmFyIHI9dC5nZXRDYWNoZUZvclR5cGUoSSk7dm9pZCAwPT09KHQ9ci5nZXQoZSkpJiYodD1EKCksci5zZXQoZSx0KSkscj0wO2Zvcih2YXIgbj1hcmd1bWVudHMubGVuZ3RoO3I8bjtyKyspe3ZhciB1PWFyZ3VtZW50c1tyXTtpZigiZnVuY3Rpb24iPT10eXBlb2YgdXx8Im9iamVjdCI9PXR5cGVvZiB1JiZudWxsIT09dSl7dmFyIG89dC5vO251bGw9PT1vJiYodC5vPW89bmV3IFdlYWtNYXApLHZvaWQgMD09PSh0PW8uZ2V0KHUpKSYmKHQ9RCgpLG8uc2V0KHUsdCkpfWVsc2UgbnVsbD09PShvPXQucCkmJih0LnA9bz1uZXcgTWFwKSx2b2lkIDA9PT0odD1vLmdldCh1KSkmJih0PUQoKSxvLnNldCh1LHQpKX1pZigxPT09dC5zKXJldHVybiB0LnY7aWYoMj09PXQucyl0aHJvdyB0LnY7dHJ5e3ZhciBsPWUuYXBwbHkobnVsbCxhcmd1bWVudHMpO3JldHVybihyPXQpLnM9MSxyLnY9bH1jYXRjaChlKXt0aHJvdyhsPXQpLnM9MixsLnY9ZSxlfX19LHQuY2xvbmVFbGVtZW50PWZ1bmN0aW9uKGUsdCxuKXtpZihudWxsPT1lKXRocm93IEVycm9yKCJSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCAiK2UrIi4iKTt2YXIgdT1iKHt9LGUucHJvcHMpLG89ZS5rZXksbD1lLnJlZixhPWUuX293bmVyO2lmKG51bGwhPXQpe2lmKHZvaWQgMCE9PXQucmVmJiYobD10LnJlZixhPWouY3VycmVudCksdm9pZCAwIT09dC5rZXkmJihvPSIiK3Qua2V5KSxlLnR5cGUmJmUudHlwZS5kZWZhdWx0UHJvcHMpdmFyIGk9ZS50eXBlLmRlZmF1bHRQcm9wcztmb3IoYyBpbiB0KVIuY2FsbCh0LGMpJiYhUy5oYXNPd25Qcm9wZXJ0eShjKSYmKHVbY109dm9pZCAwPT09dFtjXSYmdm9pZCAwIT09aT9pW2NdOnRbY10pfXZhciBjPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09Yyl1LmNoaWxkcmVuPW47ZWxzZSBpZigxPGMpe2k9QXJyYXkoYyk7Zm9yKHZhciBzPTA7czxjO3MrKylpW3NdPWFyZ3VtZW50c1tzKzJdO3UuY2hpbGRyZW49aX1yZXR1cm57JCR0eXBlb2Y6cix0eXBlOmUudHlwZSxrZXk6byxyZWY6bCxwcm9wczp1LF9vd25lcjphfX0sdC5jcmVhdGVDb250ZXh0PWZ1bmN0aW9uKGUpe3JldHVybihlPXskJHR5cGVvZjppLF9jdXJyZW50VmFsdWU6ZSxfY3VycmVudFZhbHVlMjplLF90aHJlYWRDb3VudDowLFByb3ZpZGVyOm51bGwsQ29uc3VtZXI6bnVsbCxfZGVmYXVsdFZhbHVlOm51bGwsX2dsb2JhbE5hbWU6bnVsbH0pLlByb3ZpZGVyPXskJHR5cGVvZjphLF9jb250ZXh0OmV9LGUuQ29uc3VtZXI9ZX0sdC5jcmVhdGVFbGVtZW50PVQsdC5jcmVhdGVGYWN0b3J5PWZ1bmN0aW9uKGUpe3ZhciB0PVQuYmluZChudWxsLGUpO3JldHVybiB0LnR5cGU9ZSx0fSx0LmNyZWF0ZVJlZj1mdW5jdGlvbigpe3JldHVybntjdXJyZW50Om51bGx9fSx0LmNyZWF0ZVNlcnZlckNvbnRleHQ9ZnVuY3Rpb24oZSx0KXt2YXIgcj0hMDtpZighTFtlXSl7cj0hMTt2YXIgbj17JCR0eXBlb2Y6YyxfY3VycmVudFZhbHVlOnQsX2N1cnJlbnRWYWx1ZTI6dCxfZGVmYXVsdFZhbHVlOnQsX3RocmVhZENvdW50OjAsUHJvdmlkZXI6bnVsbCxDb25zdW1lcjpudWxsLF9nbG9iYWxOYW1lOmV9O24uUHJvdmlkZXI9eyQkdHlwZW9mOmEsX2NvbnRleHQ6bn0sTFtlXT1ufWlmKChuPUxbZV0pLl9kZWZhdWx0VmFsdWU9PT1oKW4uX2RlZmF1bHRWYWx1ZT10LG4uX2N1cnJlbnRWYWx1ZT09PWgmJihuLl9jdXJyZW50VmFsdWU9dCksbi5fY3VycmVudFZhbHVlMj09PWgmJihuLl9jdXJyZW50VmFsdWUyPXQpO2Vsc2UgaWYocil0aHJvdyBFcnJvcigiU2VydmVyQ29udGV4dDogIitlKyIgYWxyZWFkeSBkZWZpbmVkIik7cmV0dXJuIG59LHQuZm9yd2FyZFJlZj1mdW5jdGlvbihlKXtyZXR1cm57JCR0eXBlb2Y6cyxyZW5kZXI6ZX19LHQuaXNWYWxpZEVsZW1lbnQ9TSx0Lmxhenk9ZnVuY3Rpb24oZSl7cmV0dXJueyQkdHlwZW9mOnAsX3BheWxvYWQ6e19zdGF0dXM6LTEsX3Jlc3VsdDplfSxfaW5pdDpBfX0sdC5tZW1vPWZ1bmN0aW9uKGUsdCl7cmV0dXJueyQkdHlwZW9mOmQsdHlwZTplLGNvbXBhcmU6dm9pZCAwPT09dD9udWxsOnR9fSx0LnN0YXJ0VHJhbnNpdGlvbj1mdW5jdGlvbihlKXt2YXIgdD1GLnRyYW5zaXRpb247Ri50cmFuc2l0aW9uPXt9O3RyeXtlKCl9ZmluYWxseXtGLnRyYW5zaXRpb249dH19LHQudW5zdGFibGVfYWN0PWZ1bmN0aW9uKCl7dGhyb3cgRXJyb3IoImFjdCguLi4pIGlzIG5vdCBzdXBwb3J0ZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMgb2YgUmVhY3QuIil9LHQudW5zdGFibGVfdXNlQ2FjaGVSZWZyZXNoPWZ1bmN0aW9uKCl7cmV0dXJuIGsuY3VycmVudC51c2VDYWNoZVJlZnJlc2goKX0sdC51c2U9ZnVuY3Rpb24oZSl7cmV0dXJuIGsuY3VycmVudC51c2UoZSl9LHQudXNlQ2FsbGJhY2s9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gay5jdXJyZW50LnVzZUNhbGxiYWNrKGUsdCl9LHQudXNlQ29udGV4dD1mdW5jdGlvbihlKXtyZXR1cm4gay5jdXJyZW50LnVzZUNvbnRleHQoZSl9LHQudXNlRGVidWdWYWx1ZT1mdW5jdGlvbigpe30sdC51c2VEZWZlcnJlZFZhbHVlPWZ1bmN0aW9uKGUpe3JldHVybiBrLmN1cnJlbnQudXNlRGVmZXJyZWRWYWx1ZShlKX0sdC51c2VFZmZlY3Q9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gay5jdXJyZW50LnVzZUVmZmVjdChlLHQpfSx0LnVzZUlkPWZ1bmN0aW9uKCl7cmV0dXJuIGsuY3VycmVudC51c2VJZCgpfSx0LnVzZUltcGVyYXRpdmVIYW5kbGU9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBrLmN1cnJlbnQudXNlSW1wZXJhdGl2ZUhhbmRsZShlLHQscil9LHQudXNlSW5zZXJ0aW9uRWZmZWN0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGsuY3VycmVudC51c2VJbnNlcnRpb25FZmZlY3QoZSx0KX0sdC51c2VMYXlvdXRFZmZlY3Q9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gay5jdXJyZW50LnVzZUxheW91dEVmZmVjdChlLHQpfSx0LnVzZU1lbW89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gay5jdXJyZW50LnVzZU1lbW8oZSx0KX0sdC51c2VSZWR1Y2VyPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gay5jdXJyZW50LnVzZVJlZHVjZXIoZSx0LHIpfSx0LnVzZVJlZj1mdW5jdGlvbihlKXtyZXR1cm4gay5jdXJyZW50LnVzZVJlZihlKX0sdC51c2VTdGF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gay5jdXJyZW50LnVzZVN0YXRlKGUpfSx0LnVzZVN5bmNFeHRlcm5hbFN0b3JlPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gay5jdXJyZW50LnVzZVN5bmNFeHRlcm5hbFN0b3JlKGUsdCxyKX0sdC51c2VUcmFuc2l0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGsuY3VycmVudC51c2VUcmFuc2l0aW9uKCl9LHQudmVyc2lvbj0iMTguMy4wLWNhbmFyeS05Mzc3ZTEwMTAtMjAyMzA3MTIifSw2MDA2OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7ZS5leHBvcnRzPXIoODExMCl9LDQyNDg6ZnVuY3Rpb24oZSx0KXsidXNlIHN0cmljdCI7LyoqCiAqIEBsaWNlbnNlIFJlYWN0CiAqIHNjaGVkdWxlci5wcm9kdWN0aW9uLm1pbi5qcwogKgogKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLgogKgogKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGUKICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLgogKi9mdW5jdGlvbiByKGUsdCl7dmFyIHI9ZS5sZW5ndGg7Zm9yKGUucHVzaCh0KTswPHI7KXt2YXIgbj1yLTE+Pj4xLHU9ZVtuXTtpZigwPG8odSx0KSllW25dPXQsZVtyXT11LHI9bjtlbHNlIGJyZWFrfX1mdW5jdGlvbiBuKGUpe3JldHVybiAwPT09ZS5sZW5ndGg/bnVsbDplWzBdfWZ1bmN0aW9uIHUoZSl7aWYoMD09PWUubGVuZ3RoKXJldHVybiBudWxsO3ZhciB0PWVbMF0scj1lLnBvcCgpO2lmKHIhPT10KXtlWzBdPXI7Zm9yKHZhciBuPTAsdT1lLmxlbmd0aCxsPXU+Pj4xO248bDspe3ZhciBhPTIqKG4rMSktMSxpPWVbYV0sYz1hKzEscz1lW2NdO2lmKDA+byhpLHIpKWM8dSYmMD5vKHMsaSk/KGVbbl09cyxlW2NdPXIsbj1jKTooZVtuXT1pLGVbYV09cixuPWEpO2Vsc2UgaWYoYzx1JiYwPm8ocyxyKSllW25dPXMsZVtjXT1yLG49YztlbHNlIGJyZWFrfX1yZXR1cm4gdH1mdW5jdGlvbiBvKGUsdCl7dmFyIHI9ZS5zb3J0SW5kZXgtdC5zb3J0SW5kZXg7cmV0dXJuIDAhPT1yP3I6ZS5pZC10LmlkfWlmKHQudW5zdGFibGVfbm93PXZvaWQgMCwib2JqZWN0Ij09dHlwZW9mIHBlcmZvcm1hbmNlJiYiZnVuY3Rpb24iPT10eXBlb2YgcGVyZm9ybWFuY2Uubm93KXt2YXIgbCxhPXBlcmZvcm1hbmNlO3QudW5zdGFibGVfbm93PWZ1bmN0aW9uKCl7cmV0dXJuIGEubm93KCl9fWVsc2V7dmFyIGk9RGF0ZSxjPWkubm93KCk7dC51bnN0YWJsZV9ub3c9ZnVuY3Rpb24oKXtyZXR1cm4gaS5ub3coKS1jfX12YXIgcz1bXSxmPVtdLGQ9MSxwPW51bGwsaD0zLF89ITEseT0hMSxiPSExLHY9ImZ1bmN0aW9uIj09dHlwZW9mIHNldFRpbWVvdXQ/c2V0VGltZW91dDpudWxsLG09ImZ1bmN0aW9uIj09dHlwZW9mIGNsZWFyVGltZW91dD9jbGVhclRpbWVvdXQ6bnVsbCxnPSJ1bmRlZmluZWQiIT10eXBlb2Ygc2V0SW1tZWRpYXRlP3NldEltbWVkaWF0ZTpudWxsO2Z1bmN0aW9uIE8oZSl7Zm9yKHZhciB0PW4oZik7bnVsbCE9PXQ7KXtpZihudWxsPT09dC5jYWxsYmFjayl1KGYpO2Vsc2UgaWYodC5zdGFydFRpbWU8PWUpdShmKSx0LnNvcnRJbmRleD10LmV4cGlyYXRpb25UaW1lLHIocyx0KTtlbHNlIGJyZWFrO3Q9bihmKX19ZnVuY3Rpb24gUChlKXtpZihiPSExLE8oZSksIXkpe2lmKG51bGwhPT1uKHMpKXk9ITAsTihFKTtlbHNle3ZhciB0PW4oZik7bnVsbCE9PXQmJkkoUCx0LnN0YXJ0VGltZS1lKX19fWZ1bmN0aW9uIEUoZSxyKXt5PSExLGImJihiPSExLG0oUyksUz0tMSksXz0hMDt2YXIgbz1oO3RyeXtlOntmb3IoTyhyKSxwPW4ocyk7bnVsbCE9PXAmJighKHAuZXhwaXJhdGlvblRpbWU+cil8fGUmJiF3KCkpOyl7dmFyIGw9cC5jYWxsYmFjaztpZigiZnVuY3Rpb24iPT10eXBlb2YgbCl7cC5jYWxsYmFjaz1udWxsLGg9cC5wcmlvcml0eUxldmVsO3ZhciBhPWwocC5leHBpcmF0aW9uVGltZTw9cik7aWYocj10LnVuc3RhYmxlX25vdygpLCJmdW5jdGlvbiI9PXR5cGVvZiBhKXtwLmNhbGxiYWNrPWEsTyhyKTt2YXIgaT0hMDticmVhayBlfXA9PT1uKHMpJiZ1KHMpLE8ocil9ZWxzZSB1KHMpO3A9bihzKX1pZihudWxsIT09cClpPSEwO2Vsc2V7dmFyIGM9bihmKTtudWxsIT09YyYmSShQLGMuc3RhcnRUaW1lLXIpLGk9ITF9fXJldHVybiBpfWZpbmFsbHl7cD1udWxsLGg9byxfPSExfX0idW5kZWZpbmVkIiE9dHlwZW9mIG5hdmlnYXRvciYmdm9pZCAwIT09bmF2aWdhdG9yLnNjaGVkdWxpbmcmJnZvaWQgMCE9PW5hdmlnYXRvci5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nJiZuYXZpZ2F0b3Iuc2NoZWR1bGluZy5pc0lucHV0UGVuZGluZy5iaW5kKG5hdmlnYXRvci5zY2hlZHVsaW5nKTt2YXIgUj0hMSxqPW51bGwsUz0tMSxUPTUsTT0tMTtmdW5jdGlvbiB3KCl7cmV0dXJuISh0LnVuc3RhYmxlX25vdygpLU08VCl9ZnVuY3Rpb24gQygpe2lmKG51bGwhPT1qKXt2YXIgZT10LnVuc3RhYmxlX25vdygpO009ZTt2YXIgcj0hMDt0cnl7cj1qKCEwLGUpfWZpbmFsbHl7cj9sKCk6KFI9ITEsaj1udWxsKX19ZWxzZSBSPSExfWlmKCJmdW5jdGlvbiI9PXR5cGVvZiBnKWw9ZnVuY3Rpb24oKXtnKEMpfTtlbHNlIGlmKCJ1bmRlZmluZWQiIT10eXBlb2YgTWVzc2FnZUNoYW5uZWwpe3ZhciB4PW5ldyBNZXNzYWdlQ2hhbm5lbCxBPXgucG9ydDI7eC5wb3J0MS5vbm1lc3NhZ2U9QyxsPWZ1bmN0aW9uKCl7QS5wb3N0TWVzc2FnZShudWxsKX19ZWxzZSBsPWZ1bmN0aW9uKCl7dihDLDApfTtmdW5jdGlvbiBOKGUpe2o9ZSxSfHwoUj0hMCxsKCkpfWZ1bmN0aW9uIEkoZSxyKXtTPXYoZnVuY3Rpb24oKXtlKHQudW5zdGFibGVfbm93KCkpfSxyKX10LnVuc3RhYmxlX0lkbGVQcmlvcml0eT01LHQudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHk9MSx0LnVuc3RhYmxlX0xvd1ByaW9yaXR5PTQsdC51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eT0zLHQudW5zdGFibGVfUHJvZmlsaW5nPW51bGwsdC51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eT0yLHQudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2s9ZnVuY3Rpb24oZSl7ZS5jYWxsYmFjaz1udWxsfSx0LnVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uPWZ1bmN0aW9uKCl7eXx8X3x8KHk9ITAsTihFKSl9LHQudW5zdGFibGVfZm9yY2VGcmFtZVJhdGU9ZnVuY3Rpb24oZSl7MD5lfHwxMjU8ZT9jb25zb2xlLmVycm9yKCJmb3JjZUZyYW1lUmF0ZSB0YWtlcyBhIHBvc2l0aXZlIGludCBiZXR3ZWVuIDAgYW5kIDEyNSwgZm9yY2luZyBmcmFtZSByYXRlcyBoaWdoZXIgdGhhbiAxMjUgZnBzIGlzIG5vdCBzdXBwb3J0ZWQiKTpUPTA8ZT9NYXRoLmZsb29yKDFlMy9lKTo1fSx0LnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsPWZ1bmN0aW9uKCl7cmV0dXJuIGh9LHQudW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGU9ZnVuY3Rpb24oKXtyZXR1cm4gbihzKX0sdC51bnN0YWJsZV9uZXh0PWZ1bmN0aW9uKGUpe3N3aXRjaChoKXtjYXNlIDE6Y2FzZSAyOmNhc2UgMzp2YXIgdD0zO2JyZWFrO2RlZmF1bHQ6dD1ofXZhciByPWg7aD10O3RyeXtyZXR1cm4gZSgpfWZpbmFsbHl7aD1yfX0sdC51bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbj1mdW5jdGlvbigpe30sdC51bnN0YWJsZV9yZXF1ZXN0UGFpbnQ9ZnVuY3Rpb24oKXt9LHQudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5PWZ1bmN0aW9uKGUsdCl7c3dpdGNoKGUpe2Nhc2UgMTpjYXNlIDI6Y2FzZSAzOmNhc2UgNDpjYXNlIDU6YnJlYWs7ZGVmYXVsdDplPTN9dmFyIHI9aDtoPWU7dHJ5e3JldHVybiB0KCl9ZmluYWxseXtoPXJ9fSx0LnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2s9ZnVuY3Rpb24oZSx1LG8pe3ZhciBsPXQudW5zdGFibGVfbm93KCk7c3dpdGNoKG89Im9iamVjdCI9PXR5cGVvZiBvJiZudWxsIT09byYmIm51bWJlciI9PXR5cGVvZihvPW8uZGVsYXkpJiYwPG8/bCtvOmwsZSl7Y2FzZSAxOnZhciBhPS0xO2JyZWFrO2Nhc2UgMjphPTI1MDticmVhaztjYXNlIDU6YT0xMDczNzQxODIzO2JyZWFrO2Nhc2UgNDphPTFlNDticmVhaztkZWZhdWx0OmE9NWUzfXJldHVybiBhPW8rYSxlPXtpZDpkKyssY2FsbGJhY2s6dSxwcmlvcml0eUxldmVsOmUsc3RhcnRUaW1lOm8sZXhwaXJhdGlvblRpbWU6YSxzb3J0SW5kZXg6LTF9LG8+bD8oZS5zb3J0SW5kZXg9byxyKGYsZSksbnVsbD09PW4ocykmJmU9PT1uKGYpJiYoYj8obShTKSxTPS0xKTpiPSEwLEkoUCxvLWwpKSk6KGUuc29ydEluZGV4PWEscihzLGUpLHl8fF98fCh5PSEwLE4oRSkpKSxlfSx0LnVuc3RhYmxlX3Nob3VsZFlpZWxkPXcsdC51bnN0YWJsZV93cmFwQ2FsbGJhY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9aDtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgcj1oO2g9dDt0cnl7cmV0dXJuIGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbmFsbHl7aD1yfX19fSw2MTgzOmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7ZS5leHBvcnRzPXIoNDI0OCl9LDQ3Nzg6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImdldFNlZ21lbnRQYXJhbSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHV9fSk7bGV0IG49cig3Mzk5KTtmdW5jdGlvbiB1KGUpe2xldCB0PW4uSU5URVJDRVBUSU9OX1JPVVRFX01BUktFUlMuZmluZCh0PT5lLnN0YXJ0c1dpdGgodCkpO3JldHVybih0JiYoZT1lLnNsaWNlKHQubGVuZ3RoKSksZS5zdGFydHNXaXRoKCJbWy4uLiIpJiZlLmVuZHNXaXRoKCJdXSIpKT97dHlwZToib3B0aW9uYWwtY2F0Y2hhbGwiLHBhcmFtOmUuc2xpY2UoNSwtMil9OmUuc3RhcnRzV2l0aCgiWy4uLiIpJiZlLmVuZHNXaXRoKCJdIik/e3R5cGU6ImNhdGNoYWxsIixwYXJhbTplLnNsaWNlKDQsLTEpfTplLnN0YXJ0c1dpdGgoIlsiKSYmZS5lbmRzV2l0aCgiXSIpP3t0eXBlOiJkeW5hbWljIixwYXJhbTplLnNsaWNlKDEsLTEpfTpudWxsfX0sNzM5OTpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ITAsZ2V0OnRbcl19KX0odCx7SU5URVJDRVBUSU9OX1JPVVRFX01BUktFUlM6ZnVuY3Rpb24oKXtyZXR1cm4gdX0saXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGg6ZnVuY3Rpb24oKXtyZXR1cm4gb30sZXh0cmFjdEludGVyY2VwdGlvblJvdXRlSW5mb3JtYXRpb246ZnVuY3Rpb24oKXtyZXR1cm4gbH19KTtsZXQgbj1yKDMwNzQpLHU9WyIoLi4pKC4uKSIsIiguKSIsIiguLikiLCIoLi4uKSJdO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIHZvaWQgMCE9PWUuc3BsaXQoIi8iKS5maW5kKGU9PnUuZmluZCh0PT5lLnN0YXJ0c1dpdGgodCkpKX1mdW5jdGlvbiBsKGUpe2xldCB0LHIsbztmb3IobGV0IG4gb2YgZS5zcGxpdCgiLyIpKWlmKHI9dS5maW5kKGU9Pm4uc3RhcnRzV2l0aChlKSkpe1t0LG9dPWUuc3BsaXQociwyKTticmVha31pZighdHx8IXJ8fCFvKXRocm93IEVycm9yKGBJbnZhbGlkIGludGVyY2VwdGlvbiByb3V0ZTogJHtlfS4gTXVzdCBiZSBpbiB0aGUgZm9ybWF0IC88aW50ZXJjZXB0aW5nIHJvdXRlPi8oLi58Li4ufC4uKSguLikvPGludGVyY2VwdGVkIHJvdXRlPmApO3N3aXRjaCh0PSgwLG4ubm9ybWFsaXplQXBwUGF0aCkodCkscil7Y2FzZSIoLikiOm89Ii8iPT09dD9gLyR7b31gOnQrIi8iK287YnJlYWs7Y2FzZSIoLi4pIjppZigiLyI9PT10KXRocm93IEVycm9yKGBJbnZhbGlkIGludGVyY2VwdGlvbiByb3V0ZTogJHtlfS4gQ2Fubm90IHVzZSAoLi4pIG1hcmtlciBhdCB0aGUgcm9vdCBsZXZlbCwgdXNlICguKSBpbnN0ZWFkLmApO289dC5zcGxpdCgiLyIpLnNsaWNlKDAsLTEpLmNvbmNhdChvKS5qb2luKCIvIik7YnJlYWs7Y2FzZSIoLi4uKSI6bz0iLyIrbzticmVhaztjYXNlIiguLikoLi4pIjpsZXQgbD10LnNwbGl0KCIvIik7aWYobC5sZW5ndGg8PTIpdGhyb3cgRXJyb3IoYEludmFsaWQgaW50ZXJjZXB0aW9uIHJvdXRlOiAke2V9LiBDYW5ub3QgdXNlICguLikoLi4pIG1hcmtlciBhdCB0aGUgcm9vdCBsZXZlbCBvciBvbmUgbGV2ZWwgdXAuYCk7bz1sLnNsaWNlKDAsLTIpLmNvbmNhdChvKS5qb2luKCIvIik7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcigiSW52YXJpYW50OiB1bmV4cGVjdGVkIG1hcmtlciIpfXJldHVybntpbnRlcmNlcHRpbmdSb3V0ZTp0LGludGVyY2VwdGVkUm91dGU6b319fSw2OTI3OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ci5yKHQpLHIuZCh0LHtfOmZ1bmN0aW9uKCl7cmV0dXJuIG59LF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdDpmdW5jdGlvbigpe3JldHVybiBufX0pfSw1OTA5OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gbihlKXtpZigiZnVuY3Rpb24iIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcCxyPW5ldyBXZWFrTWFwO3JldHVybihuPWZ1bmN0aW9uKGUpe3JldHVybiBlP3I6dH0pKGUpfWZ1bmN0aW9uIHUoZSx0KXtpZighdCYmZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO2lmKG51bGw9PT1lfHwib2JqZWN0IiE9dHlwZW9mIGUmJiJmdW5jdGlvbiIhPXR5cGVvZiBlKXJldHVybntkZWZhdWx0OmV9O3ZhciByPW4odCk7aWYociYmci5oYXMoZSkpcmV0dXJuIHIuZ2V0KGUpO3ZhciB1PXt9LG89T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgbCBpbiBlKWlmKCJkZWZhdWx0IiE9PWwmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLGwpKXt2YXIgYT1vP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxsKTpudWxsO2EmJihhLmdldHx8YS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LGwsYSk6dVtsXT1lW2xdfXJldHVybiB1LmRlZmF1bHQ9ZSxyJiZyLnNldChlLHUpLHV9ci5yKHQpLHIuZCh0LHtfOmZ1bmN0aW9uKCl7cmV0dXJuIHV9LF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQ6ZnVuY3Rpb24oKXtyZXR1cm4gdX19KX19XSk7\")\nassets.set(\"/_next/static/chunks/app/layout-e7b6b16812ee975a.js\", \"data:application/javascript;base64,KHNlbGYud2VicGFja0NodW5rX05fRT1zZWxmLndlYnBhY2tDaHVua19OX0V8fFtdKS5wdXNoKFtbMTg1XSx7NTA4NDpmdW5jdGlvbihuLGUsdCl7UHJvbWlzZS5yZXNvbHZlKCkudGhlbih0LnQuYmluZCh0LDI3NDYsMjMpKSxQcm9taXNlLnJlc29sdmUoKS50aGVuKHQudC5iaW5kKHQsMzQ4MCwyMykpfSwyNzQ2OmZ1bmN0aW9uKCl7fSwzNDgwOmZ1bmN0aW9uKG4pe24uZXhwb3J0cz17c3R5bGU6e2ZvbnRGYW1pbHk6IidfX0ludGVyXzIwOTUxZicsICdfX0ludGVyX0ZhbGxiYWNrXzIwOTUxZiciLGZvbnRTdHlsZToibm9ybWFsIn0sY2xhc3NOYW1lOiJfX2NsYXNzTmFtZV8yMDk1MWYifX19LGZ1bmN0aW9uKG4pe24uTygwLFsyNTMsOTYxLDc0NF0sZnVuY3Rpb24oKXtyZXR1cm4gbihuLnM9NTA4NCl9KSxfTl9FPW4uTygpfV0pOw==\")\nassets.set(\"/_next/static/chunks/app/page-66fce5d1f1e2c581.js\", \"data:application/javascript;base64,KHNlbGYud2VicGFja0NodW5rX05fRT1zZWxmLndlYnBhY2tDaHVua19OX0V8fFtdKS5wdXNoKFtbOTMxXSx7OTI1MzpmdW5jdGlvbihlLHQsbil7UHJvbWlzZS5yZXNvbHZlKCkudGhlbihuLnQuYmluZChuLDMyNDAsMjMpKX0sMzI0MDpmdW5jdGlvbihlLHQsbil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiSW1hZ2UiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBtfX0pO2xldCByPW4oNjkyNyksaT1uKDU5MDkpLG89aS5fKG4oNjAwNikpLGE9ci5fKG4oNTUzOCkpLGw9big1NDY4KSx1PW4oNTE0OSkscz1uKDIyODEpO24oMzU3OSk7bGV0IGQ9ci5fKG4oNDQ4OSkpLGM9e2RldmljZVNpemVzOls2NDAsNzUwLDgyOCwxMDgwLDEyMDAsMTkyMCwyMDQ4LDM4NDBdLGltYWdlU2l6ZXM6WzE2LDMyLDQ4LDY0LDk2LDEyOCwyNTYsMzg0XSxwYXRoOiIvX25leHQvaW1hZ2UiLGxvYWRlcjoiZGVmYXVsdCIsZGFuZ2Vyb3VzbHlBbGxvd1NWRzohMSx1bm9wdGltaXplZDohMH07ZnVuY3Rpb24gZihlLHQsbixyLGksbyl7bGV0IGE9bnVsbD09ZT92b2lkIDA6ZS5zcmM7aWYoIWV8fGVbImRhdGEtbG9hZGVkLXNyYyJdPT09YSlyZXR1cm47ZVsiZGF0YS1sb2FkZWQtc3JjIl09YTtsZXQgbD0iZGVjb2RlImluIGU/ZS5kZWNvZGUoKTpQcm9taXNlLnJlc29sdmUoKTtsLmNhdGNoKCgpPT57fSkudGhlbigoKT0+e2lmKGUucGFyZW50RWxlbWVudCYmZS5pc0Nvbm5lY3RlZCl7aWYoImJsdXIiPT09dCYmaSghMCksbnVsbD09bj92b2lkIDA6bi5jdXJyZW50KXtsZXQgdD1uZXcgRXZlbnQoImxvYWQiKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwidGFyZ2V0Iix7d3JpdGFibGU6ITEsdmFsdWU6ZX0pO2xldCByPSExLGk9ITE7bi5jdXJyZW50KHsuLi50LG5hdGl2ZUV2ZW50OnQsY3VycmVudFRhcmdldDplLHRhcmdldDplLGlzRGVmYXVsdFByZXZlbnRlZDooKT0+cixpc1Byb3BhZ2F0aW9uU3RvcHBlZDooKT0+aSxwZXJzaXN0OigpPT57fSxwcmV2ZW50RGVmYXVsdDooKT0+e3I9ITAsdC5wcmV2ZW50RGVmYXVsdCgpfSxzdG9wUHJvcGFnYXRpb246KCk9PntpPSEwLHQuc3RvcFByb3BhZ2F0aW9uKCl9fSl9KG51bGw9PXI/dm9pZCAwOnIuY3VycmVudCkmJnIuY3VycmVudChlKX19KX1mdW5jdGlvbiBwKGUpe2xldFt0LG5dPW8udmVyc2lvbi5zcGxpdCgiLiIpLHI9cGFyc2VJbnQodCwxMCksaT1wYXJzZUludChuLDEwKTtyZXR1cm4gcj4xOHx8MTg9PT1yJiZpPj0zP3tmZXRjaFByaW9yaXR5OmV9OntmZXRjaHByaW9yaXR5OmV9fWxldCBnPSgwLG8uZm9yd2FyZFJlZikoKGUsdCk9PntsZXR7c3JjOm4sc3JjU2V0OnIsc2l6ZXM6aSxoZWlnaHQ6YSx3aWR0aDpsLGRlY29kaW5nOnUsY2xhc3NOYW1lOnMsc3R5bGU6ZCxmZXRjaFByaW9yaXR5OmMscGxhY2Vob2xkZXI6Zyxsb2FkaW5nOm0sdW5vcHRpbWl6ZWQ6aCxmaWxsOnksb25Mb2FkUmVmOmIsb25Mb2FkaW5nQ29tcGxldGVSZWY6dixzZXRCbHVyQ29tcGxldGU6XyxzZXRTaG93QWx0VGV4dDp3LG9uTG9hZDpTLG9uRXJyb3I6QywuLi5QfT1lO3JldHVybiBvLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgiaW1nIix7Li4uUCwuLi5wKGMpLGxvYWRpbmc6bSx3aWR0aDpsLGhlaWdodDphLGRlY29kaW5nOnUsImRhdGEtbmltZyI6eT8iZmlsbCI6IjEiLGNsYXNzTmFtZTpzLHN0eWxlOmQsc2l6ZXM6aSxzcmNTZXQ6cixzcmM6bixyZWY6KDAsby51c2VDYWxsYmFjaykoZT0+e3QmJigiZnVuY3Rpb24iPT10eXBlb2YgdD90KGUpOiJvYmplY3QiPT10eXBlb2YgdCYmKHQuY3VycmVudD1lKSksZSYmKEMmJihlLnNyYz1lLnNyYyksZS5jb21wbGV0ZSYmZihlLGcsYix2LF8saCkpfSxbbixnLGIsdixfLEMsaCx0XSksb25Mb2FkOmU9PntsZXQgdD1lLmN1cnJlbnRUYXJnZXQ7Zih0LGcsYix2LF8saCl9LG9uRXJyb3I6ZT0+e3coITApLCJibHVyIj09PWcmJl8oITApLEMmJkMoZSl9fSl9KSxtPSgwLG8uZm9yd2FyZFJlZikoKGUsdCk9PntsZXQgbj0oMCxvLnVzZUNvbnRleHQpKHMuSW1hZ2VDb25maWdDb250ZXh0KSxyPSgwLG8udXNlTWVtbykoKCk9PntsZXQgZT1jfHxufHx1LmltYWdlQ29uZmlnRGVmYXVsdCx0PVsuLi5lLmRldmljZVNpemVzLC4uLmUuaW1hZ2VTaXplc10uc29ydCgoZSx0KT0+ZS10KSxyPWUuZGV2aWNlU2l6ZXMuc29ydCgoZSx0KT0+ZS10KTtyZXR1cm57Li4uZSxhbGxTaXplczp0LGRldmljZVNpemVzOnJ9fSxbbl0pLHtvbkxvYWQ6aSxvbkxvYWRpbmdDb21wbGV0ZTpmfT1lLG09KDAsby51c2VSZWYpKGkpOygwLG8udXNlRWZmZWN0KSgoKT0+e20uY3VycmVudD1pfSxbaV0pO2xldCBoPSgwLG8udXNlUmVmKShmKTsoMCxvLnVzZUVmZmVjdCkoKCk9PntoLmN1cnJlbnQ9Zn0sW2ZdKTtsZXRbeSxiXT0oMCxvLnVzZVN0YXRlKSghMSksW3YsX109KDAsby51c2VTdGF0ZSkoITEpLHtwcm9wczp3LG1ldGE6U309KDAsbC5nZXRJbWdQcm9wcykoZSx7ZGVmYXVsdExvYWRlcjpkLmRlZmF1bHQsaW1nQ29uZjpyLGJsdXJDb21wbGV0ZTp5LHNob3dBbHRUZXh0OnZ9KTtyZXR1cm4gby5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoby5kZWZhdWx0LkZyYWdtZW50LG51bGwsby5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoZyx7Li4udyx1bm9wdGltaXplZDpTLnVub3B0aW1pemVkLHBsYWNlaG9sZGVyOlMucGxhY2Vob2xkZXIsZmlsbDpTLmZpbGwsb25Mb2FkUmVmOm0sb25Mb2FkaW5nQ29tcGxldGVSZWY6aCxzZXRCbHVyQ29tcGxldGU6YixzZXRTaG93QWx0VGV4dDpfLHJlZjp0fSksUy5wcmlvcml0eT9vLmRlZmF1bHQuY3JlYXRlRWxlbWVudChhLmRlZmF1bHQsbnVsbCxvLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgibGluayIse2tleToiX19uaW1nLSIrdy5zcmMrdy5zcmNTZXQrdy5zaXplcyxyZWw6InByZWxvYWQiLGFzOiJpbWFnZSIsaHJlZjp3LnNyY1NldD92b2lkIDA6dy5zcmMsaW1hZ2VTcmNTZXQ6dy5zcmNTZXQsaW1hZ2VTaXplczp3LnNpemVzLGNyb3NzT3JpZ2luOncuY3Jvc3NPcmlnaW4scmVmZXJyZXJQb2xpY3k6dy5yZWZlcnJlclBvbGljeSwuLi5wKHcuZmV0Y2hQcmlvcml0eSl9KSk6bnVsbCl9KTsoImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSwzMTg4OmZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJBbXBTdGF0ZUNvbnRleHQiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBvfX0pO2xldCByPW4oNjkyNyksaT1yLl8obig2MDA2KSksbz1pLmRlZmF1bHQuY3JlYXRlQ29udGV4dCh7fSl9LDkzMzQ6ZnVuY3Rpb24oZSx0KXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gbihlKXtsZXR7YW1wRmlyc3Q6dD0hMSxoeWJyaWQ6bj0hMSxoYXNRdWVyeTpyPSExfT12b2lkIDA9PT1lP3t9OmU7cmV0dXJuIHR8fG4mJnJ9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJpc0luQW1wTW9kZSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG59fSl9LDU0Njg6ZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImdldEltZ1Byb3BzIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbH19KSxuKDM1NzkpO2xldCByPW4oOTUyNyksaT1uKDUxNDkpO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIHZvaWQgMCE9PWUuZGVmYXVsdH1mdW5jdGlvbiBhKGUpe3JldHVybiB2b2lkIDA9PT1lP2U6Im51bWJlciI9PXR5cGVvZiBlP051bWJlci5pc0Zpbml0ZShlKT9lOk5hTjoic3RyaW5nIj09dHlwZW9mIGUmJi9eWzAtOV0rJC8udGVzdChlKT9wYXJzZUludChlLDEwKTpOYU59ZnVuY3Rpb24gbChlLHQpe3ZhciBuO2xldCBsLHUscyx7c3JjOmQsc2l6ZXM6Yyx1bm9wdGltaXplZDpmPSExLHByaW9yaXR5OnA9ITEsbG9hZGluZzpnLGNsYXNzTmFtZTptLHF1YWxpdHk6aCx3aWR0aDp5LGhlaWdodDpiLGZpbGw6dj0hMSxzdHlsZTpfLG9uTG9hZDp3LG9uTG9hZGluZ0NvbXBsZXRlOlMscGxhY2Vob2xkZXI6Qz0iZW1wdHkiLGJsdXJEYXRhVVJMOlAsZmV0Y2hQcmlvcml0eTpqLGxheW91dDpPLG9iamVjdEZpdDpFLG9iamVjdFBvc2l0aW9uOngsbGF6eUJvdW5kYXJ5OnosbGF6eVJvb3Q6TSwuLi5rfT1lLHtpbWdDb25mOkksc2hvd0FsdFRleHQ6QSxibHVyQ29tcGxldGU6UixkZWZhdWx0TG9hZGVyOkR9PXQsTj1JfHxpLmltYWdlQ29uZmlnRGVmYXVsdDtpZigiYWxsU2l6ZXMiaW4gTilsPU47ZWxzZXtsZXQgZT1bLi4uTi5kZXZpY2VTaXplcywuLi5OLmltYWdlU2l6ZXNdLnNvcnQoKGUsdCk9PmUtdCksdD1OLmRldmljZVNpemVzLnNvcnQoKGUsdCk9PmUtdCk7bD17Li4uTixhbGxTaXplczplLGRldmljZVNpemVzOnR9fWxldCBVPWsubG9hZGVyfHxEO2RlbGV0ZSBrLmxvYWRlcixkZWxldGUgay5zcmNTZXQ7bGV0IEw9Il9fbmV4dF9pbWdfZGVmYXVsdCJpbiBVO2lmKEwpe2lmKCJjdXN0b20iPT09bC5sb2FkZXIpdGhyb3cgRXJyb3IoJ0ltYWdlIHdpdGggc3JjICInK2QrJyIgaXMgbWlzc2luZyAibG9hZGVyIiBwcm9wLlxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLW1pc3NpbmctbG9hZGVyJyl9ZWxzZXtsZXQgZT1VO1U9dD0+e2xldHtjb25maWc6biwuLi5yfT10O3JldHVybiBlKHIpfX1pZihPKXsiZmlsbCI9PT1PJiYodj0hMCk7bGV0IGU9e2ludHJpbnNpYzp7bWF4V2lkdGg6IjEwMCUiLGhlaWdodDoiYXV0byJ9LHJlc3BvbnNpdmU6e3dpZHRoOiIxMDAlIixoZWlnaHQ6ImF1dG8ifX1bT107ZSYmKF89ey4uLl8sLi4uZX0pO2xldCB0PXtyZXNwb25zaXZlOiIxMDB2dyIsZmlsbDoiMTAwdncifVtPXTt0JiYhYyYmKGM9dCl9bGV0IFQ9IiIsRj1hKHkpLEI9YShiKTtpZigib2JqZWN0Ij09dHlwZW9mKG49ZCkmJihvKG4pfHx2b2lkIDAhPT1uLnNyYykpe2xldCBlPW8oZCk/ZC5kZWZhdWx0OmQ7aWYoIWUuc3JjKXRocm93IEVycm9yKCJBbiBvYmplY3Qgc2hvdWxkIG9ubHkgYmUgcGFzc2VkIHRvIHRoZSBpbWFnZSBjb21wb25lbnQgc3JjIHBhcmFtZXRlciBpZiBpdCBjb21lcyBmcm9tIGEgc3RhdGljIGltYWdlIGltcG9ydC4gSXQgbXVzdCBpbmNsdWRlIHNyYy4gUmVjZWl2ZWQgIitKU09OLnN0cmluZ2lmeShlKSk7aWYoIWUuaGVpZ2h0fHwhZS53aWR0aCl0aHJvdyBFcnJvcigiQW4gb2JqZWN0IHNob3VsZCBvbmx5IGJlIHBhc3NlZCB0byB0aGUgaW1hZ2UgY29tcG9uZW50IHNyYyBwYXJhbWV0ZXIgaWYgaXQgY29tZXMgZnJvbSBhIHN0YXRpYyBpbWFnZSBpbXBvcnQuIEl0IG11c3QgaW5jbHVkZSBoZWlnaHQgYW5kIHdpZHRoLiBSZWNlaXZlZCAiK0pTT04uc3RyaW5naWZ5KGUpKTtpZih1PWUuYmx1cldpZHRoLHM9ZS5ibHVySGVpZ2h0LFA9UHx8ZS5ibHVyRGF0YVVSTCxUPWUuc3JjLCF2KXtpZihGfHxCKXtpZihGJiYhQil7bGV0IHQ9Ri9lLndpZHRoO0I9TWF0aC5yb3VuZChlLmhlaWdodCp0KX1lbHNlIGlmKCFGJiZCKXtsZXQgdD1CL2UuaGVpZ2h0O0Y9TWF0aC5yb3VuZChlLndpZHRoKnQpfX1lbHNlIEY9ZS53aWR0aCxCPWUuaGVpZ2h0fX1sZXQgVz0hcCYmKCJsYXp5Ij09PWd8fHZvaWQgMD09PWcpOyghKGQ9InN0cmluZyI9PXR5cGVvZiBkP2Q6VCl8fGQuc3RhcnRzV2l0aCgiZGF0YToiKXx8ZC5zdGFydHNXaXRoKCJibG9iOiIpKSYmKGY9ITAsVz0hMSksbC51bm9wdGltaXplZCYmKGY9ITApLEwmJmQuZW5kc1dpdGgoIi5zdmciKSYmIWwuZGFuZ2Vyb3VzbHlBbGxvd1NWRyYmKGY9ITApLHAmJihqPSJoaWdoIik7bGV0IEc9YShoKSxWPU9iamVjdC5hc3NpZ24odj97cG9zaXRpb246ImFic29sdXRlIixoZWlnaHQ6IjEwMCUiLHdpZHRoOiIxMDAlIixsZWZ0OjAsdG9wOjAscmlnaHQ6MCxib3R0b206MCxvYmplY3RGaXQ6RSxvYmplY3RQb3NpdGlvbjp4fTp7fSxBP3t9Ontjb2xvcjoidHJhbnNwYXJlbnQifSxfKSxIPSJibHVyIj09PUMmJlAmJiFSP3tiYWNrZ3JvdW5kU2l6ZTpWLm9iamVjdEZpdHx8ImNvdmVyIixiYWNrZ3JvdW5kUG9zaXRpb246Vi5vYmplY3RQb3NpdGlvbnx8IjUwJSA1MCUiLGJhY2tncm91bmRSZXBlYXQ6Im5vLXJlcGVhdCIsYmFja2dyb3VuZEltYWdlOid1cmwoImRhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04LCcrKDAsci5nZXRJbWFnZUJsdXJTdmcpKHt3aWR0aEludDpGLGhlaWdodEludDpCLGJsdXJXaWR0aDp1LGJsdXJIZWlnaHQ6cyxibHVyRGF0YVVSTDpQLG9iamVjdEZpdDpWLm9iamVjdEZpdH0pKyciKSd9Ont9LHE9ZnVuY3Rpb24oZSl7bGV0e2NvbmZpZzp0LHNyYzpuLHVub3B0aW1pemVkOnIsd2lkdGg6aSxxdWFsaXR5Om8sc2l6ZXM6YSxsb2FkZXI6bH09ZTtpZihyKXJldHVybntzcmM6bixzcmNTZXQ6dm9pZCAwLHNpemVzOnZvaWQgMH07bGV0e3dpZHRoczp1LGtpbmQ6c309ZnVuY3Rpb24oZSx0LG4pe2xldHtkZXZpY2VTaXplczpyLGFsbFNpemVzOml9PWU7aWYobil7bGV0IGU9LyhefFxzKSgxP1xkP1xkKXZ3L2csdD1bXTtmb3IobGV0IHI7cj1lLmV4ZWMobik7cil0LnB1c2gocGFyc2VJbnQoclsyXSkpO2lmKHQubGVuZ3RoKXtsZXQgZT0uMDEqTWF0aC5taW4oLi4udCk7cmV0dXJue3dpZHRoczppLmZpbHRlcih0PT50Pj1yWzBdKmUpLGtpbmQ6IncifX1yZXR1cm57d2lkdGhzOmksa2luZDoidyJ9fWlmKCJudW1iZXIiIT10eXBlb2YgdClyZXR1cm57d2lkdGhzOnIsa2luZDoidyJ9O2xldCBvPVsuLi5uZXcgU2V0KFt0LDIqdF0ubWFwKGU9PmkuZmluZCh0PT50Pj1lKXx8aVtpLmxlbmd0aC0xXSkpXTtyZXR1cm57d2lkdGhzOm8sa2luZDoieCJ9fSh0LGksYSksZD11Lmxlbmd0aC0xO3JldHVybntzaXplczphfHwidyIhPT1zP2E6IjEwMHZ3IixzcmNTZXQ6dS5tYXAoKGUscik9Pmwoe2NvbmZpZzp0LHNyYzpuLHF1YWxpdHk6byx3aWR0aDplfSkrIiAiKygidyI9PT1zP2U6cisxKStzKS5qb2luKCIsICIpLHNyYzpsKHtjb25maWc6dCxzcmM6bixxdWFsaXR5Om8sd2lkdGg6dVtkXX0pfX0oe2NvbmZpZzpsLHNyYzpkLHVub3B0aW1pemVkOmYsd2lkdGg6RixxdWFsaXR5Okcsc2l6ZXM6Yyxsb2FkZXI6VX0pLCQ9ey4uLmssbG9hZGluZzpXPyJsYXp5IjpnLGZldGNoUHJpb3JpdHk6aix3aWR0aDpGLGhlaWdodDpCLGRlY29kaW5nOiJhc3luYyIsY2xhc3NOYW1lOm0sc3R5bGU6ey4uLlYsLi4uSH0sc2l6ZXM6cS5zaXplcyxzcmNTZXQ6cS5zcmNTZXQsc3JjOnEuc3JjfSxKPXt1bm9wdGltaXplZDpmLHByaW9yaXR5OnAscGxhY2Vob2xkZXI6QyxmaWxsOnZ9O3JldHVybntwcm9wczokLG1ldGE6Sn19fSw1NTM4OmZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuIGluIHQpT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbix7ZW51bWVyYWJsZTohMCxnZXQ6dFtuXX0pfSh0LHtkZWZhdWx0SGVhZDpmdW5jdGlvbigpe3JldHVybiBkfSxkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJuIGd9fSk7bGV0IHI9big2OTI3KSxpPW4oNTkwOSksbz1pLl8obig2MDA2KSksYT1yLl8obig4NzAzKSksbD1uKDMxODgpLHU9big1NzcpLHM9big5MzM0KTtmdW5jdGlvbiBkKGUpe3ZvaWQgMD09PWUmJihlPSExKTtsZXQgdD1bby5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoIm1ldGEiLHtjaGFyU2V0OiJ1dGYtOCJ9KV07cmV0dXJuIGV8fHQucHVzaChvLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgibWV0YSIse25hbWU6InZpZXdwb3J0Iixjb250ZW50OiJ3aWR0aD1kZXZpY2Utd2lkdGgifSkpLHR9ZnVuY3Rpb24gYyhlLHQpe3JldHVybiJzdHJpbmciPT10eXBlb2YgdHx8Im51bWJlciI9PXR5cGVvZiB0P2U6dC50eXBlPT09by5kZWZhdWx0LkZyYWdtZW50P2UuY29uY2F0KG8uZGVmYXVsdC5DaGlsZHJlbi50b0FycmF5KHQucHJvcHMuY2hpbGRyZW4pLnJlZHVjZSgoZSx0KT0+InN0cmluZyI9PXR5cGVvZiB0fHwibnVtYmVyIj09dHlwZW9mIHQ/ZTplLmNvbmNhdCh0KSxbXSkpOmUuY29uY2F0KHQpfW4oMzU3OSk7bGV0IGY9WyJuYW1lIiwiaHR0cEVxdWl2IiwiY2hhclNldCIsIml0ZW1Qcm9wIl07ZnVuY3Rpb24gcChlLHQpe2xldHtpbkFtcE1vZGU6bn09dDtyZXR1cm4gZS5yZWR1Y2UoYyxbXSkucmV2ZXJzZSgpLmNvbmNhdChkKG4pLnJldmVyc2UoKSkuZmlsdGVyKGZ1bmN0aW9uKCl7bGV0IGU9bmV3IFNldCx0PW5ldyBTZXQsbj1uZXcgU2V0LHI9e307cmV0dXJuIGk9PntsZXQgbz0hMCxhPSExO2lmKGkua2V5JiYibnVtYmVyIiE9dHlwZW9mIGkua2V5JiZpLmtleS5pbmRleE9mKCIkIik+MCl7YT0hMDtsZXQgdD1pLmtleS5zbGljZShpLmtleS5pbmRleE9mKCIkIikrMSk7ZS5oYXModCk/bz0hMTplLmFkZCh0KX1zd2l0Y2goaS50eXBlKXtjYXNlInRpdGxlIjpjYXNlImJhc2UiOnQuaGFzKGkudHlwZSk/bz0hMTp0LmFkZChpLnR5cGUpO2JyZWFrO2Nhc2UibWV0YSI6Zm9yKGxldCBlPTAsdD1mLmxlbmd0aDtlPHQ7ZSsrKXtsZXQgdD1mW2VdO2lmKGkucHJvcHMuaGFzT3duUHJvcGVydHkodCkpe2lmKCJjaGFyU2V0Ij09PXQpbi5oYXModCk/bz0hMTpuLmFkZCh0KTtlbHNle2xldCBlPWkucHJvcHNbdF0sbj1yW3RdfHxuZXcgU2V0OygibmFtZSIhPT10fHwhYSkmJm4uaGFzKGUpP289ITE6KG4uYWRkKGUpLHJbdF09bil9fX19cmV0dXJuIG99fSgpKS5yZXZlcnNlKCkubWFwKChlLHQpPT57bGV0IHI9ZS5rZXl8fHQ7aWYoIW4mJiJsaW5rIj09PWUudHlwZSYmZS5wcm9wcy5ocmVmJiZbImh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzIiwiaHR0cHM6Ly91c2UudHlwZWtpdC5uZXQvIl0uc29tZSh0PT5lLnByb3BzLmhyZWYuc3RhcnRzV2l0aCh0KSkpe2xldCB0PXsuLi5lLnByb3BzfHx7fX07cmV0dXJuIHRbImRhdGEtaHJlZiJdPXQuaHJlZix0LmhyZWY9dm9pZCAwLHRbImRhdGEtb3B0aW1pemVkLWZvbnRzIl09ITAsby5kZWZhdWx0LmNsb25lRWxlbWVudChlLHQpfXJldHVybiBvLmRlZmF1bHQuY2xvbmVFbGVtZW50KGUse2tleTpyfSl9KX1sZXQgZz1mdW5jdGlvbihlKXtsZXR7Y2hpbGRyZW46dH09ZSxuPSgwLG8udXNlQ29udGV4dCkobC5BbXBTdGF0ZUNvbnRleHQpLHI9KDAsby51c2VDb250ZXh0KSh1LkhlYWRNYW5hZ2VyQ29udGV4dCk7cmV0dXJuIG8uZGVmYXVsdC5jcmVhdGVFbGVtZW50KGEuZGVmYXVsdCx7cmVkdWNlQ29tcG9uZW50c1RvU3RhdGU6cCxoZWFkTWFuYWdlcjpyLGluQW1wTW9kZTooMCxzLmlzSW5BbXBNb2RlKShuKX0sdCl9OygiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDk1Mjc6ZnVuY3Rpb24oZSx0KXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gbihlKXtsZXR7d2lkdGhJbnQ6dCxoZWlnaHRJbnQ6bixibHVyV2lkdGg6cixibHVySGVpZ2h0OmksYmx1ckRhdGFVUkw6byxvYmplY3RGaXQ6YX09ZSxsPXJ8fHQsdT1pfHxuLHM9by5zdGFydHNXaXRoKCJkYXRhOmltYWdlL2pwZWciKT8iJTNDZmVDb21wb25lbnRUcmFuc2ZlciUzRSUzQ2ZlRnVuY0EgdHlwZT0nZGlzY3JldGUnIHRhYmxlVmFsdWVzPScxIDEnLyUzRSUzQy9mZUNvbXBvbmVudFRyYW5zZmVyJTNFJSI6IiI7cmV0dXJuIGwmJnU/IiUzQ3N2ZyB4bWxucz0naHR0cCUzQS8vd3d3LnczLm9yZy8yMDAwL3N2Zycgdmlld0JveD0nMCAwICIrbCsiICIrdSsiJyUzRSUzQ2ZpbHRlciBpZD0nYicgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSdzUkdCJyUzRSUzQ2ZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0nIisociYmaT8iMSI6IjIwIikrIicvJTNFIitzKyIlM0MvZmlsdGVyJTNFJTNDaW1hZ2UgcHJlc2VydmVBc3BlY3RSYXRpbz0nbm9uZScgZmlsdGVyPSd1cmwoJTIzYiknIHg9JzAnIHk9JzAnIGhlaWdodD0nMTAwJTI1JyB3aWR0aD0nMTAwJTI1JyBocmVmPSciK28rIicvJTNFJTNDL3N2ZyUzRSI6IiUzQ3N2ZyB4bWxucz0naHR0cCUzQS8vd3d3LnczLm9yZy8yMDAwL3N2ZyclM0UlM0NpbWFnZSBzdHlsZT0nZmlsdGVyOmJsdXIoMjBweCknIHByZXNlcnZlQXNwZWN0UmF0aW89JyIrKCJjb250YWluIj09PWE/InhNaWRZTWlkIjoiY292ZXIiPT09YT8ieE1pZFlNaWQgc2xpY2UiOiJub25lIikrIicgeD0nMCcgeT0nMCcgaGVpZ2h0PScxMDAlMjUnIHdpZHRoPScxMDAlMjUnIGhyZWY9JyIrbysiJy8lM0UlM0Mvc3ZnJTNFIn1PYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImdldEltYWdlQmx1clN2ZyIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG59fSl9LDIyODE6ZnVuY3Rpb24oZSx0LG4peyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIkltYWdlQ29uZmlnQ29udGV4dCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGF9fSk7bGV0IHI9big2OTI3KSxpPXIuXyhuKDYwMDYpKSxvPW4oNTE0OSksYT1pLmRlZmF1bHQuY3JlYXRlQ29udGV4dChvLmltYWdlQ29uZmlnRGVmYXVsdCl9LDUxNDk6ZnVuY3Rpb24oZSx0KXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuIGluIHQpT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbix7ZW51bWVyYWJsZTohMCxnZXQ6dFtuXX0pfSh0LHtWQUxJRF9MT0FERVJTOmZ1bmN0aW9uKCl7cmV0dXJuIG59LGltYWdlQ29uZmlnRGVmYXVsdDpmdW5jdGlvbigpe3JldHVybiByfX0pO2xldCBuPVsiZGVmYXVsdCIsImltZ2l4IiwiY2xvdWRpbmFyeSIsImFrYW1haSIsImN1c3RvbSJdLHI9e2RldmljZVNpemVzOls2NDAsNzUwLDgyOCwxMDgwLDEyMDAsMTkyMCwyMDQ4LDM4NDBdLGltYWdlU2l6ZXM6WzE2LDMyLDQ4LDY0LDk2LDEyOCwyNTYsMzg0XSxwYXRoOiIvX25leHQvaW1hZ2UiLGxvYWRlcjoiZGVmYXVsdCIsbG9hZGVyRmlsZToiIixkb21haW5zOltdLGRpc2FibGVTdGF0aWNJbWFnZXM6ITEsbWluaW11bUNhY2hlVFRMOjYwLGZvcm1hdHM6WyJpbWFnZS93ZWJwIl0sZGFuZ2Vyb3VzbHlBbGxvd1NWRzohMSxjb250ZW50U2VjdXJpdHlQb2xpY3k6InNjcmlwdC1zcmMgJ25vbmUnOyBmcmFtZS1zcmMgJ25vbmUnOyBzYW5kYm94OyIsY29udGVudERpc3Bvc2l0aW9uVHlwZToiaW5saW5lIixyZW1vdGVQYXR0ZXJuczpbXSx1bm9wdGltaXplZDohMX19LDQ0ODk6ZnVuY3Rpb24oZSx0KXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gbihlKXtsZXR7Y29uZmlnOnQsc3JjOm4sd2lkdGg6cixxdWFsaXR5Oml9PWU7cmV0dXJuIHQucGF0aCsiP3VybD0iK2VuY29kZVVSSUNvbXBvbmVudChuKSsiJnc9IityKyImcT0iKyhpfHw3NSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJkZWZhdWx0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcn19KSxuLl9fbmV4dF9pbWdfZGVmYXVsdD0hMDtsZXQgcj1ufSw4NzAzOmZ1bmN0aW9uKGUsdCxuKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJkZWZhdWx0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbH19KTtsZXQgcj1uKDU5MDkpLGk9ci5fKG4oNjAwNikpLG89aS51c2VMYXlvdXRFZmZlY3QsYT1pLnVzZUVmZmVjdDtmdW5jdGlvbiBsKGUpe2xldHtoZWFkTWFuYWdlcjp0LHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlOm59PWU7ZnVuY3Rpb24gcigpe2lmKHQmJnQubW91bnRlZEluc3RhbmNlcyl7bGV0IHI9aS5DaGlsZHJlbi50b0FycmF5KEFycmF5LmZyb20odC5tb3VudGVkSW5zdGFuY2VzKS5maWx0ZXIoQm9vbGVhbikpO3QudXBkYXRlSGVhZChuKHIsZSkpfX1yZXR1cm4gbygoKT0+e3ZhciBuO3JldHVybiBudWxsPT10fHxudWxsPT0obj10Lm1vdW50ZWRJbnN0YW5jZXMpfHxuLmFkZChlLmNoaWxkcmVuKSwoKT0+e3ZhciBuO251bGw9PXR8fG51bGw9PShuPXQubW91bnRlZEluc3RhbmNlcyl8fG4uZGVsZXRlKGUuY2hpbGRyZW4pfX0pLG8oKCk9Pih0JiYodC5fcGVuZGluZ1VwZGF0ZT1yKSwoKT0+e3QmJih0Ll9wZW5kaW5nVXBkYXRlPXIpfSkpLGEoKCk9Pih0JiZ0Ll9wZW5kaW5nVXBkYXRlJiYodC5fcGVuZGluZ1VwZGF0ZSgpLHQuX3BlbmRpbmdVcGRhdGU9bnVsbCksKCk9Pnt0JiZ0Ll9wZW5kaW5nVXBkYXRlJiYodC5fcGVuZGluZ1VwZGF0ZSgpLHQuX3BlbmRpbmdVcGRhdGU9bnVsbCl9KSksbnVsbH19LDM1Nzk6ZnVuY3Rpb24oZSx0KXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJ3YXJuT25jZSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG59fSk7bGV0IG49ZT0+e319fSxmdW5jdGlvbihlKXtlLk8oMCxbMjUzLDk2MSw3NDRdLGZ1bmN0aW9uKCl7cmV0dXJuIGUoZS5zPTkyNTMpfSksX05fRT1lLk8oKX1dKTs=\")\nassets.set(\"/_next/static/chunks/bce60fc1-3138fc63e84359d9.js\", \"data:application/javascript;base64,InVzZSBzdHJpY3QiOyhzZWxmLndlYnBhY2tDaHVua19OX0U9c2VsZi53ZWJwYWNrQ2h1bmtfTl9FfHxbXSkucHVzaChbWzI1M10sezI2MTQ6ZnVuY3Rpb24oZSx0LG4pey8qKgogKiBAbGljZW5zZSBSZWFjdAogKiByZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanMKICoKICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy4KICoKICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlCiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4KICovdmFyIHIsbD1uKDYwMDYpLGE9big2MTgzKSxvPXt1c2luZ0NsaWVudEVudHJ5UG9pbnQ6ITEsRXZlbnRzOm51bGwsRGlzcGF0Y2hlcjp7Y3VycmVudDpudWxsfX07ZnVuY3Rpb24gaShlKXtmb3IodmFyIHQ9Imh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PSIrZSxuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyl0Kz0iJmFyZ3NbXT0iK2VuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbbl0pO3JldHVybiJNaW5pZmllZCBSZWFjdCBlcnJvciAjIitlKyI7IHZpc2l0ICIrdCsiIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4ifXZhciB1PU9iamVjdC5hc3NpZ24scz1sLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELGM9W10sZj0tMTtmdW5jdGlvbiBkKGUpe3JldHVybntjdXJyZW50OmV9fWZ1bmN0aW9uIHAoZSl7MD5mfHwoZS5jdXJyZW50PWNbZl0sY1tmXT1udWxsLGYtLSl9ZnVuY3Rpb24gaChlLHQpe2NbKytmXT1lLmN1cnJlbnQsZS5jdXJyZW50PXR9dmFyIG09U3ltYm9sLmZvcigicmVhY3QuZWxlbWVudCIpLGc9U3ltYm9sLmZvcigicmVhY3QucG9ydGFsIikseT1TeW1ib2wuZm9yKCJyZWFjdC5mcmFnbWVudCIpLHY9U3ltYm9sLmZvcigicmVhY3Quc3RyaWN0X21vZGUiKSxiPVN5bWJvbC5mb3IoInJlYWN0LnByb2ZpbGVyIiksaz1TeW1ib2wuZm9yKCJyZWFjdC5wcm92aWRlciIpLHc9U3ltYm9sLmZvcigicmVhY3QuY29udGV4dCIpLFM9U3ltYm9sLmZvcigicmVhY3Quc2VydmVyX2NvbnRleHQiKSxFPVN5bWJvbC5mb3IoInJlYWN0LmZvcndhcmRfcmVmIiksQz1TeW1ib2wuZm9yKCJyZWFjdC5zdXNwZW5zZSIpLHg9U3ltYm9sLmZvcigicmVhY3Quc3VzcGVuc2VfbGlzdCIpLHo9U3ltYm9sLmZvcigicmVhY3QubWVtbyIpLFA9U3ltYm9sLmZvcigicmVhY3QubGF6eSIpLE49U3ltYm9sLmZvcigicmVhY3Quc2NvcGUiKTtTeW1ib2wuZm9yKCJyZWFjdC5kZWJ1Z190cmFjZV9tb2RlIik7dmFyIF89U3ltYm9sLmZvcigicmVhY3Qub2Zmc2NyZWVuIiksTD1TeW1ib2wuZm9yKCJyZWFjdC5sZWdhY3lfaGlkZGVuIiksVD1TeW1ib2wuZm9yKCJyZWFjdC5jYWNoZSIpO1N5bWJvbC5mb3IoInJlYWN0LnRyYWNpbmdfbWFya2VyIik7dmFyIE09U3ltYm9sLmZvcigicmVhY3QuZGVmYXVsdF92YWx1ZSIpLEY9U3ltYm9sLml0ZXJhdG9yO2Z1bmN0aW9uIEQoZSl7cmV0dXJuIG51bGw9PT1lfHwib2JqZWN0IiE9dHlwZW9mIGU/bnVsbDoiZnVuY3Rpb24iPT10eXBlb2YoZT1GJiZlW0ZdfHxlWyJAQGl0ZXJhdG9yIl0pP2U6bnVsbH12YXIgUj1kKG51bGwpLE89ZChudWxsKSxBPWQobnVsbCk7ZnVuY3Rpb24gSShlLHQpe3N3aXRjaChoKEEsdCksaChPLGUpLGgoUixudWxsKSxlPXQubm9kZVR5cGUpe2Nhc2UgOTpjYXNlIDExOnQ9KHQ9dC5kb2N1bWVudEVsZW1lbnQpJiYodD10Lm5hbWVzcGFjZVVSSSk/c2codCk6MDticmVhaztkZWZhdWx0OmlmKHQ9KGU9OD09PWU/dC5wYXJlbnROb2RlOnQpLnRhZ05hbWUsZT1lLm5hbWVzcGFjZVVSSSl0PXN5KGU9c2coZSksdCk7ZWxzZSBzd2l0Y2godCl7Y2FzZSJzdmciOnQ9MTticmVhaztjYXNlIm1hdGgiOnQ9MjticmVhaztkZWZhdWx0OnQ9MH19cChSKSxoKFIsdCl9ZnVuY3Rpb24gVSgpe3AoUikscChPKSxwKEEpfWZ1bmN0aW9uIEIoZSl7dmFyIHQ9Ui5jdXJyZW50LG49c3kodCxlLnR5cGUpO3QhPT1uJiYoaChPLGUpLGgoUixuKSl9ZnVuY3Rpb24gUShlKXtPLmN1cnJlbnQ9PT1lJiYocChSKSxwKE8pKX12YXIgVj1hLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssJD1hLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrLFc9YS51bnN0YWJsZV9zaG91bGRZaWVsZCxqPWEudW5zdGFibGVfcmVxdWVzdFBhaW50LEg9YS51bnN0YWJsZV9ub3cscT1hLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsLEs9YS51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSxZPWEudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHksWD1hLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LEc9YS51bnN0YWJsZV9Mb3dQcmlvcml0eSxaPWEudW5zdGFibGVfSWRsZVByaW9yaXR5LEo9bnVsbCxlZT1udWxsLGV0PU1hdGguY2x6MzI/TWF0aC5jbHozMjpmdW5jdGlvbihlKXtyZXR1cm4gMD09KGU+Pj49MCk/MzI6MzEtKGVuKGUpL2VyfDApfDB9LGVuPU1hdGgubG9nLGVyPU1hdGguTE4yLGVsPTEyOCxlYT04Mzg4NjA4O2Z1bmN0aW9uIGVvKGUpe3N3aXRjaChlJi1lKXtjYXNlIDE6cmV0dXJuIDE7Y2FzZSAyOnJldHVybiAyO2Nhc2UgNDpyZXR1cm4gNDtjYXNlIDg6cmV0dXJuIDg7Y2FzZSAxNjpyZXR1cm4gMTY7Y2FzZSAzMjpyZXR1cm4gMzI7Y2FzZSA2NDpyZXR1cm4gNjQ7Y2FzZSAxMjg6Y2FzZSAyNTY6Y2FzZSA1MTI6Y2FzZSAxMDI0OmNhc2UgMjA0ODpjYXNlIDQwOTY6Y2FzZSA4MTkyOmNhc2UgMTYzODQ6Y2FzZSAzMjc2ODpjYXNlIDY1NTM2OmNhc2UgMTMxMDcyOmNhc2UgMjYyMTQ0OmNhc2UgNTI0Mjg4OmNhc2UgMTA0ODU3NjpjYXNlIDIwOTcxNTI6Y2FzZSA0MTk0MzA0OnJldHVybiA4Mzg4NDgwJmU7Y2FzZSA4Mzg4NjA4OmNhc2UgMTY3NzcyMTY6Y2FzZSAzMzU1NDQzMjpjYXNlIDY3MTA4ODY0OnJldHVybiAxMjU4MjkxMjAmZTtjYXNlIDEzNDIxNzcyODpyZXR1cm4gMTM0MjE3NzI4O2Nhc2UgMjY4NDM1NDU2OnJldHVybiAyNjg0MzU0NTY7Y2FzZSA1MzY4NzA5MTI6cmV0dXJuIDUzNjg3MDkxMjtjYXNlIDEwNzM3NDE4MjQ6cmV0dXJuIDEwNzM3NDE4MjQ7ZGVmYXVsdDpyZXR1cm4gZX19ZnVuY3Rpb24gZWkoZSx0KXt2YXIgbj1lLnBlbmRpbmdMYW5lcztpZigwPT09bilyZXR1cm4gMDt2YXIgcj0wLGw9ZS5zdXNwZW5kZWRMYW5lcyxhPWUucGluZ2VkTGFuZXMsbz0yNjg0MzU0NTUmbjtpZigwIT09byl7dmFyIGk9byZ+bDswIT09aT9yPWVvKGkpOjAhPShhJj1vKSYmKHI9ZW8oYSkpfWVsc2UgMCE9KG89biZ+bCk/cj1lbyhvKTowIT09YSYmKHI9ZW8oYSkpO2lmKDA9PT1yKXJldHVybiAwO2lmKDAhPT10JiZ0IT09ciYmMD09KHQmbCkmJigobD1yJi1yKT49KGE9dCYtdCl8fDMyPT09bCYmMCE9KDgzODg0ODAmYSkpKXJldHVybiB0O2lmKDAhPSg4JnIpJiYocnw9MzImbiksMCE9PSh0PWUuZW50YW5nbGVkTGFuZXMpKWZvcihlPWUuZW50YW5nbGVtZW50cyx0Jj1yOzA8dDspbD0xPDwobj0zMS1ldCh0KSkscnw9ZVtuXSx0Jj1+bDtyZXR1cm4gcn1mdW5jdGlvbiBldShlLHQpe3JldHVybiBlLmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzJnQ/MDowIT0oZT0tMTA3Mzc0MTgyNSZlLnBlbmRpbmdMYW5lcyk/ZToxMDczNzQxODI0JmU/MTA3Mzc0MTgyNDowfWZ1bmN0aW9uIGVzKCl7dmFyIGU9ZWw7cmV0dXJuIDA9PSg4Mzg4NDgwJihlbDw8PTEpKSYmKGVsPTEyOCksZX1mdW5jdGlvbiBlYygpe3ZhciBlPWVhO3JldHVybiAwPT0oMTI1ODI5MTIwJihlYTw8PTEpKSYmKGVhPTgzODg2MDgpLGV9ZnVuY3Rpb24gZWYoZSl7Zm9yKHZhciB0PVtdLG49MDszMT5uO24rKyl0LnB1c2goZSk7cmV0dXJuIHR9ZnVuY3Rpb24gZWQoZSx0KXtlLnBlbmRpbmdMYW5lc3w9dCw1MzY4NzA5MTIhPT10JiYoZS5zdXNwZW5kZWRMYW5lcz0wLGUucGluZ2VkTGFuZXM9MCl9ZnVuY3Rpb24gZXAoZSx0KXt2YXIgbj1lLmVudGFuZ2xlZExhbmVzfD10O2ZvcihlPWUuZW50YW5nbGVtZW50cztuOyl7dmFyIHI9MzEtZXQobiksbD0xPDxyO2wmdHxlW3JdJnQmJihlW3JdfD10KSxuJj1+bH19dmFyIGVoPTA7ZnVuY3Rpb24gZW0oZSl7cmV0dXJuIDI8KGUmPS1lKT84PGU/MCE9KDI2ODQzNTQ1NSZlKT8zMjo1MzY4NzA5MTI6ODoyfXZhciBlZz1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LGV5PU1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpLGV2PSJfX3JlYWN0RmliZXIkIitleSxlYj0iX19yZWFjdFByb3BzJCIrZXksZWs9Il9fcmVhY3RDb250YWluZXIkIitleSxldz0iX19yZWFjdEV2ZW50cyQiK2V5LGVTPSJfX3JlYWN0TGlzdGVuZXJzJCIrZXksZUU9Il9fcmVhY3RIYW5kbGVzJCIrZXksZUM9Il9fcmVhY3RSZXNvdXJjZXMkIitleSxleD0iX19yZWFjdE1hcmtlciQiK2V5O2Z1bmN0aW9uIGV6KGUpe2RlbGV0ZSBlW2V2XSxkZWxldGUgZVtlYl0sZGVsZXRlIGVbZXddLGRlbGV0ZSBlW2VTXSxkZWxldGUgZVtlRV19ZnVuY3Rpb24gZVAoZSl7dmFyIHQ9ZVtldl07aWYodClyZXR1cm4gdDtmb3IodmFyIG49ZS5wYXJlbnROb2RlO247KXtpZih0PW5bZWtdfHxuW2V2XSl7aWYobj10LmFsdGVybmF0ZSxudWxsIT09dC5jaGlsZHx8bnVsbCE9PW4mJm51bGwhPT1uLmNoaWxkKWZvcihlPXNOKGUpO251bGwhPT1lOyl7aWYobj1lW2V2XSlyZXR1cm4gbjtlPXNOKGUpfXJldHVybiB0fW49KGU9bikucGFyZW50Tm9kZX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBlTihlKXtpZihlPWVbZXZdfHxlW2VrXSl7dmFyIHQ9ZS50YWc7aWYoNT09PXR8fDY9PT10fHwxMz09PXR8fDI2PT09dHx8Mjc9PT10fHwzPT09dClyZXR1cm4gZX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBlXyhlKXt2YXIgdD1lLnRhZztpZig1PT09dHx8MjY9PT10fHwyNz09PXR8fDY9PT10KXJldHVybiBlLnN0YXRlTm9kZTt0aHJvdyBFcnJvcihpKDMzKSl9ZnVuY3Rpb24gZUwoZSl7cmV0dXJuIGVbZWJdfHxudWxsfWZ1bmN0aW9uIGVUKGUpe3ZhciB0PWVbZUNdO3JldHVybiB0fHwodD1lW2VDXT17aG9pc3RhYmxlU3R5bGVzOm5ldyBNYXAsaG9pc3RhYmxlU2NyaXB0czpuZXcgTWFwfSksdH1mdW5jdGlvbiBlTShlKXtlW2V4XT0hMH12YXIgZUY9bmV3IFNldCxlRD17fTtmdW5jdGlvbiBlUihlLHQpe2VPKGUsdCksZU8oZSsiQ2FwdHVyZSIsdCl9ZnVuY3Rpb24gZU8oZSx0KXtmb3IoZURbZV09dCxlPTA7ZTx0Lmxlbmd0aDtlKyspZUYuYWRkKHRbZV0pfXZhciBlQT0hKCJ1bmRlZmluZWQiPT10eXBlb2Ygd2luZG93fHx2b2lkIDA9PT13aW5kb3cuZG9jdW1lbnR8fHZvaWQgMD09PXdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KSxlST1SZWdFeHAoIl5bOkEtWl9hLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRF1bOkEtWl9hLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRFxcLS4wLTlcXHUwMEI3XFx1MDMwMC1cXHUwMzZGXFx1MjAzRi1cXHUyMDQwXSokIiksZVU9e30sZUI9e307ZnVuY3Rpb24gZVEoZSx0LG4pe2lmKGVnLmNhbGwoZUIsdCl8fCFlZy5jYWxsKGVVLHQpJiYoZUkudGVzdCh0KT9lQlt0XT0hMDooZVVbdF09ITAsITEpKSl7aWYobnVsbD09PW4pZS5yZW1vdmVBdHRyaWJ1dGUodCk7ZWxzZXtzd2l0Y2godHlwZW9mIG4pe2Nhc2UidW5kZWZpbmVkIjpjYXNlImZ1bmN0aW9uIjpjYXNlInN5bWJvbCI6ZS5yZW1vdmVBdHRyaWJ1dGUodCk7cmV0dXJuO2Nhc2UiYm9vbGVhbiI6dmFyIHI9dC50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsNSk7aWYoImRhdGEtIiE9PXImJiJhcmlhLSIhPT1yKXtlLnJlbW92ZUF0dHJpYnV0ZSh0KTtyZXR1cm59fWUuc2V0QXR0cmlidXRlKHQsIiIrbil9fX1mdW5jdGlvbiBlVihlLHQsbil7aWYobnVsbD09PW4pZS5yZW1vdmVBdHRyaWJ1dGUodCk7ZWxzZXtzd2l0Y2godHlwZW9mIG4pe2Nhc2UidW5kZWZpbmVkIjpjYXNlImZ1bmN0aW9uIjpjYXNlInN5bWJvbCI6Y2FzZSJib29sZWFuIjplLnJlbW92ZUF0dHJpYnV0ZSh0KTtyZXR1cm59ZS5zZXRBdHRyaWJ1dGUodCwiIituKX19ZnVuY3Rpb24gZSQoZSx0LG4scil7aWYobnVsbD09PXIpZS5yZW1vdmVBdHRyaWJ1dGUobik7ZWxzZXtzd2l0Y2godHlwZW9mIHIpe2Nhc2UidW5kZWZpbmVkIjpjYXNlImZ1bmN0aW9uIjpjYXNlInN5bWJvbCI6Y2FzZSJib29sZWFuIjplLnJlbW92ZUF0dHJpYnV0ZShuKTtyZXR1cm59ZS5zZXRBdHRyaWJ1dGVOUyh0LG4sIiIrcil9fWZ1bmN0aW9uIGVXKGUpe2lmKHZvaWQgMD09PWlkKXRyeXt0aHJvdyBFcnJvcigpfWNhdGNoKGUpe3ZhciB0PWUuc3RhY2sudHJpbSgpLm1hdGNoKC9cbiggKihhdCApPykvKTtpZD10JiZ0WzFdfHwiIn1yZXR1cm4iXG4iK2lkK2V9dmFyIGVqPSExO2Z1bmN0aW9uIGVIKGUsdCl7aWYoIWV8fGVqKXJldHVybiIiO2VqPSEwO3ZhciBuPUVycm9yLnByZXBhcmVTdGFja1RyYWNlO0Vycm9yLnByZXBhcmVTdGFja1RyYWNlPXZvaWQgMDt0cnl7aWYodCl7aWYodD1mdW5jdGlvbigpe3Rocm93IEVycm9yKCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSwicHJvcHMiLHtzZXQ6ZnVuY3Rpb24oKXt0aHJvdyBFcnJvcigpfX0pLCJvYmplY3QiPT10eXBlb2YgUmVmbGVjdCYmUmVmbGVjdC5jb25zdHJ1Y3Qpe3RyeXtSZWZsZWN0LmNvbnN0cnVjdCh0LFtdKX1jYXRjaChlKXt2YXIgcj1lfVJlZmxlY3QuY29uc3RydWN0KGUsW10sdCl9ZWxzZXt0cnl7dC5jYWxsKCl9Y2F0Y2goZSl7cj1lfWUuY2FsbCh0LnByb3RvdHlwZSl9fWVsc2V7dHJ5e3Rocm93IEVycm9yKCl9Y2F0Y2goZSl7cj1lfXZhciBsPWUoKTtsJiYiZnVuY3Rpb24iPT10eXBlb2YgbC5jYXRjaCYmbC5jYXRjaChmdW5jdGlvbigpe30pfX1jYXRjaCh0KXtpZih0JiZyJiYic3RyaW5nIj09dHlwZW9mIHQuc3RhY2spe2Zvcih2YXIgYT10LnN0YWNrLnNwbGl0KCJcbiIpLG89ci5zdGFjay5zcGxpdCgiXG4iKSxpPWEubGVuZ3RoLTEsdT1vLmxlbmd0aC0xOzE8PWkmJjA8PXUmJmFbaV0hPT1vW3VdOyl1LS07Zm9yKDsxPD1pJiYwPD11O2ktLSx1LS0paWYoYVtpXSE9PW9bdV0pe2lmKDEhPT1pfHwxIT09dSlkbyBpZihpLS0sMD4tLXV8fGFbaV0hPT1vW3VdKXt2YXIgcz0iXG4iK2FbaV0ucmVwbGFjZSgiIGF0IG5ldyAiLCIgYXQgIik7cmV0dXJuIGUuZGlzcGxheU5hbWUmJnMuaW5jbHVkZXMoIjxhbm9ueW1vdXM+IikmJihzPXMucmVwbGFjZSgiPGFub255bW91cz4iLGUuZGlzcGxheU5hbWUpKSxzfXdoaWxlKDE8PWkmJjA8PXUpO2JyZWFrfX19ZmluYWxseXtlaj0hMSxFcnJvci5wcmVwYXJlU3RhY2tUcmFjZT1ufXJldHVybihlPWU/ZS5kaXNwbGF5TmFtZXx8ZS5uYW1lOiIiKT9lVyhlKToiIn1mdW5jdGlvbiBlcShlKXtzd2l0Y2godHlwZW9mIGUpe2Nhc2UiYm9vbGVhbiI6Y2FzZSJudW1iZXIiOmNhc2Uic3RyaW5nIjpjYXNlInVuZGVmaW5lZCI6Y2FzZSJvYmplY3QiOnJldHVybiBlO2RlZmF1bHQ6cmV0dXJuIiJ9fWZ1bmN0aW9uIGVLKGUpe3ZhciB0PWUudHlwZTtyZXR1cm4oZT1lLm5vZGVOYW1lKSYmImlucHV0Ij09PWUudG9Mb3dlckNhc2UoKSYmKCJjaGVja2JveCI9PT10fHwicmFkaW8iPT09dCl9ZnVuY3Rpb24gZVkoZSl7ZS5fdmFsdWVUcmFja2VyfHwoZS5fdmFsdWVUcmFja2VyPWZ1bmN0aW9uKGUpe3ZhciB0PWVLKGUpPyJjaGVja2VkIjoidmFsdWUiLG49T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSx0KSxyPSIiK2VbdF07aWYoIWUuaGFzT3duUHJvcGVydHkodCkmJnZvaWQgMCE9PW4mJiJmdW5jdGlvbiI9PXR5cGVvZiBuLmdldCYmImZ1bmN0aW9uIj09dHlwZW9mIG4uc2V0KXt2YXIgbD1uLmdldCxhPW4uc2V0O3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGwuY2FsbCh0aGlzKX0sc2V0OmZ1bmN0aW9uKGUpe3I9IiIrZSxhLmNhbGwodGhpcyxlKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtlbnVtZXJhYmxlOm4uZW51bWVyYWJsZX0pLHtnZXRWYWx1ZTpmdW5jdGlvbigpe3JldHVybiByfSxzZXRWYWx1ZTpmdW5jdGlvbihlKXtyPSIiK2V9LHN0b3BUcmFja2luZzpmdW5jdGlvbigpe2UuX3ZhbHVlVHJhY2tlcj1udWxsLGRlbGV0ZSBlW3RdfX19fShlKSl9ZnVuY3Rpb24gZVgoZSl7aWYoIWUpcmV0dXJuITE7dmFyIHQ9ZS5fdmFsdWVUcmFja2VyO2lmKCF0KXJldHVybiEwO3ZhciBuPXQuZ2V0VmFsdWUoKSxyPSIiO3JldHVybiBlJiYocj1lSyhlKT9lLmNoZWNrZWQ/InRydWUiOiJmYWxzZSI6ZS52YWx1ZSksKGU9cikhPT1uJiYodC5zZXRWYWx1ZShlKSwhMCl9ZnVuY3Rpb24gZUcoZSl7aWYodm9pZCAwPT09KGU9ZXx8KCJ1bmRlZmluZWQiIT10eXBlb2YgZG9jdW1lbnQ/ZG9jdW1lbnQ6dm9pZCAwKSkpcmV0dXJuIG51bGw7dHJ5e3JldHVybiBlLmFjdGl2ZUVsZW1lbnR8fGUuYm9keX1jYXRjaCh0KXtyZXR1cm4gZS5ib2R5fX12YXIgZVo9L1tcbiJcXF0vZztmdW5jdGlvbiBlSihlKXtyZXR1cm4gZS5yZXBsYWNlKGVaLGZ1bmN0aW9uKGUpe3JldHVybiJcXCIrZS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSsiICJ9KX1mdW5jdGlvbiBlMChlLHQsbixyLGwsYSxvLGkpe2UubmFtZT0iIixudWxsIT1vJiYiZnVuY3Rpb24iIT10eXBlb2YgbyYmInN5bWJvbCIhPXR5cGVvZiBvJiYiYm9vbGVhbiIhPXR5cGVvZiBvP2UudHlwZT1vOmUucmVtb3ZlQXR0cmlidXRlKCJ0eXBlIiksbnVsbCE9dD8ibnVtYmVyIj09PW8/KDA9PT10JiYiIj09PWUudmFsdWV8fGUudmFsdWUhPXQpJiYoZS52YWx1ZT0iIitlcSh0KSk6ZS52YWx1ZSE9PSIiK2VxKHQpJiYoZS52YWx1ZT0iIitlcSh0KSk6InN1Ym1pdCIhPT1vJiYicmVzZXQiIT09b3x8ZS5yZW1vdmVBdHRyaWJ1dGUoInZhbHVlIiksbnVsbCE9dD9lMihlLG8sZXEodCkpOm51bGwhPW4/ZTIoZSxvLGVxKG4pKTpudWxsIT1yJiZlLnJlbW92ZUF0dHJpYnV0ZSgidmFsdWUiKSxudWxsPT1sJiZudWxsIT1hJiYoZS5kZWZhdWx0Q2hlY2tlZD0hIWEpLG51bGwhPWwmJiEhbCE9PWUuY2hlY2tlZCYmKGUuY2hlY2tlZD1sKSxudWxsIT1pJiYiZnVuY3Rpb24iIT10eXBlb2YgaSYmInN5bWJvbCIhPXR5cGVvZiBpJiYiYm9vbGVhbiIhPXR5cGVvZiBpP2UubmFtZT0iIitlcShpKTplLnJlbW92ZUF0dHJpYnV0ZSgibmFtZSIpfWZ1bmN0aW9uIGUxKGUsdCxuLHIsbCxhLG8saSl7aWYobnVsbCE9YSYmImZ1bmN0aW9uIiE9dHlwZW9mIGEmJiJzeW1ib2wiIT10eXBlb2YgYSYmImJvb2xlYW4iIT10eXBlb2YgYSYmKGUudHlwZT1hKSxudWxsIT10fHxudWxsIT1uKXtpZighKCJzdWJtaXQiIT09YSYmInJlc2V0IiE9PWF8fG51bGwhPXQpKXJldHVybjtuPW51bGwhPW4/IiIrZXEobik6IiIsdD1udWxsIT10PyIiK2VxKHQpOm4saXx8dD09PWUudmFsdWV8fChlLnZhbHVlPXQpLGUuZGVmYXVsdFZhbHVlPXR9cj0iZnVuY3Rpb24iIT10eXBlb2Yocj1udWxsIT1yP3I6bCkmJiJzeW1ib2wiIT10eXBlb2YgciYmISFyLGl8fChlLmNoZWNrZWQ9ISFyKSxlLmRlZmF1bHRDaGVja2VkPSEhcixudWxsIT1vJiYiZnVuY3Rpb24iIT10eXBlb2YgbyYmInN5bWJvbCIhPXR5cGVvZiBvJiYiYm9vbGVhbiIhPXR5cGVvZiBvJiYoZS5uYW1lPW8pfWZ1bmN0aW9uIGUyKGUsdCxuKXsibnVtYmVyIj09PXQmJmVHKGUub3duZXJEb2N1bWVudCk9PT1lfHxlLmRlZmF1bHRWYWx1ZT09PSIiK258fChlLmRlZmF1bHRWYWx1ZT0iIituKX12YXIgZTM9QXJyYXkuaXNBcnJheTtmdW5jdGlvbiBlNChlLHQsbixyKXtpZihlPWUub3B0aW9ucyx0KXt0PXt9O2Zvcih2YXIgbD0wO2w8bi5sZW5ndGg7bCsrKXRbIiQiK25bbF1dPSEwO2ZvcihuPTA7bjxlLmxlbmd0aDtuKyspbD10Lmhhc093blByb3BlcnR5KCIkIitlW25dLnZhbHVlKSxlW25dLnNlbGVjdGVkIT09bCYmKGVbbl0uc2VsZWN0ZWQ9bCksbCYmciYmKGVbbl0uZGVmYXVsdFNlbGVjdGVkPSEwKX1lbHNle2ZvcihsPTAsbj0iIitlcShuKSx0PW51bGw7bDxlLmxlbmd0aDtsKyspe2lmKGVbbF0udmFsdWU9PT1uKXtlW2xdLnNlbGVjdGVkPSEwLHImJihlW2xdLmRlZmF1bHRTZWxlY3RlZD0hMCk7cmV0dXJufW51bGwhPT10fHxlW2xdLmRpc2FibGVkfHwodD1lW2xdKX1udWxsIT09dCYmKHQuc2VsZWN0ZWQ9ITApfX1mdW5jdGlvbiBlOChlLHQsbil7aWYobnVsbCE9dCYmKCh0PSIiK2VxKHQpKSE9PWUudmFsdWUmJihlLnZhbHVlPXQpLG51bGw9PW4pKXtlLmRlZmF1bHRWYWx1ZSE9PXQmJihlLmRlZmF1bHRWYWx1ZT10KTtyZXR1cm59ZS5kZWZhdWx0VmFsdWU9bnVsbCE9bj8iIitlcShuKToiIn1mdW5jdGlvbiBlNihlLHQsbixyKXtpZihudWxsPT10KXtpZihudWxsIT1yKXtpZihudWxsIT1uKXRocm93IEVycm9yKGkoOTIpKTtpZihlMyhyKSl7aWYoMTxyLmxlbmd0aCl0aHJvdyBFcnJvcihpKDkzKSk7cj1yWzBdfW49cn1udWxsPT1uJiYobj0iIiksdD1ufW49ZXEodCksZS5kZWZhdWx0VmFsdWU9biwocj1lLnRleHRDb250ZW50KT09PW4mJiIiIT09ciYmbnVsbCE9PXImJihlLnZhbHVlPXIpfWZ1bmN0aW9uIGU1KGUsdCl7aWYoImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiE9PWUubmFtZXNwYWNlVVJJfHwiaW5uZXJIVE1MImluIGUpZS5pbm5lckhUTUw9dDtlbHNle2ZvcigoaXA9aXB8fGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpKS5pbm5lckhUTUw9Ijxzdmc+Iit0LnZhbHVlT2YoKS50b1N0cmluZygpKyI8L3N2Zz4iLHQ9aXAuZmlyc3RDaGlsZDtlLmZpcnN0Q2hpbGQ7KWUucmVtb3ZlQ2hpbGQoZS5maXJzdENoaWxkKTtmb3IoO3QuZmlyc3RDaGlsZDspZS5hcHBlbmRDaGlsZCh0LmZpcnN0Q2hpbGQpfX12YXIgZTc9ZTU7InVuZGVmaW5lZCIhPXR5cGVvZiBNU0FwcCYmTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24mJihlNz1mdW5jdGlvbihlLHQpe3JldHVybiBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbigpe3JldHVybiBlNShlLHQpfSl9KTt2YXIgZTk9ZTc7ZnVuY3Rpb24gdGUoZSx0KXtpZih0KXt2YXIgbj1lLmZpcnN0Q2hpbGQ7aWYobiYmbj09PWUubGFzdENoaWxkJiYzPT09bi5ub2RlVHlwZSl7bi5ub2RlVmFsdWU9dDtyZXR1cm59fWUudGV4dENvbnRlbnQ9dH12YXIgdHQ9bmV3IFNldCgiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQgYXNwZWN0UmF0aW8gYm9yZGVySW1hZ2VPdXRzZXQgYm9yZGVySW1hZ2VTbGljZSBib3JkZXJJbWFnZVdpZHRoIGJveEZsZXggYm94RmxleEdyb3VwIGJveE9yZGluYWxHcm91cCBjb2x1bW5Db3VudCBjb2x1bW5zIGZsZXggZmxleEdyb3cgZmxleFBvc2l0aXZlIGZsZXhTaHJpbmsgZmxleE5lZ2F0aXZlIGZsZXhPcmRlciBncmlkQXJlYSBncmlkUm93IGdyaWRSb3dFbmQgZ3JpZFJvd1NwYW4gZ3JpZFJvd1N0YXJ0IGdyaWRDb2x1bW4gZ3JpZENvbHVtbkVuZCBncmlkQ29sdW1uU3BhbiBncmlkQ29sdW1uU3RhcnQgZm9udFdlaWdodCBsaW5lQ2xhbXAgbGluZUhlaWdodCBvcGFjaXR5IG9yZGVyIG9ycGhhbnMgc2NhbGUgdGFiU2l6ZSB3aWRvd3MgekluZGV4IHpvb20gZmlsbE9wYWNpdHkgZmxvb2RPcGFjaXR5IHN0b3BPcGFjaXR5IHN0cm9rZURhc2hhcnJheSBzdHJva2VEYXNob2Zmc2V0IHN0cm9rZU1pdGVybGltaXQgc3Ryb2tlT3BhY2l0eSBzdHJva2VXaWR0aCBNb3pBbmltYXRpb25JdGVyYXRpb25Db3VudCBNb3pCb3hGbGV4IE1vekJveEZsZXhHcm91cCBNb3pMaW5lQ2xhbXAgbXNBbmltYXRpb25JdGVyYXRpb25Db3VudCBtc0ZsZXggbXNab29tIG1zRmxleEdyb3cgbXNGbGV4TmVnYXRpdmUgbXNGbGV4T3JkZXIgbXNGbGV4UG9zaXRpdmUgbXNGbGV4U2hyaW5rIG1zR3JpZENvbHVtbiBtc0dyaWRDb2x1bW5TcGFuIG1zR3JpZFJvdyBtc0dyaWRSb3dTcGFuIFdlYmtpdEFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IFdlYmtpdEJveEZsZXggV2ViS2l0Qm94RmxleEdyb3VwIFdlYmtpdEJveE9yZGluYWxHcm91cCBXZWJraXRDb2x1bW5Db3VudCBXZWJraXRDb2x1bW5zIFdlYmtpdEZsZXggV2Via2l0RmxleEdyb3cgV2Via2l0RmxleFBvc2l0aXZlIFdlYmtpdEZsZXhTaHJpbmsgV2Via2l0TGluZUNsYW1wIi5zcGxpdCgiICIpKTtmdW5jdGlvbiB0bihlLHQpe2lmKG51bGwhPXQmJiJvYmplY3QiIT10eXBlb2YgdCl0aHJvdyBFcnJvcihpKDYyKSk7Zm9yKHZhciBuIGluIGU9ZS5zdHlsZSx0KWlmKHQuaGFzT3duUHJvcGVydHkobikpe3ZhciByPXRbbl0sbD0wPT09bi5pbmRleE9mKCItLSIpO251bGw9PXJ8fCJib29sZWFuIj09dHlwZW9mIHJ8fCIiPT09cj9sP2Uuc2V0UHJvcGVydHkobiwiIik6ImZsb2F0Ij09PW4/ZS5jc3NGbG9hdD0iIjplW25dPSIiOmw/ZS5zZXRQcm9wZXJ0eShuLHIpOiJudW1iZXIiIT10eXBlb2Ygcnx8MD09PXJ8fHR0LmhhcyhuKT8iZmxvYXQiPT09bj9lLmNzc0Zsb2F0PXI6ZVtuXT0oIiIrcikudHJpbSgpOmVbbl09cisicHgifX1mdW5jdGlvbiB0cihlKXtpZigtMT09PWUuaW5kZXhPZigiLSIpKXJldHVybiExO3N3aXRjaChlKXtjYXNlImFubm90YXRpb24teG1sIjpjYXNlImNvbG9yLXByb2ZpbGUiOmNhc2UiZm9udC1mYWNlIjpjYXNlImZvbnQtZmFjZS1zcmMiOmNhc2UiZm9udC1mYWNlLXVyaSI6Y2FzZSJmb250LWZhY2UtZm9ybWF0IjpjYXNlImZvbnQtZmFjZS1uYW1lIjpjYXNlIm1pc3NpbmctZ2x5cGgiOnJldHVybiExO2RlZmF1bHQ6cmV0dXJuITB9fXZhciB0bD1uZXcgTWFwKFtbImFjY2VwdENoYXJzZXQiLCJhY2NlcHQtY2hhcnNldCJdLFsiaHRtbEZvciIsImZvciJdLFsiaHR0cEVxdWl2IiwiaHR0cC1lcXVpdiJdLFsiY3Jvc3NPcmlnaW4iLCJjcm9zc29yaWdpbiJdLFsiYWNjZW50SGVpZ2h0IiwiYWNjZW50LWhlaWdodCJdLFsiYWxpZ25tZW50QmFzZWxpbmUiLCJhbGlnbm1lbnQtYmFzZWxpbmUiXSxbImFyYWJpY0Zvcm0iLCJhcmFiaWMtZm9ybSJdLFsiYmFzZWxpbmVTaGlmdCIsImJhc2VsaW5lLXNoaWZ0Il0sWyJjYXBIZWlnaHQiLCJjYXAtaGVpZ2h0Il0sWyJjbGlwUGF0aCIsImNsaXAtcGF0aCJdLFsiY2xpcFJ1bGUiLCJjbGlwLXJ1bGUiXSxbImNvbG9ySW50ZXJwb2xhdGlvbiIsImNvbG9yLWludGVycG9sYXRpb24iXSxbImNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMiLCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMiXSxbImNvbG9yUHJvZmlsZSIsImNvbG9yLXByb2ZpbGUiXSxbImNvbG9yUmVuZGVyaW5nIiwiY29sb3ItcmVuZGVyaW5nIl0sWyJkb21pbmFudEJhc2VsaW5lIiwiZG9taW5hbnQtYmFzZWxpbmUiXSxbImVuYWJsZUJhY2tncm91bmQiLCJlbmFibGUtYmFja2dyb3VuZCJdLFsiZmlsbE9wYWNpdHkiLCJmaWxsLW9wYWNpdHkiXSxbImZpbGxSdWxlIiwiZmlsbC1ydWxlIl0sWyJmbG9vZENvbG9yIiwiZmxvb2QtY29sb3IiXSxbImZsb29kT3BhY2l0eSIsImZsb29kLW9wYWNpdHkiXSxbImZvbnRGYW1pbHkiLCJmb250LWZhbWlseSJdLFsiZm9udFNpemUiLCJmb250LXNpemUiXSxbImZvbnRTaXplQWRqdXN0IiwiZm9udC1zaXplLWFkanVzdCJdLFsiZm9udFN0cmV0Y2giLCJmb250LXN0cmV0Y2giXSxbImZvbnRTdHlsZSIsImZvbnQtc3R5bGUiXSxbImZvbnRWYXJpYW50IiwiZm9udC12YXJpYW50Il0sWyJmb250V2VpZ2h0IiwiZm9udC13ZWlnaHQiXSxbImdseXBoTmFtZSIsImdseXBoLW5hbWUiXSxbImdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsIiwiZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCJdLFsiZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsIiwiZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwiXSxbImhvcml6QWR2WCIsImhvcml6LWFkdi14Il0sWyJob3Jpek9yaWdpblgiLCJob3Jpei1vcmlnaW4teCJdLFsiaW1hZ2VSZW5kZXJpbmciLCJpbWFnZS1yZW5kZXJpbmciXSxbImxldHRlclNwYWNpbmciLCJsZXR0ZXItc3BhY2luZyJdLFsibGlnaHRpbmdDb2xvciIsImxpZ2h0aW5nLWNvbG9yIl0sWyJtYXJrZXJFbmQiLCJtYXJrZXItZW5kIl0sWyJtYXJrZXJNaWQiLCJtYXJrZXItbWlkIl0sWyJtYXJrZXJTdGFydCIsIm1hcmtlci1zdGFydCJdLFsib3ZlcmxpbmVQb3NpdGlvbiIsIm92ZXJsaW5lLXBvc2l0aW9uIl0sWyJvdmVybGluZVRoaWNrbmVzcyIsIm92ZXJsaW5lLXRoaWNrbmVzcyJdLFsicGFpbnRPcmRlciIsInBhaW50LW9yZGVyIl0sWyJwYW5vc2UtMSIsInBhbm9zZS0xIl0sWyJwb2ludGVyRXZlbnRzIiwicG9pbnRlci1ldmVudHMiXSxbInJlbmRlcmluZ0ludGVudCIsInJlbmRlcmluZy1pbnRlbnQiXSxbInNoYXBlUmVuZGVyaW5nIiwic2hhcGUtcmVuZGVyaW5nIl0sWyJzdG9wQ29sb3IiLCJzdG9wLWNvbG9yIl0sWyJzdG9wT3BhY2l0eSIsInN0b3Atb3BhY2l0eSJdLFsic3RyaWtldGhyb3VnaFBvc2l0aW9uIiwic3RyaWtldGhyb3VnaC1wb3NpdGlvbiJdLFsic3RyaWtldGhyb3VnaFRoaWNrbmVzcyIsInN0cmlrZXRocm91Z2gtdGhpY2tuZXNzIl0sWyJzdHJva2VEYXNoYXJyYXkiLCJzdHJva2UtZGFzaGFycmF5Il0sWyJzdHJva2VEYXNob2Zmc2V0Iiwic3Ryb2tlLWRhc2hvZmZzZXQiXSxbInN0cm9rZUxpbmVjYXAiLCJzdHJva2UtbGluZWNhcCJdLFsic3Ryb2tlTGluZWpvaW4iLCJzdHJva2UtbGluZWpvaW4iXSxbInN0cm9rZU1pdGVybGltaXQiLCJzdHJva2UtbWl0ZXJsaW1pdCJdLFsic3Ryb2tlT3BhY2l0eSIsInN0cm9rZS1vcGFjaXR5Il0sWyJzdHJva2VXaWR0aCIsInN0cm9rZS13aWR0aCJdLFsidGV4dEFuY2hvciIsInRleHQtYW5jaG9yIl0sWyJ0ZXh0RGVjb3JhdGlvbiIsInRleHQtZGVjb3JhdGlvbiJdLFsidGV4dFJlbmRlcmluZyIsInRleHQtcmVuZGVyaW5nIl0sWyJ0cmFuc2Zvcm1PcmlnaW4iLCJ0cmFuc2Zvcm0tb3JpZ2luIl0sWyJ1bmRlcmxpbmVQb3NpdGlvbiIsInVuZGVybGluZS1wb3NpdGlvbiJdLFsidW5kZXJsaW5lVGhpY2tuZXNzIiwidW5kZXJsaW5lLXRoaWNrbmVzcyJdLFsidW5pY29kZUJpZGkiLCJ1bmljb2RlLWJpZGkiXSxbInVuaWNvZGVSYW5nZSIsInVuaWNvZGUtcmFuZ2UiXSxbInVuaXRzUGVyRW0iLCJ1bml0cy1wZXItZW0iXSxbInZBbHBoYWJldGljIiwidi1hbHBoYWJldGljIl0sWyJ2SGFuZ2luZyIsInYtaGFuZ2luZyJdLFsidklkZW9ncmFwaGljIiwidi1pZGVvZ3JhcGhpYyJdLFsidk1hdGhlbWF0aWNhbCIsInYtbWF0aGVtYXRpY2FsIl0sWyJ2ZWN0b3JFZmZlY3QiLCJ2ZWN0b3ItZWZmZWN0Il0sWyJ2ZXJ0QWR2WSIsInZlcnQtYWR2LXkiXSxbInZlcnRPcmlnaW5YIiwidmVydC1vcmlnaW4teCJdLFsidmVydE9yaWdpblkiLCJ2ZXJ0LW9yaWdpbi15Il0sWyJ3b3JkU3BhY2luZyIsIndvcmQtc3BhY2luZyJdLFsid3JpdGluZ01vZGUiLCJ3cml0aW5nLW1vZGUiXSxbInhtbG5zWGxpbmsiLCJ4bWxuczp4bGluayJdLFsieEhlaWdodCIsIngtaGVpZ2h0Il1dKSx0YT1udWxsO2Z1bmN0aW9uIHRvKGUpe3JldHVybihlPWUudGFyZ2V0fHxlLnNyY0VsZW1lbnR8fHdpbmRvdykuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQmJihlPWUuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpLDM9PT1lLm5vZGVUeXBlP2UucGFyZW50Tm9kZTplfXZhciB0aT1udWxsLHR1PW51bGw7ZnVuY3Rpb24gdHMoZSl7dmFyIHQ9ZU4oZSk7aWYodCYmKGU9dC5zdGF0ZU5vZGUpKXt2YXIgbj1lTChlKTtzd2l0Y2goZT10LnN0YXRlTm9kZSx0LnR5cGUpe2Nhc2UiaW5wdXQiOmlmKGUwKGUsbi52YWx1ZSxuLmRlZmF1bHRWYWx1ZSxuLmRlZmF1bHRWYWx1ZSxuLmNoZWNrZWQsbi5kZWZhdWx0Q2hlY2tlZCxuLnR5cGUsbi5uYW1lKSx0PW4ubmFtZSwicmFkaW8iPT09bi50eXBlJiZudWxsIT10KXtmb3Iobj1lO24ucGFyZW50Tm9kZTspbj1uLnBhcmVudE5vZGU7Zm9yKG49bi5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPSInK2VKKCIiK3QpKyciXVt0eXBlPSJyYWRpbyJdJyksdD0wO3Q8bi5sZW5ndGg7dCsrKXt2YXIgcj1uW3RdO2lmKHIhPT1lJiZyLmZvcm09PT1lLmZvcm0pe3ZhciBsPWVMKHIpO2lmKCFsKXRocm93IEVycm9yKGkoOTApKTtlWChyKSxlMChyLGwudmFsdWUsbC5kZWZhdWx0VmFsdWUsbC5kZWZhdWx0VmFsdWUsbC5jaGVja2VkLGwuZGVmYXVsdENoZWNrZWQsbC50eXBlLGwubmFtZSl9fX1icmVhaztjYXNlInRleHRhcmVhIjplOChlLG4udmFsdWUsbi5kZWZhdWx0VmFsdWUpO2JyZWFrO2Nhc2Uic2VsZWN0IjpudWxsIT0odD1uLnZhbHVlKSYmZTQoZSwhIW4ubXVsdGlwbGUsdCwhMSl9fX1mdW5jdGlvbiB0YyhlKXt0aT90dT90dS5wdXNoKGUpOnR1PVtlXTp0aT1lfWZ1bmN0aW9uIHRmKCl7aWYodGkpe3ZhciBlPXRpLHQ9dHU7aWYodHU9dGk9bnVsbCx0cyhlKSx0KWZvcihlPTA7ZTx0Lmxlbmd0aDtlKyspdHModFtlXSl9fWZ1bmN0aW9uIHRkKGUpe3ZhciB0PWUsbj1lO2lmKGUuYWx0ZXJuYXRlKWZvcig7dC5yZXR1cm47KXQ9dC5yZXR1cm47ZWxzZXtlPXQ7ZG8gMCE9KDQwOTgmKHQ9ZSkuZmxhZ3MpJiYobj10LnJldHVybiksZT10LnJldHVybjt3aGlsZShlKX1yZXR1cm4gMz09PXQudGFnP246bnVsbH1mdW5jdGlvbiB0cChlKXtpZigxMz09PWUudGFnKXt2YXIgdD1lLm1lbW9pemVkU3RhdGU7aWYobnVsbD09PXQmJm51bGwhPT0oZT1lLmFsdGVybmF0ZSkmJih0PWUubWVtb2l6ZWRTdGF0ZSksbnVsbCE9PXQpcmV0dXJuIHQuZGVoeWRyYXRlZH1yZXR1cm4gbnVsbH1mdW5jdGlvbiB0aChlKXtpZih0ZChlKSE9PWUpdGhyb3cgRXJyb3IoaSgxODgpKX1mdW5jdGlvbiB0bShlKXtyZXR1cm4gbnVsbCE9PShlPWZ1bmN0aW9uKGUpe3ZhciB0PWUuYWx0ZXJuYXRlO2lmKCF0KXtpZihudWxsPT09KHQ9dGQoZSkpKXRocm93IEVycm9yKGkoMTg4KSk7cmV0dXJuIHQhPT1lP251bGw6ZX1mb3IodmFyIG49ZSxyPXQ7Oyl7dmFyIGw9bi5yZXR1cm47aWYobnVsbD09PWwpYnJlYWs7dmFyIGE9bC5hbHRlcm5hdGU7aWYobnVsbD09PWEpe2lmKG51bGwhPT0ocj1sLnJldHVybikpe249cjtjb250aW51ZX1icmVha31pZihsLmNoaWxkPT09YS5jaGlsZCl7Zm9yKGE9bC5jaGlsZDthOyl7aWYoYT09PW4pcmV0dXJuIHRoKGwpLGU7aWYoYT09PXIpcmV0dXJuIHRoKGwpLHQ7YT1hLnNpYmxpbmd9dGhyb3cgRXJyb3IoaSgxODgpKX1pZihuLnJldHVybiE9PXIucmV0dXJuKW49bCxyPWE7ZWxzZXtmb3IodmFyIG89ITEsdT1sLmNoaWxkO3U7KXtpZih1PT09bil7bz0hMCxuPWwscj1hO2JyZWFrfWlmKHU9PT1yKXtvPSEwLHI9bCxuPWE7YnJlYWt9dT11LnNpYmxpbmd9aWYoIW8pe2Zvcih1PWEuY2hpbGQ7dTspe2lmKHU9PT1uKXtvPSEwLG49YSxyPWw7YnJlYWt9aWYodT09PXIpe289ITAscj1hLG49bDticmVha311PXUuc2libGluZ31pZighbyl0aHJvdyBFcnJvcihpKDE4OSkpfX1pZihuLmFsdGVybmF0ZSE9PXIpdGhyb3cgRXJyb3IoaSgxOTApKX1pZigzIT09bi50YWcpdGhyb3cgRXJyb3IoaSgxODgpKTtyZXR1cm4gbi5zdGF0ZU5vZGUuY3VycmVudD09PW4/ZTp0fShlKSk/ZnVuY3Rpb24gZSh0KXt2YXIgbj10LnRhZztpZig1PT09bnx8MjY9PT1ufHwyNz09PW58fDY9PT1uKXJldHVybiB0O2Zvcih0PXQuY2hpbGQ7bnVsbCE9PXQ7KXtpZihudWxsIT09KG49ZSh0KSkpcmV0dXJuIG47dD10LnNpYmxpbmd9cmV0dXJuIG51bGx9KGUpOm51bGx9dmFyIHRnPXt9LHR5PWQodGcpLHR2PWQoITEpLHRiPXRnO2Z1bmN0aW9uIHRrKGUsdCl7dmFyIG49ZS50eXBlLmNvbnRleHRUeXBlcztpZighbilyZXR1cm4gdGc7dmFyIHI9ZS5zdGF0ZU5vZGU7aWYociYmci5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PT09dClyZXR1cm4gci5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dDt2YXIgbCxhPXt9O2ZvcihsIGluIG4pYVtsXT10W2xdO3JldHVybiByJiYoKGU9ZS5zdGF0ZU5vZGUpLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9dCxlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0PWEpLGF9ZnVuY3Rpb24gdHcoZSl7cmV0dXJuIG51bGwhPShlPWUuY2hpbGRDb250ZXh0VHlwZXMpfWZ1bmN0aW9uIHRTKCl7cCh0dikscCh0eSl9ZnVuY3Rpb24gdEUoZSx0LG4pe2lmKHR5LmN1cnJlbnQhPT10Zyl0aHJvdyBFcnJvcihpKDE2OCkpO2godHksdCksaCh0dixuKX1mdW5jdGlvbiB0QyhlLHQsbil7dmFyIHI9ZS5zdGF0ZU5vZGU7aWYodD10LmNoaWxkQ29udGV4dFR5cGVzLCJmdW5jdGlvbiIhPXR5cGVvZiByLmdldENoaWxkQ29udGV4dClyZXR1cm4gbjtmb3IodmFyIGwgaW4gcj1yLmdldENoaWxkQ29udGV4dCgpKWlmKCEobCBpbiB0KSl0aHJvdyBFcnJvcihpKDEwOCxmdW5jdGlvbihlKXt2YXIgdD1lLnR5cGU7c3dpdGNoKGUudGFnKXtjYXNlIDI0OnJldHVybiJDYWNoZSI7Y2FzZSA5OnJldHVybih0LmRpc3BsYXlOYW1lfHwiQ29udGV4dCIpKyIuQ29uc3VtZXIiO2Nhc2UgMTA6cmV0dXJuKHQuX2NvbnRleHQuZGlzcGxheU5hbWV8fCJDb250ZXh0IikrIi5Qcm92aWRlciI7Y2FzZSAxODpyZXR1cm4iRGVoeWRyYXRlZEZyYWdtZW50IjtjYXNlIDExOnJldHVybiBlPShlPXQucmVuZGVyKS5kaXNwbGF5TmFtZXx8ZS5uYW1lfHwiIix0LmRpc3BsYXlOYW1lfHwoIiIhPT1lPyJGb3J3YXJkUmVmKCIrZSsiKSI6IkZvcndhcmRSZWYiKTtjYXNlIDc6cmV0dXJuIkZyYWdtZW50IjtjYXNlIDI2OmNhc2UgMjc6Y2FzZSA1OnJldHVybiB0O2Nhc2UgNDpyZXR1cm4iUG9ydGFsIjtjYXNlIDM6cmV0dXJuIlJvb3QiO2Nhc2UgNjpyZXR1cm4iVGV4dCI7Y2FzZSAxNjpyZXR1cm4gZnVuY3Rpb24gZSh0KXtpZihudWxsPT10KXJldHVybiBudWxsO2lmKCJmdW5jdGlvbiI9PXR5cGVvZiB0KXJldHVybiB0LmRpc3BsYXlOYW1lfHx0Lm5hbWV8fG51bGw7aWYoInN0cmluZyI9PXR5cGVvZiB0KXJldHVybiB0O3N3aXRjaCh0KXtjYXNlIHk6cmV0dXJuIkZyYWdtZW50IjtjYXNlIGc6cmV0dXJuIlBvcnRhbCI7Y2FzZSBiOnJldHVybiJQcm9maWxlciI7Y2FzZSB2OnJldHVybiJTdHJpY3RNb2RlIjtjYXNlIEM6cmV0dXJuIlN1c3BlbnNlIjtjYXNlIHg6cmV0dXJuIlN1c3BlbnNlTGlzdCI7Y2FzZSBUOnJldHVybiJDYWNoZSJ9aWYoIm9iamVjdCI9PXR5cGVvZiB0KXN3aXRjaCh0LiQkdHlwZW9mKXtjYXNlIHc6cmV0dXJuKHQuZGlzcGxheU5hbWV8fCJDb250ZXh0IikrIi5Db25zdW1lciI7Y2FzZSBrOnJldHVybih0Ll9jb250ZXh0LmRpc3BsYXlOYW1lfHwiQ29udGV4dCIpKyIuUHJvdmlkZXIiO2Nhc2UgRTp2YXIgbj10LnJlbmRlcjtyZXR1cm4odD10LmRpc3BsYXlOYW1lKXx8KHQ9IiIhPT0odD1uLmRpc3BsYXlOYW1lfHxuLm5hbWV8fCIiKT8iRm9yd2FyZFJlZigiK3QrIikiOiJGb3J3YXJkUmVmIiksdDtjYXNlIHo6cmV0dXJuIG51bGwhPT0obj10LmRpc3BsYXlOYW1lfHxudWxsKT9uOmUodC50eXBlKXx8Ik1lbW8iO2Nhc2UgUDpuPXQuX3BheWxvYWQsdD10Ll9pbml0O3RyeXtyZXR1cm4gZSh0KG4pKX1jYXRjaChlKXticmVha31jYXNlIFM6cmV0dXJuKHQuZGlzcGxheU5hbWV8fHQuX2dsb2JhbE5hbWUpKyIuUHJvdmlkZXIifXJldHVybiBudWxsfSh0KTtjYXNlIDg6cmV0dXJuIHQ9PT12PyJTdHJpY3RNb2RlIjoiTW9kZSI7Y2FzZSAyMjpyZXR1cm4iT2Zmc2NyZWVuIjtjYXNlIDEyOnJldHVybiJQcm9maWxlciI7Y2FzZSAyMTpyZXR1cm4iU2NvcGUiO2Nhc2UgMTM6cmV0dXJuIlN1c3BlbnNlIjtjYXNlIDE5OnJldHVybiJTdXNwZW5zZUxpc3QiO2Nhc2UgMjU6cmV0dXJuIlRyYWNpbmdNYXJrZXIiO2Nhc2UgMTpjYXNlIDA6Y2FzZSAxNzpjYXNlIDI6Y2FzZSAxNDpjYXNlIDE1OmlmKCJmdW5jdGlvbiI9PXR5cGVvZiB0KXJldHVybiB0LmRpc3BsYXlOYW1lfHx0Lm5hbWV8fG51bGw7aWYoInN0cmluZyI9PXR5cGVvZiB0KXJldHVybiB0fXJldHVybiBudWxsfShlKXx8IlVua25vd24iLGwpKTtyZXR1cm4gdSh7fSxuLHIpfWZ1bmN0aW9uIHR4KGUpe3JldHVybiBlPShlPWUuc3RhdGVOb2RlKSYmZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dHx8dGcsdGI9dHkuY3VycmVudCxoKHR5LGUpLGgodHYsdHYuY3VycmVudCksITB9ZnVuY3Rpb24gdHooZSx0LG4pe3ZhciByPWUuc3RhdGVOb2RlO2lmKCFyKXRocm93IEVycm9yKGkoMTY5KSk7bj8oZT10QyhlLHQsdGIpLHIuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ9ZSxwKHR2KSxwKHR5KSxoKHR5LGUpKTpwKHR2KSxoKHR2LG4pfXZhciB0UD0iZnVuY3Rpb24iPT10eXBlb2YgT2JqZWN0LmlzP09iamVjdC5pczpmdW5jdGlvbihlLHQpe3JldHVybiBlPT09dCYmKDAhPT1lfHwxL2U9PTEvdCl8fGUhPWUmJnQhPXR9LHROPVtdLHRfPTAsdEw9bnVsbCx0VD0wLHRNPVtdLHRGPTAsdEQ9bnVsbCx0Uj0xLHRPPSIiO2Z1bmN0aW9uIHRBKGUsdCl7dE5bdF8rK109dFQsdE5bdF8rK109dEwsdEw9ZSx0VD10fWZ1bmN0aW9uIHRJKGUsdCxuKXt0TVt0RisrXT10Uix0TVt0RisrXT10Tyx0TVt0RisrXT10RCx0RD1lO3ZhciByPXRSO2U9dE87dmFyIGw9MzItZXQociktMTtyJj1+KDE8PGwpLG4rPTE7dmFyIGE9MzItZXQodCkrbDtpZigzMDxhKXt2YXIgbz1sLWwlNTthPShyJigxPDxvKS0xKS50b1N0cmluZygzMikscj4+PW8sbC09byx0Uj0xPDwzMi1ldCh0KStsfG48PGx8cix0Tz1hK2V9ZWxzZSB0Uj0xPDxhfG48PGx8cix0Tz1lfWZ1bmN0aW9uIHRVKGUpe251bGwhPT1lLnJldHVybiYmKHRBKGUsMSksdEkoZSwxLDApKX1mdW5jdGlvbiB0QihlKXtmb3IoO2U9PT10TDspdEw9dE5bLS10X10sdE5bdF9dPW51bGwsdFQ9dE5bLS10X10sdE5bdF9dPW51bGw7Zm9yKDtlPT09dEQ7KXREPXRNWy0tdEZdLHRNW3RGXT1udWxsLHRPPXRNWy0tdEZdLHRNW3RGXT1udWxsLHRSPXRNWy0tdEZdLHRNW3RGXT1udWxsfXZhciB0UT1udWxsLHRWPW51bGwsdCQ9ITEsdFc9bnVsbCx0aj0hMTtmdW5jdGlvbiB0SChlLHQpe3ZhciBuPW9xKDUsbnVsbCxudWxsLDApO24uZWxlbWVudFR5cGU9IkRFTEVURUQiLG4uc3RhdGVOb2RlPXQsbi5yZXR1cm49ZSxudWxsPT09KHQ9ZS5kZWxldGlvbnMpPyhlLmRlbGV0aW9ucz1bbl0sZS5mbGFnc3w9MTYpOnQucHVzaChuKX1mdW5jdGlvbiB0cShlLHQpe3QuZmxhZ3M9LTQwOTcmdC5mbGFnc3wyfWZ1bmN0aW9uIHRLKGUsdCl7cmV0dXJuIG51bGwhPT0odD1mdW5jdGlvbihlLHQsbixyKXtmb3IoOzE9PT1lLm5vZGVUeXBlOyl7aWYoZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIT09dC50b0xvd2VyQ2FzZSgpKXtpZighcilicmVha31lbHNle2lmKCFyKXJldHVybiBlO2lmKCFlW2V4XSlzd2l0Y2godCl7Y2FzZSJtZXRhIjppZighZS5oYXNBdHRyaWJ1dGUoIml0ZW1wcm9wIikpYnJlYWs7cmV0dXJuIGU7Y2FzZSJsaW5rIjp2YXIgbD1lLmdldEF0dHJpYnV0ZSgicmVsIik7aWYoInN0eWxlc2hlZXQiPT09bCYmZS5oYXNBdHRyaWJ1dGUoImRhdGEtcHJlY2VkZW5jZSIpfHxsIT09bi5yZWx8fGUuZ2V0QXR0cmlidXRlKCJocmVmIikhPT0obnVsbD09bi5ocmVmP251bGw6bi5ocmVmKXx8ZS5nZXRBdHRyaWJ1dGUoImNyb3Nzb3JpZ2luIikhPT0obnVsbD09bi5jcm9zc09yaWdpbj9udWxsOm4uY3Jvc3NPcmlnaW4pfHxlLmdldEF0dHJpYnV0ZSgidGl0bGUiKSE9PShudWxsPT1uLnRpdGxlP251bGw6bi50aXRsZSkpYnJlYWs7cmV0dXJuIGU7Y2FzZSJzdHlsZSI6aWYoZS5oYXNBdHRyaWJ1dGUoImRhdGEtcHJlY2VkZW5jZSIpKWJyZWFrO3JldHVybiBlO2Nhc2Uic2NyaXB0IjppZigoKGw9ZS5nZXRBdHRyaWJ1dGUoInNyYyIpKSE9PShudWxsPT1uLnNyYz9udWxsOm4uc3JjKXx8ZS5nZXRBdHRyaWJ1dGUoInR5cGUiKSE9PShudWxsPT1uLnR5cGU/bnVsbDpuLnR5cGUpfHxlLmdldEF0dHJpYnV0ZSgiY3Jvc3NvcmlnaW4iKSE9PShudWxsPT1uLmNyb3NzT3JpZ2luP251bGw6bi5jcm9zc09yaWdpbikpJiZsJiZlLmhhc0F0dHJpYnV0ZSgiYXN5bmMiKSYmIWUuaGFzQXR0cmlidXRlKCJpdGVtcHJvcCIpKWJyZWFrO3JldHVybiBlO2RlZmF1bHQ6cmV0dXJuIGV9fWlmKG51bGw9PT0oZT1zUChlLm5leHRTaWJsaW5nKSkpYnJlYWt9cmV0dXJuIG51bGx9KHQsZS50eXBlLGUucGVuZGluZ1Byb3BzLHRqKSkmJihlLnN0YXRlTm9kZT10LHRRPWUsdFY9c1AodC5maXJzdENoaWxkKSx0aj0hMSwhMCl9ZnVuY3Rpb24gdFkoZSx0KXtyZXR1cm4gbnVsbCE9PSh0PWZ1bmN0aW9uKGUsdCxuKXtpZigiIj09PXQpcmV0dXJuIG51bGw7Zm9yKDszIT09ZS5ub2RlVHlwZTspaWYoIW58fG51bGw9PT0oZT1zUChlLm5leHRTaWJsaW5nKSkpcmV0dXJuIG51bGw7cmV0dXJuIGV9KHQsZS5wZW5kaW5nUHJvcHMsdGopKSYmKGUuc3RhdGVOb2RlPXQsdFE9ZSx0Vj1udWxsLCEwKX1mdW5jdGlvbiB0WChlLHQpe2U6e3ZhciBuPXQ7Zm9yKHQ9dGo7OCE9PW4ubm9kZVR5cGU7KWlmKCF0fHxudWxsPT09KG49c1Aobi5uZXh0U2libGluZykpKXt0PW51bGw7YnJlYWsgZX10PW59cmV0dXJuIG51bGwhPT10JiYobj1udWxsIT09dEQ/e2lkOnRSLG92ZXJmbG93OnRPfTpudWxsLGUubWVtb2l6ZWRTdGF0ZT17ZGVoeWRyYXRlZDp0LHRyZWVDb250ZXh0Om4scmV0cnlMYW5lOjEwNzM3NDE4MjR9LChuPW9xKDE4LG51bGwsbnVsbCwwKSkuc3RhdGVOb2RlPXQsbi5yZXR1cm49ZSxlLmNoaWxkPW4sdFE9ZSx0Vj1udWxsLCEwKX1mdW5jdGlvbiB0RyhlKXtyZXR1cm4gMCE9KDEmZS5tb2RlKSYmMD09KDEyOCZlLmZsYWdzKX1mdW5jdGlvbiB0Wigpe3Rocm93IEVycm9yKGkoNDE4KSl9ZnVuY3Rpb24gdEooZSl7dmFyIHQ9ZS5zdGF0ZU5vZGUsbj1lLnR5cGUscj1lLm1lbW9pemVkUHJvcHM7dFtldl09ZSx0W2ViXT1yO3ZhciBsPTAhPSgxJmUubW9kZSk7c3dpdGNoKG4pe2Nhc2UiZGlhbG9nIjp1NCgiY2FuY2VsIix0KSx1NCgiY2xvc2UiLHQpO2JyZWFrO2Nhc2UiaWZyYW1lIjpjYXNlIm9iamVjdCI6Y2FzZSJlbWJlZCI6dTQoImxvYWQiLHQpO2JyZWFrO2Nhc2UidmlkZW8iOmNhc2UiYXVkaW8iOmZvcihuPTA7bjx1MC5sZW5ndGg7bisrKXU0KHUwW25dLHQpO2JyZWFrO2Nhc2Uic291cmNlIjp1NCgiZXJyb3IiLHQpO2JyZWFrO2Nhc2UiaW1nIjpjYXNlImltYWdlIjpjYXNlImxpbmsiOnU0KCJlcnJvciIsdCksdTQoImxvYWQiLHQpO2JyZWFrO2Nhc2UiZGV0YWlscyI6dTQoInRvZ2dsZSIsdCk7YnJlYWs7Y2FzZSJpbnB1dCI6dTQoImludmFsaWQiLHQpLGUxKHQsci52YWx1ZSxyLmRlZmF1bHRWYWx1ZSxyLmNoZWNrZWQsci5kZWZhdWx0Q2hlY2tlZCxyLnR5cGUsci5uYW1lLCEwKSxlWSh0KTticmVhaztjYXNlInNlbGVjdCI6dTQoImludmFsaWQiLHQpO2JyZWFrO2Nhc2UidGV4dGFyZWEiOnU0KCJpbnZhbGlkIix0KSxlNih0LHIudmFsdWUsci5kZWZhdWx0VmFsdWUsci5jaGlsZHJlbiksZVkodCl9bj1udWxsO3ZhciBhPXIuY2hpbGRyZW47cmV0dXJuInN0cmluZyIhPXR5cGVvZiBhJiYibnVtYmVyIiE9dHlwZW9mIGF8fHQudGV4dENvbnRlbnQ9PT0iIithfHwoITAhPT1yLnN1cHByZXNzSHlkcmF0aW9uV2FybmluZyYmc2kodC50ZXh0Q29udGVudCxhLGwpLGx8fChuPVsiY2hpbGRyZW4iLGFdKSksbnVsbCE9ci5vblNjcm9sbCYmdTQoInNjcm9sbCIsdCksbnVsbCE9ci5vbkNsaWNrJiYodC5vbmNsaWNrPXN1KSx0PW4sZS51cGRhdGVRdWV1ZT10LG51bGwhPT10fWZ1bmN0aW9uIHQwKGUpe2Zvcih0UT1lLnJldHVybjt0UTspc3dpdGNoKHRRLnRhZyl7Y2FzZSAzOmNhc2UgMjc6dGo9ITA7cmV0dXJuO2Nhc2UgNTpjYXNlIDEzOnRqPSExO3JldHVybjtkZWZhdWx0OnRRPXRRLnJldHVybn19ZnVuY3Rpb24gdDEoZSl7aWYoZSE9PXRRKXJldHVybiExO2lmKCF0JClyZXR1cm4gdDAoZSksdCQ9ITAsITE7dmFyIHQ9ITE7aWYoMz09PWUudGFnfHwyNz09PWUudGFnfHw1PT09ZS50YWcmJnN2KGUudHlwZSxlLm1lbW9pemVkUHJvcHMpfHwodD0hMCksdCYmKHQ9dFYpKXtpZih0RyhlKSl0MigpLHRaKCk7ZWxzZSBmb3IoO3Q7KXRIKGUsdCksdD1zUCh0Lm5leHRTaWJsaW5nKX1pZih0MChlKSwxMz09PWUudGFnKXtpZighKGU9bnVsbCE9PShlPWUubWVtb2l6ZWRTdGF0ZSk/ZS5kZWh5ZHJhdGVkOm51bGwpKXRocm93IEVycm9yKGkoMzE3KSk7ZTp7Zm9yKHQ9MCxlPWUubmV4dFNpYmxpbmc7ZTspe2lmKDg9PT1lLm5vZGVUeXBlKXt2YXIgbj1lLmRhdGE7aWYoIi8kIj09PW4pe2lmKDA9PT10KXt0Vj1zUChlLm5leHRTaWJsaW5nKTticmVhayBlfXQtLX1lbHNlIiQiIT09biYmIiQhIiE9PW4mJiIkPyIhPT1ufHx0Kyt9ZT1lLm5leHRTaWJsaW5nfXRWPW51bGx9fWVsc2UgdFY9dFE/c1AoZS5zdGF0ZU5vZGUubmV4dFNpYmxpbmcpOm51bGw7cmV0dXJuITB9ZnVuY3Rpb24gdDIoKXtmb3IodmFyIGU9dFY7ZTspZT1zUChlLm5leHRTaWJsaW5nKX1mdW5jdGlvbiB0Mygpe3RWPXRRPW51bGwsdCQ9ITF9ZnVuY3Rpb24gdDQoZSl7bnVsbD09PXRXP3RXPVtlXTp0Vy5wdXNoKGUpfXZhciB0OD1bXSx0Nj0wLHQ1PTA7ZnVuY3Rpb24gdDcoKXtmb3IodmFyIGU9dDYsdD10NT10Nj0wO3Q8ZTspe3ZhciBuPXQ4W3RdO3Q4W3QrK109bnVsbDt2YXIgcj10OFt0XTt0OFt0KytdPW51bGw7dmFyIGw9dDhbdF07dDhbdCsrXT1udWxsO3ZhciBhPXQ4W3RdO2lmKHQ4W3QrK109bnVsbCxudWxsIT09ciYmbnVsbCE9PWwpe3ZhciBvPXIucGVuZGluZztudWxsPT09bz9sLm5leHQ9bDoobC5uZXh0PW8ubmV4dCxvLm5leHQ9bCksci5wZW5kaW5nPWx9MCE9PWEmJm50KG4sbCxhKX19ZnVuY3Rpb24gdDkoZSx0LG4scil7dDhbdDYrK109ZSx0OFt0NisrXT10LHQ4W3Q2KytdPW4sdDhbdDYrK109cix0NXw9cixlLmxhbmVzfD1yLG51bGwhPT0oZT1lLmFsdGVybmF0ZSkmJihlLmxhbmVzfD1yKX1mdW5jdGlvbiBuZShlLHQpe3JldHVybiB0OShlLG51bGwsbnVsbCx0KSxubihlKX1mdW5jdGlvbiBudChlLHQsbil7ZS5sYW5lc3w9bjt2YXIgcj1lLmFsdGVybmF0ZTtudWxsIT09ciYmKHIubGFuZXN8PW4pO2Zvcih2YXIgbD0hMSxhPWUucmV0dXJuO251bGwhPT1hOylhLmNoaWxkTGFuZXN8PW4sbnVsbCE9PShyPWEuYWx0ZXJuYXRlKSYmKHIuY2hpbGRMYW5lc3w9biksMjI9PT1hLnRhZyYmKG51bGw9PT0oZT1hLnN0YXRlTm9kZSl8fDEmZS5fdmlzaWJpbGl0eXx8KGw9ITApKSxlPWEsYT1hLnJldHVybjtsJiZudWxsIT09dCYmMz09PWUudGFnJiYoYT1lLnN0YXRlTm9kZSxsPTMxLWV0KG4pLG51bGw9PT0oZT0oYT1hLmhpZGRlblVwZGF0ZXMpW2xdKT9hW2xdPVt0XTplLnB1c2godCksdC5sYW5lPTEwNzM3NDE4MjR8bil9ZnVuY3Rpb24gbm4oZSl7aWYoNTA8b3ApdGhyb3cgb3A9MCxvaD1udWxsLEVycm9yKGkoMTg1KSk7Zm9yKHZhciB0PWUucmV0dXJuO251bGwhPT10Oyl0PShlPXQpLnJldHVybjtyZXR1cm4gMz09PWUudGFnP2Uuc3RhdGVOb2RlOm51bGx9dmFyIG5yPSExO2Z1bmN0aW9uIG5sKGUpe2UudXBkYXRlUXVldWU9e2Jhc2VTdGF0ZTplLm1lbW9pemVkU3RhdGUsZmlyc3RCYXNlVXBkYXRlOm51bGwsbGFzdEJhc2VVcGRhdGU6bnVsbCxzaGFyZWQ6e3BlbmRpbmc6bnVsbCxsYW5lczowLGhpZGRlbkNhbGxiYWNrczpudWxsfSxjYWxsYmFja3M6bnVsbH19ZnVuY3Rpb24gbmEoZSx0KXtlPWUudXBkYXRlUXVldWUsdC51cGRhdGVRdWV1ZT09PWUmJih0LnVwZGF0ZVF1ZXVlPXtiYXNlU3RhdGU6ZS5iYXNlU3RhdGUsZmlyc3RCYXNlVXBkYXRlOmUuZmlyc3RCYXNlVXBkYXRlLGxhc3RCYXNlVXBkYXRlOmUubGFzdEJhc2VVcGRhdGUsc2hhcmVkOmUuc2hhcmVkLGNhbGxiYWNrczpudWxsfSl9ZnVuY3Rpb24gbm8oZSl7cmV0dXJue2xhbmU6ZSx0YWc6MCxwYXlsb2FkOm51bGwsY2FsbGJhY2s6bnVsbCxuZXh0Om51bGx9fWZ1bmN0aW9uIG5pKGUsdCxuKXt2YXIgcj1lLnVwZGF0ZVF1ZXVlO2lmKG51bGw9PT1yKXJldHVybiBudWxsO2lmKHI9ci5zaGFyZWQsMCE9KDImYUcpKXt2YXIgbD1yLnBlbmRpbmc7cmV0dXJuIG51bGw9PT1sP3QubmV4dD10Oih0Lm5leHQ9bC5uZXh0LGwubmV4dD10KSxyLnBlbmRpbmc9dCx0PW5uKGUpLG50KGUsbnVsbCxuKSx0fXJldHVybiB0OShlLHIsdCxuKSxubihlKX1mdW5jdGlvbiBudShlLHQsbil7aWYobnVsbCE9PSh0PXQudXBkYXRlUXVldWUpJiYodD10LnNoYXJlZCwwIT0oODM4ODQ4MCZuKSkpe3ZhciByPXQubGFuZXM7ciY9ZS5wZW5kaW5nTGFuZXMsbnw9cix0LmxhbmVzPW4sZXAoZSxuKX19ZnVuY3Rpb24gbnMoZSx0KXt2YXIgbj1lLnVwZGF0ZVF1ZXVlLHI9ZS5hbHRlcm5hdGU7aWYobnVsbCE9PXImJm49PT0ocj1yLnVwZGF0ZVF1ZXVlKSl7dmFyIGw9bnVsbCxhPW51bGw7aWYobnVsbCE9PShuPW4uZmlyc3RCYXNlVXBkYXRlKSl7ZG97dmFyIG89e2xhbmU6bi5sYW5lLHRhZzpuLnRhZyxwYXlsb2FkOm4ucGF5bG9hZCxjYWxsYmFjazpudWxsLG5leHQ6bnVsbH07bnVsbD09PWE/bD1hPW86YT1hLm5leHQ9byxuPW4ubmV4dH13aGlsZShudWxsIT09bik7bnVsbD09PWE/bD1hPXQ6YT1hLm5leHQ9dH1lbHNlIGw9YT10O249e2Jhc2VTdGF0ZTpyLmJhc2VTdGF0ZSxmaXJzdEJhc2VVcGRhdGU6bCxsYXN0QmFzZVVwZGF0ZTphLHNoYXJlZDpyLnNoYXJlZCxjYWxsYmFja3M6ci5jYWxsYmFja3N9LGUudXBkYXRlUXVldWU9bjtyZXR1cm59bnVsbD09PShlPW4ubGFzdEJhc2VVcGRhdGUpP24uZmlyc3RCYXNlVXBkYXRlPXQ6ZS5uZXh0PXQsbi5sYXN0QmFzZVVwZGF0ZT10fWZ1bmN0aW9uIG5jKGUsdCxuLHIpe3ZhciBsPWUudXBkYXRlUXVldWU7bnI9ITE7dmFyIGE9bC5maXJzdEJhc2VVcGRhdGUsbz1sLmxhc3RCYXNlVXBkYXRlLGk9bC5zaGFyZWQucGVuZGluZztpZihudWxsIT09aSl7bC5zaGFyZWQucGVuZGluZz1udWxsO3ZhciBzPWksYz1zLm5leHQ7cy5uZXh0PW51bGwsbnVsbD09PW8/YT1jOm8ubmV4dD1jLG89czt2YXIgZj1lLmFsdGVybmF0ZTtudWxsIT09ZiYmKGk9KGY9Zi51cGRhdGVRdWV1ZSkubGFzdEJhc2VVcGRhdGUpIT09byYmKG51bGw9PT1pP2YuZmlyc3RCYXNlVXBkYXRlPWM6aS5uZXh0PWMsZi5sYXN0QmFzZVVwZGF0ZT1zKX1pZihudWxsIT09YSl7dmFyIGQ9bC5iYXNlU3RhdGU7Zm9yKG89MCxmPWM9cz1udWxsLGk9YTs7KXt2YXIgcD0tMTA3Mzc0MTgyNSZpLmxhbmUsaD1wIT09aS5sYW5lO2lmKGg/KGEwJnApPT09cDoociZwKT09PXApe251bGwhPT1mJiYoZj1mLm5leHQ9e2xhbmU6MCx0YWc6aS50YWcscGF5bG9hZDppLnBheWxvYWQsY2FsbGJhY2s6bnVsbCxuZXh0Om51bGx9KTtlOnt2YXIgbT1lLGc9aTtzd2l0Y2gocD10LGcudGFnKXtjYXNlIDE6aWYoImZ1bmN0aW9uIj09dHlwZW9mKG09Zy5wYXlsb2FkKSl7ZD1tLmNhbGwobixkLHApO2JyZWFrIGV9ZD1tO2JyZWFrIGU7Y2FzZSAzOm0uZmxhZ3M9LTY1NTM3Jm0uZmxhZ3N8MTI4O2Nhc2UgMDppZihudWxsPT0ocD0iZnVuY3Rpb24iPT10eXBlb2YobT1nLnBheWxvYWQpP20uY2FsbChuLGQscCk6bSkpYnJlYWsgZTtkPXUoe30sZCxwKTticmVhayBlO2Nhc2UgMjpucj0hMH19bnVsbCE9PShwPWkuY2FsbGJhY2spJiYoZS5mbGFnc3w9NjQsaCYmKGUuZmxhZ3N8PTgxOTIpLG51bGw9PT0oaD1sLmNhbGxiYWNrcyk/bC5jYWxsYmFja3M9W3BdOmgucHVzaChwKSl9ZWxzZSBoPXtsYW5lOnAsdGFnOmkudGFnLHBheWxvYWQ6aS5wYXlsb2FkLGNhbGxiYWNrOmkuY2FsbGJhY2ssbmV4dDpudWxsfSxudWxsPT09Zj8oYz1mPWgscz1kKTpmPWYubmV4dD1oLG98PXA7aWYobnVsbD09PShpPWkubmV4dCkpe2lmKG51bGw9PT0oaT1sLnNoYXJlZC5wZW5kaW5nKSlicmVhaztpPShoPWkpLm5leHQsaC5uZXh0PW51bGwsbC5sYXN0QmFzZVVwZGF0ZT1oLGwuc2hhcmVkLnBlbmRpbmc9bnVsbH19bnVsbD09PWYmJihzPWQpLGwuYmFzZVN0YXRlPXMsbC5maXJzdEJhc2VVcGRhdGU9YyxsLmxhc3RCYXNlVXBkYXRlPWYsbnVsbD09PWEmJihsLnNoYXJlZC5sYW5lcz0wKSxhNXw9byxlLmxhbmVzPW8sZS5tZW1vaXplZFN0YXRlPWR9fWZ1bmN0aW9uIG5mKGUsdCl7aWYoImZ1bmN0aW9uIiE9dHlwZW9mIGUpdGhyb3cgRXJyb3IoaSgxOTEsZSkpO2UuY2FsbCh0KX1mdW5jdGlvbiBuZChlLHQpe3ZhciBuPWUuY2FsbGJhY2tzO2lmKG51bGwhPT1uKWZvcihlLmNhbGxiYWNrcz1udWxsLGU9MDtlPG4ubGVuZ3RoO2UrKyluZihuW2VdLHQpfWZ1bmN0aW9uIG5wKGUsdCl7aWYodFAoZSx0KSlyZXR1cm4hMDtpZigib2JqZWN0IiE9dHlwZW9mIGV8fG51bGw9PT1lfHwib2JqZWN0IiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVybiExO3ZhciBuPU9iamVjdC5rZXlzKGUpLHI9T2JqZWN0LmtleXModCk7aWYobi5sZW5ndGghPT1yLmxlbmd0aClyZXR1cm4hMTtmb3Iocj0wO3I8bi5sZW5ndGg7cisrKXt2YXIgbD1uW3JdO2lmKCFlZy5jYWxsKHQsbCl8fCF0UChlW2xdLHRbbF0pKXJldHVybiExfXJldHVybiEwfXZhciBuaD1FcnJvcihpKDQ2MCkpLG5tPUVycm9yKGkoNDc0KSksbmc9e3RoZW46ZnVuY3Rpb24oKXt9fTtmdW5jdGlvbiBueShlKXtyZXR1cm4iZnVsZmlsbGVkIj09PShlPWUuc3RhdHVzKXx8InJlamVjdGVkIj09PWV9ZnVuY3Rpb24gbnYoKXt9ZnVuY3Rpb24gbmIoZSx0LG4pe3N3aXRjaCh2b2lkIDA9PT0obj1lW25dKT9lLnB1c2godCk6biE9PXQmJih0LnRoZW4obnYsbnYpLHQ9biksdC5zdGF0dXMpe2Nhc2UiZnVsZmlsbGVkIjpyZXR1cm4gdC52YWx1ZTtjYXNlInJlamVjdGVkIjppZigoZT10LnJlYXNvbik9PT1uaCl0aHJvdyBFcnJvcihpKDQ4MykpO3Rocm93IGU7ZGVmYXVsdDppZigic3RyaW5nIj09dHlwZW9mIHQuc3RhdHVzKXQudGhlbihudixudik7ZWxzZXtpZihudWxsIT09KGU9YVopJiYxMDA8ZS5zaGVsbFN1c3BlbmRDb3VudGVyKXRocm93IEVycm9yKGkoNDgyKSk7c3dpdGNoKChlPXQpLnN0YXR1cz0icGVuZGluZyIsZS50aGVuKGZ1bmN0aW9uKGUpe2lmKCJwZW5kaW5nIj09PXQuc3RhdHVzKXt2YXIgbj10O24uc3RhdHVzPSJmdWxmaWxsZWQiLG4udmFsdWU9ZX19LGZ1bmN0aW9uKGUpe2lmKCJwZW5kaW5nIj09PXQuc3RhdHVzKXt2YXIgbj10O24uc3RhdHVzPSJyZWplY3RlZCIsbi5yZWFzb249ZX19KSx0LnN0YXR1cyl7Y2FzZSJmdWxmaWxsZWQiOnJldHVybiB0LnZhbHVlO2Nhc2UicmVqZWN0ZWQiOmlmKChlPXQucmVhc29uKT09PW5oKXRocm93IEVycm9yKGkoNDgzKSk7dGhyb3cgZX19dGhyb3cgbms9dCxuaH19dmFyIG5rPW51bGw7ZnVuY3Rpb24gbncoKXtpZihudWxsPT09bmspdGhyb3cgRXJyb3IoaSg0NTkpKTt2YXIgZT1uaztyZXR1cm4gbms9bnVsbCxlfXZhciBuUz1udWxsLG5FPTA7ZnVuY3Rpb24gbkMoZSl7dmFyIHQ9bkU7cmV0dXJuIG5FKz0xLG51bGw9PT1uUyYmKG5TPVtdKSxuYihuUyxlLHQpfWZ1bmN0aW9uIG54KGUsdCxuKXtpZihudWxsIT09KGU9bi5yZWYpJiYiZnVuY3Rpb24iIT10eXBlb2YgZSYmIm9iamVjdCIhPXR5cGVvZiBlKXtpZihuLl9vd25lcil7aWYobj1uLl9vd25lcil7aWYoMSE9PW4udGFnKXRocm93IEVycm9yKGkoMzA5KSk7dmFyIHI9bi5zdGF0ZU5vZGV9aWYoIXIpdGhyb3cgRXJyb3IoaSgxNDcsZSkpO3ZhciBsPXIsYT0iIitlO3JldHVybiBudWxsIT09dCYmbnVsbCE9PXQucmVmJiYiZnVuY3Rpb24iPT10eXBlb2YgdC5yZWYmJnQucmVmLl9zdHJpbmdSZWY9PT1hP3QucmVmOigodD1mdW5jdGlvbihlKXt2YXIgdD1sLnJlZnM7bnVsbD09PWU/ZGVsZXRlIHRbYV06dFthXT1lfSkuX3N0cmluZ1JlZj1hLHQpfWlmKCJzdHJpbmciIT10eXBlb2YgZSl0aHJvdyBFcnJvcihpKDI4NCkpO2lmKCFuLl9vd25lcil0aHJvdyBFcnJvcihpKDI5MCxlKSl9cmV0dXJuIGV9ZnVuY3Rpb24gbnooZSx0KXt0aHJvdyBFcnJvcihpKDMxLCJbb2JqZWN0IE9iamVjdF0iPT09KGU9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpKT8ib2JqZWN0IHdpdGgga2V5cyB7IitPYmplY3Qua2V5cyh0KS5qb2luKCIsICIpKyJ9IjplKSl9ZnVuY3Rpb24gblAoZSl7cmV0dXJuKDAsZS5faW5pdCkoZS5fcGF5bG9hZCl9ZnVuY3Rpb24gbk4oZSl7ZnVuY3Rpb24gdCh0LG4pe2lmKGUpe3ZhciByPXQuZGVsZXRpb25zO251bGw9PT1yPyh0LmRlbGV0aW9ucz1bbl0sdC5mbGFnc3w9MTYpOnIucHVzaChuKX19ZnVuY3Rpb24gbihuLHIpe2lmKCFlKXJldHVybiBudWxsO2Zvcig7bnVsbCE9PXI7KXQobixyKSxyPXIuc2libGluZztyZXR1cm4gbnVsbH1mdW5jdGlvbiByKGUsdCl7Zm9yKGU9bmV3IE1hcDtudWxsIT09dDspbnVsbCE9PXQua2V5P2Uuc2V0KHQua2V5LHQpOmUuc2V0KHQuaW5kZXgsdCksdD10LnNpYmxpbmc7cmV0dXJuIGV9ZnVuY3Rpb24gbChlLHQpe3JldHVybihlPW9ZKGUsdCkpLmluZGV4PTAsZS5zaWJsaW5nPW51bGwsZX1mdW5jdGlvbiBhKHQsbixyKXtyZXR1cm4odC5pbmRleD1yLGUpP251bGwhPT0ocj10LmFsdGVybmF0ZSk/KHI9ci5pbmRleCk8bj8odC5mbGFnc3w9MzM1NTQ0MzQsbik6cjoodC5mbGFnc3w9MzM1NTQ0MzQsbik6KHQuZmxhZ3N8PTEwNDg1NzYsbil9ZnVuY3Rpb24gbyh0KXtyZXR1cm4gZSYmbnVsbD09PXQuYWx0ZXJuYXRlJiYodC5mbGFnc3w9MzM1NTQ0MzQpLHR9ZnVuY3Rpb24gdShlLHQsbixyKXtyZXR1cm4gbnVsbD09PXR8fDYhPT10LnRhZz8odD1vMChuLGUubW9kZSxyKSkucmV0dXJuPWU6KHQ9bCh0LG4pKS5yZXR1cm49ZSx0fWZ1bmN0aW9uIHMoZSx0LG4scil7dmFyIGE9bi50eXBlO3JldHVybiBhPT09eT9mKGUsdCxuLnByb3BzLmNoaWxkcmVuLHIsbi5rZXkpOihudWxsIT09dCYmKHQuZWxlbWVudFR5cGU9PT1hfHwib2JqZWN0Ij09dHlwZW9mIGEmJm51bGwhPT1hJiZhLiQkdHlwZW9mPT09UCYmblAoYSk9PT10LnR5cGUpPyhyPWwodCxuLnByb3BzKSkucmVmPW54KGUsdCxuKToocj1vRyhuLnR5cGUsbi5rZXksbi5wcm9wcyxudWxsLGUubW9kZSxyKSkucmVmPW54KGUsdCxuKSxyLnJldHVybj1lLHIpfWZ1bmN0aW9uIGMoZSx0LG4scil7cmV0dXJuIG51bGw9PT10fHw0IT09dC50YWd8fHQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8hPT1uLmNvbnRhaW5lckluZm98fHQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uIT09bi5pbXBsZW1lbnRhdGlvbj8odD1vMShuLGUubW9kZSxyKSkucmV0dXJuPWU6KHQ9bCh0LG4uY2hpbGRyZW58fFtdKSkucmV0dXJuPWUsdH1mdW5jdGlvbiBmKGUsdCxuLHIsYSl7cmV0dXJuIG51bGw9PT10fHw3IT09dC50YWc/KHQ9b1oobixlLm1vZGUscixhKSkucmV0dXJuPWU6KHQ9bCh0LG4pKS5yZXR1cm49ZSx0fWZ1bmN0aW9uIGQoZSx0LG4pe2lmKCJzdHJpbmciPT10eXBlb2YgdCYmIiIhPT10fHwibnVtYmVyIj09dHlwZW9mIHQpcmV0dXJuKHQ9bzAoIiIrdCxlLm1vZGUsbikpLnJldHVybj1lLHQ7aWYoIm9iamVjdCI9PXR5cGVvZiB0JiZudWxsIT09dCl7c3dpdGNoKHQuJCR0eXBlb2Ype2Nhc2UgbTpyZXR1cm4obj1vRyh0LnR5cGUsdC5rZXksdC5wcm9wcyxudWxsLGUubW9kZSxuKSkucmVmPW54KGUsbnVsbCx0KSxuLnJldHVybj1lLG47Y2FzZSBnOnJldHVybih0PW8xKHQsZS5tb2RlLG4pKS5yZXR1cm49ZSx0O2Nhc2UgUDp2YXIgcj10Ll9pbml0O3JldHVybiBkKGUscih0Ll9wYXlsb2FkKSxuKX1pZihlMyh0KXx8RCh0KSlyZXR1cm4odD1vWih0LGUubW9kZSxuLG51bGwpKS5yZXR1cm49ZSx0O2lmKCJmdW5jdGlvbiI9PXR5cGVvZiB0LnRoZW4pcmV0dXJuIGQoZSxuQyh0KSxuKTtpZih0LiQkdHlwZW9mPT09d3x8dC4kJHR5cGVvZj09PVMpcmV0dXJuIGQoZSxsQihlLHQsbiksbik7bnooZSx0KX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBwKGUsdCxuLHIpe3ZhciBsPW51bGwhPT10P3Qua2V5Om51bGw7aWYoInN0cmluZyI9PXR5cGVvZiBuJiYiIiE9PW58fCJudW1iZXIiPT10eXBlb2YgbilyZXR1cm4gbnVsbCE9PWw/bnVsbDp1KGUsdCwiIituLHIpO2lmKCJvYmplY3QiPT10eXBlb2YgbiYmbnVsbCE9PW4pe3N3aXRjaChuLiQkdHlwZW9mKXtjYXNlIG06cmV0dXJuIG4ua2V5PT09bD9zKGUsdCxuLHIpOm51bGw7Y2FzZSBnOnJldHVybiBuLmtleT09PWw/YyhlLHQsbixyKTpudWxsO2Nhc2UgUDpyZXR1cm4gcChlLHQsKGw9bi5faW5pdCkobi5fcGF5bG9hZCkscil9aWYoZTMobil8fEQobikpcmV0dXJuIG51bGwhPT1sP251bGw6ZihlLHQsbixyLG51bGwpO2lmKCJmdW5jdGlvbiI9PXR5cGVvZiBuLnRoZW4pcmV0dXJuIHAoZSx0LG5DKG4pLHIpO2lmKG4uJCR0eXBlb2Y9PT13fHxuLiQkdHlwZW9mPT09UylyZXR1cm4gcChlLHQsbEIoZSxuLHIpLHIpO256KGUsbil9cmV0dXJuIG51bGx9ZnVuY3Rpb24gaChlLHQsbixyLGwpe2lmKCJzdHJpbmciPT10eXBlb2YgciYmIiIhPT1yfHwibnVtYmVyIj09dHlwZW9mIHIpcmV0dXJuIHUodCxlPWUuZ2V0KG4pfHxudWxsLCIiK3IsbCk7aWYoIm9iamVjdCI9PXR5cGVvZiByJiZudWxsIT09cil7c3dpdGNoKHIuJCR0eXBlb2Ype2Nhc2UgbTpyZXR1cm4gcyh0LGU9ZS5nZXQobnVsbD09PXIua2V5P246ci5rZXkpfHxudWxsLHIsbCk7Y2FzZSBnOnJldHVybiBjKHQsZT1lLmdldChudWxsPT09ci5rZXk/bjpyLmtleSl8fG51bGwscixsKTtjYXNlIFA6cmV0dXJuIGgoZSx0LG4sKDAsci5faW5pdCkoci5fcGF5bG9hZCksbCl9aWYoZTMocil8fEQocikpcmV0dXJuIGYodCxlPWUuZ2V0KG4pfHxudWxsLHIsbCxudWxsKTtpZigiZnVuY3Rpb24iPT10eXBlb2Ygci50aGVuKXJldHVybiBoKGUsdCxuLG5DKHIpLGwpO2lmKHIuJCR0eXBlb2Y9PT13fHxyLiQkdHlwZW9mPT09UylyZXR1cm4gaChlLHQsbixsQih0LHIsbCksbCk7bnoodCxyKX1yZXR1cm4gbnVsbH1yZXR1cm4gZnVuY3Rpb24gdShzLGMsZix2KXtyZXR1cm4gbkU9MCxzPWZ1bmN0aW9uIHMoYyxmLHYsYil7aWYoIm9iamVjdCI9PXR5cGVvZiB2JiZudWxsIT09diYmdi50eXBlPT09eSYmbnVsbD09PXYua2V5JiYodj12LnByb3BzLmNoaWxkcmVuKSwib2JqZWN0Ij09dHlwZW9mIHYmJm51bGwhPT12KXtzd2l0Y2godi4kJHR5cGVvZil7Y2FzZSBtOmU6e2Zvcih2YXIgaz12LmtleSxFPWY7bnVsbCE9PUU7KXtpZihFLmtleT09PWspe2lmKChrPXYudHlwZSk9PT15KXtpZig3PT09RS50YWcpe24oYyxFLnNpYmxpbmcpLChmPWwoRSx2LnByb3BzLmNoaWxkcmVuKSkucmV0dXJuPWMsYz1mO2JyZWFrIGV9fWVsc2UgaWYoRS5lbGVtZW50VHlwZT09PWt8fCJvYmplY3QiPT10eXBlb2YgayYmbnVsbCE9PWsmJmsuJCR0eXBlb2Y9PT1QJiZuUChrKT09PUUudHlwZSl7bihjLEUuc2libGluZyksKGY9bChFLHYucHJvcHMpKS5yZWY9bngoYyxFLHYpLGYucmV0dXJuPWMsYz1mO2JyZWFrIGV9bihjLEUpO2JyZWFrfXQoYyxFKSxFPUUuc2libGluZ312LnR5cGU9PT15PygoZj1vWih2LnByb3BzLmNoaWxkcmVuLGMubW9kZSxiLHYua2V5KSkucmV0dXJuPWMsYz1mKTooKGI9b0codi50eXBlLHYua2V5LHYucHJvcHMsbnVsbCxjLm1vZGUsYikpLnJlZj1ueChjLGYsdiksYi5yZXR1cm49YyxjPWIpfXJldHVybiBvKGMpO2Nhc2UgZzplOntmb3IoRT12LmtleTtudWxsIT09Zjspe2lmKGYua2V5PT09RSl7aWYoND09PWYudGFnJiZmLnN0YXRlTm9kZS5jb250YWluZXJJbmZvPT09di5jb250YWluZXJJbmZvJiZmLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbj09PXYuaW1wbGVtZW50YXRpb24pe24oYyxmLnNpYmxpbmcpLChmPWwoZix2LmNoaWxkcmVufHxbXSkpLnJldHVybj1jLGM9ZjticmVhayBlfW4oYyxmKTticmVha310KGMsZiksZj1mLnNpYmxpbmd9KGY9bzEodixjLm1vZGUsYikpLnJldHVybj1jLGM9Zn1yZXR1cm4gbyhjKTtjYXNlIFA6cmV0dXJuIHUoYyxmLChFPXYuX2luaXQpKHYuX3BheWxvYWQpLGIpfWlmKGUzKHYpKXJldHVybiBmdW5jdGlvbihsLG8saSx1KXtmb3IodmFyIHM9bnVsbCxjPW51bGwsZj1vLG09bz0wLGc9bnVsbDtudWxsIT09ZiYmbTxpLmxlbmd0aDttKyspe2YuaW5kZXg+bT8oZz1mLGY9bnVsbCk6Zz1mLnNpYmxpbmc7dmFyIHk9cChsLGYsaVttXSx1KTtpZihudWxsPT09eSl7bnVsbD09PWYmJihmPWcpO2JyZWFrfWUmJmYmJm51bGw9PT15LmFsdGVybmF0ZSYmdChsLGYpLG89YSh5LG8sbSksbnVsbD09PWM/cz15OmMuc2libGluZz15LGM9eSxmPWd9aWYobT09PWkubGVuZ3RoKXJldHVybiBuKGwsZiksdCQmJnRBKGwsbSkscztpZihudWxsPT09Zil7Zm9yKDttPGkubGVuZ3RoO20rKyludWxsIT09KGY9ZChsLGlbbV0sdSkpJiYobz1hKGYsbyxtKSxudWxsPT09Yz9zPWY6Yy5zaWJsaW5nPWYsYz1mKTtyZXR1cm4gdCQmJnRBKGwsbSksc31mb3IoZj1yKGwsZik7bTxpLmxlbmd0aDttKyspbnVsbCE9PShnPWgoZixsLG0saVttXSx1KSkmJihlJiZudWxsIT09Zy5hbHRlcm5hdGUmJmYuZGVsZXRlKG51bGw9PT1nLmtleT9tOmcua2V5KSxvPWEoZyxvLG0pLG51bGw9PT1jP3M9ZzpjLnNpYmxpbmc9ZyxjPWcpO3JldHVybiBlJiZmLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQobCxlKX0pLHQkJiZ0QShsLG0pLHN9KGMsZix2LGIpO2lmKEQodikpcmV0dXJuIGZ1bmN0aW9uKGwsbyx1LHMpe3ZhciBjPUQodSk7aWYoImZ1bmN0aW9uIiE9dHlwZW9mIGMpdGhyb3cgRXJyb3IoaSgxNTApKTtpZihudWxsPT0odT1jLmNhbGwodSkpKXRocm93IEVycm9yKGkoMTUxKSk7Zm9yKHZhciBmPWM9bnVsbCxtPW8sZz1vPTAseT1udWxsLHY9dS5uZXh0KCk7bnVsbCE9PW0mJiF2LmRvbmU7ZysrLHY9dS5uZXh0KCkpe20uaW5kZXg+Zz8oeT1tLG09bnVsbCk6eT1tLnNpYmxpbmc7dmFyIGI9cChsLG0sdi52YWx1ZSxzKTtpZihudWxsPT09Yil7bnVsbD09PW0mJihtPXkpO2JyZWFrfWUmJm0mJm51bGw9PT1iLmFsdGVybmF0ZSYmdChsLG0pLG89YShiLG8sZyksbnVsbD09PWY/Yz1iOmYuc2libGluZz1iLGY9YixtPXl9aWYodi5kb25lKXJldHVybiBuKGwsbSksdCQmJnRBKGwsZyksYztpZihudWxsPT09bSl7Zm9yKDshdi5kb25lO2crKyx2PXUubmV4dCgpKW51bGwhPT0odj1kKGwsdi52YWx1ZSxzKSkmJihvPWEodixvLGcpLG51bGw9PT1mP2M9djpmLnNpYmxpbmc9dixmPXYpO3JldHVybiB0JCYmdEEobCxnKSxjfWZvcihtPXIobCxtKTshdi5kb25lO2crKyx2PXUubmV4dCgpKW51bGwhPT0odj1oKG0sbCxnLHYudmFsdWUscykpJiYoZSYmbnVsbCE9PXYuYWx0ZXJuYXRlJiZtLmRlbGV0ZShudWxsPT09di5rZXk/Zzp2LmtleSksbz1hKHYsbyxnKSxudWxsPT09Zj9jPXY6Zi5zaWJsaW5nPXYsZj12KTtyZXR1cm4gZSYmbS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0KGwsZSl9KSx0JCYmdEEobCxnKSxjfShjLGYsdixiKTtpZigiZnVuY3Rpb24iPT10eXBlb2Ygdi50aGVuKXJldHVybiBzKGMsZixuQyh2KSxiKTtpZih2LiQkdHlwZW9mPT09d3x8di4kJHR5cGVvZj09PVMpcmV0dXJuIHMoYyxmLGxCKGMsdixiKSxiKTtueihjLHYpfXJldHVybiJzdHJpbmciPT10eXBlb2YgdiYmIiIhPT12fHwibnVtYmVyIj09dHlwZW9mIHY/KHY9IiIrdixudWxsIT09ZiYmNj09PWYudGFnPyhuKGMsZi5zaWJsaW5nKSwoZj1sKGYsdikpLnJldHVybj1jKToobihjLGYpLChmPW8wKHYsYy5tb2RlLGIpKS5yZXR1cm49YyksbyhjPWYpKTpuKGMsZil9KHMsYyxmLHYpLG5TPW51bGwsc319dmFyIG5fPW5OKCEwKSxuTD1uTighMSksblQ9ZChudWxsKSxuTT1kKDApO2Z1bmN0aW9uIG5GKGUsdCl7aChuTSxlPWE0KSxoKG5ULHQpLGE0PWV8dC5iYXNlTGFuZXN9ZnVuY3Rpb24gbkQoKXtoKG5NLGE0KSxoKG5ULG5ULmN1cnJlbnQpfWZ1bmN0aW9uIG5SKCl7YTQ9bk0uY3VycmVudCxwKG5UKSxwKG5NKX12YXIgbk89ZChudWxsKSxuQT1udWxsO2Z1bmN0aW9uIG5JKGUpe3ZhciB0PWUuYWx0ZXJuYXRlO2goblYsMSZuVi5jdXJyZW50KSxoKG5PLGUpLG51bGw9PT1uQSYmKG51bGw9PT10fHxudWxsIT09blQuY3VycmVudD9uQT1lOm51bGwhPT10Lm1lbW9pemVkU3RhdGUmJihuQT1lKSl9ZnVuY3Rpb24gblUoZSl7aWYoMjI9PT1lLnRhZyl7aWYoaChuVixuVi5jdXJyZW50KSxoKG5PLGUpLG51bGw9PT1uQSl7dmFyIHQ9ZS5hbHRlcm5hdGU7bnVsbCE9PXQmJm51bGwhPT10Lm1lbW9pemVkU3RhdGUmJihuQT1lKX19ZWxzZSBuQihlKX1mdW5jdGlvbiBuQigpe2goblYsblYuY3VycmVudCksaChuTyxuTy5jdXJyZW50KX1mdW5jdGlvbiBuUShlKXtwKG5PKSxuQT09PWUmJihuQT1udWxsKSxwKG5WKX12YXIgblY9ZCgwKTtmdW5jdGlvbiBuJChlKXtmb3IodmFyIHQ9ZTtudWxsIT09dDspe2lmKDEzPT09dC50YWcpe3ZhciBuPXQubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09biYmKG51bGw9PT0obj1uLmRlaHlkcmF0ZWQpfHwiJD8iPT09bi5kYXRhfHwiJCEiPT09bi5kYXRhKSlyZXR1cm4gdH1lbHNlIGlmKDE5PT09dC50YWcmJnZvaWQgMCE9PXQubWVtb2l6ZWRQcm9wcy5yZXZlYWxPcmRlcil7aWYoMCE9KDEyOCZ0LmZsYWdzKSlyZXR1cm4gdH1lbHNlIGlmKG51bGwhPT10LmNoaWxkKXt0LmNoaWxkLnJldHVybj10LHQ9dC5jaGlsZDtjb250aW51ZX1pZih0PT09ZSlicmVhaztmb3IoO251bGw9PT10LnNpYmxpbmc7KXtpZihudWxsPT09dC5yZXR1cm58fHQucmV0dXJuPT09ZSlyZXR1cm4gbnVsbDt0PXQucmV0dXJufXQuc2libGluZy5yZXR1cm49dC5yZXR1cm4sdD10LnNpYmxpbmd9cmV0dXJuIG51bGx9dmFyIG5XPW51bGwsbmo9bnVsbCxuSD0hMSxucT0hMSxuSz0hMSxuWT0wO2Z1bmN0aW9uIG5YKGUpe2UhPT1uaiYmbnVsbD09PWUubmV4dCYmKG51bGw9PT1uaj9uVz1uaj1lOm5qPW5qLm5leHQ9ZSksbnE9ITAsbkh8fChuSD0hMCxuMShuSikpfWZ1bmN0aW9uIG5HKGUpe2lmKCFuSyYmbnEpe3ZhciB0PWFaLG49YTAscj1udWxsO25LPSEwO2RvIGZvcih2YXIgbD0hMSxhPW5XO251bGwhPT1hOyl7aWYoKCFlfHwwPT09YS50YWcpJiYwIT0oMyZlaShhLGE9PT10P246MCkpKXRyeXtsPSEwO3ZhciBvPWE7aWYoMCE9KDYmYUcpKXRocm93IEVycm9yKGkoMzI3KSk7b0koKTt2YXIgdT1laShvLDApO2lmKDAhPSgzJnUpKXt2YXIgcz1vVChvLHUpO2lmKDAhPT1vLnRhZyYmMj09PXMpe3ZhciBjPXUsZj1ldShvLGMpOzAhPT1mJiYodT1mLHM9b3YobyxjLGYpKX1pZigxPT09cyl0aHJvdyBjPWE2LG94KG8sMCksb3cobyx1KSxuWChvKSxjOzY9PT1zP293KG8sdSk6KG8uZmluaXNoZWRXb3JrPW8uY3VycmVudC5hbHRlcm5hdGUsby5maW5pc2hlZExhbmVzPXUsb08obyxvdCxvbCkpfW5YKG8pfWNhdGNoKGUpe251bGw9PT1yP3I9W2VdOnIucHVzaChlKX1hPWEubmV4dH13aGlsZShsKTtpZihuSz0hMSxudWxsIT09cil7aWYoMTxyLmxlbmd0aCl7aWYoImZ1bmN0aW9uIj09dHlwZW9mIEFnZ3JlZ2F0ZUVycm9yKXRocm93IEFnZ3JlZ2F0ZUVycm9yKHIpO2ZvcihlPTE7ZTxyLmxlbmd0aDtlKyspbjEoblouYmluZChudWxsLHJbZV0pKX10aHJvdyByWzBdfX19ZnVuY3Rpb24gblooZSl7dGhyb3cgZX1mdW5jdGlvbiBuSigpe25xPW5IPSExO2Zvcih2YXIgZT1IKCksdD1udWxsLG49blc7bnVsbCE9PW47KXt2YXIgcj1uLm5leHQ7MCE9PW5ZJiZ3aW5kb3cuZXZlbnQmJiJwb3BzdGF0ZSI9PT13aW5kb3cuZXZlbnQudHlwZSYmZXAobiwyfG5ZKTt2YXIgbD1uMChuLGUpOzA9PT1sPyhuLm5leHQ9bnVsbCxudWxsPT09dD9uVz1yOnQubmV4dD1yLG51bGw9PT1yJiYobmo9dCkpOih0PW4sMCE9KDMmbCkmJihucT0hMCkpLG49cn1uWT0wLG5HKCExKX1mdW5jdGlvbiBuMChlLHQpe2Zvcih2YXIgbj1lLnN1c3BlbmRlZExhbmVzLHI9ZS5waW5nZWRMYW5lcyxsPWUuZXhwaXJhdGlvblRpbWVzLGE9LTEyNTgyOTEyMSZlLnBlbmRpbmdMYW5lczswPGE7KXt2YXIgbz0zMS1ldChhKSxpPTE8PG8sdT1sW29dOy0xPT09dT8oMD09KGkmbil8fDAhPShpJnIpKSYmKGxbb109ZnVuY3Rpb24oZSx0KXtzd2l0Y2goZSl7Y2FzZSAxOmNhc2UgMjpjYXNlIDQ6Y2FzZSA4OnJldHVybiB0KzI1MDtjYXNlIDE2OmNhc2UgMzI6Y2FzZSA2NDpjYXNlIDEyODpjYXNlIDI1NjpjYXNlIDUxMjpjYXNlIDEwMjQ6Y2FzZSAyMDQ4OmNhc2UgNDA5NjpjYXNlIDgxOTI6Y2FzZSAxNjM4NDpjYXNlIDMyNzY4OmNhc2UgNjU1MzY6Y2FzZSAxMzEwNzI6Y2FzZSAyNjIxNDQ6Y2FzZSA1MjQyODg6Y2FzZSAxMDQ4NTc2OmNhc2UgMjA5NzE1MjpjYXNlIDQxOTQzMDQ6cmV0dXJuIHQrNWUzO2RlZmF1bHQ6cmV0dXJuIC0xfX0oaSx0KSk6dTw9dCYmKGUuZXhwaXJlZExhbmVzfD1pKSxhJj1+aX1pZih0PWFaLG49YTAsbj1laShlLGU9PT10P246MCkscj1lLmNhbGxiYWNrTm9kZSwwPT09bnx8ZT09PXQmJjI9PT1hMXx8bnVsbCE9PWUuY2FuY2VsUGVuZGluZ0NvbW1pdClyZXR1cm4gbnVsbCE9PXImJm51bGwhPT1yJiYkKHIpLGUuY2FsbGJhY2tOb2RlPW51bGwsZS5jYWxsYmFja1ByaW9yaXR5PTA7aWYoMCE9KDMmbikpcmV0dXJuIG51bGwhPT1yJiZudWxsIT09ciYmJChyKSxlLmNhbGxiYWNrUHJpb3JpdHk9MixlLmNhbGxiYWNrTm9kZT1udWxsLDI7aWYoKHQ9biYtbik9PT1lLmNhbGxiYWNrUHJpb3JpdHkpcmV0dXJuIHQ7c3dpdGNoKG51bGwhPT1yJiYkKHIpLGVtKG4pKXtjYXNlIDI6bj1LO2JyZWFrO2Nhc2UgODpuPVk7YnJlYWs7Y2FzZSAzMjpkZWZhdWx0Om49WDticmVhaztjYXNlIDUzNjg3MDkxMjpuPVp9cmV0dXJuIHI9b3kuYmluZChudWxsLGUpLG49VihuLHIpLGUuY2FsbGJhY2tQcmlvcml0eT10LGUuY2FsbGJhY2tOb2RlPW4sdH1mdW5jdGlvbiBuMShlKXtzUyhmdW5jdGlvbigpezAhPSg2JmFHKT9WKEssZSk6ZSgpfSl9dmFyIG4yPXMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixuMz1zLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLG40PTAsbjg9bnVsbCxuNj1udWxsLG41PW51bGwsbjc9ITEsbjk9ITEscmU9ITEscnQ9MCxybj0wLHJyPW51bGwscmw9MDtmdW5jdGlvbiByYSgpe3Rocm93IEVycm9yKGkoMzIxKSl9ZnVuY3Rpb24gcm8oZSx0KXtpZihudWxsPT09dClyZXR1cm4hMTtmb3IodmFyIG49MDtuPHQubGVuZ3RoJiZuPGUubGVuZ3RoO24rKylpZighdFAoZVtuXSx0W25dKSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiByaShlLHQsbixyLGwsYSl7cmV0dXJuIG40PWEsbjg9dCx0Lm1lbW9pemVkU3RhdGU9bnVsbCx0LnVwZGF0ZVF1ZXVlPW51bGwsdC5sYW5lcz0wLG4yLmN1cnJlbnQ9bnVsbD09PWV8fG51bGw9PT1lLm1lbW9pemVkU3RhdGU/ckc6closcmU9ITEsZT1uKHIsbCkscmU9ITEsbjkmJihlPXJzKHQsbixyLGwpKSxydSgpLGV9ZnVuY3Rpb24gcnUoKXtuMi5jdXJyZW50PXJYO3ZhciBlPW51bGwhPT1uNiYmbnVsbCE9PW42Lm5leHQ7aWYobjQ9MCxuNT1uNj1uOD1udWxsLG43PSExLHJuPTAscnI9bnVsbCxlKXRocm93IEVycm9yKGkoMzAwKSl9ZnVuY3Rpb24gcnMoZSx0LG4scil7bjg9ZTt2YXIgbD0wO2Rve2lmKG45JiYocnI9bnVsbCkscm49MCxuOT0hMSwyNTw9bCl0aHJvdyBFcnJvcihpKDMwMSkpO2wrPTEsbjU9bjY9bnVsbCxlLnVwZGF0ZVF1ZXVlPW51bGwsbjIuY3VycmVudD1ySjt2YXIgYT10KG4scil9d2hpbGUobjkpO3JldHVybiBhfWZ1bmN0aW9uIHJjKCl7dmFyIGU9MCE9PXJ0O3JldHVybiBydD0wLGV9ZnVuY3Rpb24gcmYoZSx0LG4pe3QudXBkYXRlUXVldWU9ZS51cGRhdGVRdWV1ZSx0LmZsYWdzJj0tMjA1MyxlLmxhbmVzJj1+bn1mdW5jdGlvbiByZChlKXtpZihuNyl7Zm9yKGU9ZS5tZW1vaXplZFN0YXRlO251bGwhPT1lOyl7dmFyIHQ9ZS5xdWV1ZTtudWxsIT09dCYmKHQucGVuZGluZz1udWxsKSxlPWUubmV4dH1uNz0hMX1uND0wLG41PW42PW44PW51bGwsbjk9ITEscm49cnQ9MCxycj1udWxsfWZ1bmN0aW9uIHJwKCl7dmFyIGU9e21lbW9pemVkU3RhdGU6bnVsbCxiYXNlU3RhdGU6bnVsbCxiYXNlUXVldWU6bnVsbCxxdWV1ZTpudWxsLG5leHQ6bnVsbH07cmV0dXJuIG51bGw9PT1uNT9uOC5tZW1vaXplZFN0YXRlPW41PWU6bjU9bjUubmV4dD1lLG41fWZ1bmN0aW9uIHJoKCl7aWYobnVsbD09PW42KXt2YXIgZT1uOC5hbHRlcm5hdGU7ZT1udWxsIT09ZT9lLm1lbW9pemVkU3RhdGU6bnVsbH1lbHNlIGU9bjYubmV4dDt2YXIgdD1udWxsPT09bjU/bjgubWVtb2l6ZWRTdGF0ZTpuNS5uZXh0O2lmKG51bGwhPT10KW41PXQsbjY9ZTtlbHNle2lmKG51bGw9PT1lKXtpZihudWxsPT09bjguYWx0ZXJuYXRlKXRocm93IEVycm9yKGkoNDY3KSk7dGhyb3cgRXJyb3IoaSgzMTApKX1lPXttZW1vaXplZFN0YXRlOihuNj1lKS5tZW1vaXplZFN0YXRlLGJhc2VTdGF0ZTpuNi5iYXNlU3RhdGUsYmFzZVF1ZXVlOm42LmJhc2VRdWV1ZSxxdWV1ZTpuNi5xdWV1ZSxuZXh0Om51bGx9LG51bGw9PT1uNT9uOC5tZW1vaXplZFN0YXRlPW41PWU6bjU9bjUubmV4dD1lfXJldHVybiBuNX1mdW5jdGlvbiBybShlKXt2YXIgdD1ybjtyZXR1cm4gcm4rPTEsbnVsbD09PXJyJiYocnI9W10pLGU9bmIocnIsZSx0KSxudWxsPT09bjguYWx0ZXJuYXRlJiYobnVsbD09PW41P251bGw9PT1uOC5tZW1vaXplZFN0YXRlOm51bGw9PT1uNS5uZXh0KSYmKG4yLmN1cnJlbnQ9ckcpLGV9ZnVuY3Rpb24gcmcoZSl7aWYobnVsbCE9PWUmJiJvYmplY3QiPT10eXBlb2YgZSl7aWYoImZ1bmN0aW9uIj09dHlwZW9mIGUudGhlbilyZXR1cm4gcm0oZSk7aWYoZS4kJHR5cGVvZj09PXd8fGUuJCR0eXBlb2Y9PT1TKXJldHVybiBsVShlKX10aHJvdyBFcnJvcihpKDQzOCxTdHJpbmcoZSkpKX1mdW5jdGlvbiByeShlLHQpe3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZiB0P3QoZSk6dH1mdW5jdGlvbiBydihlKXt2YXIgdD1yaCgpLG49bjYscj10LnF1ZXVlO2lmKG51bGw9PT1yKXRocm93IEVycm9yKGkoMzExKSk7ci5sYXN0UmVuZGVyZWRSZWR1Y2VyPWU7dmFyIGw9dC5iYXNlUXVldWUsYT1yLnBlbmRpbmc7aWYobnVsbCE9PWEpe2lmKG51bGwhPT1sKXt2YXIgbz1sLm5leHQ7bC5uZXh0PWEubmV4dCxhLm5leHQ9b31uLmJhc2VRdWV1ZT1sPWEsci5wZW5kaW5nPW51bGx9aWYobnVsbCE9PWwpe249bC5uZXh0LGE9dC5iYXNlU3RhdGU7dmFyIHU9bz1udWxsLHM9bnVsbCxjPW47ZG97dmFyIGY9LTEwNzM3NDE4MjUmYy5sYW5lO2lmKGYhPT1jLmxhbmU/KGEwJmYpPT09ZjoobjQmZik9PT1mKW51bGwhPT1zJiYocz1zLm5leHQ9e2xhbmU6MCxyZXZlcnRMYW5lOjAsYWN0aW9uOmMuYWN0aW9uLGhhc0VhZ2VyU3RhdGU6Yy5oYXNFYWdlclN0YXRlLGVhZ2VyU3RhdGU6Yy5lYWdlclN0YXRlLG5leHQ6bnVsbH0pLGY9Yy5hY3Rpb24scmUmJmUoYSxmKSxhPWMuaGFzRWFnZXJTdGF0ZT9jLmVhZ2VyU3RhdGU6ZShhLGYpO2Vsc2V7dmFyIGQ9e2xhbmU6ZixyZXZlcnRMYW5lOmMucmV2ZXJ0TGFuZSxhY3Rpb246Yy5hY3Rpb24saGFzRWFnZXJTdGF0ZTpjLmhhc0VhZ2VyU3RhdGUsZWFnZXJTdGF0ZTpjLmVhZ2VyU3RhdGUsbmV4dDpudWxsfTtudWxsPT09cz8odT1zPWQsbz1hKTpzPXMubmV4dD1kLG44LmxhbmVzfD1mLGE1fD1mfWM9Yy5uZXh0fXdoaWxlKG51bGwhPT1jJiZjIT09bik7bnVsbD09PXM/bz1hOnMubmV4dD11LHRQKGEsdC5tZW1vaXplZFN0YXRlKXx8KGxhPSEwKSx0Lm1lbW9pemVkU3RhdGU9YSx0LmJhc2VTdGF0ZT1vLHQuYmFzZVF1ZXVlPXMsci5sYXN0UmVuZGVyZWRTdGF0ZT1hfXJldHVybiBudWxsPT09bCYmKHIubGFuZXM9MCksW3QubWVtb2l6ZWRTdGF0ZSxyLmRpc3BhdGNoXX1mdW5jdGlvbiByYihlKXt2YXIgdD1yaCgpLG49dC5xdWV1ZTtpZihudWxsPT09bil0aHJvdyBFcnJvcihpKDMxMSkpO24ubGFzdFJlbmRlcmVkUmVkdWNlcj1lO3ZhciByPW4uZGlzcGF0Y2gsbD1uLnBlbmRpbmcsYT10Lm1lbW9pemVkU3RhdGU7aWYobnVsbCE9PWwpe24ucGVuZGluZz1udWxsO3ZhciBvPWw9bC5uZXh0O2RvIGE9ZShhLG8uYWN0aW9uKSxvPW8ubmV4dDt3aGlsZShvIT09bCk7dFAoYSx0Lm1lbW9pemVkU3RhdGUpfHwobGE9ITApLHQubWVtb2l6ZWRTdGF0ZT1hLG51bGw9PT10LmJhc2VRdWV1ZSYmKHQuYmFzZVN0YXRlPWEpLG4ubGFzdFJlbmRlcmVkU3RhdGU9YX1yZXR1cm5bYSxyXX1mdW5jdGlvbiByayhlLHQsbil7dmFyIHI9bjgsbD1yaCgpLGE9dCQ7aWYoYSl7aWYodm9pZCAwPT09bil0aHJvdyBFcnJvcihpKDQwNykpO249bigpfWVsc2Ugbj10KCk7dmFyIG89IXRQKChuNnx8bCkubWVtb2l6ZWRTdGF0ZSxuKTtpZihvJiYobC5tZW1vaXplZFN0YXRlPW4sbGE9ITApLGw9bC5xdWV1ZSxyTShyRS5iaW5kKG51bGwscixsLGUpLFtlXSksbC5nZXRTbmFwc2hvdCE9PXR8fG98fG51bGwhPT1uNSYmMSZuNS5tZW1vaXplZFN0YXRlLnRhZyl7aWYoci5mbGFnc3w9MjA0OCxyUCg5LHJTLmJpbmQobnVsbCxyLGwsbix0KSx7ZGVzdHJveTp2b2lkIDB9LG51bGwpLG51bGw9PT1hWil0aHJvdyBFcnJvcihpKDM0OSkpO2F8fDAhPSg2MCZuNCl8fHJ3KHIsdCxuKX1yZXR1cm4gbn1mdW5jdGlvbiBydyhlLHQsbil7ZS5mbGFnc3w9MTYzODQsZT17Z2V0U25hcHNob3Q6dCx2YWx1ZTpufSxudWxsPT09KHQ9bjgudXBkYXRlUXVldWUpPyh0PWloKCksbjgudXBkYXRlUXVldWU9dCx0LnN0b3Jlcz1bZV0pOm51bGw9PT0obj10LnN0b3Jlcyk/dC5zdG9yZXM9W2VdOm4ucHVzaChlKX1mdW5jdGlvbiByUyhlLHQsbixyKXt0LnZhbHVlPW4sdC5nZXRTbmFwc2hvdD1yLHJDKHQpJiZyeChlKX1mdW5jdGlvbiByRShlLHQsbil7cmV0dXJuIG4oZnVuY3Rpb24oKXtyQyh0KSYmcngoZSl9KX1mdW5jdGlvbiByQyhlKXt2YXIgdD1lLmdldFNuYXBzaG90O2U9ZS52YWx1ZTt0cnl7dmFyIG49dCgpO3JldHVybiF0UChlLG4pfWNhdGNoKGUpe3JldHVybiEwfX1mdW5jdGlvbiByeChlKXt2YXIgdD1uZShlLDIpO251bGwhPT10JiZvZyh0LGUsMil9ZnVuY3Rpb24gcnooZSl7dmFyIHQ9cnAoKTtyZXR1cm4iZnVuY3Rpb24iPT10eXBlb2YgZSYmKGU9ZSgpKSx0Lm1lbW9pemVkU3RhdGU9dC5iYXNlU3RhdGU9ZSx0LnF1ZXVlPXtwZW5kaW5nOm51bGwsbGFuZXM6MCxkaXNwYXRjaDpudWxsLGxhc3RSZW5kZXJlZFJlZHVjZXI6cnksbGFzdFJlbmRlcmVkU3RhdGU6ZX0sdH1mdW5jdGlvbiByUChlLHQsbixyKXtyZXR1cm4gZT17dGFnOmUsY3JlYXRlOnQsaW5zdDpuLGRlcHM6cixuZXh0Om51bGx9LG51bGw9PT0odD1uOC51cGRhdGVRdWV1ZSk/KHQ9aWgoKSxuOC51cGRhdGVRdWV1ZT10LHQubGFzdEVmZmVjdD1lLm5leHQ9ZSk6bnVsbD09PShuPXQubGFzdEVmZmVjdCk/dC5sYXN0RWZmZWN0PWUubmV4dD1lOihyPW4ubmV4dCxuLm5leHQ9ZSxlLm5leHQ9cix0Lmxhc3RFZmZlY3Q9ZSksZX1mdW5jdGlvbiByTigpe3JldHVybiByaCgpLm1lbW9pemVkU3RhdGV9ZnVuY3Rpb24gcl8oZSx0LG4scil7dmFyIGw9cnAoKTtuOC5mbGFnc3w9ZSxsLm1lbW9pemVkU3RhdGU9clAoMXx0LG4se2Rlc3Ryb3k6dm9pZCAwfSx2b2lkIDA9PT1yP251bGw6cil9ZnVuY3Rpb24gckwoZSx0LG4scil7dmFyIGw9cmgoKTtyPXZvaWQgMD09PXI/bnVsbDpyO3ZhciBhPWwubWVtb2l6ZWRTdGF0ZS5pbnN0O251bGwhPT1uNiYmbnVsbCE9PXImJnJvKHIsbjYubWVtb2l6ZWRTdGF0ZS5kZXBzKT9sLm1lbW9pemVkU3RhdGU9clAodCxuLGEscik6KG44LmZsYWdzfD1lLGwubWVtb2l6ZWRTdGF0ZT1yUCgxfHQsbixhLHIpKX1mdW5jdGlvbiByVChlLHQpe3JfKDgzOTA2NTYsOCxlLHQpfWZ1bmN0aW9uIHJNKGUsdCl7ckwoMjA0OCw4LGUsdCl9ZnVuY3Rpb24gckYoZSx0KXtyZXR1cm4gckwoNCwyLGUsdCl9ZnVuY3Rpb24gckQoZSx0KXtyZXR1cm4gckwoNCw0LGUsdCl9ZnVuY3Rpb24gclIoZSx0KXtyZXR1cm4iZnVuY3Rpb24iPT10eXBlb2YgdD8odChlPWUoKSksZnVuY3Rpb24oKXt0KG51bGwpfSk6bnVsbCE9dD8oZT1lKCksdC5jdXJyZW50PWUsZnVuY3Rpb24oKXt0LmN1cnJlbnQ9bnVsbH0pOnZvaWQgMH1mdW5jdGlvbiByTyhlLHQsbil7bj1udWxsIT1uP24uY29uY2F0KFtlXSk6bnVsbCxyTCg0LDQsclIuYmluZChudWxsLHQsZSksbil9ZnVuY3Rpb24gckEoKXt9ZnVuY3Rpb24gckkoZSx0KXt2YXIgbj1yaCgpO3Q9dm9pZCAwPT09dD9udWxsOnQ7dmFyIHI9bi5tZW1vaXplZFN0YXRlO3JldHVybiBudWxsIT09dCYmcm8odCxyWzFdKT9yWzBdOihuLm1lbW9pemVkU3RhdGU9W2UsdF0sZSl9ZnVuY3Rpb24gclUoZSx0KXt2YXIgbj1yaCgpO3Q9dm9pZCAwPT09dD9udWxsOnQ7dmFyIHI9bi5tZW1vaXplZFN0YXRlO3JldHVybiBudWxsIT09dCYmcm8odCxyWzFdKT9yWzBdOihyZSYmZSgpLGU9ZSgpLG4ubWVtb2l6ZWRTdGF0ZT1bZSx0XSxlKX1mdW5jdGlvbiByQihlLHQsbil7cmV0dXJuIDA9PSg0MiZuNCk/KGUuYmFzZVN0YXRlJiYoZS5iYXNlU3RhdGU9ITEsbGE9ITApLGUubWVtb2l6ZWRTdGF0ZT1uKToodFAobix0KXx8KG49ZXMoKSxuOC5sYW5lc3w9bixhNXw9bixlLmJhc2VTdGF0ZT0hMCksdCl9ZnVuY3Rpb24gclEoZSx0LG4scixsKXt2YXIgYT1laDtlaD0wIT09YSYmOD5hP2E6ODt2YXIgbz1uMy50cmFuc2l0aW9uO24zLnRyYW5zaXRpb249bnVsbCxySChlLHQsbiksbjMudHJhbnNpdGlvbj17fTt0cnl7ckgoZSx0LHIpLGwoKX1jYXRjaChlKXt0aHJvdyBlfWZpbmFsbHl7ZWg9YSxuMy50cmFuc2l0aW9uPW99fWZ1bmN0aW9uIHJWKCl7cmV0dXJuIHJoKCkubWVtb2l6ZWRTdGF0ZX1mdW5jdGlvbiByJCgpe3JldHVybiByaCgpLm1lbW9pemVkU3RhdGV9ZnVuY3Rpb24gclcoZSl7Zm9yKHZhciB0PWUucmV0dXJuO251bGwhPT10Oyl7c3dpdGNoKHQudGFnKXtjYXNlIDI0OmNhc2UgMzp2YXIgbj1vbSh0KTtlPW5vKG4pO3ZhciByPW5pKHQsZSxuKTtudWxsIT09ciYmKG9nKHIsdCxuKSxudShyLHQsbikpLHQ9e2NhY2hlOmxIKCl9LGUucGF5bG9hZD10O3JldHVybn10PXQucmV0dXJufX1mdW5jdGlvbiByaihlLHQsbil7dmFyIHI9b20oZSk7bj17bGFuZTpyLHJldmVydExhbmU6MCxhY3Rpb246bixoYXNFYWdlclN0YXRlOiExLGVhZ2VyU3RhdGU6bnVsbCxuZXh0Om51bGx9LHJxKGUpP3JLKHQsbik6KHQ5KGUsdCxuLHIpLG51bGwhPT0obj1ubihlKSkmJihvZyhuLGUsciksclkobix0LHIpKSl9ZnVuY3Rpb24gckgoZSx0LG4pe3ZhciByPW9tKGUpLGw9e2xhbmU6cixyZXZlcnRMYW5lOjAsYWN0aW9uOm4saGFzRWFnZXJTdGF0ZTohMSxlYWdlclN0YXRlOm51bGwsbmV4dDpudWxsfTtpZihycShlKSlySyh0LGwpO2Vsc2V7dmFyIGE9ZS5hbHRlcm5hdGU7aWYoMD09PWUubGFuZXMmJihudWxsPT09YXx8MD09PWEubGFuZXMpJiZudWxsIT09KGE9dC5sYXN0UmVuZGVyZWRSZWR1Y2VyKSl0cnl7dmFyIG89dC5sYXN0UmVuZGVyZWRTdGF0ZSxpPWEobyxuKTtpZihsLmhhc0VhZ2VyU3RhdGU9ITAsbC5lYWdlclN0YXRlPWksdFAoaSxvKSl7dDkoZSx0LGwsMCksbnVsbD09PWFaJiZ0NygpO3JldHVybn19Y2F0Y2goZSl7fWZpbmFsbHl7fXQ5KGUsdCxsLHIpLG51bGwhPT0obj1ubihlKSkmJihvZyhuLGUsciksclkobix0LHIpKX19ZnVuY3Rpb24gcnEoZSl7dmFyIHQ9ZS5hbHRlcm5hdGU7cmV0dXJuIGU9PT1uOHx8bnVsbCE9PXQmJnQ9PT1uOH1mdW5jdGlvbiBySyhlLHQpe245PW43PSEwO3ZhciBuPWUucGVuZGluZztudWxsPT09bj90Lm5leHQ9dDoodC5uZXh0PW4ubmV4dCxuLm5leHQ9dCksZS5wZW5kaW5nPXR9ZnVuY3Rpb24gclkoZSx0LG4pe2lmKDAhPSg4Mzg4NDgwJm4pKXt2YXIgcj10LmxhbmVzO3ImPWUucGVuZGluZ0xhbmVzLG58PXIsdC5sYW5lcz1uLGVwKGUsbil9fWloPWZ1bmN0aW9uKCl7cmV0dXJue2xhc3RFZmZlY3Q6bnVsbCxldmVudHM6bnVsbCxzdG9yZXM6bnVsbH19O3ZhciByWD17cmVhZENvbnRleHQ6bFUsdXNlOnJnLHVzZUNhbGxiYWNrOnJhLHVzZUNvbnRleHQ6cmEsdXNlRWZmZWN0OnJhLHVzZUltcGVyYXRpdmVIYW5kbGU6cmEsdXNlSW5zZXJ0aW9uRWZmZWN0OnJhLHVzZUxheW91dEVmZmVjdDpyYSx1c2VNZW1vOnJhLHVzZVJlZHVjZXI6cmEsdXNlUmVmOnJhLHVzZVN0YXRlOnJhLHVzZURlYnVnVmFsdWU6cmEsdXNlRGVmZXJyZWRWYWx1ZTpyYSx1c2VUcmFuc2l0aW9uOnJhLHVzZVN5bmNFeHRlcm5hbFN0b3JlOnJhLHVzZUlkOnJhfTtyWC51c2VDYWNoZVJlZnJlc2g9cmE7dmFyIHJHPXtyZWFkQ29udGV4dDpsVSx1c2U6cmcsdXNlQ2FsbGJhY2s6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gcnAoKS5tZW1vaXplZFN0YXRlPVtlLHZvaWQgMD09PXQ/bnVsbDp0XSxlfSx1c2VDb250ZXh0OmxVLHVzZUVmZmVjdDpyVCx1c2VJbXBlcmF0aXZlSGFuZGxlOmZ1bmN0aW9uKGUsdCxuKXtuPW51bGwhPW4/bi5jb25jYXQoW2VdKTpudWxsLHJfKDQxOTQzMDgsNCxyUi5iaW5kKG51bGwsdCxlKSxuKX0sdXNlTGF5b3V0RWZmZWN0OmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHJfKDQxOTQzMDgsNCxlLHQpfSx1c2VJbnNlcnRpb25FZmZlY3Q6ZnVuY3Rpb24oZSx0KXtyXyg0LDIsZSx0KX0sdXNlTWVtbzpmdW5jdGlvbihlLHQpe3ZhciBuPXJwKCk7cmV0dXJuIHQ9dm9pZCAwPT09dD9udWxsOnQscmUmJmUoKSxlPWUoKSxuLm1lbW9pemVkU3RhdGU9W2UsdF0sZX0sdXNlUmVkdWNlcjpmdW5jdGlvbihlLHQsbil7dmFyIHI9cnAoKTtyZXR1cm4gdD12b2lkIDAhPT1uP24odCk6dCxyLm1lbW9pemVkU3RhdGU9ci5iYXNlU3RhdGU9dCxlPXtwZW5kaW5nOm51bGwsbGFuZXM6MCxkaXNwYXRjaDpudWxsLGxhc3RSZW5kZXJlZFJlZHVjZXI6ZSxsYXN0UmVuZGVyZWRTdGF0ZTp0fSxyLnF1ZXVlPWUsZT1lLmRpc3BhdGNoPXJqLmJpbmQobnVsbCxuOCxlKSxbci5tZW1vaXplZFN0YXRlLGVdfSx1c2VSZWY6ZnVuY3Rpb24oZSl7cmV0dXJuIGU9e2N1cnJlbnQ6ZX0scnAoKS5tZW1vaXplZFN0YXRlPWV9LHVzZVN0YXRlOmZ1bmN0aW9uKGUpe3ZhciB0PShlPXJ6KGUpKS5xdWV1ZSxuPXJILmJpbmQobnVsbCxuOCx0KTtyZXR1cm4gdC5kaXNwYXRjaD1uLFtlLm1lbW9pemVkU3RhdGUsbl19LHVzZURlYnVnVmFsdWU6ckEsdXNlRGVmZXJyZWRWYWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gcnAoKS5tZW1vaXplZFN0YXRlPWV9LHVzZVRyYW5zaXRpb246ZnVuY3Rpb24oKXt2YXIgZT1yeighMSk7cmV0dXJuIGU9clEuYmluZChudWxsLG44LGUucXVldWUsITAsITEpLHJwKCkubWVtb2l6ZWRTdGF0ZT1lLFshMSxlXX0sdXNlU3luY0V4dGVybmFsU3RvcmU6ZnVuY3Rpb24oZSx0LG4pe3ZhciByPW44LGw9cnAoKTtpZih0JCl7aWYodm9pZCAwPT09bil0aHJvdyBFcnJvcihpKDQwNykpO249bigpfWVsc2V7aWYobj10KCksbnVsbD09PWFaKXRocm93IEVycm9yKGkoMzQ5KSk7MCE9KDYwJm40KXx8cncocix0LG4pfWwubWVtb2l6ZWRTdGF0ZT1uO3ZhciBhPXt2YWx1ZTpuLGdldFNuYXBzaG90OnR9O3JldHVybiBsLnF1ZXVlPWEsclQockUuYmluZChudWxsLHIsYSxlKSxbZV0pLHIuZmxhZ3N8PTIwNDgsclAoOSxyUy5iaW5kKG51bGwscixhLG4sdCkse2Rlc3Ryb3k6dm9pZCAwfSxudWxsKSxufSx1c2VJZDpmdW5jdGlvbigpe3ZhciBlPXJwKCksdD1hWi5pZGVudGlmaWVyUHJlZml4O2lmKHQkKXt2YXIgbj10TyxyPXRSO3Q9IjoiK3QrIlIiKyhuPShyJn4oMTw8MzItZXQociktMSkpLnRvU3RyaW5nKDMyKStuKSwwPChuPXJ0KyspJiYodCs9IkgiK24udG9TdHJpbmcoMzIpKSx0Kz0iOiJ9ZWxzZSB0PSI6Iit0KyJyIisobj1ybCsrKS50b1N0cmluZygzMikrIjoiO3JldHVybiBlLm1lbW9pemVkU3RhdGU9dH0sdXNlQ2FjaGVSZWZyZXNoOmZ1bmN0aW9uKCl7cmV0dXJuIHJwKCkubWVtb2l6ZWRTdGF0ZT1yVy5iaW5kKG51bGwsbjgpfX0sclo9e3JlYWRDb250ZXh0OmxVLHVzZTpyZyx1c2VDYWxsYmFjazpySSx1c2VDb250ZXh0OmxVLHVzZUVmZmVjdDpyTSx1c2VJbXBlcmF0aXZlSGFuZGxlOnJPLHVzZUluc2VydGlvbkVmZmVjdDpyRix1c2VMYXlvdXRFZmZlY3Q6ckQsdXNlTWVtbzpyVSx1c2VSZWR1Y2VyOnJ2LHVzZVJlZjpyTix1c2VTdGF0ZTpmdW5jdGlvbigpe3JldHVybiBydihyeSl9LHVzZURlYnVnVmFsdWU6ckEsdXNlRGVmZXJyZWRWYWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gckIocmgoKSxuNi5tZW1vaXplZFN0YXRlLGUpfSx1c2VUcmFuc2l0aW9uOmZ1bmN0aW9uKCl7dmFyIGU9cnYocnkpWzBdLHQ9cmgoKS5tZW1vaXplZFN0YXRlO3JldHVyblsiYm9vbGVhbiI9PXR5cGVvZiBlP2U6cm0oZSksdF19LHVzZVN5bmNFeHRlcm5hbFN0b3JlOnJrLHVzZUlkOnJWfTtyWi51c2VDYWNoZVJlZnJlc2g9ciQ7dmFyIHJKPXtyZWFkQ29udGV4dDpsVSx1c2U6cmcsdXNlQ2FsbGJhY2s6ckksdXNlQ29udGV4dDpsVSx1c2VFZmZlY3Q6ck0sdXNlSW1wZXJhdGl2ZUhhbmRsZTpyTyx1c2VJbnNlcnRpb25FZmZlY3Q6ckYsdXNlTGF5b3V0RWZmZWN0OnJELHVzZU1lbW86clUsdXNlUmVkdWNlcjpyYix1c2VSZWY6ck4sdXNlU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gcmIocnkpfSx1c2VEZWJ1Z1ZhbHVlOnJBLHVzZURlZmVycmVkVmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9cmgoKTtyZXR1cm4gbnVsbD09PW42P3QubWVtb2l6ZWRTdGF0ZT1lOnJCKHQsbjYubWVtb2l6ZWRTdGF0ZSxlKX0sdXNlVHJhbnNpdGlvbjpmdW5jdGlvbigpe3ZhciBlPXJiKHJ5KVswXSx0PXJoKCkubWVtb2l6ZWRTdGF0ZTtyZXR1cm5bImJvb2xlYW4iPT10eXBlb2YgZT9lOnJtKGUpLHRdfSx1c2VTeW5jRXh0ZXJuYWxTdG9yZTpyayx1c2VJZDpyVn07ZnVuY3Rpb24gcjAoZSx0KXtpZihlJiZlLmRlZmF1bHRQcm9wcylmb3IodmFyIG4gaW4gdD11KHt9LHQpLGU9ZS5kZWZhdWx0UHJvcHMpdm9pZCAwPT09dFtuXSYmKHRbbl09ZVtuXSk7cmV0dXJuIHR9ZnVuY3Rpb24gcjEoZSx0LG4scil7dD1lLm1lbW9pemVkU3RhdGUsbj1udWxsPT0obj1uKHIsdCkpP3Q6dSh7fSx0LG4pLGUubWVtb2l6ZWRTdGF0ZT1uLDA9PT1lLmxhbmVzJiYoZS51cGRhdGVRdWV1ZS5iYXNlU3RhdGU9bil9ckoudXNlQ2FjaGVSZWZyZXNoPXIkO3ZhciByMj17aXNNb3VudGVkOmZ1bmN0aW9uKGUpe3JldHVybiEhKGU9ZS5fcmVhY3RJbnRlcm5hbHMpJiZ0ZChlKT09PWV9LGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbihlLHQsbil7dmFyIHI9b20oZT1lLl9yZWFjdEludGVybmFscyksbD1ubyhyKTtsLnBheWxvYWQ9dCxudWxsIT1uJiYobC5jYWxsYmFjaz1uKSxudWxsIT09KHQ9bmkoZSxsLHIpKSYmKG9nKHQsZSxyKSxudSh0LGUscikpfSxlbnF1ZXVlUmVwbGFjZVN0YXRlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1vbShlPWUuX3JlYWN0SW50ZXJuYWxzKSxsPW5vKHIpO2wudGFnPTEsbC5wYXlsb2FkPXQsbnVsbCE9biYmKGwuY2FsbGJhY2s9biksbnVsbCE9PSh0PW5pKGUsbCxyKSkmJihvZyh0LGUsciksbnUodCxlLHIpKX0sZW5xdWV1ZUZvcmNlVXBkYXRlOmZ1bmN0aW9uKGUsdCl7dmFyIG49b20oZT1lLl9yZWFjdEludGVybmFscykscj1ubyhuKTtyLnRhZz0yLG51bGwhPXQmJihyLmNhbGxiYWNrPXQpLG51bGwhPT0odD1uaShlLHIsbikpJiYob2codCxlLG4pLG51KHQsZSxuKSl9fTtmdW5jdGlvbiByMyhlLHQsbixyLGwsYSxvKXtyZXR1cm4iZnVuY3Rpb24iPT10eXBlb2YoZT1lLnN0YXRlTm9kZSkuc2hvdWxkQ29tcG9uZW50VXBkYXRlP2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKHIsYSxvKTohdC5wcm90b3R5cGV8fCF0LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudHx8IW5wKG4scil8fCFucChsLGEpfWZ1bmN0aW9uIHI0KGUsdCxuKXt2YXIgcj0hMSxsPXRnLGE9dC5jb250ZXh0VHlwZTtyZXR1cm4ib2JqZWN0Ij09dHlwZW9mIGEmJm51bGwhPT1hP2E9bFUoYSk6KGw9dHcodCk/dGI6dHkuY3VycmVudCxhPShyPW51bGwhPShyPXQuY29udGV4dFR5cGVzKSk/dGsoZSxsKTp0ZyksdD1uZXcgdChuLGEpLGUubWVtb2l6ZWRTdGF0ZT1udWxsIT09dC5zdGF0ZSYmdm9pZCAwIT09dC5zdGF0ZT90LnN0YXRlOm51bGwsdC51cGRhdGVyPXIyLGUuc3RhdGVOb2RlPXQsdC5fcmVhY3RJbnRlcm5hbHM9ZSxyJiYoKGU9ZS5zdGF0ZU5vZGUpLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9bCxlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0PWEpLHR9ZnVuY3Rpb24gcjgoZSx0LG4scil7ZT10LnN0YXRlLCJmdW5jdGlvbiI9PXR5cGVvZiB0LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJnQuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuLHIpLCJmdW5jdGlvbiI9PXR5cGVvZiB0LlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZ0LlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG4sciksdC5zdGF0ZSE9PWUmJnIyLmVucXVldWVSZXBsYWNlU3RhdGUodCx0LnN0YXRlLG51bGwpfWZ1bmN0aW9uIHI2KGUsdCxuLHIpe3ZhciBsPWUuc3RhdGVOb2RlO2wucHJvcHM9bixsLnN0YXRlPWUubWVtb2l6ZWRTdGF0ZSxsLnJlZnM9e30sbmwoZSk7dmFyIGE9dC5jb250ZXh0VHlwZTsib2JqZWN0Ij09dHlwZW9mIGEmJm51bGwhPT1hP2wuY29udGV4dD1sVShhKTooYT10dyh0KT90Yjp0eS5jdXJyZW50LGwuY29udGV4dD10ayhlLGEpKSxsLnN0YXRlPWUubWVtb2l6ZWRTdGF0ZSwiZnVuY3Rpb24iPT10eXBlb2YoYT10LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcykmJihyMShlLHQsYSxuKSxsLnN0YXRlPWUubWVtb2l6ZWRTdGF0ZSksImZ1bmN0aW9uIj09dHlwZW9mIHQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzfHwiZnVuY3Rpb24iPT10eXBlb2YgbC5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8ImZ1bmN0aW9uIiE9dHlwZW9mIGwuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCYmImZ1bmN0aW9uIiE9dHlwZW9mIGwuY29tcG9uZW50V2lsbE1vdW50fHwodD1sLnN0YXRlLCJmdW5jdGlvbiI9PXR5cGVvZiBsLmNvbXBvbmVudFdpbGxNb3VudCYmbC5jb21wb25lbnRXaWxsTW91bnQoKSwiZnVuY3Rpb24iPT10eXBlb2YgbC5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JiZsLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKSx0IT09bC5zdGF0ZSYmcjIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShsLGwuc3RhdGUsbnVsbCksbmMoZSxuLGwsciksbC5zdGF0ZT1lLm1lbW9pemVkU3RhdGUpLCJmdW5jdGlvbiI9PXR5cGVvZiBsLmNvbXBvbmVudERpZE1vdW50JiYoZS5mbGFnc3w9NDE5NDMwOCl9ZnVuY3Rpb24gcjUoZSx0KXt0cnl7dmFyIG49IiIscj10O2RvIG4rPWZ1bmN0aW9uKGUpe3N3aXRjaChlLnRhZyl7Y2FzZSAyNjpjYXNlIDI3OmNhc2UgNTpyZXR1cm4gZVcoZS50eXBlKTtjYXNlIDE2OnJldHVybiBlVygiTGF6eSIpO2Nhc2UgMTM6cmV0dXJuIGVXKCJTdXNwZW5zZSIpO2Nhc2UgMTk6cmV0dXJuIGVXKCJTdXNwZW5zZUxpc3QiKTtjYXNlIDA6Y2FzZSAyOmNhc2UgMTU6cmV0dXJuIGU9ZUgoZS50eXBlLCExKTtjYXNlIDExOnJldHVybiBlPWVIKGUudHlwZS5yZW5kZXIsITEpO2Nhc2UgMTpyZXR1cm4gZT1lSChlLnR5cGUsITApO2RlZmF1bHQ6cmV0dXJuIiJ9fShyKSxyPXIucmV0dXJuO3doaWxlKHIpO3ZhciBsPW59Y2F0Y2goZSl7bD0iXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiAiK2UubWVzc2FnZSsiXG4iK2Uuc3RhY2t9cmV0dXJue3ZhbHVlOmUsc291cmNlOnQsc3RhY2s6bCxkaWdlc3Q6bnVsbH19ZnVuY3Rpb24gcjcoZSx0LG4pe3JldHVybnt2YWx1ZTplLHNvdXJjZTpudWxsLHN0YWNrOm51bGwhPW4/bjpudWxsLGRpZ2VzdDpudWxsIT10P3Q6bnVsbH19ZnVuY3Rpb24gcjkoZSx0KXt0cnl7Y29uc29sZS5lcnJvcih0LnZhbHVlKX1jYXRjaChlKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgZX0pfX1mdW5jdGlvbiBsZShlLHQsbil7KG49bm8obikpLnRhZz0zLG4ucGF5bG9hZD17ZWxlbWVudDpudWxsfTt2YXIgcj10LnZhbHVlO3JldHVybiBuLmNhbGxiYWNrPWZ1bmN0aW9uKCl7b2F8fChvYT0hMCxvbz1yKSxyOShlLHQpfSxufWZ1bmN0aW9uIGx0KGUsdCxuKXsobj1ubyhuKSkudGFnPTM7dmFyIHI9ZS50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjtpZigiZnVuY3Rpb24iPT10eXBlb2Ygcil7dmFyIGw9dC52YWx1ZTtuLnBheWxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gcihsKX0sbi5jYWxsYmFjaz1mdW5jdGlvbigpe3I5KGUsdCl9fXZhciBhPWUuc3RhdGVOb2RlO3JldHVybiBudWxsIT09YSYmImZ1bmN0aW9uIj09dHlwZW9mIGEuY29tcG9uZW50RGlkQ2F0Y2gmJihuLmNhbGxiYWNrPWZ1bmN0aW9uKCl7cjkoZSx0KSwiZnVuY3Rpb24iIT10eXBlb2YgciYmKG51bGw9PT1vaT9vaT1uZXcgU2V0KFt0aGlzXSk6b2kuYWRkKHRoaXMpKTt2YXIgbj10LnN0YWNrO3RoaXMuY29tcG9uZW50RGlkQ2F0Y2godC52YWx1ZSx7Y29tcG9uZW50U3RhY2s6bnVsbCE9PW4/bjoiIn0pfSksbn1mdW5jdGlvbiBsbihlLHQsbixyLGwpe3JldHVybiAwPT0oMSZlLm1vZGUpP2U9PT10P2UuZmxhZ3N8PTY1NTM2OihlLmZsYWdzfD0xMjgsbi5mbGFnc3w9MTMxMDcyLG4uZmxhZ3MmPS01MjgwNSwxPT09bi50YWcmJihudWxsPT09bi5hbHRlcm5hdGU/bi50YWc9MTc6KCh0PW5vKDIpKS50YWc9MixuaShuLHQsMikpKSxuLmxhbmVzfD0yKTooZS5mbGFnc3w9NjU1MzYsZS5sYW5lcz1sKSxlfXZhciBscj1zLlJlYWN0Q3VycmVudE93bmVyLGxsPUVycm9yKGkoNDYxKSksbGE9ITE7ZnVuY3Rpb24gbG8oZSx0LG4scil7dC5jaGlsZD1udWxsPT09ZT9uTCh0LG51bGwsbixyKTpuXyh0LGUuY2hpbGQsbixyKX1mdW5jdGlvbiBsaShlLHQsbixyLGwpe249bi5yZW5kZXI7dmFyIGE9dC5yZWY7cmV0dXJuKGxJKHQsbCkscj1yaShlLHQsbixyLGEsbCksbj1yYygpLG51bGw9PT1lfHxsYSk/KHQkJiZuJiZ0VSh0KSx0LmZsYWdzfD0xLGxvKGUsdCxyLGwpLHQuY2hpbGQpOihyZihlLHQsbCksbE4oZSx0LGwpKX1mdW5jdGlvbiBsdShlLHQsbixyLGwpe2lmKG51bGw9PT1lKXt2YXIgYT1uLnR5cGU7cmV0dXJuImZ1bmN0aW9uIiE9dHlwZW9mIGF8fG9LKGEpfHx2b2lkIDAhPT1hLmRlZmF1bHRQcm9wc3x8bnVsbCE9PW4uY29tcGFyZXx8dm9pZCAwIT09bi5kZWZhdWx0UHJvcHM/KChlPW9HKG4udHlwZSxudWxsLHIsdCx0Lm1vZGUsbCkpLnJlZj10LnJlZixlLnJldHVybj10LHQuY2hpbGQ9ZSk6KHQudGFnPTE1LHQudHlwZT1hLGxzKGUsdCxhLHIsbCkpfWlmKGE9ZS5jaGlsZCwwPT0oZS5sYW5lcyZsKSl7dmFyIG89YS5tZW1vaXplZFByb3BzO2lmKChuPW51bGwhPT0obj1uLmNvbXBhcmUpP246bnApKG8scikmJmUucmVmPT09dC5yZWYpcmV0dXJuIGxOKGUsdCxsKX1yZXR1cm4gdC5mbGFnc3w9MSwoZT1vWShhLHIpKS5yZWY9dC5yZWYsZS5yZXR1cm49dCx0LmNoaWxkPWV9ZnVuY3Rpb24gbHMoZSx0LG4scixsKXtpZihudWxsIT09ZSl7dmFyIGE9ZS5tZW1vaXplZFByb3BzO2lmKG5wKGEscikmJmUucmVmPT09dC5yZWYpe2lmKGxhPSExLHQucGVuZGluZ1Byb3BzPXI9YSwwPT0oZS5sYW5lcyZsKSlyZXR1cm4gdC5sYW5lcz1lLmxhbmVzLGxOKGUsdCxsKTswIT0oMTMxMDcyJmUuZmxhZ3MpJiYobGE9ITApfX1yZXR1cm4gbHAoZSx0LG4scixsKX1mdW5jdGlvbiBsYyhlLHQsbil7dmFyIHI9dC5wZW5kaW5nUHJvcHMsbD1yLmNoaWxkcmVuLGE9MCE9KDImdC5zdGF0ZU5vZGUuX3BlbmRpbmdWaXNpYmlsaXR5KSxvPW51bGwhPT1lP2UubWVtb2l6ZWRTdGF0ZTpudWxsO2lmKGxkKGUsdCksImhpZGRlbiI9PT1yLm1vZGV8fGEpe2lmKDAhPSgxMjgmdC5mbGFncykpe2lmKG49bnVsbCE9PW8/by5iYXNlTGFuZXN8bjpuLG51bGwhPT1lKXtmb3IobD0wLHI9dC5jaGlsZD1lLmNoaWxkO251bGwhPT1yOylsPWx8ci5sYW5lc3xyLmNoaWxkTGFuZXMscj1yLnNpYmxpbmc7dC5jaGlsZExhbmVzPWwmfm59ZWxzZSB0LmNoaWxkTGFuZXM9MCx0LmNoaWxkPW51bGw7cmV0dXJuIGxmKGUsdCxuKX1pZigwPT0oMSZ0Lm1vZGUpKXQubWVtb2l6ZWRTdGF0ZT17YmFzZUxhbmVzOjAsY2FjaGVQb29sOm51bGx9LG51bGwhPT1lJiZsRyh0LG51bGwpLG5EKCksblUodCk7ZWxzZXtpZigwPT0oMTA3Mzc0MTgyNCZuKSlyZXR1cm4gdC5sYW5lcz10LmNoaWxkTGFuZXM9MTA3Mzc0MTgyNCxsZihlLHQsbnVsbCE9PW8/by5iYXNlTGFuZXN8bjpuKTt0Lm1lbW9pemVkU3RhdGU9e2Jhc2VMYW5lczowLGNhY2hlUG9vbDpudWxsfSxudWxsIT09ZSYmbEcodCxudWxsIT09bz9vLmNhY2hlUG9vbDpudWxsKSxudWxsIT09bz9uRih0LG8pOm5EKCksblUodCl9fWVsc2UgbnVsbCE9PW8/KGxHKHQsby5jYWNoZVBvb2wpLG5GKHQsbyksbkIodCksdC5tZW1vaXplZFN0YXRlPW51bGwpOihudWxsIT09ZSYmbEcodCxudWxsKSxuRCgpLG5CKHQpKTtyZXR1cm4gbG8oZSx0LGwsbiksdC5jaGlsZH1mdW5jdGlvbiBsZihlLHQsbil7dmFyIHI9bFgoKTtyZXR1cm4gcj1udWxsPT09cj9udWxsOntwYXJlbnQ6bGouX2N1cnJlbnRWYWx1ZSxwb29sOnJ9LHQubWVtb2l6ZWRTdGF0ZT17YmFzZUxhbmVzOm4sY2FjaGVQb29sOnJ9LG51bGwhPT1lJiZsRyh0LG51bGwpLG5EKCksblUodCksbnVsbH1mdW5jdGlvbiBsZChlLHQpe3ZhciBuPXQucmVmOyhudWxsPT09ZSYmbnVsbCE9PW58fG51bGwhPT1lJiZlLnJlZiE9PW4pJiYodC5mbGFnc3w9NTEyLHQuZmxhZ3N8PTIwOTcxNTIpfWZ1bmN0aW9uIGxwKGUsdCxuLHIsbCl7dmFyIGE9dHcobik/dGI6dHkuY3VycmVudDtyZXR1cm4oYT10ayh0LGEpLGxJKHQsbCksbj1yaShlLHQsbixyLGEsbCkscj1yYygpLG51bGw9PT1lfHxsYSk/KHQkJiZyJiZ0VSh0KSx0LmZsYWdzfD0xLGxvKGUsdCxuLGwpLHQuY2hpbGQpOihyZihlLHQsbCksbE4oZSx0LGwpKX1mdW5jdGlvbiBsaChlLHQsbixyLGwsYSl7cmV0dXJuKGxJKHQsYSksbj1ycyh0LHIsbixsKSxydSgpLHI9cmMoKSxudWxsPT09ZXx8bGEpPyh0JCYmciYmdFUodCksdC5mbGFnc3w9MSxsbyhlLHQsbixhKSx0LmNoaWxkKToocmYoZSx0LGEpLGxOKGUsdCxhKSl9ZnVuY3Rpb24gbG0oZSx0LG4scixsKXtpZih0dyhuKSl7dmFyIGE9ITA7dHgodCl9ZWxzZSBhPSExO2lmKGxJKHQsbCksbnVsbD09PXQuc3RhdGVOb2RlKWxQKGUsdCkscjQodCxuLHIpLHI2KHQsbixyLGwpLHI9ITA7ZWxzZSBpZihudWxsPT09ZSl7dmFyIG89dC5zdGF0ZU5vZGUsaT10Lm1lbW9pemVkUHJvcHM7by5wcm9wcz1pO3ZhciB1PW8uY29udGV4dCxzPW4uY29udGV4dFR5cGU7cz0ib2JqZWN0Ij09dHlwZW9mIHMmJm51bGwhPT1zP2xVKHMpOnRrKHQscz10dyhuKT90Yjp0eS5jdXJyZW50KTt2YXIgYz1uLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyxmPSJmdW5jdGlvbiI9PXR5cGVvZiBjfHwiZnVuY3Rpb24iPT10eXBlb2Ygby5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtmfHwiZnVuY3Rpb24iIT10eXBlb2Ygby5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyYmImZ1bmN0aW9uIiE9dHlwZW9mIG8uY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc3x8KGkhPT1yfHx1IT09cykmJnI4KHQsbyxyLHMpLG5yPSExO3ZhciBkPXQubWVtb2l6ZWRTdGF0ZTtvLnN0YXRlPWQsbmModCxyLG8sbCksdT10Lm1lbW9pemVkU3RhdGUsaSE9PXJ8fGQhPT11fHx0di5jdXJyZW50fHxucj8oImZ1bmN0aW9uIj09dHlwZW9mIGMmJihyMSh0LG4sYyxyKSx1PXQubWVtb2l6ZWRTdGF0ZSksKGk9bnJ8fHIzKHQsbixpLHIsZCx1LHMpKT8oZnx8ImZ1bmN0aW9uIiE9dHlwZW9mIG8uVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCYmImZ1bmN0aW9uIiE9dHlwZW9mIG8uY29tcG9uZW50V2lsbE1vdW50fHwoImZ1bmN0aW9uIj09dHlwZW9mIG8uY29tcG9uZW50V2lsbE1vdW50JiZvLmNvbXBvbmVudFdpbGxNb3VudCgpLCJmdW5jdGlvbiI9PXR5cGVvZiBvLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQmJm8uVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpKSwiZnVuY3Rpb24iPT10eXBlb2Ygby5jb21wb25lbnREaWRNb3VudCYmKHQuZmxhZ3N8PTQxOTQzMDgpKTooImZ1bmN0aW9uIj09dHlwZW9mIG8uY29tcG9uZW50RGlkTW91bnQmJih0LmZsYWdzfD00MTk0MzA4KSx0Lm1lbW9pemVkUHJvcHM9cix0Lm1lbW9pemVkU3RhdGU9dSksby5wcm9wcz1yLG8uc3RhdGU9dSxvLmNvbnRleHQ9cyxyPWkpOigiZnVuY3Rpb24iPT10eXBlb2Ygby5jb21wb25lbnREaWRNb3VudCYmKHQuZmxhZ3N8PTQxOTQzMDgpLHI9ITEpfWVsc2V7bz10LnN0YXRlTm9kZSxuYShlLHQpLGk9dC5tZW1vaXplZFByb3BzLHM9dC50eXBlPT09dC5lbGVtZW50VHlwZT9pOnIwKHQudHlwZSxpKSxvLnByb3BzPXMsZj10LnBlbmRpbmdQcm9wcyxkPW8uY29udGV4dCx1PSJvYmplY3QiPT10eXBlb2YodT1uLmNvbnRleHRUeXBlKSYmbnVsbCE9PXU/bFUodSk6dGsodCx1PXR3KG4pP3RiOnR5LmN1cnJlbnQpO3ZhciBwPW4uZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOyhjPSJmdW5jdGlvbiI9PXR5cGVvZiBwfHwiZnVuY3Rpb24iPT10eXBlb2Ygby5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSl8fCJmdW5jdGlvbiIhPXR5cGVvZiBvLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiYiZnVuY3Rpb24iIT10eXBlb2Ygby5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzfHwoaSE9PWZ8fGQhPT11KSYmcjgodCxvLHIsdSksbnI9ITEsZD10Lm1lbW9pemVkU3RhdGUsby5zdGF0ZT1kLG5jKHQscixvLGwpO3ZhciBoPXQubWVtb2l6ZWRTdGF0ZTtpIT09Znx8ZCE9PWh8fHR2LmN1cnJlbnR8fG5yPygiZnVuY3Rpb24iPT10eXBlb2YgcCYmKHIxKHQsbixwLHIpLGg9dC5tZW1vaXplZFN0YXRlKSwocz1ucnx8cjModCxuLHMscixkLGgsdSl8fCExKT8oY3x8ImZ1bmN0aW9uIiE9dHlwZW9mIG8uVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUmJiJmdW5jdGlvbiIhPXR5cGVvZiBvLmNvbXBvbmVudFdpbGxVcGRhdGV8fCgiZnVuY3Rpb24iPT10eXBlb2Ygby5jb21wb25lbnRXaWxsVXBkYXRlJiZvLmNvbXBvbmVudFdpbGxVcGRhdGUocixoLHUpLCJmdW5jdGlvbiI9PXR5cGVvZiBvLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlJiZvLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlKHIsaCx1KSksImZ1bmN0aW9uIj09dHlwZW9mIG8uY29tcG9uZW50RGlkVXBkYXRlJiYodC5mbGFnc3w9NCksImZ1bmN0aW9uIj09dHlwZW9mIG8uZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUmJih0LmZsYWdzfD0xMDI0KSk6KCJmdW5jdGlvbiIhPXR5cGVvZiBvLmNvbXBvbmVudERpZFVwZGF0ZXx8aT09PWUubWVtb2l6ZWRQcm9wcyYmZD09PWUubWVtb2l6ZWRTdGF0ZXx8KHQuZmxhZ3N8PTQpLCJmdW5jdGlvbiIhPXR5cGVvZiBvLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlfHxpPT09ZS5tZW1vaXplZFByb3BzJiZkPT09ZS5tZW1vaXplZFN0YXRlfHwodC5mbGFnc3w9MTAyNCksdC5tZW1vaXplZFByb3BzPXIsdC5tZW1vaXplZFN0YXRlPWgpLG8ucHJvcHM9cixvLnN0YXRlPWgsby5jb250ZXh0PXUscj1zKTooImZ1bmN0aW9uIiE9dHlwZW9mIG8uY29tcG9uZW50RGlkVXBkYXRlfHxpPT09ZS5tZW1vaXplZFByb3BzJiZkPT09ZS5tZW1vaXplZFN0YXRlfHwodC5mbGFnc3w9NCksImZ1bmN0aW9uIiE9dHlwZW9mIG8uZ2V0U25hcHNob3RCZWZvcmVVcGRhdGV8fGk9PT1lLm1lbW9pemVkUHJvcHMmJmQ9PT1lLm1lbW9pemVkU3RhdGV8fCh0LmZsYWdzfD0xMDI0KSxyPSExKX1yZXR1cm4gbGcoZSx0LG4scixhLGwpfWZ1bmN0aW9uIGxnKGUsdCxuLHIsbCxhKXtsZChlLHQpO3ZhciBvPTAhPSgxMjgmdC5mbGFncyk7aWYoIXImJiFvKXJldHVybiBsJiZ0eih0LG4sITEpLGxOKGUsdCxhKTtyPXQuc3RhdGVOb2RlLGxyLmN1cnJlbnQ9dDt2YXIgaT1vJiYiZnVuY3Rpb24iIT10eXBlb2Ygbi5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I/bnVsbDpyLnJlbmRlcigpO3JldHVybiB0LmZsYWdzfD0xLG51bGwhPT1lJiZvPyh0LmNoaWxkPW5fKHQsZS5jaGlsZCxudWxsLGEpLHQuY2hpbGQ9bl8odCxudWxsLGksYSkpOmxvKGUsdCxpLGEpLHQubWVtb2l6ZWRTdGF0ZT1yLnN0YXRlLGwmJnR6KHQsbiwhMCksdC5jaGlsZH1mdW5jdGlvbiBseShlKXt2YXIgdD1lLnN0YXRlTm9kZTt0LnBlbmRpbmdDb250ZXh0P3RFKGUsdC5wZW5kaW5nQ29udGV4dCx0LnBlbmRpbmdDb250ZXh0IT09dC5jb250ZXh0KTp0LmNvbnRleHQmJnRFKGUsdC5jb250ZXh0LCExKSxJKGUsdC5jb250YWluZXJJbmZvKX1mdW5jdGlvbiBsdihlLHQsbixyLGwpe3JldHVybiB0MygpLHQ0KGwpLHQuZmxhZ3N8PTI1NixsbyhlLHQsbixyKSx0LmNoaWxkfXZhciBsYj17ZGVoeWRyYXRlZDpudWxsLHRyZWVDb250ZXh0Om51bGwscmV0cnlMYW5lOjB9O2Z1bmN0aW9uIGxrKGUpe3JldHVybntiYXNlTGFuZXM6ZSxjYWNoZVBvb2w6bFooKX19ZnVuY3Rpb24gbHcoZSx0LG4pe3ZhciByLGw9dC5wZW5kaW5nUHJvcHMsYT0hMSxvPTAhPSgxMjgmdC5mbGFncyk7aWYoKHI9byl8fChyPShudWxsPT09ZXx8bnVsbCE9PWUubWVtb2l6ZWRTdGF0ZSkmJjAhPSgyJm5WLmN1cnJlbnQpKSxyJiYoYT0hMCx0LmZsYWdzJj0tMTI5KSxudWxsPT09ZSl7aWYodCQpe2lmKGE/bkkodCk6bkIodCksdCQmJigobz1lPXRWKT90WCh0LG8pfHwodEcodCkmJnRaKCksdFY9c1Aoby5uZXh0U2libGluZykscj10USx0ViYmdFgodCx0Vik/dEgocixvKToodHEodFEsdCksdCQ9ITEsdFE9dCx0Vj1lKSk6KHRHKHQpJiZ0WigpLHRxKHRRLHQpLHQkPSExLHRRPXQsdFY9ZSkpLG51bGwhPT0oZT10Lm1lbW9pemVkU3RhdGUpJiZudWxsIT09KGU9ZS5kZWh5ZHJhdGVkKSlyZXR1cm4gMD09KDEmdC5tb2RlKT90LmxhbmVzPTI6IiQhIj09PWUuZGF0YT90LmxhbmVzPTE2OnQubGFuZXM9MTA3Mzc0MTgyNCxudWxsO25RKHQpfXJldHVybihvPWwuY2hpbGRyZW4sZT1sLmZhbGxiYWNrLGEpPyhuQih0KSxsPXQubW9kZSxhPXQuY2hpbGQsbz17bW9kZToiaGlkZGVuIixjaGlsZHJlbjpvfSwwPT0oMSZsKSYmbnVsbCE9PWE/KGEuY2hpbGRMYW5lcz0wLGEucGVuZGluZ1Byb3BzPW8pOmE9b0oobyxsLDAsbnVsbCksZT1vWihlLGwsbixudWxsKSxhLnJldHVybj10LGUucmV0dXJuPXQsYS5zaWJsaW5nPWUsdC5jaGlsZD1hLHQuY2hpbGQubWVtb2l6ZWRTdGF0ZT1sayhuKSx0Lm1lbW9pemVkU3RhdGU9bGIsZSk6KG5JKHQpLGxTKHQsbykpfWlmKG51bGwhPT0ocj1lLm1lbW9pemVkU3RhdGUpKXt2YXIgdT1yLmRlaHlkcmF0ZWQ7aWYobnVsbCE9PXUpcmV0dXJuIGZ1bmN0aW9uKGUsdCxuLHIsbCxhLG8pe2lmKG4pcmV0dXJuIDI1NiZ0LmZsYWdzPyhuSSh0KSx0LmZsYWdzJj0tMjU3LGxFKGUsdCxvLHI9cjcoRXJyb3IoaSg0MjIpKSkpKTpudWxsIT09dC5tZW1vaXplZFN0YXRlPyhuQih0KSx0LmNoaWxkPWUuY2hpbGQsdC5mbGFnc3w9MTI4LG51bGwpOihuQih0KSxhPXIuZmFsbGJhY2ssbD10Lm1vZGUscj1vSih7bW9kZToidmlzaWJsZSIsY2hpbGRyZW46ci5jaGlsZHJlbn0sbCwwLG51bGwpLGE9b1ooYSxsLG8sbnVsbCksYS5mbGFnc3w9MixyLnJldHVybj10LGEucmV0dXJuPXQsci5zaWJsaW5nPWEsdC5jaGlsZD1yLDAhPSgxJnQubW9kZSkmJm5fKHQsZS5jaGlsZCxudWxsLG8pLHQuY2hpbGQubWVtb2l6ZWRTdGF0ZT1sayhvKSx0Lm1lbW9pemVkU3RhdGU9bGIsYSk7aWYobkkodCksMD09KDEmdC5tb2RlKSlyZXR1cm4gbEUoZSx0LG8sbnVsbCk7aWYoIiQhIj09PWwuZGF0YSl7aWYocj1sLm5leHRTaWJsaW5nJiZsLm5leHRTaWJsaW5nLmRhdGFzZXQpdmFyIHU9ci5kZ3N0O3JldHVybiByPXUsKGE9RXJyb3IoaSg0MTkpKSkuZGlnZXN0PXIscj1yNyhhLHIsdm9pZCAwKSxsRShlLHQsbyxyKX1pZih1PTAhPShvJmUuY2hpbGRMYW5lcyksbGF8fHUpe2lmKG51bGwhPT0ocj1hWikpe3N3aXRjaChvJi1vKXtjYXNlIDI6bD0xO2JyZWFrO2Nhc2UgODpsPTQ7YnJlYWs7Y2FzZSAzMjpsPTE2O2JyZWFrO2Nhc2UgMTI4OmNhc2UgMjU2OmNhc2UgNTEyOmNhc2UgMTAyNDpjYXNlIDIwNDg6Y2FzZSA0MDk2OmNhc2UgODE5MjpjYXNlIDE2Mzg0OmNhc2UgMzI3Njg6Y2FzZSA2NTUzNjpjYXNlIDEzMTA3MjpjYXNlIDI2MjE0NDpjYXNlIDUyNDI4ODpjYXNlIDEwNDg1NzY6Y2FzZSAyMDk3MTUyOmNhc2UgNDE5NDMwNDpjYXNlIDgzODg2MDg6Y2FzZSAxNjc3NzIxNjpjYXNlIDMzNTU0NDMyOmNhc2UgNjcxMDg4NjQ6bD02NDticmVhaztjYXNlIDUzNjg3MDkxMjpsPTI2ODQzNTQ1NjticmVhaztkZWZhdWx0Omw9MH1pZigwIT09KGw9MCE9KGwmKHIuc3VzcGVuZGVkTGFuZXN8bykpPzA6bCkmJmwhPT1hLnJldHJ5TGFuZSl0aHJvdyBhLnJldHJ5TGFuZT1sLG5lKGUsbCksb2cocixlLGwpLGxsfXJldHVybiBvTCgpLGxFKGUsdCxvLG51bGwpfXJldHVybiIkPyI9PT1sLmRhdGE/KHQuZmxhZ3N8PTEyOCx0LmNoaWxkPWUuY2hpbGQsdD1vVy5iaW5kKG51bGwsZSksbC5fcmVhY3RSZXRyeT10LG51bGwpOihlPWEudHJlZUNvbnRleHQsdFY9c1AobC5uZXh0U2libGluZyksdFE9dCx0JD0hMCx0Vz1udWxsLHRqPSExLG51bGwhPT1lJiYodE1bdEYrK109dFIsdE1bdEYrK109dE8sdE1bdEYrK109dEQsdFI9ZS5pZCx0Tz1lLm92ZXJmbG93LHREPXQpLHQ9bFModCxyLmNoaWxkcmVuKSx0LmZsYWdzfD00MDk2LHQpfShlLHQsbyxsLHUscixuKX1pZihhKXtuQih0KSxhPWwuZmFsbGJhY2ssbz10Lm1vZGUsdT0ocj1lLmNoaWxkKS5zaWJsaW5nO3ZhciBzPXttb2RlOiJoaWRkZW4iLGNoaWxkcmVuOmwuY2hpbGRyZW59O3JldHVybiAwPT0oMSZvKSYmdC5jaGlsZCE9PXI/KChsPXQuY2hpbGQpLmNoaWxkTGFuZXM9MCxsLnBlbmRpbmdQcm9wcz1zLHQuZGVsZXRpb25zPW51bGwpOihsPW9ZKHIscykpLnN1YnRyZWVGbGFncz0zMTQ1NzI4MCZyLnN1YnRyZWVGbGFncyxudWxsIT09dT9hPW9ZKHUsYSk6KGE9b1ooYSxvLG4sbnVsbCksYS5mbGFnc3w9MiksYS5yZXR1cm49dCxsLnJldHVybj10LGwuc2libGluZz1hLHQuY2hpbGQ9bCxsPWEsYT10LmNoaWxkLG51bGw9PT0obz1lLmNoaWxkLm1lbW9pemVkU3RhdGUpP289bGsobik6KG51bGwhPT0ocj1vLmNhY2hlUG9vbCk/KHU9bGouX2N1cnJlbnRWYWx1ZSxyPXIucGFyZW50IT09dT97cGFyZW50OnUscG9vbDp1fTpyKTpyPWxaKCksbz17YmFzZUxhbmVzOm8uYmFzZUxhbmVzfG4sY2FjaGVQb29sOnJ9KSxhLm1lbW9pemVkU3RhdGU9byxhLmNoaWxkTGFuZXM9ZS5jaGlsZExhbmVzJn5uLHQubWVtb2l6ZWRTdGF0ZT1sYixsfXJldHVybiBuSSh0KSxlPShhPWUuY2hpbGQpLnNpYmxpbmcsbD1vWShhLHttb2RlOiJ2aXNpYmxlIixjaGlsZHJlbjpsLmNoaWxkcmVufSksMD09KDEmdC5tb2RlKSYmKGwubGFuZXM9biksbC5yZXR1cm49dCxsLnNpYmxpbmc9bnVsbCxudWxsIT09ZSYmKG51bGw9PT0obj10LmRlbGV0aW9ucyk/KHQuZGVsZXRpb25zPVtlXSx0LmZsYWdzfD0xNik6bi5wdXNoKGUpKSx0LmNoaWxkPWwsdC5tZW1vaXplZFN0YXRlPW51bGwsbH1mdW5jdGlvbiBsUyhlLHQpe3JldHVybih0PW9KKHttb2RlOiJ2aXNpYmxlIixjaGlsZHJlbjp0fSxlLm1vZGUsMCxudWxsKSkucmV0dXJuPWUsZS5jaGlsZD10fWZ1bmN0aW9uIGxFKGUsdCxuLHIpe3JldHVybiBudWxsIT09ciYmdDQociksbl8odCxlLmNoaWxkLG51bGwsbiksZT1sUyh0LHQucGVuZGluZ1Byb3BzLmNoaWxkcmVuKSxlLmZsYWdzfD0yLHQubWVtb2l6ZWRTdGF0ZT1udWxsLGV9ZnVuY3Rpb24gbEMoZSx0LG4pe2UubGFuZXN8PXQ7dmFyIHI9ZS5hbHRlcm5hdGU7bnVsbCE9PXImJihyLmxhbmVzfD10KSxsTyhlLnJldHVybix0LG4pfWZ1bmN0aW9uIGx4KGUsdCxuLHIsbCl7dmFyIGE9ZS5tZW1vaXplZFN0YXRlO251bGw9PT1hP2UubWVtb2l6ZWRTdGF0ZT17aXNCYWNrd2FyZHM6dCxyZW5kZXJpbmc6bnVsbCxyZW5kZXJpbmdTdGFydFRpbWU6MCxsYXN0OnIsdGFpbDpuLHRhaWxNb2RlOmx9OihhLmlzQmFja3dhcmRzPXQsYS5yZW5kZXJpbmc9bnVsbCxhLnJlbmRlcmluZ1N0YXJ0VGltZT0wLGEubGFzdD1yLGEudGFpbD1uLGEudGFpbE1vZGU9bCl9ZnVuY3Rpb24gbHooZSx0LG4pe3ZhciByPXQucGVuZGluZ1Byb3BzLGw9ci5yZXZlYWxPcmRlcixhPXIudGFpbDtpZihsbyhlLHQsci5jaGlsZHJlbixuKSwwIT0oMiYocj1uVi5jdXJyZW50KSkpcj0xJnJ8Mix0LmZsYWdzfD0xMjg7ZWxzZXtpZihudWxsIT09ZSYmMCE9KDEyOCZlLmZsYWdzKSllOmZvcihlPXQuY2hpbGQ7bnVsbCE9PWU7KXtpZigxMz09PWUudGFnKW51bGwhPT1lLm1lbW9pemVkU3RhdGUmJmxDKGUsbix0KTtlbHNlIGlmKDE5PT09ZS50YWcpbEMoZSxuLHQpO2Vsc2UgaWYobnVsbCE9PWUuY2hpbGQpe2UuY2hpbGQucmV0dXJuPWUsZT1lLmNoaWxkO2NvbnRpbnVlfWlmKGU9PT10KWJyZWFrO2Zvcig7bnVsbD09PWUuc2libGluZzspe2lmKG51bGw9PT1lLnJldHVybnx8ZS5yZXR1cm49PT10KWJyZWFrIGU7ZT1lLnJldHVybn1lLnNpYmxpbmcucmV0dXJuPWUucmV0dXJuLGU9ZS5zaWJsaW5nfXImPTF9aWYoaChuVixyKSwwPT0oMSZ0Lm1vZGUpKXQubWVtb2l6ZWRTdGF0ZT1udWxsO2Vsc2Ugc3dpdGNoKGwpe2Nhc2UiZm9yd2FyZHMiOmZvcihsPW51bGwsbj10LmNoaWxkO251bGwhPT1uOyludWxsIT09KGU9bi5hbHRlcm5hdGUpJiZudWxsPT09biQoZSkmJihsPW4pLG49bi5zaWJsaW5nO251bGw9PT0obj1sKT8obD10LmNoaWxkLHQuY2hpbGQ9bnVsbCk6KGw9bi5zaWJsaW5nLG4uc2libGluZz1udWxsKSxseCh0LCExLGwsbixhKTticmVhaztjYXNlImJhY2t3YXJkcyI6Zm9yKG49bnVsbCxsPXQuY2hpbGQsdC5jaGlsZD1udWxsO251bGwhPT1sOyl7aWYobnVsbCE9PShlPWwuYWx0ZXJuYXRlKSYmbnVsbD09PW4kKGUpKXt0LmNoaWxkPWw7YnJlYWt9ZT1sLnNpYmxpbmcsbC5zaWJsaW5nPW4sbj1sLGw9ZX1seCh0LCEwLG4sbnVsbCxhKTticmVhaztjYXNlInRvZ2V0aGVyIjpseCh0LCExLG51bGwsbnVsbCx2b2lkIDApO2JyZWFrO2RlZmF1bHQ6dC5tZW1vaXplZFN0YXRlPW51bGx9cmV0dXJuIHQuY2hpbGR9ZnVuY3Rpb24gbFAoZSx0KXswPT0oMSZ0Lm1vZGUpJiZudWxsIT09ZSYmKGUuYWx0ZXJuYXRlPW51bGwsdC5hbHRlcm5hdGU9bnVsbCx0LmZsYWdzfD0yKX1mdW5jdGlvbiBsTihlLHQsbil7aWYobnVsbCE9PWUmJih0LmRlcGVuZGVuY2llcz1lLmRlcGVuZGVuY2llcyksYTV8PXQubGFuZXMsMD09KG4mdC5jaGlsZExhbmVzKSlyZXR1cm4gbnVsbDtpZihudWxsIT09ZSYmdC5jaGlsZCE9PWUuY2hpbGQpdGhyb3cgRXJyb3IoaSgxNTMpKTtpZihudWxsIT09dC5jaGlsZCl7Zm9yKG49b1koZT10LmNoaWxkLGUucGVuZGluZ1Byb3BzKSx0LmNoaWxkPW4sbi5yZXR1cm49dDtudWxsIT09ZS5zaWJsaW5nOyllPWUuc2libGluZywobj1uLnNpYmxpbmc9b1koZSxlLnBlbmRpbmdQcm9wcykpLnJldHVybj10O24uc2libGluZz1udWxsfXJldHVybiB0LmNoaWxkfXZhciBsXz1kKG51bGwpLGxMPW51bGwsbFQ9bnVsbCxsTT1udWxsO2Z1bmN0aW9uIGxGKCl7bE09bFQ9bEw9bnVsbH1mdW5jdGlvbiBsRChlLHQsbil7aChsXyx0Ll9jdXJyZW50VmFsdWUpLHQuX2N1cnJlbnRWYWx1ZT1ufWZ1bmN0aW9uIGxSKGUpe3ZhciB0PWxfLmN1cnJlbnQ7ZS5fY3VycmVudFZhbHVlPXQ9PT1NP2UuX2RlZmF1bHRWYWx1ZTp0LHAobF8pfWZ1bmN0aW9uIGxPKGUsdCxuKXtmb3IoO251bGwhPT1lOyl7dmFyIHI9ZS5hbHRlcm5hdGU7aWYoKGUuY2hpbGRMYW5lcyZ0KSE9PXQ/KGUuY2hpbGRMYW5lc3w9dCxudWxsIT09ciYmKHIuY2hpbGRMYW5lc3w9dCkpOm51bGwhPT1yJiYoci5jaGlsZExhbmVzJnQpIT09dCYmKHIuY2hpbGRMYW5lc3w9dCksZT09PW4pYnJlYWs7ZT1lLnJldHVybn19ZnVuY3Rpb24gbEEoZSx0LG4pe3ZhciByPWUuY2hpbGQ7Zm9yKG51bGwhPT1yJiYoci5yZXR1cm49ZSk7bnVsbCE9PXI7KXt2YXIgbD1yLmRlcGVuZGVuY2llcztpZihudWxsIT09bClmb3IodmFyIGE9ci5jaGlsZCxvPWwuZmlyc3RDb250ZXh0O251bGwhPT1vOyl7aWYoby5jb250ZXh0PT09dCl7aWYoMT09PXIudGFnKXsobz1ubyhuJi1uKSkudGFnPTI7dmFyIHU9ci51cGRhdGVRdWV1ZTtpZihudWxsIT09dSl7dmFyIHM9KHU9dS5zaGFyZWQpLnBlbmRpbmc7bnVsbD09PXM/by5uZXh0PW86KG8ubmV4dD1zLm5leHQscy5uZXh0PW8pLHUucGVuZGluZz1vfX1yLmxhbmVzfD1uLG51bGwhPT0obz1yLmFsdGVybmF0ZSkmJihvLmxhbmVzfD1uKSxsTyhyLnJldHVybixuLGUpLGwubGFuZXN8PW47YnJlYWt9bz1vLm5leHR9ZWxzZSBpZigxMD09PXIudGFnKWE9ci50eXBlPT09ZS50eXBlP251bGw6ci5jaGlsZDtlbHNlIGlmKDE4PT09ci50YWcpe2lmKG51bGw9PT0oYT1yLnJldHVybikpdGhyb3cgRXJyb3IoaSgzNDEpKTthLmxhbmVzfD1uLG51bGwhPT0obD1hLmFsdGVybmF0ZSkmJihsLmxhbmVzfD1uKSxsTyhhLG4sZSksYT1yLnNpYmxpbmd9ZWxzZSBhPXIuY2hpbGQ7aWYobnVsbCE9PWEpYS5yZXR1cm49cjtlbHNlIGZvcihhPXI7bnVsbCE9PWE7KXtpZihhPT09ZSl7YT1udWxsO2JyZWFrfWlmKG51bGwhPT0ocj1hLnNpYmxpbmcpKXtyLnJldHVybj1hLnJldHVybixhPXI7YnJlYWt9YT1hLnJldHVybn1yPWF9fWZ1bmN0aW9uIGxJKGUsdCl7bEw9ZSxsTT1sVD1udWxsLG51bGwhPT0oZT1lLmRlcGVuZGVuY2llcykmJm51bGwhPT1lLmZpcnN0Q29udGV4dCYmKDAhPShlLmxhbmVzJnQpJiYobGE9ITApLGUuZmlyc3RDb250ZXh0PW51bGwpfWZ1bmN0aW9uIGxVKGUpe3JldHVybiBsUShsTCxlKX1mdW5jdGlvbiBsQihlLHQsbil7cmV0dXJuIG51bGw9PT1sTCYmbEkoZSxuKSxsUShlLHQpfWZ1bmN0aW9uIGxRKGUsdCl7dmFyIG49dC5fY3VycmVudFZhbHVlO2lmKGxNIT09dCl7aWYodD17Y29udGV4dDp0LG1lbW9pemVkVmFsdWU6bixuZXh0Om51bGx9LG51bGw9PT1sVCl7aWYobnVsbD09PWUpdGhyb3cgRXJyb3IoaSgzMDgpKTtsVD10LGUuZGVwZW5kZW5jaWVzPXtsYW5lczowLGZpcnN0Q29udGV4dDp0fX1lbHNlIGxUPWxULm5leHQ9dH1yZXR1cm4gbn12YXIgbFY9InVuZGVmaW5lZCIhPXR5cGVvZiBBYm9ydENvbnRyb2xsZXI/QWJvcnRDb250cm9sbGVyOmZ1bmN0aW9uKCl7dmFyIGU9W10sdD10aGlzLnNpZ25hbD17YWJvcnRlZDohMSxhZGRFdmVudExpc3RlbmVyOmZ1bmN0aW9uKHQsbil7ZS5wdXNoKG4pfX07dGhpcy5hYm9ydD1mdW5jdGlvbigpe3QuYWJvcnRlZD0hMCxlLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGUoKX0pfX0sbCQ9YS51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrLGxXPWEudW5zdGFibGVfTm9ybWFsUHJpb3JpdHksbGo9eyQkdHlwZW9mOncsQ29uc3VtZXI6bnVsbCxQcm92aWRlcjpudWxsLF9jdXJyZW50VmFsdWU6bnVsbCxfY3VycmVudFZhbHVlMjpudWxsLF90aHJlYWRDb3VudDowLF9kZWZhdWx0VmFsdWU6bnVsbCxfZ2xvYmFsTmFtZTpudWxsfTtmdW5jdGlvbiBsSCgpe3JldHVybntjb250cm9sbGVyOm5ldyBsVixkYXRhOm5ldyBNYXAscmVmQ291bnQ6MH19ZnVuY3Rpb24gbHEoZSl7ZS5yZWZDb3VudC0tLDA9PT1lLnJlZkNvdW50JiZsJChsVyxmdW5jdGlvbigpe2UuY29udHJvbGxlci5hYm9ydCgpfSl9dmFyIGxLPXMuUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsbFk9ZChudWxsKTtmdW5jdGlvbiBsWCgpe3ZhciBlPWxZLmN1cnJlbnQ7cmV0dXJuIG51bGwhPT1lP2U6YVoucG9vbGVkQ2FjaGV9ZnVuY3Rpb24gbEcoZSx0KXtudWxsPT09dD9oKGxZLGxZLmN1cnJlbnQpOmgobFksdC5wb29sKX1mdW5jdGlvbiBsWigpe3ZhciBlPWxYKCk7cmV0dXJuIG51bGw9PT1lP251bGw6e3BhcmVudDpsai5fY3VycmVudFZhbHVlLHBvb2w6ZX19ZnVuY3Rpb24gbEooZSl7ZS5mbGFnc3w9NH1mdW5jdGlvbiBsMChlKXtlLmZsYWdzfD0yMDk3NjY0fWZ1bmN0aW9uIGwxKGUsdCxuLHIpe2lmKChlPWUubWVtb2l6ZWRQcm9wcykhPT1yKXtuPW51bGw7dmFyIGwsYSxvPW51bGw7Zm9yKGwgaW4gZSlpZighci5oYXNPd25Qcm9wZXJ0eShsKSYmZS5oYXNPd25Qcm9wZXJ0eShsKSYmbnVsbCE9ZVtsXSl7aWYoInN0eWxlIj09PWwpe3ZhciBpPWVbbF07Zm9yKGEgaW4gaSlpLmhhc093blByb3BlcnR5KGEpJiYob3x8KG89e30pLG9bYV09IiIpfWVsc2Uobj1ufHxbXSkucHVzaChsLG51bGwpfWZvcihsIGluIHIpe2k9cltsXTt2YXIgdT1udWxsIT1lP2VbbF06dm9pZCAwO2lmKHIuaGFzT3duUHJvcGVydHkobCkmJmkhPT11JiYobnVsbCE9aXx8bnVsbCE9dSkpe2lmKCJzdHlsZSI9PT1sKXtpZih1KXtmb3IoYSBpbiB1KSF1Lmhhc093blByb3BlcnR5KGEpfHxpJiZpLmhhc093blByb3BlcnR5KGEpfHwob3x8KG89e30pLG9bYV09IiIpO2ZvcihhIGluIGkpaS5oYXNPd25Qcm9wZXJ0eShhKSYmdVthXSE9PWlbYV0mJihvfHwobz17fSksb1thXT1pW2FdKX1lbHNlIG98fChufHwobj1bXSksbi5wdXNoKGwsbykpLG89aX1lbHNlKG49bnx8W10pLnB1c2gobCxpKX19byYmKG49bnx8W10pLnB1c2goInN0eWxlIixvKSxyPW4sKHQudXBkYXRlUXVldWU9cikmJmxKKHQpfX1mdW5jdGlvbiBsMihlLHQpe2lmKCJzdHlsZXNoZWV0IiE9PXQudHlwZXx8MCE9KDQmdC5zdGF0ZS5sb2FkaW5nKSllLmZsYWdzJj0tMTY3NzcyMTc7ZWxzZSBpZihlLmZsYWdzfD0xNjc3NzIxNiwwPT0oNDImYTApJiYhKHQ9InN0eWxlc2hlZXQiIT09dC50eXBlfHwwIT0oMyZ0LnN0YXRlLmxvYWRpbmcpKSl7aWYob1AoKSllLmZsYWdzfD04MTkyO2Vsc2UgdGhyb3cgbms9bmcsbm19fWZ1bmN0aW9uIGwzKGUsdCl7bnVsbCE9PXQ/ZS5mbGFnc3w9NDoxNjM4NCZlLmZsYWdzJiYodD0yMiE9PWUudGFnP2VjKCk6MTA3Mzc0MTgyNCxlLmxhbmVzfD10KX1mdW5jdGlvbiBsNChlLHQpe2lmKCF0JClzd2l0Y2goZS50YWlsTW9kZSl7Y2FzZSJoaWRkZW4iOnQ9ZS50YWlsO2Zvcih2YXIgbj1udWxsO251bGwhPT10OyludWxsIT09dC5hbHRlcm5hdGUmJihuPXQpLHQ9dC5zaWJsaW5nO251bGw9PT1uP2UudGFpbD1udWxsOm4uc2libGluZz1udWxsO2JyZWFrO2Nhc2UiY29sbGFwc2VkIjpuPWUudGFpbDtmb3IodmFyIHI9bnVsbDtudWxsIT09bjspbnVsbCE9PW4uYWx0ZXJuYXRlJiYocj1uKSxuPW4uc2libGluZztudWxsPT09cj90fHxudWxsPT09ZS50YWlsP2UudGFpbD1udWxsOmUudGFpbC5zaWJsaW5nPW51bGw6ci5zaWJsaW5nPW51bGx9fWZ1bmN0aW9uIGw4KGUpe3ZhciB0PW51bGwhPT1lLmFsdGVybmF0ZSYmZS5hbHRlcm5hdGUuY2hpbGQ9PT1lLmNoaWxkLG49MCxyPTA7aWYodClmb3IodmFyIGw9ZS5jaGlsZDtudWxsIT09bDspbnw9bC5sYW5lc3xsLmNoaWxkTGFuZXMscnw9MzE0NTcyODAmbC5zdWJ0cmVlRmxhZ3Mscnw9MzE0NTcyODAmbC5mbGFncyxsLnJldHVybj1lLGw9bC5zaWJsaW5nO2Vsc2UgZm9yKGw9ZS5jaGlsZDtudWxsIT09bDspbnw9bC5sYW5lc3xsLmNoaWxkTGFuZXMscnw9bC5zdWJ0cmVlRmxhZ3Mscnw9bC5mbGFncyxsLnJldHVybj1lLGw9bC5zaWJsaW5nO3JldHVybiBlLnN1YnRyZWVGbGFnc3w9cixlLmNoaWxkTGFuZXM9bix0fWZ1bmN0aW9uIGw2KGUsdCl7c3dpdGNoKHRCKHQpLHQudGFnKXtjYXNlIDE6bnVsbCE9KGU9dC50eXBlLmNoaWxkQ29udGV4dFR5cGVzKSYmdFMoKTticmVhaztjYXNlIDM6bFIobGopLFUoKSxwKHR2KSxwKHR5KTticmVhaztjYXNlIDI2OmNhc2UgMjc6Y2FzZSA1OlEodCk7YnJlYWs7Y2FzZSA0OlUoKTticmVhaztjYXNlIDEzOm5RKHQpO2JyZWFrO2Nhc2UgMTk6cChuVik7YnJlYWs7Y2FzZSAxMDpsUih0LnR5cGUuX2NvbnRleHQpO2JyZWFrO2Nhc2UgMjI6Y2FzZSAyMzpuUSh0KSxuUigpLG51bGwhPT1lJiZwKGxZKTticmVhaztjYXNlIDI0OmxSKGxqKX19ZnVuY3Rpb24gbDUoZSx0LG4pe3ZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywzKTt0cnl7dC5hcHBseShuLHIpfWNhdGNoKGUpe3RoaXMub25FcnJvcihlKX19dmFyIGw3PSExLGw5PW51bGwsYWU9ITEsYXQ9bnVsbCxhbj17b25FcnJvcjpmdW5jdGlvbihlKXtsNz0hMCxsOT1lfX07ZnVuY3Rpb24gYXIoZSx0LG4scixsLGEsbyxpLHUpe2w3PSExLGw5PW51bGwsbDUuYXBwbHkoYW4sYXJndW1lbnRzKX12YXIgYWw9ITEsYWE9ITEsYW89ImZ1bmN0aW9uIj09dHlwZW9mIFdlYWtTZXQ/V2Vha1NldDpTZXQsYWk9bnVsbDtmdW5jdGlvbiBhdShlLHQpe3RyeXt2YXIgbj1lLnJlZjtpZihudWxsIT09bil7dmFyIHI9ZS5zdGF0ZU5vZGU7c3dpdGNoKGUudGFnKXtjYXNlIDI2OmNhc2UgMjc6Y2FzZSA1OnZhciBsPXI7YnJlYWs7ZGVmYXVsdDpsPXJ9ImZ1bmN0aW9uIj09dHlwZW9mIG4/ZS5yZWZDbGVhbnVwPW4obCk6bi5jdXJyZW50PWx9fWNhdGNoKG4pe29CKGUsdCxuKX19ZnVuY3Rpb24gYXMoZSx0KXt2YXIgbj1lLnJlZixyPWUucmVmQ2xlYW51cDtpZihudWxsIT09bil7aWYoImZ1bmN0aW9uIj09dHlwZW9mIHIpdHJ5e3IoKX1jYXRjaChuKXtvQihlLHQsbil9ZmluYWxseXtlLnJlZkNsZWFudXA9bnVsbCxudWxsIT0oZT1lLmFsdGVybmF0ZSkmJihlLnJlZkNsZWFudXA9bnVsbCl9ZWxzZSBpZigiZnVuY3Rpb24iPT10eXBlb2Ygbil0cnl7bihudWxsKX1jYXRjaChuKXtvQihlLHQsbil9ZWxzZSBuLmN1cnJlbnQ9bnVsbH19ZnVuY3Rpb24gYWMoZSx0LG4pe3RyeXtuKCl9Y2F0Y2gobil7b0IoZSx0LG4pfX12YXIgYWY9ITE7ZnVuY3Rpb24gYWQoZSx0LG4pe3ZhciByPXQudXBkYXRlUXVldWU7aWYobnVsbCE9PShyPW51bGwhPT1yP3IubGFzdEVmZmVjdDpudWxsKSl7dmFyIGw9cj1yLm5leHQ7ZG97aWYoKGwudGFnJmUpPT09ZSl7dmFyIGE9bC5pbnN0LG89YS5kZXN0cm95O3ZvaWQgMCE9PW8mJihhLmRlc3Ryb3k9dm9pZCAwLGFjKHQsbixvKSl9bD1sLm5leHR9d2hpbGUobCE9PXIpfX1mdW5jdGlvbiBhcChlLHQpe2lmKG51bGwhPT0odD1udWxsIT09KHQ9dC51cGRhdGVRdWV1ZSk/dC5sYXN0RWZmZWN0Om51bGwpKXt2YXIgbj10PXQubmV4dDtkb3tpZigobi50YWcmZSk9PT1lKXt2YXIgcj1uLmNyZWF0ZSxsPW4uaW5zdDtyPXIoKSxsLmRlc3Ryb3k9cn1uPW4ubmV4dH13aGlsZShuIT09dCl9fWZ1bmN0aW9uIGFoKGUsdCl7dHJ5e2FwKHQsZSl9Y2F0Y2godCl7b0IoZSxlLnJldHVybix0KX19ZnVuY3Rpb24gYW0oZSl7dmFyIHQ9ZS51cGRhdGVRdWV1ZTtpZihudWxsIT09dCl7dmFyIG49ZS5zdGF0ZU5vZGU7dHJ5e25kKHQsbil9Y2F0Y2godCl7b0IoZSxlLnJldHVybix0KX19fWZ1bmN0aW9uIGFnKGUpe3ZhciB0PWUudHlwZSxuPWUubWVtb2l6ZWRQcm9wcyxyPWUuc3RhdGVOb2RlO3RyeXtzd2l0Y2godCl7Y2FzZSJidXR0b24iOmNhc2UiaW5wdXQiOmNhc2Uic2VsZWN0IjpjYXNlInRleHRhcmVhIjpuLmF1dG9Gb2N1cyYmci5mb2N1cygpO2JyZWFrO2Nhc2UiaW1nIjpuLnNyYyYmKHIuc3JjPW4uc3JjKX19Y2F0Y2godCl7b0IoZSxlLnJldHVybix0KX19ZnVuY3Rpb24gYXkoZSx0LG4pe3ZhciByPW4uZmxhZ3M7c3dpdGNoKG4udGFnKXtjYXNlIDA6Y2FzZSAxMTpjYXNlIDE1OmFUKGUsbiksNCZyJiZhaChuLDUpO2JyZWFrO2Nhc2UgMTppZihhVChlLG4pLDQmcil7aWYoZT1uLnN0YXRlTm9kZSxudWxsPT09dCl0cnl7ZS5jb21wb25lbnREaWRNb3VudCgpfWNhdGNoKGUpe29CKG4sbi5yZXR1cm4sZSl9ZWxzZXt2YXIgbD1uLmVsZW1lbnRUeXBlPT09bi50eXBlP3QubWVtb2l6ZWRQcm9wczpyMChuLnR5cGUsdC5tZW1vaXplZFByb3BzKTt0PXQubWVtb2l6ZWRTdGF0ZTt0cnl7ZS5jb21wb25lbnREaWRVcGRhdGUobCx0LGUuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUpfWNhdGNoKGUpe29CKG4sbi5yZXR1cm4sZSl9fX02NCZyJiZhbShuKSw1MTImciYmYXUobixuLnJldHVybik7YnJlYWs7Y2FzZSAzOmlmKGFUKGUsbiksNjQmciYmbnVsbCE9PShyPW4udXBkYXRlUXVldWUpKXtpZihlPW51bGwsbnVsbCE9PW4uY2hpbGQpc3dpdGNoKG4uY2hpbGQudGFnKXtjYXNlIDI3OmNhc2UgNTpjYXNlIDE6ZT1uLmNoaWxkLnN0YXRlTm9kZX10cnl7bmQocixlKX1jYXRjaChlKXtvQihuLG4ucmV0dXJuLGUpfX1icmVhaztjYXNlIDI2OmFUKGUsbiksNTEyJnImJmF1KG4sbi5yZXR1cm4pO2JyZWFrO2Nhc2UgMjc6Y2FzZSA1OmFUKGUsbiksbnVsbD09PXQmJjQmciYmYWcobiksNTEyJnImJmF1KG4sbi5yZXR1cm4pO2JyZWFrO2Nhc2UgMTI6ZGVmYXVsdDphVChlLG4pO2JyZWFrO2Nhc2UgMTM6YVQoZSxuKSw0JnImJmF4KGUsbik7YnJlYWs7Y2FzZSAyMjppZigwIT0oMSZuLm1vZGUpKXtpZighKGw9bnVsbCE9PW4ubWVtb2l6ZWRTdGF0ZXx8YWwpKXt0PW51bGwhPT10JiZudWxsIT09dC5tZW1vaXplZFN0YXRlfHxhYTt2YXIgYT1hbCxvPWFhO2FsPWwsKGFhPXQpJiYhbz9mdW5jdGlvbiBlKHQsbixyKXtmb3Iocj1yJiYwIT0oODc3MiZuLnN1YnRyZWVGbGFncyksbj1uLmNoaWxkO251bGwhPT1uOyl7dmFyIGw9bi5hbHRlcm5hdGUsYT10LG89bixpPW8uZmxhZ3M7c3dpdGNoKG8udGFnKXtjYXNlIDA6Y2FzZSAxMTpjYXNlIDE1OmUoYSxvLHIpLGFoKG8sNCk7YnJlYWs7Y2FzZSAxOmlmKGUoYSxvLHIpLCJmdW5jdGlvbiI9PXR5cGVvZihhPW8uc3RhdGVOb2RlKS5jb21wb25lbnREaWRNb3VudCl0cnl7YS5jb21wb25lbnREaWRNb3VudCgpfWNhdGNoKGUpe29CKG8sby5yZXR1cm4sZSl9aWYobnVsbCE9PShsPW8udXBkYXRlUXVldWUpKXt2YXIgdT1sLnNoYXJlZC5oaWRkZW5DYWxsYmFja3M7aWYobnVsbCE9PXUpZm9yKGwuc2hhcmVkLmhpZGRlbkNhbGxiYWNrcz1udWxsLGw9MDtsPHUubGVuZ3RoO2wrKyluZih1W2xdLGEpfXImJjY0JmkmJmFtKG8pLGF1KG8sby5yZXR1cm4pO2JyZWFrO2Nhc2UgMjY6Y2FzZSAyNzpjYXNlIDU6ZShhLG8sciksciYmbnVsbD09PWwmJjQmaSYmYWcobyksYXUobyxvLnJldHVybik7YnJlYWs7Y2FzZSAxMjpkZWZhdWx0OmUoYSxvLHIpO2JyZWFrO2Nhc2UgMTM6ZShhLG8sciksciYmNCZpJiZheChhLG8pO2JyZWFrO2Nhc2UgMjI6bnVsbD09PW8ubWVtb2l6ZWRTdGF0ZSYmZShhLG8sciksYXUobyxvLnJldHVybil9bj1uLnNpYmxpbmd9fShlLG4sMCE9KDg3NzImbi5zdWJ0cmVlRmxhZ3MpKTphVChlLG4pLGFsPWEsYWE9b319ZWxzZSBhVChlLG4pOzUxMiZyJiYoIm1hbnVhbCI9PT1uLm1lbW9pemVkUHJvcHMubW9kZT9hdShuLG4ucmV0dXJuKTphcyhuLG4ucmV0dXJuKSl9fWZ1bmN0aW9uIGF2KGUpe3JldHVybiA1PT09ZS50YWd8fDM9PT1lLnRhZ3x8MjY9PT1lLnRhZ3x8Mjc9PT1lLnRhZ3x8ND09PWUudGFnfWZ1bmN0aW9uIGFiKGUpe2U6Zm9yKDs7KXtmb3IoO251bGw9PT1lLnNpYmxpbmc7KXtpZihudWxsPT09ZS5yZXR1cm58fGF2KGUucmV0dXJuKSlyZXR1cm4gbnVsbDtlPWUucmV0dXJufWZvcihlLnNpYmxpbmcucmV0dXJuPWUucmV0dXJuLGU9ZS5zaWJsaW5nOzUhPT1lLnRhZyYmNiE9PWUudGFnJiYyNyE9PWUudGFnJiYxOCE9PWUudGFnOyl7aWYoMiZlLmZsYWdzfHxudWxsPT09ZS5jaGlsZHx8ND09PWUudGFnKWNvbnRpbnVlIGU7ZS5jaGlsZC5yZXR1cm49ZSxlPWUuY2hpbGR9aWYoISgyJmUuZmxhZ3MpKXJldHVybiBlLnN0YXRlTm9kZX19ZnVuY3Rpb24gYWsoZSx0LG4pe3ZhciByPWUudGFnO2lmKDU9PT1yfHw2PT09cillPWUuc3RhdGVOb2RlLHQ/bi5pbnNlcnRCZWZvcmUoZSx0KTpuLmFwcGVuZENoaWxkKGUpO2Vsc2UgaWYoNCE9PXImJjI3IT09ciYmbnVsbCE9PShlPWUuY2hpbGQpKWZvcihhayhlLHQsbiksZT1lLnNpYmxpbmc7bnVsbCE9PWU7KWFrKGUsdCxuKSxlPWUuc2libGluZ312YXIgYXc9bnVsbCxhUz0hMTtmdW5jdGlvbiBhRShlLHQsbil7Zm9yKG49bi5jaGlsZDtudWxsIT09bjspYUMoZSx0LG4pLG49bi5zaWJsaW5nfWZ1bmN0aW9uIGFDKGUsdCxuKXtpZihlZSYmImZ1bmN0aW9uIj09dHlwZW9mIGVlLm9uQ29tbWl0RmliZXJVbm1vdW50KXRyeXtlZS5vbkNvbW1pdEZpYmVyVW5tb3VudChKLG4pfWNhdGNoKGUpe31zd2l0Y2gobi50YWcpe2Nhc2UgMjY6YWF8fGFzKG4sdCksYUUoZSx0LG4pLG4ubWVtb2l6ZWRTdGF0ZT9uLm1lbW9pemVkU3RhdGUuY291bnQtLTpuLnN0YXRlTm9kZSYmKG49bi5zdGF0ZU5vZGUpLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobik7YnJlYWs7Y2FzZSAyNzphYXx8YXMobix0KTt2YXIgcj1hdyxsPWFTO2Zvcihhdz1uLnN0YXRlTm9kZSxhRShlLHQsbiksZT0obj1uLnN0YXRlTm9kZSkuYXR0cmlidXRlcztlLmxlbmd0aDspbi5yZW1vdmVBdHRyaWJ1dGVOb2RlKGVbMF0pO2V6KG4pLGF3PXIsYVM9bDticmVhaztjYXNlIDU6YWF8fGFzKG4sdCk7Y2FzZSA2OnI9YXcsbD1hUyxhdz1udWxsLGFFKGUsdCxuKSxhdz1yLGFTPWwsbnVsbCE9PWF3JiYoYVM/KGU9YXcsbj1uLnN0YXRlTm9kZSw4PT09ZS5ub2RlVHlwZT9lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobik6ZS5yZW1vdmVDaGlsZChuKSk6YXcucmVtb3ZlQ2hpbGQobi5zdGF0ZU5vZGUpKTticmVhaztjYXNlIDE4Om51bGwhPT1hdyYmKGFTPyhlPWF3LG49bi5zdGF0ZU5vZGUsOD09PWUubm9kZVR5cGU/c0MoZS5wYXJlbnROb2RlLG4pOjE9PT1lLm5vZGVUeXBlJiZzQyhlLG4pLGkxKGUpKTpzQyhhdyxuLnN0YXRlTm9kZSkpO2JyZWFrO2Nhc2UgNDpyPWF3LGw9YVMsYXc9bi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyxhUz0hMCxhRShlLHQsbiksYXc9cixhUz1sO2JyZWFrO2Nhc2UgMDpjYXNlIDExOmNhc2UgMTQ6Y2FzZSAxNTppZighYWEmJm51bGwhPT0ocj1uLnVwZGF0ZVF1ZXVlKSYmbnVsbCE9PShyPXIubGFzdEVmZmVjdCkpe2w9cj1yLm5leHQ7ZG97dmFyIGE9bC50YWcsbz1sLmluc3QsaT1vLmRlc3Ryb3k7dm9pZCAwIT09aSYmKDAhPSgyJmEpPyhvLmRlc3Ryb3k9dm9pZCAwLGFjKG4sdCxpKSk6MCE9KDQmYSkmJihvLmRlc3Ryb3k9dm9pZCAwLGFjKG4sdCxpKSkpLGw9bC5uZXh0fXdoaWxlKGwhPT1yKX1hRShlLHQsbik7YnJlYWs7Y2FzZSAxOmlmKCFhYSYmKGFzKG4sdCksImZ1bmN0aW9uIj09dHlwZW9mKHI9bi5zdGF0ZU5vZGUpLmNvbXBvbmVudFdpbGxVbm1vdW50KSl0cnl7ci5wcm9wcz1uLm1lbW9pemVkUHJvcHMsci5zdGF0ZT1uLm1lbW9pemVkU3RhdGUsci5jb21wb25lbnRXaWxsVW5tb3VudCgpfWNhdGNoKGUpe29CKG4sdCxlKX1hRShlLHQsbik7YnJlYWs7Y2FzZSAyMTpkZWZhdWx0OmFFKGUsdCxuKTticmVhaztjYXNlIDIyOmFzKG4sdCksMSZuLm1vZGU/KGFhPShyPWFhKXx8bnVsbCE9PW4ubWVtb2l6ZWRTdGF0ZSxhRShlLHQsbiksYWE9cik6YUUoZSx0LG4pfX1mdW5jdGlvbiBheChlLHQpe2lmKG51bGw9PT10Lm1lbW9pemVkU3RhdGUmJm51bGwhPT0oZT10LmFsdGVybmF0ZSkmJm51bGwhPT0oZT1lLm1lbW9pemVkU3RhdGUpJiZudWxsIT09KGU9ZS5kZWh5ZHJhdGVkKSl0cnl7aTEoZSl9Y2F0Y2goZSl7b0IodCx0LnJldHVybixlKX19ZnVuY3Rpb24gYXooZSx0KXt2YXIgbj1mdW5jdGlvbihlKXtzd2l0Y2goZS50YWcpe2Nhc2UgMTM6Y2FzZSAxOTp2YXIgdD1lLnN0YXRlTm9kZTtyZXR1cm4gbnVsbD09PXQmJih0PWUuc3RhdGVOb2RlPW5ldyBhbyksdDtjYXNlIDIyOnJldHVybiBudWxsPT09KHQ9KGU9ZS5zdGF0ZU5vZGUpLl9yZXRyeUNhY2hlKSYmKHQ9ZS5fcmV0cnlDYWNoZT1uZXcgYW8pLHQ7ZGVmYXVsdDp0aHJvdyBFcnJvcihpKDQzNSxlLnRhZykpfX0oZSk7dC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciByPW9qLmJpbmQobnVsbCxlLHQpO24uaGFzKHQpfHwobi5hZGQodCksdC50aGVuKHIscikpfSl9ZnVuY3Rpb24gYVAoZSx0KXt2YXIgbj10LmRlbGV0aW9ucztpZihudWxsIT09bilmb3IodmFyIHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIGw9bltyXTt0cnl7dmFyIGE9dCxvPWE7ZTpmb3IoO251bGwhPT1vOyl7c3dpdGNoKG8udGFnKXtjYXNlIDI3OmNhc2UgNTphdz1vLnN0YXRlTm9kZSxhUz0hMTticmVhayBlO2Nhc2UgMzpjYXNlIDQ6YXc9by5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyxhUz0hMDticmVhayBlfW89by5yZXR1cm59aWYobnVsbD09PWF3KXRocm93IEVycm9yKGkoMTYwKSk7YUMoZSxhLGwpLGF3PW51bGwsYVM9ITE7dmFyIHU9bC5hbHRlcm5hdGU7bnVsbCE9PXUmJih1LnJldHVybj1udWxsKSxsLnJldHVybj1udWxsfWNhdGNoKGUpe29CKGwsdCxlKX19aWYoMTI4NTQmdC5zdWJ0cmVlRmxhZ3MpZm9yKHQ9dC5jaGlsZDtudWxsIT09dDspYV8odCxlKSx0PXQuc2libGluZ312YXIgYU49bnVsbDtmdW5jdGlvbiBhXyhlLHQpe3ZhciBuPWUuYWx0ZXJuYXRlLHI9ZS5mbGFncztzd2l0Y2goZS50YWcpe2Nhc2UgMDpjYXNlIDExOmNhc2UgMTQ6Y2FzZSAxNTppZihhUCh0LGUpLGFMKGUpLDQmcil7dHJ5e2FkKDMsZSxlLnJldHVybiksYXAoMyxlKX1jYXRjaCh0KXtvQihlLGUucmV0dXJuLHQpfXRyeXthZCg1LGUsZS5yZXR1cm4pfWNhdGNoKHQpe29CKGUsZS5yZXR1cm4sdCl9fWJyZWFrO2Nhc2UgMTphUCh0LGUpLGFMKGUpLDUxMiZyJiZudWxsIT09biYmYXMobixuLnJldHVybiksNjQmciYmYWwmJm51bGwhPT0oZT1lLnVwZGF0ZVF1ZXVlKSYmbnVsbCE9PShuPWUuY2FsbGJhY2tzKSYmKHI9ZS5zaGFyZWQuaGlkZGVuQ2FsbGJhY2tzLGUuc2hhcmVkLmhpZGRlbkNhbGxiYWNrcz1udWxsPT09cj9uOnIuY29uY2F0KG4pKTticmVhaztjYXNlIDI2OnZhciBsPWFOO2lmKGFQKHQsZSksYUwoZSksNTEyJnImJm51bGwhPT1uJiZhcyhuLG4ucmV0dXJuKSw0JnIpe2lmKHQ9bnVsbCE9PW4/bi5tZW1vaXplZFN0YXRlOm51bGwscj1lLm1lbW9pemVkU3RhdGUsbnVsbD09PW4pe2lmKG51bGw9PT1yKXtpZihudWxsPT09ZS5zdGF0ZU5vZGUpe2U6e249ZS50eXBlLHI9ZS5tZW1vaXplZFByb3BzLHQ9bC5vd25lckRvY3VtZW50fHxsO3Q6c3dpdGNoKG4pe2Nhc2UidGl0bGUiOighKGw9dC5nZXRFbGVtZW50c0J5VGFnTmFtZSgidGl0bGUiKVswXSl8fGxbZXhdfHxsW2V2XXx8Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj09PWwubmFtZXNwYWNlVVJJfHxsLmhhc0F0dHJpYnV0ZSgiaXRlbXByb3AiKSkmJihsPXQuY3JlYXRlRWxlbWVudChuKSx0LmhlYWQuaW5zZXJ0QmVmb3JlKGwsdC5xdWVyeVNlbGVjdG9yKCJoZWFkID4gdGl0bGUiKSkpLHNmKGwsbixyKSxsW2V2XT1lLGVNKGwpLG49bDticmVhayBlO2Nhc2UibGluayI6dmFyIGE9c1coImxpbmsiLCJocmVmIix0KS5nZXQobisoci5ocmVmfHwiIikpO2lmKGEpe2Zvcih2YXIgbz0wO288YS5sZW5ndGg7bysrKWlmKChsPWFbb10pLmdldEF0dHJpYnV0ZSgiaHJlZiIpPT09KG51bGw9PXIuaHJlZj9udWxsOnIuaHJlZikmJmwuZ2V0QXR0cmlidXRlKCJyZWwiKT09PShudWxsPT1yLnJlbD9udWxsOnIucmVsKSYmbC5nZXRBdHRyaWJ1dGUoInRpdGxlIik9PT0obnVsbD09ci50aXRsZT9udWxsOnIudGl0bGUpJiZsLmdldEF0dHJpYnV0ZSgiY3Jvc3NvcmlnaW4iKT09PShudWxsPT1yLmNyb3NzT3JpZ2luP251bGw6ci5jcm9zc09yaWdpbikpe2Euc3BsaWNlKG8sMSk7YnJlYWsgdH19c2YobD10LmNyZWF0ZUVsZW1lbnQobiksbixyKSx0LmhlYWQuYXBwZW5kQ2hpbGQobCk7YnJlYWs7Y2FzZSJtZXRhIjppZihhPXNXKCJtZXRhIiwiY29udGVudCIsdCkuZ2V0KG4rKHIuY29udGVudHx8IiIpKSl7Zm9yKG89MDtvPGEubGVuZ3RoO28rKylpZigobD1hW29dKS5nZXRBdHRyaWJ1dGUoImNvbnRlbnQiKT09PShudWxsPT1yLmNvbnRlbnQ/bnVsbDoiIityLmNvbnRlbnQpJiZsLmdldEF0dHJpYnV0ZSgibmFtZSIpPT09KG51bGw9PXIubmFtZT9udWxsOnIubmFtZSkmJmwuZ2V0QXR0cmlidXRlKCJwcm9wZXJ0eSIpPT09KG51bGw9PXIucHJvcGVydHk/bnVsbDpyLnByb3BlcnR5KSYmbC5nZXRBdHRyaWJ1dGUoImh0dHAtZXF1aXYiKT09PShudWxsPT1yLmh0dHBFcXVpdj9udWxsOnIuaHR0cEVxdWl2KSYmbC5nZXRBdHRyaWJ1dGUoImNoYXJzZXQiKT09PShudWxsPT1yLmNoYXJTZXQ/bnVsbDpyLmNoYXJTZXQpKXthLnNwbGljZShvLDEpO2JyZWFrIHR9fXNmKGw9dC5jcmVhdGVFbGVtZW50KG4pLG4sciksdC5oZWFkLmFwcGVuZENoaWxkKGwpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoaSg0NjgsbikpfWxbZXZdPWUsZU0obCksbj1sfWUuc3RhdGVOb2RlPW59ZWxzZSBzaihsLGUudHlwZSxlLnN0YXRlTm9kZSl9ZWxzZSBlLnN0YXRlTm9kZT1zVShsLHIsZS5tZW1vaXplZFByb3BzKX1lbHNlIGlmKHQhPT1yKW51bGw9PT10P251bGwhPT1uLnN0YXRlTm9kZSYmKG49bi5zdGF0ZU5vZGUpLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobik6dC5jb3VudC0tLG51bGw9PT1yP3NqKGwsZS50eXBlLGUuc3RhdGVOb2RlKTpzVShsLHIsZS5tZW1vaXplZFByb3BzKTtlbHNlIGlmKG51bGw9PT1yJiZudWxsIT09ZS5zdGF0ZU5vZGUmJihyPWUudXBkYXRlUXVldWUsZS51cGRhdGVRdWV1ZT1udWxsLG51bGwhPT1yKSl0cnl7dmFyIHU9ZS5zdGF0ZU5vZGUscz1lLm1lbW9pemVkUHJvcHM7c2QodSxyLGUudHlwZSxuLm1lbW9pemVkUHJvcHMscyksdVtlYl09c31jYXRjaCh0KXtvQihlLGUucmV0dXJuLHQpfX1icmVhaztjYXNlIDI3OmlmKDQmciYmbnVsbD09PWUuYWx0ZXJuYXRlKXtmb3IobD1lLnN0YXRlTm9kZSxhPWUubWVtb2l6ZWRQcm9wcyxvPWwuZmlyc3RDaGlsZDtvOyl7dmFyIGM9by5uZXh0U2libGluZyxmPW8ubm9kZU5hbWU7b1tleF18fCJIRUFEIj09PWZ8fCJCT0RZIj09PWZ8fCJTQ1JJUFQiPT09Znx8IlNUWUxFIj09PWZ8fCJMSU5LIj09PWYmJiJzdHlsZXNoZWV0Ij09PW8ucmVsLnRvTG93ZXJDYXNlKCl8fGwucmVtb3ZlQ2hpbGQobyksbz1jfWZvcihvPWUudHlwZSxjPWwuYXR0cmlidXRlcztjLmxlbmd0aDspbC5yZW1vdmVBdHRyaWJ1dGVOb2RlKGNbMF0pO3NmKGwsbyxhKSxsW2V2XT1lLGxbZWJdPWF9Y2FzZSA1OmlmKGFQKHQsZSksYUwoZSksNTEyJnImJm51bGwhPT1uJiZhcyhuLG4ucmV0dXJuKSwzMiZlLmZsYWdzKXt0PWUuc3RhdGVOb2RlO3RyeXt0ZSh0LCIiKX1jYXRjaCh0KXtvQihlLGUucmV0dXJuLHQpfX1pZig0JnImJm51bGwhPShyPWUuc3RhdGVOb2RlKSYmKHQ9ZS5tZW1vaXplZFByb3BzLG49bnVsbCE9PW4/bi5tZW1vaXplZFByb3BzOnQsbD1lLnR5cGUsYT1lLnVwZGF0ZVF1ZXVlLGUudXBkYXRlUXVldWU9bnVsbCxudWxsIT09YSkpdHJ5e3NkKHIsYSxsLG4sdCkscltlYl09dH1jYXRjaCh0KXtvQihlLGUucmV0dXJuLHQpfWJyZWFrO2Nhc2UgNjppZihhUCh0LGUpLGFMKGUpLDQmcil7aWYobnVsbD09PWUuc3RhdGVOb2RlKXRocm93IEVycm9yKGkoMTYyKSk7bj1lLnN0YXRlTm9kZSxyPWUubWVtb2l6ZWRQcm9wczt0cnl7bi5ub2RlVmFsdWU9cn1jYXRjaCh0KXtvQihlLGUucmV0dXJuLHQpfX1icmVhaztjYXNlIDM6aWYocyQ9bnVsbCxsPWFOLGFOPXNNKHQuY29udGFpbmVySW5mbyksYVAodCxlKSxhTj1sLGFMKGUpLDQmciYmbnVsbCE9PW4mJm4ubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQpdHJ5e2kxKHQuY29udGFpbmVySW5mbyl9Y2F0Y2godCl7b0IoZSxlLnJldHVybix0KX1icmVhaztjYXNlIDQ6bj1hTixhTj1zTShlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxhUCh0LGUpLGFMKGUpLGFOPW47YnJlYWs7Y2FzZSAxMzphUCh0LGUpLGFMKGUpLDgxOTImZS5jaGlsZC5mbGFncyYmbnVsbCE9PWUubWVtb2l6ZWRTdGF0ZSE9KG51bGwhPT1uJiZudWxsIT09bi5tZW1vaXplZFN0YXRlKSYmKG9uPUgoKSksNCZyJiZudWxsIT09KG49ZS51cGRhdGVRdWV1ZSkmJihlLnVwZGF0ZVF1ZXVlPW51bGwsYXooZSxuKSk7YnJlYWs7Y2FzZSAyMjppZig1MTImciYmbnVsbCE9PW4mJmFzKG4sbi5yZXR1cm4pLHU9bnVsbCE9PWUubWVtb2l6ZWRTdGF0ZSxzPW51bGwhPT1uJiZudWxsIT09bi5tZW1vaXplZFN0YXRlLDEmZS5tb2RlKXt2YXIgZD1hbCxwPWFhO2FsPWR8fHUsYWE9cHx8cyxhUCh0LGUpLGFhPXAsYWw9ZH1lbHNlIGFQKHQsZSk7aWYoYUwoZSksKHQ9ZS5zdGF0ZU5vZGUpLl9jdXJyZW50PWUsdC5fdmlzaWJpbGl0eSY9LTMsdC5fdmlzaWJpbGl0eXw9MiZ0Ll9wZW5kaW5nVmlzaWJpbGl0eSw4MTkyJnImJih0Ll92aXNpYmlsaXR5PXU/LTImdC5fdmlzaWJpbGl0eToxfHQuX3Zpc2liaWxpdHksdSYmKHQ9YWx8fGFhLG51bGw9PT1ufHxzfHx0fHwwIT0oMSZlLm1vZGUpJiZmdW5jdGlvbiBlKHQpe2Zvcih0PXQuY2hpbGQ7bnVsbCE9PXQ7KXt2YXIgbj10O3N3aXRjaChuLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNDpjYXNlIDE1OmFkKDQsbixuLnJldHVybiksZShuKTticmVhaztjYXNlIDE6YXMobixuLnJldHVybik7dmFyIHI9bi5zdGF0ZU5vZGU7aWYoImZ1bmN0aW9uIj09dHlwZW9mIHIuY29tcG9uZW50V2lsbFVubW91bnQpe3ZhciBsPW4ucmV0dXJuO3RyeXtyLnByb3BzPW4ubWVtb2l6ZWRQcm9wcyxyLnN0YXRlPW4ubWVtb2l6ZWRTdGF0ZSxyLmNvbXBvbmVudFdpbGxVbm1vdW50KCl9Y2F0Y2goZSl7b0IobixsLGUpfX1lKG4pO2JyZWFrO2Nhc2UgMjY6Y2FzZSAyNzpjYXNlIDU6YXMobixuLnJldHVybiksZShuKTticmVhaztjYXNlIDIyOmFzKG4sbi5yZXR1cm4pLG51bGw9PT1uLm1lbW9pemVkU3RhdGUmJmUobik7YnJlYWs7ZGVmYXVsdDplKG4pfXQ9dC5zaWJsaW5nfX0oZSkpLG51bGw9PT1lLm1lbW9pemVkUHJvcHN8fCJtYW51YWwiIT09ZS5tZW1vaXplZFByb3BzLm1vZGUpKWU6Zm9yKG49bnVsbCx0PWU7Oyl7aWYoNT09PXQudGFnfHwyNj09PXQudGFnfHwyNz09PXQudGFnKXtpZihudWxsPT09bil7bj10O3RyeXtsPXQuc3RhdGVOb2RlLHU/KGE9bC5zdHlsZSwiZnVuY3Rpb24iPT10eXBlb2YgYS5zZXRQcm9wZXJ0eT9hLnNldFByb3BlcnR5KCJkaXNwbGF5Iiwibm9uZSIsImltcG9ydGFudCIpOmEuZGlzcGxheT0ibm9uZSIpOihvPXQuc3RhdGVOb2RlLGY9bnVsbCE9KGM9dC5tZW1vaXplZFByb3BzLnN0eWxlKSYmYy5oYXNPd25Qcm9wZXJ0eSgiZGlzcGxheSIpP2MuZGlzcGxheTpudWxsLG8uc3R5bGUuZGlzcGxheT1udWxsPT1mfHwiYm9vbGVhbiI9PXR5cGVvZiBmPyIiOigiIitmKS50cmltKCkpfWNhdGNoKHQpe29CKGUsZS5yZXR1cm4sdCl9fX1lbHNlIGlmKDY9PT10LnRhZyl7aWYobnVsbD09PW4pdHJ5e3Quc3RhdGVOb2RlLm5vZGVWYWx1ZT11PyIiOnQubWVtb2l6ZWRQcm9wc31jYXRjaCh0KXtvQihlLGUucmV0dXJuLHQpfX1lbHNlIGlmKCgyMiE9PXQudGFnJiYyMyE9PXQudGFnfHxudWxsPT09dC5tZW1vaXplZFN0YXRlfHx0PT09ZSkmJm51bGwhPT10LmNoaWxkKXt0LmNoaWxkLnJldHVybj10LHQ9dC5jaGlsZDtjb250aW51ZX1pZih0PT09ZSlicmVhaztmb3IoO251bGw9PT10LnNpYmxpbmc7KXtpZihudWxsPT09dC5yZXR1cm58fHQucmV0dXJuPT09ZSlicmVhayBlO249PT10JiYobj1udWxsKSx0PXQucmV0dXJufW49PT10JiYobj1udWxsKSx0LnNpYmxpbmcucmV0dXJuPXQucmV0dXJuLHQ9dC5zaWJsaW5nfTQmciYmbnVsbCE9PShuPWUudXBkYXRlUXVldWUpJiZudWxsIT09KHI9bi5yZXRyeVF1ZXVlKSYmKG4ucmV0cnlRdWV1ZT1udWxsLGF6KGUscikpO2JyZWFrO2Nhc2UgMTk6YVAodCxlKSxhTChlKSw0JnImJm51bGwhPT0obj1lLnVwZGF0ZVF1ZXVlKSYmKGUudXBkYXRlUXVldWU9bnVsbCxheihlLG4pKTticmVhaztjYXNlIDIxOmJyZWFrO2RlZmF1bHQ6YVAodCxlKSxhTChlKX19ZnVuY3Rpb24gYUwoZSl7dmFyIHQ9ZS5mbGFncztpZigyJnQpe3RyeXtpZigyNyE9PWUudGFnKXt0Ontmb3IodmFyIG49ZS5yZXR1cm47bnVsbCE9PW47KXtpZihhdihuKSl7dmFyIHI9bjticmVhayB0fW49bi5yZXR1cm59dGhyb3cgRXJyb3IoaSgxNjApKX1zd2l0Y2goci50YWcpe2Nhc2UgMjc6dmFyIGw9ci5zdGF0ZU5vZGUsYT1hYihlKTthayhlLGEsbCk7YnJlYWs7Y2FzZSA1OnZhciBvPXIuc3RhdGVOb2RlOzMyJnIuZmxhZ3MmJih0ZShvLCIiKSxyLmZsYWdzJj0tMzMpO3ZhciB1PWFiKGUpO2FrKGUsdSxvKTticmVhaztjYXNlIDM6Y2FzZSA0OnZhciBzPXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8sYz1hYihlKTshZnVuY3Rpb24gZSh0LG4scil7dmFyIGw9dC50YWc7aWYoNT09PWx8fDY9PT1sKXQ9dC5zdGF0ZU5vZGUsbj84PT09ci5ub2RlVHlwZT9yLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHQsbik6ci5pbnNlcnRCZWZvcmUodCxuKTooOD09PXIubm9kZVR5cGU/KG49ci5wYXJlbnROb2RlKS5pbnNlcnRCZWZvcmUodCxyKToobj1yKS5hcHBlbmRDaGlsZCh0KSxudWxsIT0ocj1yLl9yZWFjdFJvb3RDb250YWluZXIpfHxudWxsIT09bi5vbmNsaWNrfHwobi5vbmNsaWNrPXN1KSk7ZWxzZSBpZig0IT09bCYmMjchPT1sJiZudWxsIT09KHQ9dC5jaGlsZCkpZm9yKGUodCxuLHIpLHQ9dC5zaWJsaW5nO251bGwhPT10OyllKHQsbixyKSx0PXQuc2libGluZ30oZSxjLHMpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoaSgxNjEpKX19fWNhdGNoKHQpe29CKGUsZS5yZXR1cm4sdCl9ZS5mbGFncyY9LTN9NDA5NiZ0JiYoZS5mbGFncyY9LTQwOTcpfWZ1bmN0aW9uIGFUKGUsdCl7aWYoODc3MiZ0LnN1YnRyZWVGbGFncylmb3IodD10LmNoaWxkO251bGwhPT10OylheShlLHQuYWx0ZXJuYXRlLHQpLHQ9dC5zaWJsaW5nfWZ1bmN0aW9uIGFNKGUsdCl7dHJ5e2FwKHQsZSl9Y2F0Y2godCl7b0IoZSxlLnJldHVybix0KX19ZnVuY3Rpb24gYUYoZSx0KXt2YXIgbj1udWxsO251bGwhPT1lJiZudWxsIT09ZS5tZW1vaXplZFN0YXRlJiZudWxsIT09ZS5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCYmKG49ZS5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKSxlPW51bGwsbnVsbCE9PXQubWVtb2l6ZWRTdGF0ZSYmbnVsbCE9PXQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wmJihlPXQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCksZSE9PW4mJihudWxsIT1lJiZlLnJlZkNvdW50KyssbnVsbCE9biYmbHEobikpfWZ1bmN0aW9uIGFEKGUsdCl7ZT1udWxsLG51bGwhPT10LmFsdGVybmF0ZSYmKGU9dC5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5jYWNoZSksKHQ9dC5tZW1vaXplZFN0YXRlLmNhY2hlKSE9PWUmJih0LnJlZkNvdW50KyssbnVsbCE9ZSYmbHEoZSkpfWZ1bmN0aW9uIGFSKGUsdCxuLHIpe2lmKDEwMjU2JnQuc3VidHJlZUZsYWdzKWZvcih0PXQuY2hpbGQ7bnVsbCE9PXQ7KWFPKGUsdCxuLHIpLHQ9dC5zaWJsaW5nfWZ1bmN0aW9uIGFPKGUsdCxuLHIpe3ZhciBsPXQuZmxhZ3M7c3dpdGNoKHQudGFnKXtjYXNlIDA6Y2FzZSAxMTpjYXNlIDE1OmFSKGUsdCxuLHIpLDIwNDgmbCYmYU0odCw5KTticmVhaztjYXNlIDM6YVIoZSx0LG4sciksMjA0OCZsJiYoZT1udWxsLG51bGwhPT10LmFsdGVybmF0ZSYmKGU9dC5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5jYWNoZSksKHQ9dC5tZW1vaXplZFN0YXRlLmNhY2hlKSE9PWUmJih0LnJlZkNvdW50KyssbnVsbCE9ZSYmbHEoZSkpKTticmVhaztjYXNlIDIzOmJyZWFrO2Nhc2UgMjI6dmFyIGE9dC5zdGF0ZU5vZGU7bnVsbCE9PXQubWVtb2l6ZWRTdGF0ZT80JmEuX3Zpc2liaWxpdHk/YVIoZSx0LG4scik6MSZ0Lm1vZGU/YUEoZSx0KTooYS5fdmlzaWJpbGl0eXw9NCxhUihlLHQsbixyKSk6NCZhLl92aXNpYmlsaXR5P2FSKGUsdCxuLHIpOihhLl92aXNpYmlsaXR5fD00LGZ1bmN0aW9uIGUodCxuLHIsbCxhKXtmb3IoYT1hJiYwIT0oMTAyNTYmbi5zdWJ0cmVlRmxhZ3MpLG49bi5jaGlsZDtudWxsIT09bjspe3ZhciBvPW4saT1vLmZsYWdzO3N3aXRjaChvLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNTplKHQsbyxyLGwsYSksYU0obyw4KTticmVhaztjYXNlIDIzOmJyZWFrO2Nhc2UgMjI6dmFyIHU9by5zdGF0ZU5vZGU7bnVsbCE9PW8ubWVtb2l6ZWRTdGF0ZT80JnUuX3Zpc2liaWxpdHk/ZSh0LG8scixsLGEpOjEmby5tb2RlP2FBKHQsbyk6KHUuX3Zpc2liaWxpdHl8PTQsZSh0LG8scixsLGEpKToodS5fdmlzaWJpbGl0eXw9NCxlKHQsbyxyLGwsYSkpLGEmJjIwNDgmaSYmYUYoby5hbHRlcm5hdGUsbyk7YnJlYWs7Y2FzZSAyNDplKHQsbyxyLGwsYSksYSYmMjA0OCZpJiZhRChvLmFsdGVybmF0ZSxvKTticmVhaztkZWZhdWx0OmUodCxvLHIsbCxhKX1uPW4uc2libGluZ319KGUsdCxuLHIsMCE9KDEwMjU2JnQuc3VidHJlZUZsYWdzKSkpLDIwNDgmbCYmYUYodC5hbHRlcm5hdGUsdCk7YnJlYWs7Y2FzZSAyNDphUihlLHQsbixyKSwyMDQ4JmwmJmFEKHQuYWx0ZXJuYXRlLHQpO2JyZWFrO2RlZmF1bHQ6YVIoZSx0LG4scil9fWZ1bmN0aW9uIGFBKGUsdCl7aWYoMTAyNTYmdC5zdWJ0cmVlRmxhZ3MpZm9yKHQ9dC5jaGlsZDtudWxsIT09dDspe3ZhciBuPXQscj1uLmZsYWdzO3N3aXRjaChuLnRhZyl7Y2FzZSAyMjphQShlLG4pLDIwNDgmciYmYUYobi5hbHRlcm5hdGUsbik7YnJlYWs7Y2FzZSAyNDphQShlLG4pLDIwNDgmciYmYUQobi5hbHRlcm5hdGUsbik7YnJlYWs7ZGVmYXVsdDphQShlLG4pfXQ9dC5zaWJsaW5nfX12YXIgYUk9ODE5MjtmdW5jdGlvbiBhVShlKXtpZihlLnN1YnRyZWVGbGFncyZhSSlmb3IoZT1lLmNoaWxkO251bGwhPT1lOylhQihlKSxlPWUuc2libGluZ31mdW5jdGlvbiBhQihlKXtzd2l0Y2goZS50YWcpe2Nhc2UgMjY6YVUoZSksZS5mbGFncyZhSSYmbnVsbCE9PWUubWVtb2l6ZWRTdGF0ZSYmZnVuY3Rpb24oZSx0LG4pe2lmKG51bGw9PT1zSCl0aHJvdyBFcnJvcihpKDQ3NSkpO3ZhciByPXNIO2lmKCJzdHlsZXNoZWV0Ij09PXQudHlwZSYmKCJzdHJpbmciIT10eXBlb2Ygbi5tZWRpYXx8ITEhPT1tYXRjaE1lZGlhKG4ubWVkaWEpLm1hdGNoZXMpKXtpZihudWxsPT09dC5pbnN0YW5jZSl7dmFyIGw9c1Iobi5ocmVmKSxhPWUucXVlcnlTZWxlY3RvcihzTyhsKSk7aWYoYSl7bnVsbCE9PShlPWEuX3ApJiYib2JqZWN0Ij09dHlwZW9mIGUmJiJmdW5jdGlvbiI9PXR5cGVvZiBlLnRoZW4mJihyLmNvdW50Kysscj1zSy5iaW5kKHIpLGUudGhlbihyLHIpKSx0LnN0YXRlLmxvYWRpbmd8PTQsdC5pbnN0YW5jZT1hLGVNKGEpO3JldHVybn1hPWUub3duZXJEb2N1bWVudHx8ZSxuPXNBKG4pLChsPXNMLmdldChsKSkmJnNRKG4sbCksZU0oYT1hLmNyZWF0ZUVsZW1lbnQoImxpbmsiKSk7dmFyIG89YTtvLl9wPW5ldyBQcm9taXNlKGZ1bmN0aW9uKGUsdCl7by5vbmxvYWQ9ZSxvLm9uZXJyb3I9dH0pLHNmKGEsImxpbmsiLG4pLHQuaW5zdGFuY2U9YX1udWxsPT09ci5zdHlsZXNoZWV0cyYmKHIuc3R5bGVzaGVldHM9bmV3IE1hcCksci5zdHlsZXNoZWV0cy5zZXQodCxlKSwoZT10LnN0YXRlLnByZWxvYWQpJiYwPT0oMyZ0LnN0YXRlLmxvYWRpbmcpJiYoci5jb3VudCsrLHQ9c0suYmluZChyKSxlLmFkZEV2ZW50TGlzdGVuZXIoImxvYWQiLHQpLGUuYWRkRXZlbnRMaXN0ZW5lcigiZXJyb3IiLHQpKX19KGFOLGUubWVtb2l6ZWRTdGF0ZSxlLm1lbW9pemVkUHJvcHMpO2JyZWFrO2Nhc2UgNTpkZWZhdWx0OmFVKGUpO2JyZWFrO2Nhc2UgMzpjYXNlIDQ6dmFyIHQ9YU47YU49c00oZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyksYVUoZSksYU49dDticmVhaztjYXNlIDIyOm51bGw9PT1lLm1lbW9pemVkU3RhdGUmJihudWxsIT09KHQ9ZS5hbHRlcm5hdGUpJiZudWxsIT09dC5tZW1vaXplZFN0YXRlPyh0PWFJLGFJPTE2Nzc3MjE2LGFVKGUpLGFJPXQpOmFVKGUpKX19ZnVuY3Rpb24gYVEoZSl7dmFyIHQ9ZS5hbHRlcm5hdGU7aWYobnVsbCE9PXQmJm51bGwhPT0oZT10LmNoaWxkKSl7dC5jaGlsZD1udWxsO2RvIHQ9ZS5zaWJsaW5nLGUuc2libGluZz1udWxsLGU9dDt3aGlsZShudWxsIT09ZSl9fWZ1bmN0aW9uIGFWKGUpe3ZhciB0PWUuZGVsZXRpb25zO2lmKDAhPSgxNiZlLmZsYWdzKSl7aWYobnVsbCE9PXQpZm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07YWk9cixhVyhyLGUpfWFRKGUpfWlmKDEwMjU2JmUuc3VidHJlZUZsYWdzKWZvcihlPWUuY2hpbGQ7bnVsbCE9PWU7KWEkKGUpLGU9ZS5zaWJsaW5nfWZ1bmN0aW9uIGEkKGUpe3N3aXRjaChlLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNTphVihlKSwyMDQ4JmUuZmxhZ3MmJmFkKDksZSxlLnJldHVybik7YnJlYWs7Y2FzZSAyMjp2YXIgdD1lLnN0YXRlTm9kZTtudWxsIT09ZS5tZW1vaXplZFN0YXRlJiY0JnQuX3Zpc2liaWxpdHkmJihudWxsPT09ZS5yZXR1cm58fDEzIT09ZS5yZXR1cm4udGFnKT8odC5fdmlzaWJpbGl0eSY9LTUsZnVuY3Rpb24gZSh0KXt2YXIgbj10LmRlbGV0aW9ucztpZigwIT0oMTYmdC5mbGFncykpe2lmKG51bGwhPT1uKWZvcih2YXIgcj0wO3I8bi5sZW5ndGg7cisrKXt2YXIgbD1uW3JdO2FpPWwsYVcobCx0KX1hUSh0KX1mb3IodD10LmNoaWxkO251bGwhPT10Oyl7c3dpdGNoKChuPXQpLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNTphZCg4LG4sbi5yZXR1cm4pLGUobik7YnJlYWs7Y2FzZSAyMjo0JihyPW4uc3RhdGVOb2RlKS5fdmlzaWJpbGl0eSYmKHIuX3Zpc2liaWxpdHkmPS01LGUobikpO2JyZWFrO2RlZmF1bHQ6ZShuKX10PXQuc2libGluZ319KGUpKTphVihlKTticmVhaztkZWZhdWx0OmFWKGUpfX1mdW5jdGlvbiBhVyhlLHQpe2Zvcig7bnVsbCE9PWFpOyl7dmFyIG49YWk7c3dpdGNoKG4udGFnKXtjYXNlIDA6Y2FzZSAxMTpjYXNlIDE1OmFkKDgsbix0KTticmVhaztjYXNlIDIzOmNhc2UgMjI6aWYobnVsbCE9PW4ubWVtb2l6ZWRTdGF0ZSYmbnVsbCE9PW4ubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wpe3ZhciByPW4ubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbDtudWxsIT1yJiZyLnJlZkNvdW50Kyt9YnJlYWs7Y2FzZSAyNDpscShuLm1lbW9pemVkU3RhdGUuY2FjaGUpfWlmKG51bGwhPT0ocj1uLmNoaWxkKSlyLnJldHVybj1uLGFpPXI7ZWxzZSBmb3Iobj1lO251bGwhPT1haTspe3ZhciBsPShyPWFpKS5zaWJsaW5nLGE9ci5yZXR1cm47aWYoIWZ1bmN0aW9uIGUodCl7dmFyIG49dC5hbHRlcm5hdGU7bnVsbCE9PW4mJih0LmFsdGVybmF0ZT1udWxsLGUobikpLHQuY2hpbGQ9bnVsbCx0LmRlbGV0aW9ucz1udWxsLHQuc2libGluZz1udWxsLDU9PT10LnRhZyYmbnVsbCE9PShuPXQuc3RhdGVOb2RlKSYmZXoobiksdC5zdGF0ZU5vZGU9bnVsbCx0LnJldHVybj1udWxsLHQuZGVwZW5kZW5jaWVzPW51bGwsdC5tZW1vaXplZFByb3BzPW51bGwsdC5tZW1vaXplZFN0YXRlPW51bGwsdC5wZW5kaW5nUHJvcHM9bnVsbCx0LnN0YXRlTm9kZT1udWxsLHQudXBkYXRlUXVldWU9bnVsbH0ocikscj09PW4pe2FpPW51bGw7YnJlYWt9aWYobnVsbCE9PWwpe2wucmV0dXJuPWEsYWk9bDticmVha31haT1hfX19dmFyIGFqPXtnZXRDYWNoZVNpZ25hbDpmdW5jdGlvbigpe3JldHVybiBsVShsaikuY29udHJvbGxlci5zaWduYWx9LGdldENhY2hlRm9yVHlwZTpmdW5jdGlvbihlKXt2YXIgdD1sVShsaiksbj10LmRhdGEuZ2V0KGUpO3JldHVybiB2b2lkIDA9PT1uJiYobj1lKCksdC5kYXRhLnNldChlLG4pKSxufX0sYUg9ImZ1bmN0aW9uIj09dHlwZW9mIFdlYWtNYXA/V2Vha01hcDpNYXAsYXE9cy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLGFLPXMuUmVhY3RDdXJyZW50Q2FjaGUsYVk9cy5SZWFjdEN1cnJlbnRPd25lcixhWD1zLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLGFHPTAsYVo9bnVsbCxhSj1udWxsLGEwPTAsYTE9MCxhMj1udWxsLGEzPSExLGE0PTAsYTg9MCxhNj1udWxsLGE1PTAsYTc9MCxhOT0wLG9lPW51bGwsb3Q9bnVsbCxvbj0wLG9yPTEvMCxvbD1udWxsLG9hPSExLG9vPW51bGwsb2k9bnVsbCxvdT0hMSxvcz1udWxsLG9jPTAsb2Y9MCxvZD1udWxsLG9wPTAsb2g9bnVsbDtmdW5jdGlvbiBvbShlKXtyZXR1cm4gMD09KDEmZS5tb2RlKT8yOjAhPSgyJmFHKSYmMCE9PWEwP2EwJi1hMDpudWxsIT09bEsudHJhbnNpdGlvbj8oMD09KGU9MCkmJigwPT09blkmJihuWT1lcygpKSxlPW5ZKSxlKTowIT09KGU9ZWgpP2U6ZT12b2lkIDA9PT0oZT13aW5kb3cuZXZlbnQpPzMyOmk5KGUudHlwZSl9ZnVuY3Rpb24gb2coZSx0LG4peyhlPT09YVomJjI9PT1hMXx8bnVsbCE9PWUuY2FuY2VsUGVuZGluZ0NvbW1pdCkmJihveChlLDApLG93KGUsYTApKSxlZChlLG4pLCgwPT0oMiZhRyl8fGUhPT1hWikmJihlPT09YVomJigwPT0oMiZhRykmJihhN3w9biksND09PWE4JiZvdyhlLGEwKSksblgoZSksMj09PW4mJjA9PT1hRyYmMD09KDEmdC5tb2RlKSYmKG9yPUgoKSs1MDAsbkcoITApKSl9ZnVuY3Rpb24gb3koZSx0KXtpZigwIT0oNiZhRykpdGhyb3cgRXJyb3IoaSgzMjcpKTt2YXIgbj1lLmNhbGxiYWNrTm9kZTtpZihvSSgpJiZlLmNhbGxiYWNrTm9kZSE9PW4pcmV0dXJuIG51bGw7dmFyIHI9ZWkoZSxlPT09YVo/YTA6MCk7aWYoMD09PXIpcmV0dXJuIG51bGw7aWYoMCE9PSh0PTAhPSg2MCZyKXx8MCE9KHImZS5leHBpcmVkTGFuZXMpfHx0P29UKGUscik6ZnVuY3Rpb24oZSx0KXt2YXIgbj1hRzthR3w9Mjt2YXIgcj1vTigpLGw9b18oKTsoYVohPT1lfHxhMCE9PXQpJiYob2w9bnVsbCxvcj1IKCkrNTAwLG94KGUsdCkpO2U6Zm9yKDs7KXRyeXtpZigwIT09YTEmJm51bGwhPT1hSil7dD1hSjt2YXIgYT1hMjt0OnN3aXRjaChhMSl7Y2FzZSAxOmNhc2UgNjphMT0wLGEyPW51bGwsb0QodCxhKTticmVhaztjYXNlIDI6aWYobnkoYSkpe2ExPTAsYTI9bnVsbCxvRih0KTticmVha310PWZ1bmN0aW9uKCl7Mj09PWExJiZhWj09PWUmJihhMT03KSxuWChlKX0sYS50aGVuKHQsdCk7YnJlYWsgZTtjYXNlIDM6YTE9NzticmVhayBlO2Nhc2UgNDphMT01O2JyZWFrIGU7Y2FzZSA3Om55KGEpPyhhMT0wLGEyPW51bGwsb0YodCkpOihhMT0wLGEyPW51bGwsb0QodCxhKSk7YnJlYWs7Y2FzZSA1OnN3aXRjaChhSi50YWcpe2Nhc2UgNTpjYXNlIDI2OmNhc2UgMjc6dD1hSixhMT0wLGEyPW51bGw7dmFyIG89dC5zaWJsaW5nO2lmKG51bGwhPT1vKWFKPW87ZWxzZXt2YXIgdT10LnJldHVybjtudWxsIT09dT8oYUo9dSxvUih1KSk6YUo9bnVsbH1icmVhayB0fWExPTAsYTI9bnVsbCxvRCh0LGEpO2JyZWFrO2Nhc2UgODpvQygpLGE4PTY7YnJlYWsgZTtkZWZhdWx0OnRocm93IEVycm9yKGkoNDYyKSl9fSFmdW5jdGlvbigpe2Zvcig7bnVsbCE9PWFKJiYhVygpOylvTShhSil9KCk7YnJlYWt9Y2F0Y2godCl7b3ooZSx0KX1yZXR1cm4obEYoKSxhcS5jdXJyZW50PXIsYUsuY3VycmVudD1sLGFHPW4sbnVsbCE9PWFKKT8wOihhWj1udWxsLGEwPTAsdDcoKSxhOCl9KGUscikpKXtpZigyPT09dCl7dmFyIGw9cixhPWV1KGUsbCk7MCE9PWEmJihyPWEsdD1vdihlLGwsYSkpfWlmKDE9PT10KXRocm93IG49YTYsb3goZSwwKSxvdyhlLHIpLG5YKGUpLG47aWYoNj09PXQpb3coZSxyKTtlbHNle2lmKGw9ZS5jdXJyZW50LmFsdGVybmF0ZSwwPT0oNjAmcikmJiFmdW5jdGlvbihlKXtmb3IodmFyIHQ9ZTs7KXtpZigxNjM4NCZ0LmZsYWdzKXt2YXIgbj10LnVwZGF0ZVF1ZXVlO2lmKG51bGwhPT1uJiZudWxsIT09KG49bi5zdG9yZXMpKWZvcih2YXIgcj0wO3I8bi5sZW5ndGg7cisrKXt2YXIgbD1uW3JdLGE9bC5nZXRTbmFwc2hvdDtsPWwudmFsdWU7dHJ5e2lmKCF0UChhKCksbCkpcmV0dXJuITF9Y2F0Y2goZSl7cmV0dXJuITF9fX1pZihuPXQuY2hpbGQsMTYzODQmdC5zdWJ0cmVlRmxhZ3MmJm51bGwhPT1uKW4ucmV0dXJuPXQsdD1uO2Vsc2V7aWYodD09PWUpYnJlYWs7Zm9yKDtudWxsPT09dC5zaWJsaW5nOyl7aWYobnVsbD09PXQucmV0dXJufHx0LnJldHVybj09PWUpcmV0dXJuITA7dD10LnJldHVybn10LnNpYmxpbmcucmV0dXJuPXQucmV0dXJuLHQ9dC5zaWJsaW5nfX1yZXR1cm4hMH0obCkpe2lmKDI9PT0odD1vVChlLHIpKSl7YT1yO3ZhciBvPWV1KGUsYSk7MCE9PW8mJihyPW8sdD1vdihlLGEsbykpfWlmKDE9PT10KXRocm93IG49YTYsb3goZSwwKSxvdyhlLHIpLG5YKGUpLG59ZS5maW5pc2hlZFdvcms9bCxlLmZpbmlzaGVkTGFuZXM9cjtlOntzd2l0Y2godCl7Y2FzZSAwOmNhc2UgMTp0aHJvdyBFcnJvcihpKDM0NSkpO2Nhc2UgNDppZigoODM4ODQ4MCZyKT09PXIpe293KGUscik7YnJlYWsgZX1icmVhaztjYXNlIDI6Y2FzZSAzOmNhc2UgNTpicmVhaztkZWZhdWx0OnRocm93IEVycm9yKGkoMzI5KSl9aWYoKDEyNTgyOTEyMCZyKT09PXImJjEwPCh0PW9uKzMwMC1IKCkpKXtpZihvdyhlLHIpLDAhPT1laShlLDApKWJyZWFrIGU7ZS50aW1lb3V0SGFuZGxlPXNiKG9rLmJpbmQobnVsbCxlLGwsb3Qsb2wsciksdCk7YnJlYWsgZX1vayhlLGwsb3Qsb2wscil9fX1yZXR1cm4gblgoZSksbjAoZSxIKCkpLGU9ZS5jYWxsYmFja05vZGU9PT1uP295LmJpbmQobnVsbCxlKTpudWxsfWZ1bmN0aW9uIG92KGUsdCxuKXt2YXIgcj1vZSxsPWUuY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZDtpZihsJiYob3goZSxuKS5mbGFnc3w9MjU2KSwyIT09KG49b1QoZSxuKSkpe2lmKGEzJiYhbClyZXR1cm4gZS5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lc3w9dCxhN3w9dCw0O2U9b3Qsb3Q9cixudWxsIT09ZSYmb2IoZSl9cmV0dXJuIG59ZnVuY3Rpb24gb2IoZSl7bnVsbD09PW90P290PWU6b3QucHVzaC5hcHBseShvdCxlKX1mdW5jdGlvbiBvayhlLHQsbixyLGwpe2lmKDA9PSg0MiZsKSYmKHNIPXtzdHlsZXNoZWV0czpudWxsLGNvdW50OjAsdW5zdXNwZW5kOnNxfSxhQih0KSxudWxsIT09KHQ9ZnVuY3Rpb24oKXtpZihudWxsPT09c0gpdGhyb3cgRXJyb3IoaSg0NzUpKTt2YXIgZT1zSDtyZXR1cm4gZS5zdHlsZXNoZWV0cyYmMD09PWUuY291bnQmJnNYKGUsZS5zdHlsZXNoZWV0cyksMDxlLmNvdW50P2Z1bmN0aW9uKHQpe3ZhciBuPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtpZihlLnN0eWxlc2hlZXRzJiZzWChlLGUuc3R5bGVzaGVldHMpLGUudW5zdXNwZW5kKXt2YXIgdD1lLnVuc3VzcGVuZDtlLnVuc3VzcGVuZD1udWxsLHQoKX19LDZlNCk7cmV0dXJuIGUudW5zdXNwZW5kPXQsZnVuY3Rpb24oKXtlLnVuc3VzcGVuZD1udWxsLGNsZWFyVGltZW91dChuKX19Om51bGx9KCkpKSl7ZS5jYW5jZWxQZW5kaW5nQ29tbWl0PXQob08uYmluZChudWxsLGUsbixyKSksb3coZSxsKTtyZXR1cm59b08oZSxuLHIpfWZ1bmN0aW9uIG93KGUsdCl7Zm9yKHQmPX5hOSx0Jj1+YTcsZS5zdXNwZW5kZWRMYW5lc3w9dCxlLnBpbmdlZExhbmVzJj1+dCxlPWUuZXhwaXJhdGlvblRpbWVzOzA8dDspe3ZhciBuPTMxLWV0KHQpLHI9MTw8bjtlW25dPS0xLHQmPX5yfX1mdW5jdGlvbiBvUyhlLHQpe3ZhciBuPWFHO2FHfD0xO3RyeXtyZXR1cm4gZSh0KX1maW5hbGx5ezA9PT0oYUc9bikmJihvcj1IKCkrNTAwLG5HKCEwKSl9fWZ1bmN0aW9uIG9FKGUpe251bGwhPT1vcyYmMD09PW9zLnRhZyYmMD09KDYmYUcpJiZvSSgpO3ZhciB0PWFHO2FHfD0xO3ZhciBuPWFYLnRyYW5zaXRpb24scj1laDt0cnl7aWYoYVgudHJhbnNpdGlvbj1udWxsLGVoPTIsZSlyZXR1cm4gZSgpfWZpbmFsbHl7ZWg9cixhWC50cmFuc2l0aW9uPW4sMD09KDYmKGFHPXQpKSYmbkcoITEpfX1mdW5jdGlvbiBvQygpe2lmKG51bGwhPT1hSil7aWYoMD09PWExKXZhciBlPWFKLnJldHVybjtlbHNlIGU9YUosbEYoKSxyZChlKSxuUz1udWxsLG5FPTAsZT1hSjtmb3IoO251bGwhPT1lOylsNihlLmFsdGVybmF0ZSxlKSxlPWUucmV0dXJuO2FKPW51bGx9fWZ1bmN0aW9uIG94KGUsdCl7ZS5maW5pc2hlZFdvcms9bnVsbCxlLmZpbmlzaGVkTGFuZXM9MDt2YXIgbj1lLnRpbWVvdXRIYW5kbGU7cmV0dXJuIC0xIT09biYmKGUudGltZW91dEhhbmRsZT0tMSxzayhuKSksbnVsbCE9PShuPWUuY2FuY2VsUGVuZGluZ0NvbW1pdCkmJihlLmNhbmNlbFBlbmRpbmdDb21taXQ9bnVsbCxuKCkpLG9DKCksYVo9ZSxhSj1lPW9ZKGUuY3VycmVudCxudWxsKSxhMD1hND10LGExPTAsYTI9bnVsbCxhMz0hMSxhOD0wLGE2PW51bGwsYTk9YTc9YTU9MCxvdD1vZT1udWxsLHQ3KCksZX1mdW5jdGlvbiBveihlLHQpe244PW51bGwsbjIuY3VycmVudD1yWCxhWS5jdXJyZW50PW51bGwsdD09PW5oPyh0PW53KCksYTE9b1AoKSYmMD09KDI2ODQzNTQ1NSZhNSkmJjA9PSgyNjg0MzU0NTUmYTcpPzI6Myk6dD09PW5tPyh0PW53KCksYTE9NCk6YTE9dD09PWxsPzg6bnVsbCE9PXQmJiJvYmplY3QiPT10eXBlb2YgdCYmImZ1bmN0aW9uIj09dHlwZW9mIHQudGhlbj82OjEsYTI9dCxudWxsPT09YUomJihhOD0xLGE2PXQpfWZ1bmN0aW9uIG9QKCl7aWYoKDgzODg0ODAmYTApPT09YTApcmV0dXJuIG51bGw9PT1uQTt2YXIgZT1uTy5jdXJyZW50O3JldHVybiBudWxsIT09ZSYmKCgxMjU4MjkxMjAmYTApPT09YTB8fDAhPSgxMDczNzQxODI0JmEwKSkmJmU9PT1uQX1mdW5jdGlvbiBvTigpe3ZhciBlPWFxLmN1cnJlbnQ7cmV0dXJuIGFxLmN1cnJlbnQ9clgsbnVsbD09PWU/clg6ZX1mdW5jdGlvbiBvXygpe3ZhciBlPWFLLmN1cnJlbnQ7cmV0dXJuIGFLLmN1cnJlbnQ9YWosZX1mdW5jdGlvbiBvTCgpe2E4PTQsbnVsbD09PWFafHwwPT0oMjY4NDM1NDU1JmE1KSYmMD09KDI2ODQzNTQ1NSZhNyl8fG93KGFaLGEwKX1mdW5jdGlvbiBvVChlLHQpe3ZhciBuPWFHO2FHfD0yO3ZhciByPW9OKCksbD1vXygpOyhhWiE9PWV8fGEwIT09dCkmJihvbD1udWxsLG94KGUsdCkpLHQ9ITE7ZTpmb3IoOzspdHJ5e2lmKDAhPT1hMSYmbnVsbCE9PWFKKXt2YXIgYT1hSixvPWEyO3N3aXRjaChhMSl7Y2FzZSA4Om9DKCksYTg9NjticmVhayBlO2Nhc2UgMzpjYXNlIDI6dHx8bnVsbCE9PW5PLmN1cnJlbnR8fCh0PSEwKTtkZWZhdWx0OmExPTAsYTI9bnVsbCxvRChhLG8pfX0hZnVuY3Rpb24oKXtmb3IoO251bGwhPT1hSjspb00oYUopfSgpO2JyZWFrfWNhdGNoKHQpe296KGUsdCl9aWYodCYmZS5zaGVsbFN1c3BlbmRDb3VudGVyKyssbEYoKSxhRz1uLGFxLmN1cnJlbnQ9cixhSy5jdXJyZW50PWwsbnVsbCE9PWFKKXRocm93IEVycm9yKGkoMjYxKSk7cmV0dXJuIGFaPW51bGwsYTA9MCx0NygpLGE4fWZ1bmN0aW9uIG9NKGUpe3ZhciB0PWltKGUuYWx0ZXJuYXRlLGUsYTQpO2UubWVtb2l6ZWRQcm9wcz1lLnBlbmRpbmdQcm9wcyxudWxsPT09dD9vUihlKTphSj10LGFZLmN1cnJlbnQ9bnVsbH1mdW5jdGlvbiBvRihlKXt2YXIgdD1lLmFsdGVybmF0ZTtzd2l0Y2goZS50YWcpe2Nhc2UgMjplLnRhZz0wO2Nhc2UgMTU6Y2FzZSAwOnZhciBuPWUudHlwZSxyPWUucGVuZGluZ1Byb3BzO3I9ZS5lbGVtZW50VHlwZT09PW4/cjpyMChuLHIpO3ZhciBsPXR3KG4pP3RiOnR5LmN1cnJlbnQ7bD10ayhlLGwpLHQ9bGgodCxlLHIsbixsLGEwKTticmVhaztjYXNlIDExOm49ZS50eXBlLnJlbmRlcixyPWUucGVuZGluZ1Byb3BzLHI9ZS5lbGVtZW50VHlwZT09PW4/cjpyMChuLHIpLHQ9bGgodCxlLHIsbixlLnJlZixhMCk7YnJlYWs7Y2FzZSA1OnJkKGUpO2RlZmF1bHQ6bDYodCxlKSxlPWFKPW9YKGUsYTQpLHQ9aW0odCxlLGE0KX1lLm1lbW9pemVkUHJvcHM9ZS5wZW5kaW5nUHJvcHMsbnVsbD09PXQ/b1IoZSk6YUo9dCxhWS5jdXJyZW50PW51bGx9ZnVuY3Rpb24gb0QoZSx0KXtsRigpLHJkKGUpLG5TPW51bGwsbkU9MDt2YXIgbj1lLnJldHVybjtpZihudWxsPT09bnx8bnVsbD09PWFaKWE4PTEsYTY9dCxhSj1udWxsO2Vsc2V7dHJ5e2U6e3ZhciByPWFaLGw9dDtpZih0PWEwLGUuZmxhZ3N8PTMyNzY4LG51bGwhPT1sJiYib2JqZWN0Ij09dHlwZW9mIGwmJiJmdW5jdGlvbiI9PXR5cGVvZiBsLnRoZW4pe3ZhciBhPWwsbz1lLnRhZztpZigwPT0oMSZlLm1vZGUpJiYoMD09PW98fDExPT09b3x8MTU9PT1vKSl7dmFyIHU9ZS5hbHRlcm5hdGU7dT8oZS51cGRhdGVRdWV1ZT11LnVwZGF0ZVF1ZXVlLGUubWVtb2l6ZWRTdGF0ZT11Lm1lbW9pemVkU3RhdGUsZS5sYW5lcz11LmxhbmVzKTooZS51cGRhdGVRdWV1ZT1udWxsLGUubWVtb2l6ZWRTdGF0ZT1udWxsKX12YXIgcz1uTy5jdXJyZW50O2lmKG51bGwhPT1zKXtzd2l0Y2gocy50YWcpe2Nhc2UgMTM6aWYoMSZlLm1vZGUmJihudWxsPT09bkE/b0woKTpudWxsPT09cy5hbHRlcm5hdGUmJjA9PT1hOCYmKGE4PTMpKSxzLmZsYWdzJj0tMjU3LGxuKHMsbixlLHIsdCksYT09PW5nKXMuZmxhZ3N8PTE2Mzg0O2Vsc2V7dmFyIGM9cy51cGRhdGVRdWV1ZTtudWxsPT09Yz9zLnVwZGF0ZVF1ZXVlPW5ldyBTZXQoW2FdKTpjLmFkZChhKX1icmVhaztjYXNlIDIyOmlmKDEmcy5tb2RlKXtpZihzLmZsYWdzfD02NTUzNixhPT09bmcpcy5mbGFnc3w9MTYzODQ7ZWxzZXt2YXIgZj1zLnVwZGF0ZVF1ZXVlO2lmKG51bGw9PT1mKXt2YXIgZD17dHJhbnNpdGlvbnM6bnVsbCxtYXJrZXJJbnN0YW5jZXM6bnVsbCxyZXRyeVF1ZXVlOm5ldyBTZXQoW2FdKX07cy51cGRhdGVRdWV1ZT1kfWVsc2V7dmFyIGg9Zi5yZXRyeVF1ZXVlO251bGw9PT1oP2YucmV0cnlRdWV1ZT1uZXcgU2V0KFthXSk6aC5hZGQoYSl9fWJyZWFrfWRlZmF1bHQ6dGhyb3cgRXJyb3IoaSg0MzUscy50YWcpKX0xJnMubW9kZSYmb1EocixhLHQpO2JyZWFrIGV9aWYoMT09PXIudGFnKXtvUShyLGEsdCksb0woKTticmVhayBlfWw9RXJyb3IoaSg0MjYpKX1lbHNlIGlmKHQkJiYxJmUubW9kZSYmKGE9bk8uY3VycmVudCxudWxsIT09YSkpezA9PSg2NTUzNiZhLmZsYWdzKSYmKGEuZmxhZ3N8PTI1NiksbG4oYSxuLGUscix0KSx0NChyNShsLGUpKTticmVhayBlfXI9bD1yNShsLGUpLDQhPT1hOCYmKGE4PTIpLG51bGw9PT1vZT9vZT1bcl06b2UucHVzaChyKSxyPW47ZG97c3dpdGNoKHIudGFnKXtjYXNlIDM6dmFyIG09bDtyLmZsYWdzfD02NTUzNix0Jj0tdCxyLmxhbmVzfD10O3ZhciBnPWxlKHIsbSx0KTtucyhyLGcpO2JyZWFrIGU7Y2FzZSAxOm89bDt2YXIgeT1yLnR5cGUsdj1yLnN0YXRlTm9kZTtpZigwPT0oMTI4JnIuZmxhZ3MpJiYoImZ1bmN0aW9uIj09dHlwZW9mIHkuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yfHxudWxsIT09diYmImZ1bmN0aW9uIj09dHlwZW9mIHYuY29tcG9uZW50RGlkQ2F0Y2gmJihudWxsPT09b2l8fCFvaS5oYXModikpKSl7ci5mbGFnc3w9NjU1MzYsZz10Ji10LHIubGFuZXN8PWcsbT1sdChyLG8sZyksbnMocixtKTticmVhayBlfX1yPXIucmV0dXJufXdoaWxlKG51bGwhPT1yKX19Y2F0Y2goZSl7dGhyb3cgYUo9bixlfWlmKDMyNzY4JmUuZmxhZ3MpZTp7ZG97aWYobnVsbCE9PShuPWZ1bmN0aW9uKGUsdCl7c3dpdGNoKHRCKHQpLHQudGFnKXtjYXNlIDE6cmV0dXJuIHR3KHQudHlwZSkmJnRTKCksNjU1MzYmKGU9dC5mbGFncyk/KHQuZmxhZ3M9LTY1NTM3JmV8MTI4LHQpOm51bGw7Y2FzZSAzOnJldHVybiBsUihsaiksVSgpLHAodHYpLHAodHkpLDAhPSg2NTUzNiYoZT10LmZsYWdzKSkmJjA9PSgxMjgmZSk/KHQuZmxhZ3M9LTY1NTM3JmV8MTI4LHQpOm51bGw7Y2FzZSAyNjpjYXNlIDI3OmNhc2UgNTpyZXR1cm4gUSh0KSxudWxsO2Nhc2UgMTM6aWYoblEodCksbnVsbCE9PShlPXQubWVtb2l6ZWRTdGF0ZSkmJm51bGwhPT1lLmRlaHlkcmF0ZWQpe2lmKG51bGw9PT10LmFsdGVybmF0ZSl0aHJvdyBFcnJvcihpKDM0MCkpO3QzKCl9cmV0dXJuIDY1NTM2JihlPXQuZmxhZ3MpPyh0LmZsYWdzPS02NTUzNyZlfDEyOCx0KTpudWxsO2Nhc2UgMTk6cmV0dXJuIHAoblYpLG51bGw7Y2FzZSA0OnJldHVybiBVKCksbnVsbDtjYXNlIDEwOnJldHVybiBsUih0LnR5cGUuX2NvbnRleHQpLG51bGw7Y2FzZSAyMjpjYXNlIDIzOnJldHVybiBuUSh0KSxuUigpLG51bGwhPT1lJiZwKGxZKSw2NTUzNiYoZT10LmZsYWdzKT8odC5mbGFncz0tNjU1MzcmZXwxMjgsdCk6bnVsbDtjYXNlIDI0OnJldHVybiBsUihsaiksbnVsbDtkZWZhdWx0OnJldHVybiBudWxsfX0oZS5hbHRlcm5hdGUsZSkpKXtuLmZsYWdzJj0zMjc2NyxhSj1uO2JyZWFrIGV9bnVsbCE9PShlPWUucmV0dXJuKSYmKGUuZmxhZ3N8PTMyNzY4LGUuc3VidHJlZUZsYWdzPTAsZS5kZWxldGlvbnM9bnVsbCksYUo9ZX13aGlsZShudWxsIT09ZSk7YTg9NixhSj1udWxsfWVsc2Ugb1IoZSl9fWZ1bmN0aW9uIG9SKGUpe3ZhciB0PWU7ZG97ZT10LnJldHVybjt2YXIgbj1mdW5jdGlvbihlLHQsbil7dmFyIHI9dC5wZW5kaW5nUHJvcHM7c3dpdGNoKHRCKHQpLHQudGFnKXtjYXNlIDI6Y2FzZSAxNjpjYXNlIDE1OmNhc2UgMDpjYXNlIDExOmNhc2UgNzpjYXNlIDg6Y2FzZSAxMjpjYXNlIDk6Y2FzZSAxNDpyZXR1cm4gbDgodCksbnVsbDtjYXNlIDE6Y2FzZSAxNzpyZXR1cm4gdHcodC50eXBlKSYmdFMoKSxsOCh0KSxudWxsO2Nhc2UgMzpyZXR1cm4gcj10LnN0YXRlTm9kZSxuPW51bGwsbnVsbCE9PWUmJihuPWUubWVtb2l6ZWRTdGF0ZS5jYWNoZSksdC5tZW1vaXplZFN0YXRlLmNhY2hlIT09biYmKHQuZmxhZ3N8PTIwNDgpLGxSKGxqKSxVKCkscCh0dikscCh0eSksci5wZW5kaW5nQ29udGV4dCYmKHIuY29udGV4dD1yLnBlbmRpbmdDb250ZXh0LHIucGVuZGluZ0NvbnRleHQ9bnVsbCksKG51bGw9PT1lfHxudWxsPT09ZS5jaGlsZCkmJih0MSh0KT9sSih0KTpudWxsPT09ZXx8ZS5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZCYmMD09KDI1NiZ0LmZsYWdzKXx8KHQuZmxhZ3N8PTEwMjQsbnVsbCE9PXRXJiYob2IodFcpLHRXPW51bGwpKSksbDgodCksbnVsbDtjYXNlIDI2Om49dC50eXBlO3ZhciBsPXQubWVtb2l6ZWRTdGF0ZTtpZihudWxsPT09ZSlsSih0KSxudWxsIT09dC5yZWYmJmwwKHQpLG51bGwhPT1sPyhsOCh0KSxsMih0LGwpKToobDgodCksdC5mbGFncyY9LTE2Nzc3MjE3KTtlbHNle3ZhciBhPWUubWVtb2l6ZWRTdGF0ZTtsIT09YSYmbEoodCksZS5yZWYhPT10LnJlZiYmbDAodCksbnVsbCE9PWw/KGw4KHQpLGw9PT1hP3QuZmxhZ3MmPS0xNjc3NzIxNzpsMih0LGwpKToobDEoZSx0LG4sciksbDgodCksdC5mbGFncyY9LTE2Nzc3MjE3KX1yZXR1cm4gbnVsbDtjYXNlIDI3OmlmKFEodCksbj1BLmN1cnJlbnQsbD10LnR5cGUsbnVsbCE9PWUmJm51bGwhPXQuc3RhdGVOb2RlKWwxKGUsdCxsLHIpLGUucmVmIT09dC5yZWYmJmwwKHQpO2Vsc2V7aWYoIXIpe2lmKG51bGw9PT10LnN0YXRlTm9kZSl0aHJvdyBFcnJvcihpKDE2NikpO3JldHVybiBsOCh0KSxudWxsfWU9Ui5jdXJyZW50LHQxKHQpP3RKKHQsZSk6KGU9c18obCxyLG4pLHQuc3RhdGVOb2RlPWUsbEoodCkpLG51bGwhPT10LnJlZiYmbDAodCl9cmV0dXJuIGw4KHQpLG51bGw7Y2FzZSA1OmlmKFEodCksbj10LnR5cGUsbnVsbCE9PWUmJm51bGwhPXQuc3RhdGVOb2RlKWwxKGUsdCxuLHIpLGUucmVmIT09dC5yZWYmJmwwKHQpO2Vsc2V7aWYoIXIpe2lmKG51bGw9PT10LnN0YXRlTm9kZSl0aHJvdyBFcnJvcihpKDE2NikpO3JldHVybiBsOCh0KSxudWxsfWlmKGU9Ui5jdXJyZW50LHQxKHQpKXRKKHQsZSkmJmxKKHQpO2Vsc2V7c3dpdGNoKGw9c20oQS5jdXJyZW50KSxlKXtjYXNlIDE6ZT1sLmNyZWF0ZUVsZW1lbnROUygiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLG4pO2JyZWFrO2Nhc2UgMjplPWwuY3JlYXRlRWxlbWVudE5TKCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MIixuKTticmVhaztkZWZhdWx0OnN3aXRjaChuKXtjYXNlInN2ZyI6ZT1sLmNyZWF0ZUVsZW1lbnROUygiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLG4pO2JyZWFrO2Nhc2UibWF0aCI6ZT1sLmNyZWF0ZUVsZW1lbnROUygiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCIsbik7YnJlYWs7Y2FzZSJzY3JpcHQiOihlPWwuY3JlYXRlRWxlbWVudCgiZGl2IikpLmlubmVySFRNTD0iPHNjcmlwdD48L3NjcmlwdD4iLGU9ZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpO2JyZWFrO2Nhc2Uic2VsZWN0IjplPSJzdHJpbmciPT10eXBlb2Ygci5pcz9sLmNyZWF0ZUVsZW1lbnQoInNlbGVjdCIse2lzOnIuaXN9KTpsLmNyZWF0ZUVsZW1lbnQoInNlbGVjdCIpLHIubXVsdGlwbGU/ZS5tdWx0aXBsZT0hMDpyLnNpemUmJihlLnNpemU9ci5zaXplKTticmVhaztkZWZhdWx0OmU9InN0cmluZyI9PXR5cGVvZiByLmlzP2wuY3JlYXRlRWxlbWVudChuLHtpczpyLmlzfSk6bC5jcmVhdGVFbGVtZW50KG4pfX1lW2V2XT10LGVbZWJdPXI7ZTpmb3IobD10LmNoaWxkO251bGwhPT1sOyl7aWYoNT09PWwudGFnfHw2PT09bC50YWcpZS5hcHBlbmRDaGlsZChsLnN0YXRlTm9kZSk7ZWxzZSBpZig0IT09bC50YWcmJjI3IT09bC50YWcmJm51bGwhPT1sLmNoaWxkKXtsLmNoaWxkLnJldHVybj1sLGw9bC5jaGlsZDtjb250aW51ZX1pZihsPT09dClicmVhaztmb3IoO251bGw9PT1sLnNpYmxpbmc7KXtpZihudWxsPT09bC5yZXR1cm58fGwucmV0dXJuPT09dClicmVhayBlO2w9bC5yZXR1cm59bC5zaWJsaW5nLnJldHVybj1sLnJldHVybixsPWwuc2libGluZ31zd2l0Y2godC5zdGF0ZU5vZGU9ZSxzZihlLG4sciksbil7Y2FzZSJidXR0b24iOmNhc2UiaW5wdXQiOmNhc2Uic2VsZWN0IjpjYXNlInRleHRhcmVhIjplPSEhci5hdXRvRm9jdXM7YnJlYWs7Y2FzZSJpbWciOmU9ITA7YnJlYWs7ZGVmYXVsdDplPSExfWUmJmxKKHQpfW51bGwhPT10LnJlZiYmbDAodCl9cmV0dXJuIGw4KHQpLHQuZmxhZ3MmPS0xNjc3NzIxNyxudWxsO2Nhc2UgNjppZihlJiZudWxsIT10LnN0YXRlTm9kZSllLm1lbW9pemVkUHJvcHMhPT1yJiZsSih0KTtlbHNle2lmKCJzdHJpbmciIT10eXBlb2YgciYmbnVsbD09PXQuc3RhdGVOb2RlKXRocm93IEVycm9yKGkoMTY2KSk7aWYoZT1BLmN1cnJlbnQsdDEodCkpe2U6e2lmKGU9dC5zdGF0ZU5vZGUscj10Lm1lbW9pemVkUHJvcHMsZVtldl09dCwobj1lLm5vZGVWYWx1ZSE9PXIpJiZudWxsIT09KGw9dFEpKXN3aXRjaChsLnRhZyl7Y2FzZSAzOmlmKGw9MCE9KDEmbC5tb2RlKSxzaShlLm5vZGVWYWx1ZSxyLGwpLGwpe2U9ITE7YnJlYWsgZX1icmVhaztjYXNlIDI3OmNhc2UgNTppZihhPTAhPSgxJmwubW9kZSksITAhPT1sLm1lbW9pemVkUHJvcHMuc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJiZzaShlLm5vZGVWYWx1ZSxyLGEpLGEpe2U9ITE7YnJlYWsgZX19ZT1ufWUmJmxKKHQpfWVsc2UoZT1zbShlKS5jcmVhdGVUZXh0Tm9kZShyKSlbZXZdPXQsdC5zdGF0ZU5vZGU9ZX1yZXR1cm4gbDgodCksbnVsbDtjYXNlIDEzOmlmKG5RKHQpLHI9dC5tZW1vaXplZFN0YXRlLG51bGw9PT1lfHxudWxsIT09ZS5tZW1vaXplZFN0YXRlJiZudWxsIT09ZS5tZW1vaXplZFN0YXRlLmRlaHlkcmF0ZWQpe2lmKHQkJiZudWxsIT09dFYmJjAhPSgxJnQubW9kZSkmJjA9PSgxMjgmdC5mbGFncykpdDIoKSx0MygpLHQuZmxhZ3N8PTM4NCxsPSExO2Vsc2UgaWYobD10MSh0KSxudWxsIT09ciYmbnVsbCE9PXIuZGVoeWRyYXRlZCl7aWYobnVsbD09PWUpe2lmKCFsKXRocm93IEVycm9yKGkoMzE4KSk7aWYoIShsPW51bGwhPT0obD10Lm1lbW9pemVkU3RhdGUpP2wuZGVoeWRyYXRlZDpudWxsKSl0aHJvdyBFcnJvcihpKDMxNykpO2xbZXZdPXR9ZWxzZSB0MygpLDA9PSgxMjgmdC5mbGFncykmJih0Lm1lbW9pemVkU3RhdGU9bnVsbCksdC5mbGFnc3w9NDtsOCh0KSxsPSExfWVsc2UgbnVsbCE9PXRXJiYob2IodFcpLHRXPW51bGwpLGw9ITA7aWYoIWwpcmV0dXJuIDI1NiZ0LmZsYWdzP3Q6bnVsbH1pZigwIT0oMTI4JnQuZmxhZ3MpKXJldHVybiB0LmxhbmVzPW4sdDtyZXR1cm4gcj1udWxsIT09cixlPW51bGwhPT1lJiZudWxsIT09ZS5tZW1vaXplZFN0YXRlLHImJihuPXQuY2hpbGQsbD1udWxsLG51bGwhPT1uLmFsdGVybmF0ZSYmbnVsbCE9PW4uYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUmJm51bGwhPT1uLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCYmKGw9bi5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCksYT1udWxsLG51bGwhPT1uLm1lbW9pemVkU3RhdGUmJm51bGwhPT1uLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sJiYoYT1uLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpLGEhPT1sJiYobi5mbGFnc3w9MjA0OCkpLHIhPT1lJiZyJiYodC5jaGlsZC5mbGFnc3w9ODE5MiksbDModCx0LnVwZGF0ZVF1ZXVlKSxsOCh0KSxudWxsO2Nhc2UgNDpyZXR1cm4gVSgpLG51bGw9PT1lJiZ1NSh0LnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxsOCh0KSxudWxsO2Nhc2UgMTA6cmV0dXJuIGxSKHQudHlwZS5fY29udGV4dCksbDgodCksbnVsbDtjYXNlIDE5OmlmKHAoblYpLG51bGw9PT0obD10Lm1lbW9pemVkU3RhdGUpKXJldHVybiBsOCh0KSxudWxsO2lmKHI9MCE9KDEyOCZ0LmZsYWdzKSxudWxsPT09KGE9bC5yZW5kZXJpbmcpKXtpZihyKWw0KGwsITEpO2Vsc2V7aWYoMCE9PWE4fHxudWxsIT09ZSYmMCE9KDEyOCZlLmZsYWdzKSlmb3IoZT10LmNoaWxkO251bGwhPT1lOyl7aWYobnVsbCE9PShhPW4kKGUpKSl7Zm9yKHQuZmxhZ3N8PTEyOCxsNChsLCExKSxlPWEudXBkYXRlUXVldWUsdC51cGRhdGVRdWV1ZT1lLGwzKHQsZSksdC5zdWJ0cmVlRmxhZ3M9MCxlPW4scj10LmNoaWxkO251bGwhPT1yOylvWChyLGUpLHI9ci5zaWJsaW5nO3JldHVybiBoKG5WLDEmblYuY3VycmVudHwyKSx0LmNoaWxkfWU9ZS5zaWJsaW5nfW51bGwhPT1sLnRhaWwmJkgoKT5vciYmKHQuZmxhZ3N8PTEyOCxyPSEwLGw0KGwsITEpLHQubGFuZXM9ODM4ODYwOCl9fWVsc2V7aWYoIXIpe2lmKG51bGwhPT0oZT1uJChhKSkpe2lmKHQuZmxhZ3N8PTEyOCxyPSEwLGU9ZS51cGRhdGVRdWV1ZSx0LnVwZGF0ZVF1ZXVlPWUsbDModCxlKSxsNChsLCEwKSxudWxsPT09bC50YWlsJiYiaGlkZGVuIj09PWwudGFpbE1vZGUmJiFhLmFsdGVybmF0ZSYmIXQkKXJldHVybiBsOCh0KSxudWxsfWVsc2UgMipIKCktbC5yZW5kZXJpbmdTdGFydFRpbWU+b3ImJjEwNzM3NDE4MjQhPT1uJiYodC5mbGFnc3w9MTI4LHI9ITAsbDQobCwhMSksdC5sYW5lcz04Mzg4NjA4KX1sLmlzQmFja3dhcmRzPyhhLnNpYmxpbmc9dC5jaGlsZCx0LmNoaWxkPWEpOihudWxsIT09KGU9bC5sYXN0KT9lLnNpYmxpbmc9YTp0LmNoaWxkPWEsbC5sYXN0PWEpfWlmKG51bGwhPT1sLnRhaWwpcmV0dXJuIHQ9bC50YWlsLGwucmVuZGVyaW5nPXQsbC50YWlsPXQuc2libGluZyxsLnJlbmRlcmluZ1N0YXJ0VGltZT1IKCksdC5zaWJsaW5nPW51bGwsZT1uVi5jdXJyZW50LGgoblYscj8xJmV8MjoxJmUpLHQ7cmV0dXJuIGw4KHQpLG51bGw7Y2FzZSAyMjpjYXNlIDIzOnJldHVybiBuUSh0KSxuUigpLHI9bnVsbCE9PXQubWVtb2l6ZWRTdGF0ZSxudWxsIT09ZT9udWxsIT09ZS5tZW1vaXplZFN0YXRlIT09ciYmKHQuZmxhZ3N8PTgxOTIpOnImJih0LmZsYWdzfD04MTkyKSxyJiYwIT0oMSZ0Lm1vZGUpPzAhPSgxMDczNzQxODI0Jm4pJiYwPT0oMTI4JnQuZmxhZ3MpJiYobDgodCksNiZ0LnN1YnRyZWVGbGFncyYmKHQuZmxhZ3N8PTgxOTIpKTpsOCh0KSxudWxsIT09KHI9dC51cGRhdGVRdWV1ZSkmJmwzKHQsci5yZXRyeVF1ZXVlKSxyPW51bGwsbnVsbCE9PWUmJm51bGwhPT1lLm1lbW9pemVkU3RhdGUmJm51bGwhPT1lLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sJiYocj1lLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpLG49bnVsbCxudWxsIT09dC5tZW1vaXplZFN0YXRlJiZudWxsIT09dC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCYmKG49dC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKSxuIT09ciYmKHQuZmxhZ3N8PTIwNDgpLG51bGwhPT1lJiZwKGxZKSxudWxsO2Nhc2UgMjQ6cmV0dXJuIHI9bnVsbCxudWxsIT09ZSYmKHI9ZS5tZW1vaXplZFN0YXRlLmNhY2hlKSx0Lm1lbW9pemVkU3RhdGUuY2FjaGUhPT1yJiYodC5mbGFnc3w9MjA0OCksbFIobGopLGw4KHQpLG51bGw7Y2FzZSAyNTpyZXR1cm4gbnVsbH10aHJvdyBFcnJvcihpKDE1Nix0LnRhZykpfSh0LmFsdGVybmF0ZSx0LGE0KTtpZihudWxsIT09bil7YUo9bjtyZXR1cm59aWYobnVsbCE9PSh0PXQuc2libGluZykpe2FKPXQ7cmV0dXJufWFKPXQ9ZX13aGlsZShudWxsIT09dCk7MD09PWE4JiYoYTg9NSl9ZnVuY3Rpb24gb08oZSx0LG4pe3ZhciByPWVoLGw9YVgudHJhbnNpdGlvbjt0cnl7YVgudHJhbnNpdGlvbj1udWxsLGVoPTIsZnVuY3Rpb24oZSx0LG4scil7ZG8gb0koKTt3aGlsZShudWxsIT09b3MpO2lmKDAhPSg2JmFHKSl0aHJvdyBFcnJvcihpKDMyNykpO3ZhciBsPWUuZmluaXNoZWRXb3JrLGE9ZS5maW5pc2hlZExhbmVzO2lmKG51bGwhPT1sKXtpZihlLmZpbmlzaGVkV29yaz1udWxsLGUuZmluaXNoZWRMYW5lcz0wLGw9PT1lLmN1cnJlbnQpdGhyb3cgRXJyb3IoaSgxNzcpKTtlLmNhbGxiYWNrTm9kZT1udWxsLGUuY2FsbGJhY2tQcmlvcml0eT0wLGUuY2FuY2VsUGVuZGluZ0NvbW1pdD1udWxsO3ZhciBvPWwubGFuZXN8bC5jaGlsZExhbmVzO2lmKGZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5wZW5kaW5nTGFuZXMmfnQ7ZS5wZW5kaW5nTGFuZXM9dCxlLnN1c3BlbmRlZExhbmVzPTAsZS5waW5nZWRMYW5lcz0wLGUuZXhwaXJlZExhbmVzJj10LGUuZW50YW5nbGVkTGFuZXMmPXQsZS5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyY9dCxlLnNoZWxsU3VzcGVuZENvdW50ZXI9MCx0PWUuZW50YW5nbGVtZW50czt2YXIgcj1lLmV4cGlyYXRpb25UaW1lcztmb3IoZT1lLmhpZGRlblVwZGF0ZXM7MDxuOyl7dmFyIGw9MzEtZXQobiksYT0xPDxsO3RbbF09MCxyW2xdPS0xO3ZhciBvPWVbbF07aWYobnVsbCE9PW8pZm9yKGVbbF09bnVsbCxsPTA7bDxvLmxlbmd0aDtsKyspe3ZhciBpPW9bbF07bnVsbCE9PWkmJihpLmxhbmUmPS0xMDczNzQxODI1KX1uJj1+YX19KGUsb3w9dDUpLGU9PT1hWiYmKGFKPWFaPW51bGwsYTA9MCksMD09KDEwMjU2Jmwuc3VidHJlZUZsYWdzKSYmMD09KDEwMjU2JmwuZmxhZ3MpfHxvdXx8KG91PSEwLG9mPW8sb2Q9bixWKFgsZnVuY3Rpb24oKXtyZXR1cm4gb0koKSxudWxsfSkpLG49MCE9KDE1OTkwJmwuZmxhZ3MpLDAhPSgxNTk5MCZsLnN1YnRyZWVGbGFncyl8fG4pe249YVgudHJhbnNpdGlvbixhWC50cmFuc2l0aW9uPW51bGw7dmFyIHU9ZWg7ZWg9Mjt2YXIgcz1hRzthR3w9NCxhWS5jdXJyZW50PW51bGwsZnVuY3Rpb24oZSx0KXtpZihzcD1pMyx1RihlPXVNKCkpKXtpZigic2VsZWN0aW9uU3RhcnQiaW4gZSl2YXIgbj17c3RhcnQ6ZS5zZWxlY3Rpb25TdGFydCxlbmQ6ZS5zZWxlY3Rpb25FbmR9O2Vsc2UgZTp7dmFyIHI9KG49KG49ZS5vd25lckRvY3VtZW50KSYmbi5kZWZhdWx0Vmlld3x8d2luZG93KS5nZXRTZWxlY3Rpb24mJm4uZ2V0U2VsZWN0aW9uKCk7aWYociYmMCE9PXIucmFuZ2VDb3VudCl7bj1yLmFuY2hvck5vZGU7dmFyIGwsYT1yLmFuY2hvck9mZnNldCxvPXIuZm9jdXNOb2RlO3I9ci5mb2N1c09mZnNldDt0cnl7bi5ub2RlVHlwZSxvLm5vZGVUeXBlfWNhdGNoKGUpe249bnVsbDticmVhayBlfXZhciB1PTAscz0tMSxjPS0xLGY9MCxkPTAscD1lLGg9bnVsbDt0OmZvcig7Oyl7Zm9yKDtwIT09bnx8MCE9PWEmJjMhPT1wLm5vZGVUeXBlfHwocz11K2EpLHAhPT1vfHwwIT09ciYmMyE9PXAubm9kZVR5cGV8fChjPXUrciksMz09PXAubm9kZVR5cGUmJih1Kz1wLm5vZGVWYWx1ZS5sZW5ndGgpLG51bGwhPT0obD1wLmZpcnN0Q2hpbGQpOyloPXAscD1sO2Zvcig7Oyl7aWYocD09PWUpYnJlYWsgdDtpZihoPT09biYmKytmPT09YSYmKHM9dSksaD09PW8mJisrZD09PXImJihjPXUpLG51bGwhPT0obD1wLm5leHRTaWJsaW5nKSlicmVhaztoPShwPWgpLnBhcmVudE5vZGV9cD1sfW49LTE9PT1zfHwtMT09PWM/bnVsbDp7c3RhcnQ6cyxlbmQ6Y319ZWxzZSBuPW51bGx9bj1ufHx7c3RhcnQ6MCxlbmQ6MH19ZWxzZSBuPW51bGw7Zm9yKHNoPXtmb2N1c2VkRWxlbTplLHNlbGVjdGlvblJhbmdlOm59LGkzPSExLGFpPXQ7bnVsbCE9PWFpOylpZihlPSh0PWFpKS5jaGlsZCwwIT0oMTAyOCZ0LnN1YnRyZWVGbGFncykmJm51bGwhPT1lKWUucmV0dXJuPXQsYWk9ZTtlbHNlIGZvcig7bnVsbCE9PWFpOyl7dD1haTt0cnl7dmFyIG09dC5hbHRlcm5hdGUsZz10LmZsYWdzO3N3aXRjaCh0LnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNTpjYXNlIDU6Y2FzZSAyNjpjYXNlIDI3OmNhc2UgNjpjYXNlIDQ6Y2FzZSAxNzpicmVhaztjYXNlIDE6aWYoMCE9KDEwMjQmZykmJm51bGwhPT1tKXt2YXIgeT1tLm1lbW9pemVkUHJvcHMsdj1tLm1lbW9pemVkU3RhdGUsYj10LnN0YXRlTm9kZSxrPWIuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUodC5lbGVtZW50VHlwZT09PXQudHlwZT95OnIwKHQudHlwZSx5KSx2KTtiLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlPWt9YnJlYWs7Y2FzZSAzOjAhPSgxMDI0JmcpJiZzeCh0LnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTticmVhaztkZWZhdWx0OmlmKDAhPSgxMDI0JmcpKXRocm93IEVycm9yKGkoMTYzKSl9fWNhdGNoKGUpe29CKHQsdC5yZXR1cm4sZSl9aWYobnVsbCE9PShlPXQuc2libGluZykpe2UucmV0dXJuPXQucmV0dXJuLGFpPWU7YnJlYWt9YWk9dC5yZXR1cm59bT1hZixhZj0hMX0oZSxsKSxhXyhsLGUpLGZ1bmN0aW9uKGUpe3ZhciB0PXVNKCksbj1lLmZvY3VzZWRFbGVtLHI9ZS5zZWxlY3Rpb25SYW5nZTtpZih0IT09biYmbiYmbi5vd25lckRvY3VtZW50JiZmdW5jdGlvbiBlKHQsbil7cmV0dXJuISF0JiYhIW4mJih0PT09bnx8KCF0fHwzIT09dC5ub2RlVHlwZSkmJihuJiYzPT09bi5ub2RlVHlwZT9lKHQsbi5wYXJlbnROb2RlKToiY29udGFpbnMiaW4gdD90LmNvbnRhaW5zKG4pOiEhdC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiYmISEoMTYmdC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihuKSkpKX0obi5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxuKSl7aWYobnVsbCE9PXImJnVGKG4pKXtpZih0PXIuc3RhcnQsdm9pZCAwPT09KGU9ci5lbmQpJiYoZT10KSwic2VsZWN0aW9uU3RhcnQiaW4gbiluLnNlbGVjdGlvblN0YXJ0PXQsbi5zZWxlY3Rpb25FbmQ9TWF0aC5taW4oZSxuLnZhbHVlLmxlbmd0aCk7ZWxzZSBpZigoZT0odD1uLm93bmVyRG9jdW1lbnR8fGRvY3VtZW50KSYmdC5kZWZhdWx0Vmlld3x8d2luZG93KS5nZXRTZWxlY3Rpb24pe2U9ZS5nZXRTZWxlY3Rpb24oKTt2YXIgbD1uLnRleHRDb250ZW50Lmxlbmd0aCxhPU1hdGgubWluKHIuc3RhcnQsbCk7cj12b2lkIDA9PT1yLmVuZD9hOk1hdGgubWluKHIuZW5kLGwpLCFlLmV4dGVuZCYmYT5yJiYobD1yLHI9YSxhPWwpLGw9dVQobixhKTt2YXIgbz11VChuLHIpO2wmJm8mJigxIT09ZS5yYW5nZUNvdW50fHxlLmFuY2hvck5vZGUhPT1sLm5vZGV8fGUuYW5jaG9yT2Zmc2V0IT09bC5vZmZzZXR8fGUuZm9jdXNOb2RlIT09by5ub2RlfHxlLmZvY3VzT2Zmc2V0IT09by5vZmZzZXQpJiYoKHQ9dC5jcmVhdGVSYW5nZSgpKS5zZXRTdGFydChsLm5vZGUsbC5vZmZzZXQpLGUucmVtb3ZlQWxsUmFuZ2VzKCksYT5yPyhlLmFkZFJhbmdlKHQpLGUuZXh0ZW5kKG8ubm9kZSxvLm9mZnNldCkpOih0LnNldEVuZChvLm5vZGUsby5vZmZzZXQpLGUuYWRkUmFuZ2UodCkpKX19Zm9yKHQ9W10sZT1uO2U9ZS5wYXJlbnROb2RlOykxPT09ZS5ub2RlVHlwZSYmdC5wdXNoKHtlbGVtZW50OmUsbGVmdDplLnNjcm9sbExlZnQsdG9wOmUuc2Nyb2xsVG9wfSk7Zm9yKCJmdW5jdGlvbiI9PXR5cGVvZiBuLmZvY3VzJiZuLmZvY3VzKCksbj0wO248dC5sZW5ndGg7bisrKShlPXRbbl0pLmVsZW1lbnQuc2Nyb2xsTGVmdD1lLmxlZnQsZS5lbGVtZW50LnNjcm9sbFRvcD1lLnRvcH19KHNoKSxpMz0hIXNwLHNoPXNwPW51bGwsZS5jdXJyZW50PWwsYXkoZSxsLmFsdGVybmF0ZSxsKSxqKCksYUc9cyxlaD11LGFYLnRyYW5zaXRpb249bn1lbHNlIGUuY3VycmVudD1sO2lmKG91PyhvdT0hMSxvcz1lLG9jPWEpOm9BKGUsbyksMD09PShvPWUucGVuZGluZ0xhbmVzKSYmKG9pPW51bGwpLGZ1bmN0aW9uKGUpe2lmKGVlJiYiZnVuY3Rpb24iPT10eXBlb2YgZWUub25Db21taXRGaWJlclJvb3QpdHJ5e2VlLm9uQ29tbWl0RmliZXJSb290KEosZSx2b2lkIDAsMTI4PT0oMTI4JmUuY3VycmVudC5mbGFncykpfWNhdGNoKGUpe319KGwuc3RhdGVOb2RlLHIpLG5YKGUpLG51bGwhPT10KWZvcihyPWUub25SZWNvdmVyYWJsZUVycm9yLGw9MDtsPHQubGVuZ3RoO2wrKylvPXtkaWdlc3Q6KGE9dFtsXSkuZGlnZXN0LGNvbXBvbmVudFN0YWNrOmEuc3RhY2t9LHIoYS52YWx1ZSxvKTtpZihvYSl0aHJvdyBvYT0hMSxlPW9vLG9vPW51bGwsZTswIT0oMyZvYykmJjAhPT1lLnRhZyYmb0koKSwwIT0oMyYobz1lLnBlbmRpbmdMYW5lcykpP2U9PT1vaD9vcCsrOihvcD0wLG9oPWUpOm9wPTAsbkcoITEpfX0oZSx0LG4scil9ZmluYWxseXthWC50cmFuc2l0aW9uPWwsZWg9cn1yZXR1cm4gbnVsbH1mdW5jdGlvbiBvQShlLHQpezA9PShlLnBvb2xlZENhY2hlTGFuZXMmPXQpJiZudWxsIT0odD1lLnBvb2xlZENhY2hlKSYmKGUucG9vbGVkQ2FjaGU9bnVsbCxscSh0KSl9ZnVuY3Rpb24gb0koKXtpZihudWxsIT09b3Mpe3ZhciBlPW9zLHQ9b2Y7b2Y9MDt2YXIgbj1lbShvYykscj0zMj5uPzMyOm47bj1hWC50cmFuc2l0aW9uO3ZhciBsPWVoO3RyeXtpZihhWC50cmFuc2l0aW9uPW51bGwsZWg9cixudWxsPT09b3MpdmFyIGE9ITE7ZWxzZXtyPW9kLG9kPW51bGw7dmFyIG89b3MsdT1vYztpZihvcz1udWxsLG9jPTAsMCE9KDYmYUcpKXRocm93IEVycm9yKGkoMzMxKSk7dmFyIHM9YUc7aWYoYUd8PTQsYSQoby5jdXJyZW50KSxhTyhvLG8uY3VycmVudCx1LHIpLGFHPXMsbkcoITEpLGVlJiYiZnVuY3Rpb24iPT10eXBlb2YgZWUub25Qb3N0Q29tbWl0RmliZXJSb290KXRyeXtlZS5vblBvc3RDb21taXRGaWJlclJvb3QoSixvKX1jYXRjaChlKXt9YT0hMH1yZXR1cm4gYX1maW5hbGx5e2VoPWwsYVgudHJhbnNpdGlvbj1uLG9BKGUsdCl9fXJldHVybiExfWZ1bmN0aW9uIG9VKGUsdCxuKXt0PXI1KG4sdCksdD1sZShlLHQsMiksbnVsbCE9PShlPW5pKGUsdCwyKSkmJihlZChlLDIpLG5YKGUpKX1mdW5jdGlvbiBvQihlLHQsbil7aWYoMz09PWUudGFnKW9VKGUsZSxuKTtlbHNlIGZvcig7bnVsbCE9PXQ7KXtpZigzPT09dC50YWcpe29VKHQsZSxuKTticmVha31pZigxPT09dC50YWcpe3ZhciByPXQuc3RhdGVOb2RlO2lmKCJmdW5jdGlvbiI9PXR5cGVvZiB0LnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yfHwiZnVuY3Rpb24iPT10eXBlb2Ygci5jb21wb25lbnREaWRDYXRjaCYmKG51bGw9PT1vaXx8IW9pLmhhcyhyKSkpe2U9cjUobixlKSxlPWx0KHQsZSwyKSxudWxsIT09KHQ9bmkodCxlLDIpKSYmKGVkKHQsMiksblgodCkpO2JyZWFrfX10PXQucmV0dXJufX1mdW5jdGlvbiBvUShlLHQsbil7dmFyIHI9ZS5waW5nQ2FjaGU7aWYobnVsbD09PXIpe3I9ZS5waW5nQ2FjaGU9bmV3IGFIO3ZhciBsPW5ldyBTZXQ7ci5zZXQodCxsKX1lbHNlIHZvaWQgMD09PShsPXIuZ2V0KHQpKSYmKGw9bmV3IFNldCxyLnNldCh0LGwpKTtsLmhhcyhuKXx8KGEzPSEwLGwuYWRkKG4pLGU9b1YuYmluZChudWxsLGUsdCxuKSx0LnRoZW4oZSxlKSl9ZnVuY3Rpb24gb1YoZSx0LG4pe3ZhciByPWUucGluZ0NhY2hlO251bGwhPT1yJiZyLmRlbGV0ZSh0KSxlLnBpbmdlZExhbmVzfD1lLnN1c3BlbmRlZExhbmVzJm4sYVo9PT1lJiYoYTAmbik9PT1uJiYoND09PWE4fHwzPT09YTgmJigxMjU4MjkxMjAmYTApPT09YTAmJjMwMD5IKCktb24/MD09KDImYUcpJiZveChlLDApOmE5fD1uKSxuWChlKX1mdW5jdGlvbiBvJChlLHQpezA9PT10JiYodD0wPT0oMSZlLm1vZGUpPzI6ZWMoKSksbnVsbCE9PShlPW5lKGUsdCkpJiYoZWQoZSx0KSxuWChlKSl9ZnVuY3Rpb24gb1coZSl7dmFyIHQ9ZS5tZW1vaXplZFN0YXRlLG49MDtudWxsIT09dCYmKG49dC5yZXRyeUxhbmUpLG8kKGUsbil9ZnVuY3Rpb24gb2ooZSx0KXt2YXIgbj0wO3N3aXRjaChlLnRhZyl7Y2FzZSAxMzp2YXIgcj1lLnN0YXRlTm9kZSxsPWUubWVtb2l6ZWRTdGF0ZTtudWxsIT09bCYmKG49bC5yZXRyeUxhbmUpO2JyZWFrO2Nhc2UgMTk6cj1lLnN0YXRlTm9kZTticmVhaztjYXNlIDIyOnI9ZS5zdGF0ZU5vZGUuX3JldHJ5Q2FjaGU7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihpKDMxNCkpfW51bGwhPT1yJiZyLmRlbGV0ZSh0KSxvJChlLG4pfWZ1bmN0aW9uIG9IKGUsdCxuLHIpe3RoaXMudGFnPWUsdGhpcy5rZXk9bix0aGlzLnNpYmxpbmc9dGhpcy5jaGlsZD10aGlzLnJldHVybj10aGlzLnN0YXRlTm9kZT10aGlzLnR5cGU9dGhpcy5lbGVtZW50VHlwZT1udWxsLHRoaXMuaW5kZXg9MCx0aGlzLnJlZkNsZWFudXA9dGhpcy5yZWY9bnVsbCx0aGlzLnBlbmRpbmdQcm9wcz10LHRoaXMuZGVwZW5kZW5jaWVzPXRoaXMubWVtb2l6ZWRTdGF0ZT10aGlzLnVwZGF0ZVF1ZXVlPXRoaXMubWVtb2l6ZWRQcm9wcz1udWxsLHRoaXMubW9kZT1yLHRoaXMuc3VidHJlZUZsYWdzPXRoaXMuZmxhZ3M9MCx0aGlzLmRlbGV0aW9ucz1udWxsLHRoaXMuY2hpbGRMYW5lcz10aGlzLmxhbmVzPTAsdGhpcy5hbHRlcm5hdGU9bnVsbH1mdW5jdGlvbiBvcShlLHQsbixyKXtyZXR1cm4gbmV3IG9IKGUsdCxuLHIpfWZ1bmN0aW9uIG9LKGUpe3JldHVybiEoIShlPWUucHJvdG90eXBlKXx8IWUuaXNSZWFjdENvbXBvbmVudCl9ZnVuY3Rpb24gb1koZSx0KXt2YXIgbj1lLmFsdGVybmF0ZTtyZXR1cm4gbnVsbD09PW4/KChuPW9xKGUudGFnLHQsZS5rZXksZS5tb2RlKSkuZWxlbWVudFR5cGU9ZS5lbGVtZW50VHlwZSxuLnR5cGU9ZS50eXBlLG4uc3RhdGVOb2RlPWUuc3RhdGVOb2RlLG4uYWx0ZXJuYXRlPWUsZS5hbHRlcm5hdGU9bik6KG4ucGVuZGluZ1Byb3BzPXQsbi50eXBlPWUudHlwZSxuLmZsYWdzPTAsbi5zdWJ0cmVlRmxhZ3M9MCxuLmRlbGV0aW9ucz1udWxsKSxuLmZsYWdzPTMxNDU3MjgwJmUuZmxhZ3Msbi5jaGlsZExhbmVzPWUuY2hpbGRMYW5lcyxuLmxhbmVzPWUubGFuZXMsbi5jaGlsZD1lLmNoaWxkLG4ubWVtb2l6ZWRQcm9wcz1lLm1lbW9pemVkUHJvcHMsbi5tZW1vaXplZFN0YXRlPWUubWVtb2l6ZWRTdGF0ZSxuLnVwZGF0ZVF1ZXVlPWUudXBkYXRlUXVldWUsdD1lLmRlcGVuZGVuY2llcyxuLmRlcGVuZGVuY2llcz1udWxsPT09dD9udWxsOntsYW5lczp0LmxhbmVzLGZpcnN0Q29udGV4dDp0LmZpcnN0Q29udGV4dH0sbi5zaWJsaW5nPWUuc2libGluZyxuLmluZGV4PWUuaW5kZXgsbi5yZWY9ZS5yZWYsbi5yZWZDbGVhbnVwPWUucmVmQ2xlYW51cCxufWZ1bmN0aW9uIG9YKGUsdCl7ZS5mbGFncyY9MzE0NTcyODI7dmFyIG49ZS5hbHRlcm5hdGU7cmV0dXJuIG51bGw9PT1uPyhlLmNoaWxkTGFuZXM9MCxlLmxhbmVzPXQsZS5jaGlsZD1udWxsLGUuc3VidHJlZUZsYWdzPTAsZS5tZW1vaXplZFByb3BzPW51bGwsZS5tZW1vaXplZFN0YXRlPW51bGwsZS51cGRhdGVRdWV1ZT1udWxsLGUuZGVwZW5kZW5jaWVzPW51bGwsZS5zdGF0ZU5vZGU9bnVsbCk6KGUuY2hpbGRMYW5lcz1uLmNoaWxkTGFuZXMsZS5sYW5lcz1uLmxhbmVzLGUuY2hpbGQ9bi5jaGlsZCxlLnN1YnRyZWVGbGFncz0wLGUuZGVsZXRpb25zPW51bGwsZS5tZW1vaXplZFByb3BzPW4ubWVtb2l6ZWRQcm9wcyxlLm1lbW9pemVkU3RhdGU9bi5tZW1vaXplZFN0YXRlLGUudXBkYXRlUXVldWU9bi51cGRhdGVRdWV1ZSxlLnR5cGU9bi50eXBlLHQ9bi5kZXBlbmRlbmNpZXMsZS5kZXBlbmRlbmNpZXM9bnVsbD09PXQ/bnVsbDp7bGFuZXM6dC5sYW5lcyxmaXJzdENvbnRleHQ6dC5maXJzdENvbnRleHR9KSxlfWZ1bmN0aW9uIG9HKGUsdCxuLHIsbCxhKXt2YXIgbz0yO2lmKHI9ZSwiZnVuY3Rpb24iPT10eXBlb2YgZSlvSyhlKSYmKG89MSk7ZWxzZSBpZigic3RyaW5nIj09dHlwZW9mIGUpbz0hZnVuY3Rpb24oZSx0LG4pe2lmKDE9PT1ufHxudWxsIT10Lml0ZW1Qcm9wKXJldHVybiExO3N3aXRjaChlKXtjYXNlIm1ldGEiOmNhc2UidGl0bGUiOnJldHVybiEwO2Nhc2Uic3R5bGUiOmlmKCJzdHJpbmciIT10eXBlb2YgdC5wcmVjZWRlbmNlfHwic3RyaW5nIiE9dHlwZW9mIHQuaHJlZnx8IiI9PT10LmhyZWYpYnJlYWs7cmV0dXJuITA7Y2FzZSJsaW5rIjppZigic3RyaW5nIiE9dHlwZW9mIHQucmVsfHwic3RyaW5nIiE9dHlwZW9mIHQuaHJlZnx8IiI9PT10LmhyZWZ8fHQub25Mb2FkfHx0Lm9uRXJyb3IpYnJlYWs7aWYoInN0eWxlc2hlZXQiPT09dC5yZWwpcmV0dXJuIGU9dC5kaXNhYmxlZCwic3RyaW5nIj09dHlwZW9mIHQucHJlY2VkZW5jZSYmbnVsbD09ZTtyZXR1cm4hMDtjYXNlInNjcmlwdCI6aWYoITA9PT10LmFzeW5jJiYhdC5vbkxvYWQmJiF0Lm9uRXJyb3ImJiJzdHJpbmciPT10eXBlb2YgdC5zcmMmJnQuc3JjKXJldHVybiEwfXJldHVybiExfShlLG4sUi5jdXJyZW50KT8iaHRtbCI9PT1lfHwiaGVhZCI9PT1lfHwiYm9keSI9PT1lPzI3OjU6MjY7ZWxzZSBlOnN3aXRjaChlKXtjYXNlIHk6cmV0dXJuIG9aKG4uY2hpbGRyZW4sbCxhLHQpO2Nhc2UgdjpvPTgsMCE9KDEmKGx8PTgpKSYmKGx8PTE2KTticmVhaztjYXNlIGI6cmV0dXJuKGU9b3EoMTIsbix0LDJ8bCkpLmVsZW1lbnRUeXBlPWIsZS5sYW5lcz1hLGU7Y2FzZSBDOnJldHVybihlPW9xKDEzLG4sdCxsKSkuZWxlbWVudFR5cGU9QyxlLmxhbmVzPWEsZTtjYXNlIHg6cmV0dXJuKGU9b3EoMTksbix0LGwpKS5lbGVtZW50VHlwZT14LGUubGFuZXM9YSxlO2Nhc2UgXzpyZXR1cm4gb0oobixsLGEsdCk7Y2FzZSBMOmNhc2UgTjpjYXNlIFQ6cmV0dXJuKGU9b3EoMjQsbix0LGwpKS5lbGVtZW50VHlwZT1ULGUubGFuZXM9YSxlO2RlZmF1bHQ6aWYoIm9iamVjdCI9PXR5cGVvZiBlJiZudWxsIT09ZSlzd2l0Y2goZS4kJHR5cGVvZil7Y2FzZSBrOm89MTA7YnJlYWsgZTtjYXNlIHc6bz05O2JyZWFrIGU7Y2FzZSBFOm89MTE7YnJlYWsgZTtjYXNlIHo6bz0xNDticmVhayBlO2Nhc2UgUDpvPTE2LHI9bnVsbDticmVhayBlfXRocm93IEVycm9yKGkoMTMwLG51bGw9PWU/ZTp0eXBlb2YgZSwiIikpfXJldHVybih0PW9xKG8sbix0LGwpKS5lbGVtZW50VHlwZT1lLHQudHlwZT1yLHQubGFuZXM9YSx0fWZ1bmN0aW9uIG9aKGUsdCxuLHIpe3JldHVybihlPW9xKDcsZSxyLHQpKS5sYW5lcz1uLGV9ZnVuY3Rpb24gb0ooZSx0LG4scil7KGU9b3EoMjIsZSxyLHQpKS5lbGVtZW50VHlwZT1fLGUubGFuZXM9bjt2YXIgbD17X3Zpc2liaWxpdHk6MSxfcGVuZGluZ1Zpc2liaWxpdHk6MSxfcGVuZGluZ01hcmtlcnM6bnVsbCxfcmV0cnlDYWNoZTpudWxsLF90cmFuc2l0aW9uczpudWxsLF9jdXJyZW50Om51bGwsZGV0YWNoOmZ1bmN0aW9uKCl7dmFyIGU9bC5fY3VycmVudDtpZihudWxsPT09ZSl0aHJvdyBFcnJvcihpKDQ1NikpO2lmKDA9PSgyJmwuX3BlbmRpbmdWaXNpYmlsaXR5KSl7dmFyIHQ9bmUoZSwyKTtudWxsIT09dCYmKGwuX3BlbmRpbmdWaXNpYmlsaXR5fD0yLG9nKHQsZSwyKSl9fSxhdHRhY2g6ZnVuY3Rpb24oKXt2YXIgZT1sLl9jdXJyZW50O2lmKG51bGw9PT1lKXRocm93IEVycm9yKGkoNDU2KSk7aWYoMCE9KDImbC5fcGVuZGluZ1Zpc2liaWxpdHkpKXt2YXIgdD1uZShlLDIpO251bGwhPT10JiYobC5fcGVuZGluZ1Zpc2liaWxpdHkmPS0zLG9nKHQsZSwyKSl9fX07cmV0dXJuIGUuc3RhdGVOb2RlPWwsZX1mdW5jdGlvbiBvMChlLHQsbil7cmV0dXJuKGU9b3EoNixlLG51bGwsdCkpLmxhbmVzPW4sZX1mdW5jdGlvbiBvMShlLHQsbil7cmV0dXJuKHQ9b3EoNCxudWxsIT09ZS5jaGlsZHJlbj9lLmNoaWxkcmVuOltdLGUua2V5LHQpKS5sYW5lcz1uLHQuc3RhdGVOb2RlPXtjb250YWluZXJJbmZvOmUuY29udGFpbmVySW5mbyxwZW5kaW5nQ2hpbGRyZW46bnVsbCxpbXBsZW1lbnRhdGlvbjplLmltcGxlbWVudGF0aW9ufSx0fWZ1bmN0aW9uIG8yKGUsdCxuLHIsbCl7dGhpcy50YWc9dCx0aGlzLmNvbnRhaW5lckluZm89ZSx0aGlzLmZpbmlzaGVkV29yaz10aGlzLnBpbmdDYWNoZT10aGlzLmN1cnJlbnQ9dGhpcy5wZW5kaW5nQ2hpbGRyZW49bnVsbCx0aGlzLnRpbWVvdXRIYW5kbGU9LTEsdGhpcy5jYWxsYmFja05vZGU9dGhpcy5uZXh0PXRoaXMucGVuZGluZ0NvbnRleHQ9dGhpcy5jb250ZXh0PXRoaXMuY2FuY2VsUGVuZGluZ0NvbW1pdD1udWxsLHRoaXMuY2FsbGJhY2tQcmlvcml0eT0wLHRoaXMuZXhwaXJhdGlvblRpbWVzPWVmKC0xKSx0aGlzLmVudGFuZ2xlZExhbmVzPXRoaXMuc2hlbGxTdXNwZW5kQ291bnRlcj10aGlzLmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzPXRoaXMuZmluaXNoZWRMYW5lcz10aGlzLmV4cGlyZWRMYW5lcz10aGlzLnBpbmdlZExhbmVzPXRoaXMuc3VzcGVuZGVkTGFuZXM9dGhpcy5wZW5kaW5nTGFuZXM9MCx0aGlzLmVudGFuZ2xlbWVudHM9ZWYoMCksdGhpcy5oaWRkZW5VcGRhdGVzPWVmKG51bGwpLHRoaXMuaWRlbnRpZmllclByZWZpeD1yLHRoaXMub25SZWNvdmVyYWJsZUVycm9yPWwsdGhpcy5wb29sZWRDYWNoZT1udWxsLHRoaXMucG9vbGVkQ2FjaGVMYW5lcz0wLHRoaXMuaW5jb21wbGV0ZVRyYW5zaXRpb25zPW5ldyBNYXB9ZnVuY3Rpb24gbzMoZSx0LG4scixsLGEsbyxpLHUpe3JldHVybiBlPW5ldyBvMihlLHQsbixpLHUpLDE9PT10Pyh0PTEsITA9PT1hJiYodHw9MjQpKTp0PTAsYT1vcSgzLG51bGwsbnVsbCx0KSxlLmN1cnJlbnQ9YSxhLnN0YXRlTm9kZT1lLHQ9bEgoKSx0LnJlZkNvdW50KyssZS5wb29sZWRDYWNoZT10LHQucmVmQ291bnQrKyxhLm1lbW9pemVkU3RhdGU9e2VsZW1lbnQ6cixpc0RlaHlkcmF0ZWQ6bixjYWNoZTp0fSxubChhKSxlfWZ1bmN0aW9uIG80KGUpe2lmKCFlKXJldHVybiB0ZztlPWUuX3JlYWN0SW50ZXJuYWxzO2U6e2lmKHRkKGUpIT09ZXx8MSE9PWUudGFnKXRocm93IEVycm9yKGkoMTcwKSk7dmFyIHQ9ZTtkb3tzd2l0Y2godC50YWcpe2Nhc2UgMzp0PXQuc3RhdGVOb2RlLmNvbnRleHQ7YnJlYWsgZTtjYXNlIDE6aWYodHcodC50eXBlKSl7dD10LnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDticmVhayBlfX10PXQucmV0dXJufXdoaWxlKG51bGwhPT10KTt0aHJvdyBFcnJvcihpKDE3MSkpfWlmKDE9PT1lLnRhZyl7dmFyIG49ZS50eXBlO2lmKHR3KG4pKXJldHVybiB0QyhlLG4sdCl9cmV0dXJuIHR9ZnVuY3Rpb24gbzgoZSx0LG4scixsLGEsbyxpLHUpe3JldHVybihlPW8zKG4sciwhMCxlLGwsYSxvLGksdSkpLmNvbnRleHQ9bzQobnVsbCksKGw9bm8ocj1vbShuPWUuY3VycmVudCkpKS5jYWxsYmFjaz1udWxsIT10P3Q6bnVsbCxuaShuLGwsciksZS5jdXJyZW50LmxhbmVzPXIsZWQoZSxyKSxuWChlKSxlfWZ1bmN0aW9uIG82KGUsdCxuLHIpe3ZhciBsPXQuY3VycmVudCxhPW9tKGwpO3JldHVybiBuPW80KG4pLG51bGw9PT10LmNvbnRleHQ/dC5jb250ZXh0PW46dC5wZW5kaW5nQ29udGV4dD1uLCh0PW5vKGEpKS5wYXlsb2FkPXtlbGVtZW50OmV9LG51bGwhPT0ocj12b2lkIDA9PT1yP251bGw6cikmJih0LmNhbGxiYWNrPXIpLG51bGwhPT0oZT1uaShsLHQsYSkpJiYob2coZSxsLGEpLG51KGUsbCxhKSksYX1mdW5jdGlvbiBvNShlKXtyZXR1cm4oZT1lLmN1cnJlbnQpLmNoaWxkPyhlLmNoaWxkLnRhZyxlLmNoaWxkLnN0YXRlTm9kZSk6bnVsbH1mdW5jdGlvbiBvNyhlLHQpe2lmKG51bGwhPT0oZT1lLm1lbW9pemVkU3RhdGUpJiZudWxsIT09ZS5kZWh5ZHJhdGVkKXt2YXIgbj1lLnJldHJ5TGFuZTtlLnJldHJ5TGFuZT0wIT09biYmbjx0P246dH19ZnVuY3Rpb24gbzkoZSx0KXtvNyhlLHQpLChlPWUuYWx0ZXJuYXRlKSYmbzcoZSx0KX1mdW5jdGlvbiBpZShlKXtpZigxMz09PWUudGFnKXt2YXIgdD1uZShlLDEzNDIxNzcyOCk7bnVsbCE9PXQmJm9nKHQsZSwxMzQyMTc3MjgpLG85KGUsMTM0MjE3NzI4KX19aW09ZnVuY3Rpb24oZSx0LG4pe2lmKG51bGwhPT1lKXtpZihlLm1lbW9pemVkUHJvcHMhPT10LnBlbmRpbmdQcm9wc3x8dHYuY3VycmVudClsYT0hMDtlbHNle2lmKDA9PShlLmxhbmVzJm4pJiYwPT0oMTI4JnQuZmxhZ3MpKXJldHVybiBsYT0hMSxmdW5jdGlvbihlLHQsbil7c3dpdGNoKHQudGFnKXtjYXNlIDM6bHkodCksbEQodCxsaixlLm1lbW9pemVkU3RhdGUuY2FjaGUpLHQzKCk7YnJlYWs7Y2FzZSAyNzpjYXNlIDU6Qih0KTticmVhaztjYXNlIDE6dHcodC50eXBlKSYmdHgodCk7YnJlYWs7Y2FzZSA0OkkodCx0LnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTticmVhaztjYXNlIDEwOmxEKHQsdC50eXBlLl9jb250ZXh0LHQubWVtb2l6ZWRQcm9wcy52YWx1ZSk7YnJlYWs7Y2FzZSAxMzp2YXIgcj10Lm1lbW9pemVkU3RhdGU7aWYobnVsbCE9PXIpe2lmKG51bGwhPT1yLmRlaHlkcmF0ZWQpcmV0dXJuIG5JKHQpLHQuZmxhZ3N8PTEyOCxudWxsO2lmKDAhPShuJnQuY2hpbGQuY2hpbGRMYW5lcykpcmV0dXJuIGx3KGUsdCxuKTtyZXR1cm4gbkkodCksbnVsbCE9PShlPWxOKGUsdCxuKSk/ZS5zaWJsaW5nOm51bGx9bkkodCk7YnJlYWs7Y2FzZSAxOTppZihyPTAhPShuJnQuY2hpbGRMYW5lcyksMCE9KDEyOCZlLmZsYWdzKSl7aWYocilyZXR1cm4gbHooZSx0LG4pO3QuZmxhZ3N8PTEyOH12YXIgbD10Lm1lbW9pemVkU3RhdGU7aWYobnVsbCE9PWwmJihsLnJlbmRlcmluZz1udWxsLGwudGFpbD1udWxsLGwubGFzdEVmZmVjdD1udWxsKSxoKG5WLG5WLmN1cnJlbnQpLCFyKXJldHVybiBudWxsO2JyZWFrO2Nhc2UgMjI6Y2FzZSAyMzpyZXR1cm4gdC5sYW5lcz0wLGxjKGUsdCxuKTtjYXNlIDI0OmxEKHQsbGosZS5tZW1vaXplZFN0YXRlLmNhY2hlKX1yZXR1cm4gbE4oZSx0LG4pfShlLHQsbik7bGE9MCE9KDEzMTA3MiZlLmZsYWdzKX19ZWxzZSBsYT0hMSx0JCYmMCE9KDEwNDg1NzYmdC5mbGFncykmJnRJKHQsdFQsdC5pbmRleCk7c3dpdGNoKHQubGFuZXM9MCx0LnRhZyl7Y2FzZSAyOnZhciByPXQudHlwZTtsUChlLHQpLGU9dC5wZW5kaW5nUHJvcHM7dmFyIGw9dGsodCx0eS5jdXJyZW50KTtsSSh0LG4pLGw9cmkobnVsbCx0LHIsZSxsLG4pO3ZhciBhPXJjKCk7cmV0dXJuIHQuZmxhZ3N8PTEsIm9iamVjdCI9PXR5cGVvZiBsJiZudWxsIT09bCYmImZ1bmN0aW9uIj09dHlwZW9mIGwucmVuZGVyJiZ2b2lkIDA9PT1sLiQkdHlwZW9mPyh0LnRhZz0xLHQubWVtb2l6ZWRTdGF0ZT1udWxsLHQudXBkYXRlUXVldWU9bnVsbCx0dyhyKT8oYT0hMCx0eCh0KSk6YT0hMSx0Lm1lbW9pemVkU3RhdGU9bnVsbCE9PWwuc3RhdGUmJnZvaWQgMCE9PWwuc3RhdGU/bC5zdGF0ZTpudWxsLG5sKHQpLGwudXBkYXRlcj1yMix0LnN0YXRlTm9kZT1sLGwuX3JlYWN0SW50ZXJuYWxzPXQscjYodCxyLGUsbiksdD1sZyhudWxsLHQsciwhMCxhLG4pKToodC50YWc9MCx0JCYmYSYmdFUodCksbG8obnVsbCx0LGwsbiksdD10LmNoaWxkKSx0O2Nhc2UgMTY6cj10LmVsZW1lbnRUeXBlO2U6e3N3aXRjaChsUChlLHQpLGU9dC5wZW5kaW5nUHJvcHMscj0obD1yLl9pbml0KShyLl9wYXlsb2FkKSx0LnR5cGU9cixsPXQudGFnPWZ1bmN0aW9uKGUpe2lmKCJmdW5jdGlvbiI9PXR5cGVvZiBlKXJldHVybiBvSyhlKT8xOjA7aWYobnVsbCE9ZSl7aWYoKGU9ZS4kJHR5cGVvZik9PT1FKXJldHVybiAxMTtpZihlPT09eilyZXR1cm4gMTR9cmV0dXJuIDJ9KHIpLGU9cjAocixlKSxsKXtjYXNlIDA6dD1scChudWxsLHQscixlLG4pO2JyZWFrIGU7Y2FzZSAxOnQ9bG0obnVsbCx0LHIsZSxuKTticmVhayBlO2Nhc2UgMTE6dD1saShudWxsLHQscixlLG4pO2JyZWFrIGU7Y2FzZSAxNDp0PWx1KG51bGwsdCxyLHIwKHIudHlwZSxlKSxuKTticmVhayBlfXRocm93IEVycm9yKGkoMzA2LHIsIiIpKX1yZXR1cm4gdDtjYXNlIDA6cmV0dXJuIHI9dC50eXBlLGw9dC5wZW5kaW5nUHJvcHMsbD10LmVsZW1lbnRUeXBlPT09cj9sOnIwKHIsbCksbHAoZSx0LHIsbCxuKTtjYXNlIDE6cmV0dXJuIHI9dC50eXBlLGw9dC5wZW5kaW5nUHJvcHMsbD10LmVsZW1lbnRUeXBlPT09cj9sOnIwKHIsbCksbG0oZSx0LHIsbCxuKTtjYXNlIDM6ZTp7aWYobHkodCksbnVsbD09PWUpdGhyb3cgRXJyb3IoaSgzODcpKTtsPXQucGVuZGluZ1Byb3BzLHI9KGE9dC5tZW1vaXplZFN0YXRlKS5lbGVtZW50LG5hKGUsdCksbmModCxsLG51bGwsbik7dmFyIG89dC5tZW1vaXplZFN0YXRlO2lmKGxEKHQsbGosbD1vLmNhY2hlKSxsIT09YS5jYWNoZSYmbEEodCxsaixuKSxsPW8uZWxlbWVudCxhLmlzRGVoeWRyYXRlZCl7aWYoYT17ZWxlbWVudDpsLGlzRGVoeWRyYXRlZDohMSxjYWNoZTpvLmNhY2hlfSx0LnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZT1hLHQubWVtb2l6ZWRTdGF0ZT1hLDI1NiZ0LmZsYWdzKXtyPXI1KEVycm9yKGkoNDIzKSksdCksdD1sdihlLHQsbCxuLHIpO2JyZWFrIGV9aWYobCE9PXIpe3I9cjUoRXJyb3IoaSg0MjQpKSx0KSx0PWx2KGUsdCxsLG4scik7YnJlYWsgZX1mb3IodFY9c1AodC5zdGF0ZU5vZGUuY29udGFpbmVySW5mby5maXJzdENoaWxkKSx0UT10LHQkPSEwLHRXPW51bGwsdGo9ITAsbj1uTCh0LG51bGwsbCxuKSx0LmNoaWxkPW47bjspbi5mbGFncz0tMyZuLmZsYWdzfDQwOTYsbj1uLnNpYmxpbmd9ZWxzZXtpZih0MygpLGw9PT1yKXt0PWxOKGUsdCxuKTticmVhayBlfWxvKGUsdCxsLG4pfXQ9dC5jaGlsZH1yZXR1cm4gdDtjYXNlIDI2OnJldHVybiBsZChlLHQpLG49dC5tZW1vaXplZFN0YXRlPWZ1bmN0aW9uKGUsdCxuKXtpZighKHQ9KHQ9QS5jdXJyZW50KT9zTSh0KTpudWxsKSl0aHJvdyBFcnJvcihpKDQ0NikpO3N3aXRjaChlKXtjYXNlIm1ldGEiOmNhc2UidGl0bGUiOnJldHVybiBudWxsO2Nhc2Uic3R5bGUiOnJldHVybiJzdHJpbmciPT10eXBlb2Ygbi5wcmVjZWRlbmNlJiYic3RyaW5nIj09dHlwZW9mIG4uaHJlZj8obj1zUihuLmhyZWYpLChlPSh0PWVUKHQpLmhvaXN0YWJsZVN0eWxlcykuZ2V0KG4pKXx8KGU9e3R5cGU6InN0eWxlIixpbnN0YW5jZTpudWxsLGNvdW50OjAsc3RhdGU6bnVsbH0sdC5zZXQobixlKSksZSk6e3R5cGU6InZvaWQiLGluc3RhbmNlOm51bGwsY291bnQ6MCxzdGF0ZTpudWxsfTtjYXNlImxpbmsiOmlmKCJzdHlsZXNoZWV0Ij09PW4ucmVsJiYic3RyaW5nIj09dHlwZW9mIG4uaHJlZiYmInN0cmluZyI9PXR5cGVvZiBuLnByZWNlZGVuY2Upe2U9c1Iobi5ocmVmKTt2YXIgcixsLGEsbyx1PWVUKHQpLmhvaXN0YWJsZVN0eWxlcyxzPXUuZ2V0KGUpO3JldHVybiBzfHwodD10Lm93bmVyRG9jdW1lbnR8fHQscz17dHlwZToic3R5bGVzaGVldCIsaW5zdGFuY2U6bnVsbCxjb3VudDowLHN0YXRlOntsb2FkaW5nOjAscHJlbG9hZDpudWxsfX0sdS5zZXQoZSxzKSxzTC5oYXMoZSl8fChyPXQsbD1lLGE9e3JlbDoicHJlbG9hZCIsYXM6InN0eWxlIixocmVmOm4uaHJlZixjcm9zc09yaWdpbjpuLmNyb3NzT3JpZ2luLGludGVncml0eTpuLmludGVncml0eSxtZWRpYTpuLm1lZGlhLGhyZWZMYW5nOm4uaHJlZkxhbmcscmVmZXJyZXJQb2xpY3k6bi5yZWZlcnJlclBvbGljeX0sbz1zLnN0YXRlLHNMLnNldChsLGEpLHIucXVlcnlTZWxlY3RvcihzTyhsKSl8fChyLnF1ZXJ5U2VsZWN0b3IoJ2xpbmtbcmVsPSJwcmVsb2FkIl1bYXM9InN0eWxlIl1bJytsKyJdIik/by5sb2FkaW5nPTE6KGw9ci5jcmVhdGVFbGVtZW50KCJsaW5rIiksby5wcmVsb2FkPWwsbC5hZGRFdmVudExpc3RlbmVyKCJsb2FkIixmdW5jdGlvbigpe3JldHVybiBvLmxvYWRpbmd8PTF9KSxsLmFkZEV2ZW50TGlzdGVuZXIoImVycm9yIixmdW5jdGlvbigpe3JldHVybiBvLmxvYWRpbmd8PTJ9KSxzZihsLCJsaW5rIixhKSxlTShsKSxyLmhlYWQuYXBwZW5kQ2hpbGQobCkpKSkpLHN9cmV0dXJuIG51bGw7Y2FzZSJzY3JpcHQiOnJldHVybiJzdHJpbmciPT10eXBlb2Ygbi5zcmMmJiEwPT09bi5hc3luYz8obj1zSShuLnNyYyksKGU9KHQ9ZVQodCkuaG9pc3RhYmxlU2NyaXB0cykuZ2V0KG4pKXx8KGU9e3R5cGU6InNjcmlwdCIsaW5zdGFuY2U6bnVsbCxjb3VudDowLHN0YXRlOm51bGx9LHQuc2V0KG4sZSkpLGUpOnt0eXBlOiJ2b2lkIixpbnN0YW5jZTpudWxsLGNvdW50OjAsc3RhdGU6bnVsbH07ZGVmYXVsdDp0aHJvdyBFcnJvcihpKDQ0NCxlKSl9fSh0LnR5cGUsbnVsbD09PWU/bnVsbDplLm1lbW9pemVkUHJvcHMsdC5wZW5kaW5nUHJvcHMpLG51bGwhPT1lfHx0JHx8bnVsbCE9PW58fChuPXQudHlwZSxlPXQucGVuZGluZ1Byb3BzLChyPXNtKEEuY3VycmVudCkuY3JlYXRlRWxlbWVudChuKSlbZXZdPXQscltlYl09ZSxzZihyLG4sZSksZU0ociksdC5zdGF0ZU5vZGU9ciksbnVsbDtjYXNlIDI3OnJldHVybiBCKHQpLG51bGw9PT1lJiZ0JCYmKHI9dC5zdGF0ZU5vZGU9c18odC50eXBlLHQucGVuZGluZ1Byb3BzLEEuY3VycmVudCksdFE9dCx0aj0hMCx0Vj1zUChyLmZpcnN0Q2hpbGQpKSxyPXQucGVuZGluZ1Byb3BzLmNoaWxkcmVuLG51bGwhPT1lfHx0JD9sbyhlLHQscixuKTp0LmNoaWxkPW5fKHQsbnVsbCxyLG4pLGxkKGUsdCksdC5jaGlsZDtjYXNlIDU6cmV0dXJuIEIodCksbnVsbD09PWUmJnQkJiYoKGw9cj10Vik/dEsodCxsKXx8KHRHKHQpJiZ0WigpLHRWPXNQKGwubmV4dFNpYmxpbmcpLGE9dFEsdFYmJnRLKHQsdFYpP3RIKGEsbCk6KHRxKHRRLHQpLHQkPSExLHRRPXQsdFY9cikpOih0Ryh0KSYmdFooKSx0cSh0USx0KSx0JD0hMSx0UT10LHRWPXIpKSxyPXQudHlwZSxsPXQucGVuZGluZ1Byb3BzLGE9bnVsbCE9PWU/ZS5tZW1vaXplZFByb3BzOm51bGwsbz1sLmNoaWxkcmVuLHN2KHIsbCk/bz1udWxsOm51bGwhPT1hJiZzdihyLGEpJiYodC5mbGFnc3w9MzIpLGxkKGUsdCksbG8oZSx0LG8sbiksdC5jaGlsZDtjYXNlIDY6cmV0dXJuIG51bGw9PT1lJiZ0JCYmKChyPSIiIT09dC5wZW5kaW5nUHJvcHMsKGU9bj10VikmJnIpP3RZKHQsZSl8fCh0Ryh0KSYmdFooKSx0Vj1zUChlLm5leHRTaWJsaW5nKSxyPXRRLHRWJiZ0WSh0LHRWKT90SChyLGUpOih0cSh0USx0KSx0JD0hMSx0UT10LHRWPW4pKToodEcodCkmJnRaKCksdHEodFEsdCksdCQ9ITEsdFE9dCx0Vj1uKSksbnVsbDtjYXNlIDEzOnJldHVybiBsdyhlLHQsbik7Y2FzZSA0OnJldHVybiBJKHQsdC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbykscj10LnBlbmRpbmdQcm9wcyxudWxsPT09ZT90LmNoaWxkPW5fKHQsbnVsbCxyLG4pOmxvKGUsdCxyLG4pLHQuY2hpbGQ7Y2FzZSAxMTpyZXR1cm4gcj10LnR5cGUsbD10LnBlbmRpbmdQcm9wcyxsPXQuZWxlbWVudFR5cGU9PT1yP2w6cjAocixsKSxsaShlLHQscixsLG4pO2Nhc2UgNzpyZXR1cm4gbG8oZSx0LHQucGVuZGluZ1Byb3BzLG4pLHQuY2hpbGQ7Y2FzZSA4OmNhc2UgMTI6cmV0dXJuIGxvKGUsdCx0LnBlbmRpbmdQcm9wcy5jaGlsZHJlbixuKSx0LmNoaWxkO2Nhc2UgMTA6ZTp7aWYocj10LnR5cGUuX2NvbnRleHQsbD10LnBlbmRpbmdQcm9wcyxhPXQubWVtb2l6ZWRQcm9wcyxvPWwudmFsdWUsbEQodCxyLG8pLG51bGwhPT1hKXtpZih0UChhLnZhbHVlLG8pKXtpZihhLmNoaWxkcmVuPT09bC5jaGlsZHJlbiYmIXR2LmN1cnJlbnQpe3Q9bE4oZSx0LG4pO2JyZWFrIGV9fWVsc2UgbEEodCxyLG4pfWxvKGUsdCxsLmNoaWxkcmVuLG4pLHQ9dC5jaGlsZH1yZXR1cm4gdDtjYXNlIDk6cmV0dXJuIGw9dC50eXBlLHI9dC5wZW5kaW5nUHJvcHMuY2hpbGRyZW4sbEkodCxuKSxsPWxVKGwpLHI9cihsKSx0LmZsYWdzfD0xLGxvKGUsdCxyLG4pLHQuY2hpbGQ7Y2FzZSAxNDpyZXR1cm4gbD1yMChyPXQudHlwZSx0LnBlbmRpbmdQcm9wcyksbD1yMChyLnR5cGUsbCksbHUoZSx0LHIsbCxuKTtjYXNlIDE1OnJldHVybiBscyhlLHQsdC50eXBlLHQucGVuZGluZ1Byb3BzLG4pO2Nhc2UgMTc6cmV0dXJuIHI9dC50eXBlLGw9dC5wZW5kaW5nUHJvcHMsbD10LmVsZW1lbnRUeXBlPT09cj9sOnIwKHIsbCksbFAoZSx0KSx0LnRhZz0xLHR3KHIpPyhlPSEwLHR4KHQpKTplPSExLGxJKHQsbikscjQodCxyLGwpLHI2KHQscixsLG4pLGxnKG51bGwsdCxyLCEwLGUsbik7Y2FzZSAxOTpyZXR1cm4gbHooZSx0LG4pO2Nhc2UgMjI6cmV0dXJuIGxjKGUsdCxuKTtjYXNlIDI0OnJldHVybiBsSSh0LG4pLHI9bFUobGopLG51bGw9PT1lPyhudWxsPT09KGw9bFgoKSkmJihsPWFaLGE9bEgoKSxsLnBvb2xlZENhY2hlPWEsYS5yZWZDb3VudCsrLG51bGwhPT1hJiYobC5wb29sZWRDYWNoZUxhbmVzfD1uKSxsPWEpLHQubWVtb2l6ZWRTdGF0ZT17cGFyZW50OnIsY2FjaGU6bH0sbmwodCksbEQodCxsaixsKSk6KDAhPShlLmxhbmVzJm4pJiYobmEoZSx0KSxuYyh0LG51bGwsbnVsbCxuKSksbD1lLm1lbW9pemVkU3RhdGUsYT10Lm1lbW9pemVkU3RhdGUsbC5wYXJlbnQhPT1yPyhsPXtwYXJlbnQ6cixjYWNoZTpyfSx0Lm1lbW9pemVkU3RhdGU9bCwwPT09dC5sYW5lcyYmKHQubWVtb2l6ZWRTdGF0ZT10LnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZT1sKSxsRCh0LGxqLHIpKToocj1hLmNhY2hlLGxEKHQsbGosciksciE9PWwuY2FjaGUmJmxBKHQsbGosbikpKSxsbyhlLHQsdC5wZW5kaW5nUHJvcHMuY2hpbGRyZW4sbiksdC5jaGlsZH10aHJvdyBFcnJvcihpKDE1Nix0LnRhZykpfTt2YXIgaXQ9ITE7ZnVuY3Rpb24gaXIoZSx0LG4pe2lmKGl0KXJldHVybiBlKHQsbik7aXQ9ITA7dHJ5e3JldHVybiBvUyhlLHQsbil9ZmluYWxseXtpdD0hMSwobnVsbCE9PXRpfHxudWxsIT09dHUpJiYob0UoKSx0ZigpKX19ZnVuY3Rpb24gaWwoZSx0KXt2YXIgbj1lLnN0YXRlTm9kZTtpZihudWxsPT09bilyZXR1cm4gbnVsbDt2YXIgcj1lTChuKTtpZihudWxsPT09cilyZXR1cm4gbnVsbDtzd2l0Y2gobj1yW3RdLHQpe2Nhc2Uib25DbGljayI6Y2FzZSJvbkNsaWNrQ2FwdHVyZSI6Y2FzZSJvbkRvdWJsZUNsaWNrIjpjYXNlIm9uRG91YmxlQ2xpY2tDYXB0dXJlIjpjYXNlIm9uTW91c2VEb3duIjpjYXNlIm9uTW91c2VEb3duQ2FwdHVyZSI6Y2FzZSJvbk1vdXNlTW92ZSI6Y2FzZSJvbk1vdXNlTW92ZUNhcHR1cmUiOmNhc2Uib25Nb3VzZVVwIjpjYXNlIm9uTW91c2VVcENhcHR1cmUiOmNhc2Uib25Nb3VzZUVudGVyIjoocj0hci5kaXNhYmxlZCl8fChyPSEoImJ1dHRvbiI9PT0oZT1lLnR5cGUpfHwiaW5wdXQiPT09ZXx8InNlbGVjdCI9PT1lfHwidGV4dGFyZWEiPT09ZSkpLGU9IXI7YnJlYWs7ZGVmYXVsdDplPSExfWlmKGUpcmV0dXJuIG51bGw7aWYobiYmImZ1bmN0aW9uIiE9dHlwZW9mIG4pdGhyb3cgRXJyb3IoaSgyMzEsdCx0eXBlb2YgbikpO3JldHVybiBufXZhciBpYT0hMTtpZihlQSl0cnl7dmFyIGlvPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShpbywicGFzc2l2ZSIse2dldDpmdW5jdGlvbigpe2lhPSEwfX0pLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCJ0ZXN0Iixpbyxpbyksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoInRlc3QiLGlvLGlvKX1jYXRjaChlKXtpYT0hMX1mdW5jdGlvbiBpaShlKXt2YXIgdD1lLmtleUNvZGU7cmV0dXJuImNoYXJDb2RlImluIGU/MD09PShlPWUuY2hhckNvZGUpJiYxMz09PXQmJihlPTEzKTplPXQsMTA9PT1lJiYoZT0xMyksMzI8PWV8fDEzPT09ZT9lOjB9ZnVuY3Rpb24gaXUoKXtyZXR1cm4hMH1mdW5jdGlvbiBpcygpe3JldHVybiExfWZ1bmN0aW9uIGljKGUpe2Z1bmN0aW9uIHQodCxuLHIsbCxhKXtmb3IodmFyIG8gaW4gdGhpcy5fcmVhY3ROYW1lPXQsdGhpcy5fdGFyZ2V0SW5zdD1yLHRoaXMudHlwZT1uLHRoaXMubmF0aXZlRXZlbnQ9bCx0aGlzLnRhcmdldD1hLHRoaXMuY3VycmVudFRhcmdldD1udWxsLGUpZS5oYXNPd25Qcm9wZXJ0eShvKSYmKHQ9ZVtvXSx0aGlzW29dPXQ/dChsKTpsW29dKTtyZXR1cm4gdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9KG51bGwhPWwuZGVmYXVsdFByZXZlbnRlZD9sLmRlZmF1bHRQcmV2ZW50ZWQ6ITE9PT1sLnJldHVyblZhbHVlKT9pdTppcyx0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPWlzLHRoaXN9cmV0dXJuIHUodC5wcm90b3R5cGUse3ByZXZlbnREZWZhdWx0OmZ1bmN0aW9uKCl7dGhpcy5kZWZhdWx0UHJldmVudGVkPSEwO3ZhciBlPXRoaXMubmF0aXZlRXZlbnQ7ZSYmKGUucHJldmVudERlZmF1bHQ/ZS5wcmV2ZW50RGVmYXVsdCgpOiJ1bmtub3duIiE9dHlwZW9mIGUucmV0dXJuVmFsdWUmJihlLnJldHVyblZhbHVlPSExKSx0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD1pdSl9LHN0b3BQcm9wYWdhdGlvbjpmdW5jdGlvbigpe3ZhciBlPXRoaXMubmF0aXZlRXZlbnQ7ZSYmKGUuc3RvcFByb3BhZ2F0aW9uP2Uuc3RvcFByb3BhZ2F0aW9uKCk6InVua25vd24iIT10eXBlb2YgZS5jYW5jZWxCdWJibGUmJihlLmNhbmNlbEJ1YmJsZT0hMCksdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1pdSl9LHBlcnNpc3Q6ZnVuY3Rpb24oKXt9LGlzUGVyc2lzdGVudDppdX0pLHR9dmFyIGlkLGlwLGloLGltLGlnLGl5LGl2LGliPXtldmVudFBoYXNlOjAsYnViYmxlczowLGNhbmNlbGFibGU6MCx0aW1lU3RhbXA6ZnVuY3Rpb24oZSl7cmV0dXJuIGUudGltZVN0YW1wfHxEYXRlLm5vdygpfSxkZWZhdWx0UHJldmVudGVkOjAsaXNUcnVzdGVkOjB9LGlrPWljKGliKSxpdz11KHt9LGliLHt2aWV3OjAsZGV0YWlsOjB9KSxpUz1pYyhpdyksaUU9dSh7fSxpdyx7c2NyZWVuWDowLHNjcmVlblk6MCxjbGllbnRYOjAsY2xpZW50WTowLHBhZ2VYOjAscGFnZVk6MCxjdHJsS2V5OjAsc2hpZnRLZXk6MCxhbHRLZXk6MCxtZXRhS2V5OjAsZ2V0TW9kaWZpZXJTdGF0ZTppRCxidXR0b246MCxidXR0b25zOjAscmVsYXRlZFRhcmdldDpmdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwPT09ZS5yZWxhdGVkVGFyZ2V0P2UuZnJvbUVsZW1lbnQ9PT1lLnNyY0VsZW1lbnQ/ZS50b0VsZW1lbnQ6ZS5mcm9tRWxlbWVudDplLnJlbGF0ZWRUYXJnZXR9LG1vdmVtZW50WDpmdW5jdGlvbihlKXtyZXR1cm4ibW92ZW1lbnRYImluIGU/ZS5tb3ZlbWVudFg6KGUhPT1pdiYmKGl2JiYibW91c2Vtb3ZlIj09PWUudHlwZT8oaWc9ZS5zY3JlZW5YLWl2LnNjcmVlblgsaXk9ZS5zY3JlZW5ZLWl2LnNjcmVlblkpOml5PWlnPTAsaXY9ZSksaWcpfSxtb3ZlbWVudFk6ZnVuY3Rpb24oZSl7cmV0dXJuIm1vdmVtZW50WSJpbiBlP2UubW92ZW1lbnRZOml5fX0pLGlDPWljKGlFKSxpeD1pYyh1KHt9LGlFLHtkYXRhVHJhbnNmZXI6MH0pKSxpej1pYyh1KHt9LGl3LHtyZWxhdGVkVGFyZ2V0OjB9KSksaVA9aWModSh7fSxpYix7YW5pbWF0aW9uTmFtZTowLGVsYXBzZWRUaW1lOjAscHNldWRvRWxlbWVudDowfSkpLGlOPWljKHUoe30saWIse2NsaXBib2FyZERhdGE6ZnVuY3Rpb24oZSl7cmV0dXJuImNsaXBib2FyZERhdGEiaW4gZT9lLmNsaXBib2FyZERhdGE6d2luZG93LmNsaXBib2FyZERhdGF9fSkpLGlfPWljKHUoe30saWIse2RhdGE6MH0pKSxpTD17RXNjOiJFc2NhcGUiLFNwYWNlYmFyOiIgIixMZWZ0OiJBcnJvd0xlZnQiLFVwOiJBcnJvd1VwIixSaWdodDoiQXJyb3dSaWdodCIsRG93bjoiQXJyb3dEb3duIixEZWw6IkRlbGV0ZSIsV2luOiJPUyIsTWVudToiQ29udGV4dE1lbnUiLEFwcHM6IkNvbnRleHRNZW51IixTY3JvbGw6IlNjcm9sbExvY2siLE1velByaW50YWJsZUtleToiVW5pZGVudGlmaWVkIn0saVQ9ezg6IkJhY2tzcGFjZSIsOToiVGFiIiwxMjoiQ2xlYXIiLDEzOiJFbnRlciIsMTY6IlNoaWZ0IiwxNzoiQ29udHJvbCIsMTg6IkFsdCIsMTk6IlBhdXNlIiwyMDoiQ2Fwc0xvY2siLDI3OiJFc2NhcGUiLDMyOiIgIiwzMzoiUGFnZVVwIiwzNDoiUGFnZURvd24iLDM1OiJFbmQiLDM2OiJIb21lIiwzNzoiQXJyb3dMZWZ0IiwzODoiQXJyb3dVcCIsMzk6IkFycm93UmlnaHQiLDQwOiJBcnJvd0Rvd24iLDQ1OiJJbnNlcnQiLDQ2OiJEZWxldGUiLDExMjoiRjEiLDExMzoiRjIiLDExNDoiRjMiLDExNToiRjQiLDExNjoiRjUiLDExNzoiRjYiLDExODoiRjciLDExOToiRjgiLDEyMDoiRjkiLDEyMToiRjEwIiwxMjI6IkYxMSIsMTIzOiJGMTIiLDE0NDoiTnVtTG9jayIsMTQ1OiJTY3JvbGxMb2NrIiwyMjQ6Ik1ldGEifSxpTT17QWx0OiJhbHRLZXkiLENvbnRyb2w6ImN0cmxLZXkiLE1ldGE6Im1ldGFLZXkiLFNoaWZ0OiJzaGlmdEtleSJ9O2Z1bmN0aW9uIGlGKGUpe3ZhciB0PXRoaXMubmF0aXZlRXZlbnQ7cmV0dXJuIHQuZ2V0TW9kaWZpZXJTdGF0ZT90LmdldE1vZGlmaWVyU3RhdGUoZSk6ISEoZT1pTVtlXSkmJiEhdFtlXX1mdW5jdGlvbiBpRCgpe3JldHVybiBpRn12YXIgaVI9aWModSh7fSxpdyx7a2V5OmZ1bmN0aW9uKGUpe2lmKGUua2V5KXt2YXIgdD1pTFtlLmtleV18fGUua2V5O2lmKCJVbmlkZW50aWZpZWQiIT09dClyZXR1cm4gdH1yZXR1cm4ia2V5cHJlc3MiPT09ZS50eXBlPzEzPT09KGU9aWkoZSkpPyJFbnRlciI6U3RyaW5nLmZyb21DaGFyQ29kZShlKToia2V5ZG93biI9PT1lLnR5cGV8fCJrZXl1cCI9PT1lLnR5cGU/aVRbZS5rZXlDb2RlXXx8IlVuaWRlbnRpZmllZCI6IiJ9LGNvZGU6MCxsb2NhdGlvbjowLGN0cmxLZXk6MCxzaGlmdEtleTowLGFsdEtleTowLG1ldGFLZXk6MCxyZXBlYXQ6MCxsb2NhbGU6MCxnZXRNb2RpZmllclN0YXRlOmlELGNoYXJDb2RlOmZ1bmN0aW9uKGUpe3JldHVybiJrZXlwcmVzcyI9PT1lLnR5cGU/aWkoZSk6MH0sa2V5Q29kZTpmdW5jdGlvbihlKXtyZXR1cm4ia2V5ZG93biI9PT1lLnR5cGV8fCJrZXl1cCI9PT1lLnR5cGU/ZS5rZXlDb2RlOjB9LHdoaWNoOmZ1bmN0aW9uKGUpe3JldHVybiJrZXlwcmVzcyI9PT1lLnR5cGU/aWkoZSk6ImtleWRvd24iPT09ZS50eXBlfHwia2V5dXAiPT09ZS50eXBlP2Uua2V5Q29kZTowfX0pKSxpTz1pYyh1KHt9LGlFLHtwb2ludGVySWQ6MCx3aWR0aDowLGhlaWdodDowLHByZXNzdXJlOjAsdGFuZ2VudGlhbFByZXNzdXJlOjAsdGlsdFg6MCx0aWx0WTowLHR3aXN0OjAscG9pbnRlclR5cGU6MCxpc1ByaW1hcnk6MH0pKSxpQT1pYyh1KHt9LGl3LHt0b3VjaGVzOjAsdGFyZ2V0VG91Y2hlczowLGNoYW5nZWRUb3VjaGVzOjAsYWx0S2V5OjAsbWV0YUtleTowLGN0cmxLZXk6MCxzaGlmdEtleTowLGdldE1vZGlmaWVyU3RhdGU6aUR9KSksaUk9aWModSh7fSxpYix7cHJvcGVydHlOYW1lOjAsZWxhcHNlZFRpbWU6MCxwc2V1ZG9FbGVtZW50OjB9KSksaVU9aWModSh7fSxpRSx7ZGVsdGFYOmZ1bmN0aW9uKGUpe3JldHVybiJkZWx0YVgiaW4gZT9lLmRlbHRhWDoid2hlZWxEZWx0YVgiaW4gZT8tZS53aGVlbERlbHRhWDowfSxkZWx0YVk6ZnVuY3Rpb24oZSl7cmV0dXJuImRlbHRhWSJpbiBlP2UuZGVsdGFZOiJ3aGVlbERlbHRhWSJpbiBlPy1lLndoZWVsRGVsdGFZOiJ3aGVlbERlbHRhImluIGU/LWUud2hlZWxEZWx0YTowfSxkZWx0YVo6MCxkZWx0YU1vZGU6MH0pKSxpQj0hMSxpUT1udWxsLGlWPW51bGwsaSQ9bnVsbCxpVz1uZXcgTWFwLGlqPW5ldyBNYXAsaUg9W10saXE9Im1vdXNlZG93biBtb3VzZXVwIHRvdWNoY2FuY2VsIHRvdWNoZW5kIHRvdWNoc3RhcnQgYXV4Y2xpY2sgZGJsY2xpY2sgcG9pbnRlcmNhbmNlbCBwb2ludGVyZG93biBwb2ludGVydXAgZHJhZ2VuZCBkcmFnc3RhcnQgZHJvcCBjb21wb3NpdGlvbmVuZCBjb21wb3NpdGlvbnN0YXJ0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgaW5wdXQgdGV4dElucHV0IGNvcHkgY3V0IHBhc3RlIGNsaWNrIGNoYW5nZSBjb250ZXh0bWVudSByZXNldCIuc3BsaXQoIiAiKTtmdW5jdGlvbiBpSyhlLHQpe3N3aXRjaChlKXtjYXNlImZvY3VzaW4iOmNhc2UiZm9jdXNvdXQiOmlRPW51bGw7YnJlYWs7Y2FzZSJkcmFnZW50ZXIiOmNhc2UiZHJhZ2xlYXZlIjppVj1udWxsO2JyZWFrO2Nhc2UibW91c2VvdmVyIjpjYXNlIm1vdXNlb3V0IjppJD1udWxsO2JyZWFrO2Nhc2UicG9pbnRlcm92ZXIiOmNhc2UicG9pbnRlcm91dCI6aVcuZGVsZXRlKHQucG9pbnRlcklkKTticmVhaztjYXNlImdvdHBvaW50ZXJjYXB0dXJlIjpjYXNlImxvc3Rwb2ludGVyY2FwdHVyZSI6aWouZGVsZXRlKHQucG9pbnRlcklkKX19ZnVuY3Rpb24gaVkoZSx0LG4scixsLGEpe3JldHVybiBudWxsPT09ZXx8ZS5uYXRpdmVFdmVudCE9PWE/KGU9e2Jsb2NrZWRPbjp0LGRvbUV2ZW50TmFtZTpuLGV2ZW50U3lzdGVtRmxhZ3M6cixuYXRpdmVFdmVudDphLHRhcmdldENvbnRhaW5lcnM6W2xdfSxudWxsIT09dCYmbnVsbCE9PSh0PWVOKHQpKSYmaWUodCkpOihlLmV2ZW50U3lzdGVtRmxhZ3N8PXIsdD1lLnRhcmdldENvbnRhaW5lcnMsbnVsbCE9PWwmJi0xPT09dC5pbmRleE9mKGwpJiZ0LnB1c2gobCkpLGV9ZnVuY3Rpb24gaVgoZSl7dmFyIHQ9ZVAoZS50YXJnZXQpO2lmKG51bGwhPT10KXt2YXIgbj10ZCh0KTtpZihudWxsIT09bil7aWYoMTM9PT0odD1uLnRhZykpe2lmKG51bGwhPT0odD10cChuKSkpe2UuYmxvY2tlZE9uPXQsZnVuY3Rpb24oZSx0KXt2YXIgbj1laDt0cnl7cmV0dXJuIGVoPWUsdCgpfWZpbmFsbHl7ZWg9bn19KGUucHJpb3JpdHksZnVuY3Rpb24oKXtpZigxMz09PW4udGFnKXt2YXIgZT1vbShuKSx0PW5lKG4sZSk7bnVsbCE9PXQmJm9nKHQsbixlKSxvOShuLGUpfX0pO3JldHVybn19ZWxzZSBpZigzPT09dCYmbi5zdGF0ZU5vZGUuY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZCl7ZS5ibG9ja2VkT249Mz09PW4udGFnP24uc3RhdGVOb2RlLmNvbnRhaW5lckluZm86bnVsbDtyZXR1cm59fX1lLmJsb2NrZWRPbj1udWxsfWZ1bmN0aW9uIGlHKGUpe2lmKG51bGwhPT1lLmJsb2NrZWRPbilyZXR1cm4hMTtmb3IodmFyIHQ9ZS50YXJnZXRDb250YWluZXJzOzA8dC5sZW5ndGg7KXt2YXIgbj1pNShlLm5hdGl2ZUV2ZW50KTtpZihudWxsIT09bilyZXR1cm4gbnVsbCE9PSh0PWVOKG4pKSYmaWUodCksZS5ibG9ja2VkT249biwhMTt2YXIgcj1uZXcobj1lLm5hdGl2ZUV2ZW50KS5jb25zdHJ1Y3RvcihuLnR5cGUsbik7dGE9cixuLnRhcmdldC5kaXNwYXRjaEV2ZW50KHIpLHRhPW51bGwsdC5zaGlmdCgpfXJldHVybiEwfWZ1bmN0aW9uIGlaKGUsdCxuKXtpRyhlKSYmbi5kZWxldGUodCl9ZnVuY3Rpb24gaUooKXtpQj0hMSxudWxsIT09aVEmJmlHKGlRKSYmKGlRPW51bGwpLG51bGwhPT1pViYmaUcoaVYpJiYoaVY9bnVsbCksbnVsbCE9PWkkJiZpRyhpJCkmJihpJD1udWxsKSxpVy5mb3JFYWNoKGlaKSxpai5mb3JFYWNoKGlaKX1mdW5jdGlvbiBpMChlLHQpe2UuYmxvY2tlZE9uPT09dCYmKGUuYmxvY2tlZE9uPW51bGwsaUJ8fChpQj0hMCxhLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2soYS51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSxpSikpKX1mdW5jdGlvbiBpMShlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBpMCh0LGUpfW51bGwhPT1pUSYmaTAoaVEsZSksbnVsbCE9PWlWJiZpMChpVixlKSxudWxsIT09aSQmJmkwKGkkLGUpLGlXLmZvckVhY2godCksaWouZm9yRWFjaCh0KTtmb3IodmFyIG49MDtuPGlILmxlbmd0aDtuKyspe3ZhciByPWlIW25dO3IuYmxvY2tlZE9uPT09ZSYmKHIuYmxvY2tlZE9uPW51bGwpfWZvcig7MDxpSC5sZW5ndGgmJm51bGw9PT0obj1pSFswXSkuYmxvY2tlZE9uOylpWChuKSxudWxsPT09bi5ibG9ja2VkT24mJmlILnNoaWZ0KCl9dmFyIGkyPXMuUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsaTM9ITA7ZnVuY3Rpb24gaTQoZSx0LG4scil7dmFyIGw9ZWgsYT1pMi50cmFuc2l0aW9uO2kyLnRyYW5zaXRpb249bnVsbDt0cnl7ZWg9MixpNihlLHQsbixyKX1maW5hbGx5e2VoPWwsaTIudHJhbnNpdGlvbj1hfX1mdW5jdGlvbiBpOChlLHQsbixyKXt2YXIgbD1laCxhPWkyLnRyYW5zaXRpb247aTIudHJhbnNpdGlvbj1udWxsO3RyeXtlaD04LGk2KGUsdCxuLHIpfWZpbmFsbHl7ZWg9bCxpMi50cmFuc2l0aW9uPWF9fWZ1bmN0aW9uIGk2KGUsdCxuLHIpe2lmKGkzKXt2YXIgbD1pNShyKTtpZihudWxsPT09bCl1OShlLHQscixpNyxuKSxpSyhlLHIpO2Vsc2UgaWYoZnVuY3Rpb24oZSx0LG4scixsKXtzd2l0Y2godCl7Y2FzZSJmb2N1c2luIjpyZXR1cm4gaVE9aVkoaVEsZSx0LG4scixsKSwhMDtjYXNlImRyYWdlbnRlciI6cmV0dXJuIGlWPWlZKGlWLGUsdCxuLHIsbCksITA7Y2FzZSJtb3VzZW92ZXIiOnJldHVybiBpJD1pWShpJCxlLHQsbixyLGwpLCEwO2Nhc2UicG9pbnRlcm92ZXIiOnZhciBhPWwucG9pbnRlcklkO3JldHVybiBpVy5zZXQoYSxpWShpVy5nZXQoYSl8fG51bGwsZSx0LG4scixsKSksITA7Y2FzZSJnb3Rwb2ludGVyY2FwdHVyZSI6cmV0dXJuIGE9bC5wb2ludGVySWQsaWouc2V0KGEsaVkoaWouZ2V0KGEpfHxudWxsLGUsdCxuLHIsbCkpLCEwfXJldHVybiExfShsLGUsdCxuLHIpKXIuc3RvcFByb3BhZ2F0aW9uKCk7ZWxzZSBpZihpSyhlLHIpLDQmdCYmLTE8aXEuaW5kZXhPZihlKSl7Zm9yKDtudWxsIT09bDspe3ZhciBhPWVOKGwpO2lmKG51bGwhPT1hJiZmdW5jdGlvbihlKXtzd2l0Y2goZS50YWcpe2Nhc2UgMzp2YXIgdD1lLnN0YXRlTm9kZTtpZih0LmN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQpe3ZhciBuPWVvKHQucGVuZGluZ0xhbmVzKTswIT09biYmKGVwKHQsMnxuKSxuWCh0KSwwPT0oNiZhRykmJihvcj1IKCkrNTAwLG5HKCExKSkpfWJyZWFrO2Nhc2UgMTM6b0UoZnVuY3Rpb24oKXt2YXIgdD1uZShlLDIpO251bGwhPT10JiZvZyh0LGUsMil9KSxvOShlLDIpfX0oYSksbnVsbD09PShhPWk1KHIpKSYmdTkoZSx0LHIsaTcsbiksYT09PWwpYnJlYWs7bD1hfW51bGwhPT1sJiZyLnN0b3BQcm9wYWdhdGlvbigpfWVsc2UgdTkoZSx0LHIsbnVsbCxuKX19ZnVuY3Rpb24gaTUoZSl7ZT10byhlKTtlOntpZihpNz1udWxsLG51bGwhPT0oZT1lUChlKSkpe3ZhciB0PXRkKGUpO2lmKG51bGw9PT10KWU9bnVsbDtlbHNle3ZhciBuPXQudGFnO2lmKDEzPT09bil7aWYobnVsbCE9PShlPXRwKHQpKSlicmVhayBlO2U9bnVsbH1lbHNlIGlmKDM9PT1uKXtpZih0LnN0YXRlTm9kZS5jdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkKXtlPTM9PT10LnRhZz90LnN0YXRlTm9kZS5jb250YWluZXJJbmZvOm51bGw7YnJlYWsgZX1lPW51bGx9ZWxzZSB0IT09ZSYmKGU9bnVsbCl9fWk3PWUsZT1udWxsfXJldHVybiBlfXZhciBpNz1udWxsO2Z1bmN0aW9uIGk5KGUpe3N3aXRjaChlKXtjYXNlImNhbmNlbCI6Y2FzZSJjbGljayI6Y2FzZSJjbG9zZSI6Y2FzZSJjb250ZXh0bWVudSI6Y2FzZSJjb3B5IjpjYXNlImN1dCI6Y2FzZSJhdXhjbGljayI6Y2FzZSJkYmxjbGljayI6Y2FzZSJkcmFnZW5kIjpjYXNlImRyYWdzdGFydCI6Y2FzZSJkcm9wIjpjYXNlImZvY3VzaW4iOmNhc2UiZm9jdXNvdXQiOmNhc2UiaW5wdXQiOmNhc2UiaW52YWxpZCI6Y2FzZSJrZXlkb3duIjpjYXNlImtleXByZXNzIjpjYXNlImtleXVwIjpjYXNlIm1vdXNlZG93biI6Y2FzZSJtb3VzZXVwIjpjYXNlInBhc3RlIjpjYXNlInBhdXNlIjpjYXNlInBsYXkiOmNhc2UicG9pbnRlcmNhbmNlbCI6Y2FzZSJwb2ludGVyZG93biI6Y2FzZSJwb2ludGVydXAiOmNhc2UicmF0ZWNoYW5nZSI6Y2FzZSJyZXNldCI6Y2FzZSJyZXNpemUiOmNhc2Uic2Vla2VkIjpjYXNlInN1Ym1pdCI6Y2FzZSJ0b3VjaGNhbmNlbCI6Y2FzZSJ0b3VjaGVuZCI6Y2FzZSJ0b3VjaHN0YXJ0IjpjYXNlInZvbHVtZWNoYW5nZSI6Y2FzZSJjaGFuZ2UiOmNhc2Uic2VsZWN0aW9uY2hhbmdlIjpjYXNlInRleHRJbnB1dCI6Y2FzZSJjb21wb3NpdGlvbnN0YXJ0IjpjYXNlImNvbXBvc2l0aW9uZW5kIjpjYXNlImNvbXBvc2l0aW9udXBkYXRlIjpjYXNlImJlZm9yZWJsdXIiOmNhc2UiYWZ0ZXJibHVyIjpjYXNlImJlZm9yZWlucHV0IjpjYXNlImJsdXIiOmNhc2UiZnVsbHNjcmVlbmNoYW5nZSI6Y2FzZSJmb2N1cyI6Y2FzZSJoYXNoY2hhbmdlIjpjYXNlInBvcHN0YXRlIjpjYXNlInNlbGVjdCI6Y2FzZSJzZWxlY3RzdGFydCI6cmV0dXJuIDI7Y2FzZSJkcmFnIjpjYXNlImRyYWdlbnRlciI6Y2FzZSJkcmFnZXhpdCI6Y2FzZSJkcmFnbGVhdmUiOmNhc2UiZHJhZ292ZXIiOmNhc2UibW91c2Vtb3ZlIjpjYXNlIm1vdXNlb3V0IjpjYXNlIm1vdXNlb3ZlciI6Y2FzZSJwb2ludGVybW92ZSI6Y2FzZSJwb2ludGVyb3V0IjpjYXNlInBvaW50ZXJvdmVyIjpjYXNlInNjcm9sbCI6Y2FzZSJ0b2dnbGUiOmNhc2UidG91Y2htb3ZlIjpjYXNlIndoZWVsIjpjYXNlIm1vdXNlZW50ZXIiOmNhc2UibW91c2VsZWF2ZSI6Y2FzZSJwb2ludGVyZW50ZXIiOmNhc2UicG9pbnRlcmxlYXZlIjpyZXR1cm4gODtjYXNlIm1lc3NhZ2UiOnN3aXRjaChxKCkpe2Nhc2UgSzpyZXR1cm4gMjtjYXNlIFk6cmV0dXJuIDg7Y2FzZSBYOmNhc2UgRzpyZXR1cm4gMzI7Y2FzZSBaOnJldHVybiA1MzY4NzA5MTI7ZGVmYXVsdDpyZXR1cm4gMzJ9ZGVmYXVsdDpyZXR1cm4gMzJ9fXZhciB1ZT1udWxsLHV0PW51bGwsdW49bnVsbDtmdW5jdGlvbiB1cigpe2lmKHVuKXJldHVybiB1bjt2YXIgZSx0LG49dXQscj1uLmxlbmd0aCxsPSJ2YWx1ZSJpbiB1ZT91ZS52YWx1ZTp1ZS50ZXh0Q29udGVudCxhPWwubGVuZ3RoO2ZvcihlPTA7ZTxyJiZuW2VdPT09bFtlXTtlKyspO3ZhciBvPXItZTtmb3IodD0xO3Q8PW8mJm5bci10XT09PWxbYS10XTt0KyspO3JldHVybiB1bj1sLnNsaWNlKGUsMTx0PzEtdDp2b2lkIDApfXZhciB1bD1bOSwxMywyNywzMl0sdWE9ZUEmJiJDb21wb3NpdGlvbkV2ZW50ImluIHdpbmRvdyx1bz1udWxsO2VBJiYiZG9jdW1lbnRNb2RlImluIGRvY3VtZW50JiYodW89ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTt2YXIgdWk9ZUEmJiJUZXh0RXZlbnQiaW4gd2luZG93JiYhdW8sdXU9ZUEmJighdWF8fHVvJiY4PHVvJiYxMT49dW8pLHVzPSExO2Z1bmN0aW9uIHVjKGUsdCl7c3dpdGNoKGUpe2Nhc2Uia2V5dXAiOnJldHVybiAtMSE9PXVsLmluZGV4T2YodC5rZXlDb2RlKTtjYXNlImtleWRvd24iOnJldHVybiAyMjkhPT10LmtleUNvZGU7Y2FzZSJrZXlwcmVzcyI6Y2FzZSJtb3VzZWRvd24iOmNhc2UiZm9jdXNvdXQiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fWZ1bmN0aW9uIHVmKGUpe3JldHVybiJvYmplY3QiPT10eXBlb2YoZT1lLmRldGFpbCkmJiJkYXRhImluIGU/ZS5kYXRhOm51bGx9dmFyIHVkPSExLHVwPXtjb2xvcjohMCxkYXRlOiEwLGRhdGV0aW1lOiEwLCJkYXRldGltZS1sb2NhbCI6ITAsZW1haWw6ITAsbW9udGg6ITAsbnVtYmVyOiEwLHBhc3N3b3JkOiEwLHJhbmdlOiEwLHNlYXJjaDohMCx0ZWw6ITAsdGV4dDohMCx0aW1lOiEwLHVybDohMCx3ZWVrOiEwfTtmdW5jdGlvbiB1aChlKXt2YXIgdD1lJiZlLm5vZGVOYW1lJiZlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuImlucHV0Ij09PXQ/ISF1cFtlLnR5cGVdOiJ0ZXh0YXJlYSI9PT10fWZ1bmN0aW9uIHVtKGUsdCxuLHIpe3RjKHIpLDA8KHQ9c3QodCwib25DaGFuZ2UiKSkubGVuZ3RoJiYobj1uZXcgaWsoIm9uQ2hhbmdlIiwiY2hhbmdlIixudWxsLG4sciksZS5wdXNoKHtldmVudDpuLGxpc3RlbmVyczp0fSkpfXZhciB1Zz1udWxsLHV5PW51bGw7ZnVuY3Rpb24gdXYoZSl7dTMoZSwwKX1mdW5jdGlvbiB1YihlKXtpZihlWChlXyhlKSkpcmV0dXJuIGV9ZnVuY3Rpb24gdWsoZSx0KXtpZigiY2hhbmdlIj09PWUpcmV0dXJuIHR9dmFyIHV3PSExO2lmKGVBKXtpZihlQSl7dmFyIHVTPSJvbmlucHV0ImluIGRvY3VtZW50O2lmKCF1Uyl7dmFyIHVFPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO3VFLnNldEF0dHJpYnV0ZSgib25pbnB1dCIsInJldHVybjsiKSx1Uz0iZnVuY3Rpb24iPT10eXBlb2YgdUUub25pbnB1dH1yPXVTfWVsc2Ugcj0hMTt1dz1yJiYoIWRvY3VtZW50LmRvY3VtZW50TW9kZXx8OTxkb2N1bWVudC5kb2N1bWVudE1vZGUpfWZ1bmN0aW9uIHVDKCl7dWcmJih1Zy5kZXRhY2hFdmVudCgib25wcm9wZXJ0eWNoYW5nZSIsdXgpLHV5PXVnPW51bGwpfWZ1bmN0aW9uIHV4KGUpe2lmKCJ2YWx1ZSI9PT1lLnByb3BlcnR5TmFtZSYmdWIodXkpKXt2YXIgdD1bXTt1bSh0LHV5LGUsdG8oZSkpLGlyKHV2LHQpfX1mdW5jdGlvbiB1eihlLHQsbil7ImZvY3VzaW4iPT09ZT8odUMoKSx1Zz10LHV5PW4sdWcuYXR0YWNoRXZlbnQoIm9ucHJvcGVydHljaGFuZ2UiLHV4KSk6ImZvY3Vzb3V0Ij09PWUmJnVDKCl9ZnVuY3Rpb24gdVAoZSl7aWYoInNlbGVjdGlvbmNoYW5nZSI9PT1lfHwia2V5dXAiPT09ZXx8ImtleWRvd24iPT09ZSlyZXR1cm4gdWIodXkpfWZ1bmN0aW9uIHVOKGUsdCl7aWYoImNsaWNrIj09PWUpcmV0dXJuIHViKHQpfWZ1bmN0aW9uIHVfKGUsdCl7aWYoImlucHV0Ij09PWV8fCJjaGFuZ2UiPT09ZSlyZXR1cm4gdWIodCl9ZnVuY3Rpb24gdUwoZSl7Zm9yKDtlJiZlLmZpcnN0Q2hpbGQ7KWU9ZS5maXJzdENoaWxkO3JldHVybiBlfWZ1bmN0aW9uIHVUKGUsdCl7dmFyIG4scj11TChlKTtmb3IoZT0wO3I7KXtpZigzPT09ci5ub2RlVHlwZSl7aWYobj1lK3IudGV4dENvbnRlbnQubGVuZ3RoLGU8PXQmJm4+PXQpcmV0dXJue25vZGU6cixvZmZzZXQ6dC1lfTtlPW59ZTp7Zm9yKDtyOyl7aWYoci5uZXh0U2libGluZyl7cj1yLm5leHRTaWJsaW5nO2JyZWFrIGV9cj1yLnBhcmVudE5vZGV9cj12b2lkIDB9cj11TChyKX19ZnVuY3Rpb24gdU0oKXtmb3IodmFyIGU9d2luZG93LHQ9ZUcoKTt0IGluc3RhbmNlb2YgZS5IVE1MSUZyYW1lRWxlbWVudDspe3RyeXt2YXIgbj0ic3RyaW5nIj09dHlwZW9mIHQuY29udGVudFdpbmRvdy5sb2NhdGlvbi5ocmVmfWNhdGNoKGUpe249ITF9aWYobillPXQuY29udGVudFdpbmRvdztlbHNlIGJyZWFrO3Q9ZUcoZS5kb2N1bWVudCl9cmV0dXJuIHR9ZnVuY3Rpb24gdUYoZSl7dmFyIHQ9ZSYmZS5ub2RlTmFtZSYmZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVybiB0JiYoImlucHV0Ij09PXQmJigidGV4dCI9PT1lLnR5cGV8fCJzZWFyY2giPT09ZS50eXBlfHwidGVsIj09PWUudHlwZXx8InVybCI9PT1lLnR5cGV8fCJwYXNzd29yZCI9PT1lLnR5cGUpfHwidGV4dGFyZWEiPT09dHx8InRydWUiPT09ZS5jb250ZW50RWRpdGFibGUpfXZhciB1RD1lQSYmImRvY3VtZW50TW9kZSJpbiBkb2N1bWVudCYmMTE+PWRvY3VtZW50LmRvY3VtZW50TW9kZSx1Uj1udWxsLHVPPW51bGwsdUE9bnVsbCx1ST0hMTtmdW5jdGlvbiB1VShlLHQsbil7dmFyIHI9bi53aW5kb3c9PT1uP24uZG9jdW1lbnQ6OT09PW4ubm9kZVR5cGU/bjpuLm93bmVyRG9jdW1lbnQ7dUl8fG51bGw9PXVSfHx1UiE9PWVHKHIpfHwocj0ic2VsZWN0aW9uU3RhcnQiaW4ocj11UikmJnVGKHIpP3tzdGFydDpyLnNlbGVjdGlvblN0YXJ0LGVuZDpyLnNlbGVjdGlvbkVuZH06e2FuY2hvck5vZGU6KHI9KHIub3duZXJEb2N1bWVudCYmci5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3fHx3aW5kb3cpLmdldFNlbGVjdGlvbigpKS5hbmNob3JOb2RlLGFuY2hvck9mZnNldDpyLmFuY2hvck9mZnNldCxmb2N1c05vZGU6ci5mb2N1c05vZGUsZm9jdXNPZmZzZXQ6ci5mb2N1c09mZnNldH0sdUEmJm5wKHVBLHIpfHwodUE9ciwwPChyPXN0KHVPLCJvblNlbGVjdCIpKS5sZW5ndGgmJih0PW5ldyBpaygib25TZWxlY3QiLCJzZWxlY3QiLG51bGwsdCxuKSxlLnB1c2goe2V2ZW50OnQsbGlzdGVuZXJzOnJ9KSx0LnRhcmdldD11UikpKX1mdW5jdGlvbiB1QihlLHQpe3ZhciBuPXt9O3JldHVybiBuW2UudG9Mb3dlckNhc2UoKV09dC50b0xvd2VyQ2FzZSgpLG5bIldlYmtpdCIrZV09IndlYmtpdCIrdCxuWyJNb3oiK2VdPSJtb3oiK3Qsbn12YXIgdVE9e2FuaW1hdGlvbmVuZDp1QigiQW5pbWF0aW9uIiwiQW5pbWF0aW9uRW5kIiksYW5pbWF0aW9uaXRlcmF0aW9uOnVCKCJBbmltYXRpb24iLCJBbmltYXRpb25JdGVyYXRpb24iKSxhbmltYXRpb25zdGFydDp1QigiQW5pbWF0aW9uIiwiQW5pbWF0aW9uU3RhcnQiKSx0cmFuc2l0aW9uZW5kOnVCKCJUcmFuc2l0aW9uIiwiVHJhbnNpdGlvbkVuZCIpfSx1Vj17fSx1JD17fTtmdW5jdGlvbiB1VyhlKXtpZih1VltlXSlyZXR1cm4gdVZbZV07aWYoIXVRW2VdKXJldHVybiBlO3ZhciB0LG49dVFbZV07Zm9yKHQgaW4gbilpZihuLmhhc093blByb3BlcnR5KHQpJiZ0IGluIHUkKXJldHVybiB1VltlXT1uW3RdO3JldHVybiBlfWVBJiYodSQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iikuc3R5bGUsIkFuaW1hdGlvbkV2ZW50ImluIHdpbmRvd3x8KGRlbGV0ZSB1US5hbmltYXRpb25lbmQuYW5pbWF0aW9uLGRlbGV0ZSB1US5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uLGRlbGV0ZSB1US5hbmltYXRpb25zdGFydC5hbmltYXRpb24pLCJUcmFuc2l0aW9uRXZlbnQiaW4gd2luZG93fHxkZWxldGUgdVEudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uKTt2YXIgdWo9dVcoImFuaW1hdGlvbmVuZCIpLHVIPXVXKCJhbmltYXRpb25pdGVyYXRpb24iKSx1cT11VygiYW5pbWF0aW9uc3RhcnQiKSx1Sz11VygidHJhbnNpdGlvbmVuZCIpLHVZPW5ldyBNYXAsdVg9ImFib3J0IGF1eENsaWNrIGNhbmNlbCBjYW5QbGF5IGNhblBsYXlUaHJvdWdoIGNsaWNrIGNsb3NlIGNvbnRleHRNZW51IGNvcHkgY3V0IGRyYWcgZHJhZ0VuZCBkcmFnRW50ZXIgZHJhZ0V4aXQgZHJhZ0xlYXZlIGRyYWdPdmVyIGRyYWdTdGFydCBkcm9wIGR1cmF0aW9uQ2hhbmdlIGVtcHRpZWQgZW5jcnlwdGVkIGVuZGVkIGVycm9yIGdvdFBvaW50ZXJDYXB0dXJlIGlucHV0IGludmFsaWQga2V5RG93biBrZXlQcmVzcyBrZXlVcCBsb2FkIGxvYWRlZERhdGEgbG9hZGVkTWV0YWRhdGEgbG9hZFN0YXJ0IGxvc3RQb2ludGVyQ2FwdHVyZSBtb3VzZURvd24gbW91c2VNb3ZlIG1vdXNlT3V0IG1vdXNlT3ZlciBtb3VzZVVwIHBhc3RlIHBhdXNlIHBsYXkgcGxheWluZyBwb2ludGVyQ2FuY2VsIHBvaW50ZXJEb3duIHBvaW50ZXJNb3ZlIHBvaW50ZXJPdXQgcG9pbnRlck92ZXIgcG9pbnRlclVwIHByb2dyZXNzIHJhdGVDaGFuZ2UgcmVzZXQgcmVzaXplIHNlZWtlZCBzZWVraW5nIHN0YWxsZWQgc3VibWl0IHN1c3BlbmQgdGltZVVwZGF0ZSB0b3VjaENhbmNlbCB0b3VjaEVuZCB0b3VjaFN0YXJ0IHZvbHVtZUNoYW5nZSBzY3JvbGwgdG9nZ2xlIHRvdWNoTW92ZSB3YWl0aW5nIHdoZWVsIi5zcGxpdCgiICIpO2Z1bmN0aW9uIHVHKGUsdCl7dVkuc2V0KGUsdCksZVIodCxbZV0pfWZvcih2YXIgdVo9MDt1Wjx1WC5sZW5ndGg7dVorKyl7dmFyIHVKPXVYW3VaXTt1Ryh1Si50b0xvd2VyQ2FzZSgpLCJvbiIrKHVKWzBdLnRvVXBwZXJDYXNlKCkrdUouc2xpY2UoMSkpKX11Ryh1aiwib25BbmltYXRpb25FbmQiKSx1Ryh1SCwib25BbmltYXRpb25JdGVyYXRpb24iKSx1Ryh1cSwib25BbmltYXRpb25TdGFydCIpLHVHKCJkYmxjbGljayIsIm9uRG91YmxlQ2xpY2siKSx1RygiZm9jdXNpbiIsIm9uRm9jdXMiKSx1RygiZm9jdXNvdXQiLCJvbkJsdXIiKSx1Ryh1Sywib25UcmFuc2l0aW9uRW5kIiksZU8oIm9uTW91c2VFbnRlciIsWyJtb3VzZW91dCIsIm1vdXNlb3ZlciJdKSxlTygib25Nb3VzZUxlYXZlIixbIm1vdXNlb3V0IiwibW91c2VvdmVyIl0pLGVPKCJvblBvaW50ZXJFbnRlciIsWyJwb2ludGVyb3V0IiwicG9pbnRlcm92ZXIiXSksZU8oIm9uUG9pbnRlckxlYXZlIixbInBvaW50ZXJvdXQiLCJwb2ludGVyb3ZlciJdKSxlUigib25DaGFuZ2UiLCJjaGFuZ2UgY2xpY2sgZm9jdXNpbiBmb2N1c291dCBpbnB1dCBrZXlkb3duIGtleXVwIHNlbGVjdGlvbmNoYW5nZSIuc3BsaXQoIiAiKSksZVIoIm9uU2VsZWN0IiwiZm9jdXNvdXQgY29udGV4dG1lbnUgZHJhZ2VuZCBmb2N1c2luIGtleWRvd24ga2V5dXAgbW91c2Vkb3duIG1vdXNldXAgc2VsZWN0aW9uY2hhbmdlIi5zcGxpdCgiICIpKSxlUigib25CZWZvcmVJbnB1dCIsWyJjb21wb3NpdGlvbmVuZCIsImtleXByZXNzIiwidGV4dElucHV0IiwicGFzdGUiXSksZVIoIm9uQ29tcG9zaXRpb25FbmQiLCJjb21wb3NpdGlvbmVuZCBmb2N1c291dCBrZXlkb3duIGtleXByZXNzIGtleXVwIG1vdXNlZG93biIuc3BsaXQoIiAiKSksZVIoIm9uQ29tcG9zaXRpb25TdGFydCIsImNvbXBvc2l0aW9uc3RhcnQgZm9jdXNvdXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd24iLnNwbGl0KCIgIikpLGVSKCJvbkNvbXBvc2l0aW9uVXBkYXRlIiwiY29tcG9zaXRpb251cGRhdGUgZm9jdXNvdXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd24iLnNwbGl0KCIgIikpO3ZhciB1MD0iYWJvcnQgY2FucGxheSBjYW5wbGF5dGhyb3VnaCBkdXJhdGlvbmNoYW5nZSBlbXB0aWVkIGVuY3J5cHRlZCBlbmRlZCBlcnJvciBsb2FkZWRkYXRhIGxvYWRlZG1ldGFkYXRhIGxvYWRzdGFydCBwYXVzZSBwbGF5IHBsYXlpbmcgcHJvZ3Jlc3MgcmF0ZWNoYW5nZSByZXNpemUgc2Vla2VkIHNlZWtpbmcgc3RhbGxlZCBzdXNwZW5kIHRpbWV1cGRhdGUgdm9sdW1lY2hhbmdlIHdhaXRpbmciLnNwbGl0KCIgIiksdTE9bmV3IFNldCgiY2FuY2VsIGNsb3NlIGludmFsaWQgbG9hZCBzY3JvbGwgdG9nZ2xlIi5zcGxpdCgiICIpLmNvbmNhdCh1MCkpO2Z1bmN0aW9uIHUyKGUsdCxuKXt2YXIgcj1lLnR5cGV8fCJ1bmtub3duLWV2ZW50IjtlLmN1cnJlbnRUYXJnZXQ9bixmdW5jdGlvbihlLHQsbixyLGwsYSxvLHUscyl7aWYoYXIuYXBwbHkodGhpcyxhcmd1bWVudHMpLGw3KXtpZihsNyl7dmFyIGM9bDk7bDc9ITEsbDk9bnVsbH1lbHNlIHRocm93IEVycm9yKGkoMTk4KSk7YWV8fChhZT0hMCxhdD1jKX19KHIsdCx2b2lkIDAsZSksZS5jdXJyZW50VGFyZ2V0PW51bGx9ZnVuY3Rpb24gdTMoZSx0KXt0PTAhPSg0JnQpO2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dLGw9ci5ldmVudDtyPXIubGlzdGVuZXJzO2U6e3ZhciBhPXZvaWQgMDtpZih0KWZvcih2YXIgbz1yLmxlbmd0aC0xOzA8PW87by0tKXt2YXIgaT1yW29dLHU9aS5pbnN0YW5jZSxzPWkuY3VycmVudFRhcmdldDtpZihpPWkubGlzdGVuZXIsdSE9PWEmJmwuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSlicmVhayBlO3UyKGwsaSxzKSxhPXV9ZWxzZSBmb3Iobz0wO288ci5sZW5ndGg7bysrKXtpZih1PShpPXJbb10pLmluc3RhbmNlLHM9aS5jdXJyZW50VGFyZ2V0LGk9aS5saXN0ZW5lcix1IT09YSYmbC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKWJyZWFrIGU7dTIobCxpLHMpLGE9dX19fWlmKGFlKXRocm93IGU9YXQsYWU9ITEsYXQ9bnVsbCxlfWZ1bmN0aW9uIHU0KGUsdCl7dmFyIG49dFtld107dm9pZCAwPT09biYmKG49dFtld109bmV3IFNldCk7dmFyIHI9ZSsiX19idWJibGUiO24uaGFzKHIpfHwodTcodCxlLDIsITEpLG4uYWRkKHIpKX1mdW5jdGlvbiB1OChlLHQsbil7dmFyIHI9MDt0JiYocnw9NCksdTcobixlLHIsdCl9dmFyIHU2PSJfcmVhY3RMaXN0ZW5pbmciK01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO2Z1bmN0aW9uIHU1KGUpe2lmKCFlW3U2XSl7ZVt1Nl09ITAsZUYuZm9yRWFjaChmdW5jdGlvbih0KXsic2VsZWN0aW9uY2hhbmdlIiE9PXQmJih1MS5oYXModCl8fHU4KHQsITEsZSksdTgodCwhMCxlKSl9KTt2YXIgdD05PT09ZS5ub2RlVHlwZT9lOmUub3duZXJEb2N1bWVudDtudWxsPT09dHx8dFt1Nl18fCh0W3U2XT0hMCx1OCgic2VsZWN0aW9uY2hhbmdlIiwhMSx0KSl9fWZ1bmN0aW9uIHU3KGUsdCxuLHIpe3N3aXRjaChpOSh0KSl7Y2FzZSAyOnZhciBsPWk0O2JyZWFrO2Nhc2UgODpsPWk4O2JyZWFrO2RlZmF1bHQ6bD1pNn1uPWwuYmluZChudWxsLHQsbixlKSxsPXZvaWQgMCxpYSYmKCJ0b3VjaHN0YXJ0Ij09PXR8fCJ0b3VjaG1vdmUiPT09dHx8IndoZWVsIj09PXQpJiYobD0hMCkscj92b2lkIDAhPT1sP2UuYWRkRXZlbnRMaXN0ZW5lcih0LG4se2NhcHR1cmU6ITAscGFzc2l2ZTpsfSk6ZS5hZGRFdmVudExpc3RlbmVyKHQsbiwhMCk6dm9pZCAwIT09bD9lLmFkZEV2ZW50TGlzdGVuZXIodCxuLHtwYXNzaXZlOmx9KTplLmFkZEV2ZW50TGlzdGVuZXIodCxuLCExKX1mdW5jdGlvbiB1OShlLHQsbixyLGwpe3ZhciBhPXI7aWYoMD09KDEmdCkmJjA9PSgyJnQpJiZudWxsIT09cillOmZvcig7Oyl7aWYobnVsbD09PXIpcmV0dXJuO3ZhciBvPXIudGFnO2lmKDM9PT1vfHw0PT09byl7dmFyIGk9ci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztpZihpPT09bHx8OD09PWkubm9kZVR5cGUmJmkucGFyZW50Tm9kZT09PWwpYnJlYWs7aWYoND09PW8pZm9yKG89ci5yZXR1cm47bnVsbCE9PW87KXt2YXIgdT1vLnRhZztpZigoMz09PXV8fDQ9PT11KSYmKCh1PW8uc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pPT09bHx8OD09PXUubm9kZVR5cGUmJnUucGFyZW50Tm9kZT09PWwpKXJldHVybjtvPW8ucmV0dXJufWZvcig7bnVsbCE9PWk7KXtpZihudWxsPT09KG89ZVAoaSkpKXJldHVybjtpZig1PT09KHU9by50YWcpfHw2PT09dXx8MjY9PT11fHwyNz09PXUpe3I9YT1vO2NvbnRpbnVlIGV9aT1pLnBhcmVudE5vZGV9fXI9ci5yZXR1cm59aXIoZnVuY3Rpb24oKXt2YXIgcj1hLGw9dG8obiksbz1bXTtlOnt2YXIgaT11WS5nZXQoZSk7aWYodm9pZCAwIT09aSl7dmFyIHU9aWsscz1lO3N3aXRjaChlKXtjYXNlImtleXByZXNzIjppZigwPT09aWkobikpYnJlYWsgZTtjYXNlImtleWRvd24iOmNhc2Uia2V5dXAiOnU9aVI7YnJlYWs7Y2FzZSJmb2N1c2luIjpzPSJmb2N1cyIsdT1pejticmVhaztjYXNlImZvY3Vzb3V0IjpzPSJibHVyIix1PWl6O2JyZWFrO2Nhc2UiYmVmb3JlYmx1ciI6Y2FzZSJhZnRlcmJsdXIiOnU9aXo7YnJlYWs7Y2FzZSJjbGljayI6aWYoMj09PW4uYnV0dG9uKWJyZWFrIGU7Y2FzZSJhdXhjbGljayI6Y2FzZSJkYmxjbGljayI6Y2FzZSJtb3VzZWRvd24iOmNhc2UibW91c2Vtb3ZlIjpjYXNlIm1vdXNldXAiOmNhc2UibW91c2VvdXQiOmNhc2UibW91c2VvdmVyIjpjYXNlImNvbnRleHRtZW51Ijp1PWlDO2JyZWFrO2Nhc2UiZHJhZyI6Y2FzZSJkcmFnZW5kIjpjYXNlImRyYWdlbnRlciI6Y2FzZSJkcmFnZXhpdCI6Y2FzZSJkcmFnbGVhdmUiOmNhc2UiZHJhZ292ZXIiOmNhc2UiZHJhZ3N0YXJ0IjpjYXNlImRyb3AiOnU9aXg7YnJlYWs7Y2FzZSJ0b3VjaGNhbmNlbCI6Y2FzZSJ0b3VjaGVuZCI6Y2FzZSJ0b3VjaG1vdmUiOmNhc2UidG91Y2hzdGFydCI6dT1pQTticmVhaztjYXNlIHVqOmNhc2UgdUg6Y2FzZSB1cTp1PWlQO2JyZWFrO2Nhc2UgdUs6dT1pSTticmVhaztjYXNlInNjcm9sbCI6dT1pUzticmVhaztjYXNlIndoZWVsIjp1PWlVO2JyZWFrO2Nhc2UiY29weSI6Y2FzZSJjdXQiOmNhc2UicGFzdGUiOnU9aU47YnJlYWs7Y2FzZSJnb3Rwb2ludGVyY2FwdHVyZSI6Y2FzZSJsb3N0cG9pbnRlcmNhcHR1cmUiOmNhc2UicG9pbnRlcmNhbmNlbCI6Y2FzZSJwb2ludGVyZG93biI6Y2FzZSJwb2ludGVybW92ZSI6Y2FzZSJwb2ludGVyb3V0IjpjYXNlInBvaW50ZXJvdmVyIjpjYXNlInBvaW50ZXJ1cCI6dT1pT312YXIgYz0wIT0oNCZ0KSxmPSFjJiYic2Nyb2xsIj09PWUsZD1jP251bGwhPT1pP2krIkNhcHR1cmUiOm51bGw6aTtjPVtdO2Zvcih2YXIgcCxoPXI7bnVsbCE9PWg7KXt2YXIgbT1oO2lmKHA9bS5zdGF0ZU5vZGUsNSE9PShtPW0udGFnKSYmMjYhPT1tJiYyNyE9PW18fG51bGw9PT1wfHxudWxsPT09ZHx8bnVsbCE9KG09aWwoaCxkKSkmJmMucHVzaChzZShoLG0scCkpLGYpYnJlYWs7aD1oLnJldHVybn0wPGMubGVuZ3RoJiYoaT1uZXcgdShpLHMsbnVsbCxuLGwpLG8ucHVzaCh7ZXZlbnQ6aSxsaXN0ZW5lcnM6Y30pKX19aWYoMD09KDcmdCkpe2lmKGk9Im1vdXNlb3ZlciI9PT1lfHwicG9pbnRlcm92ZXIiPT09ZSx1PSJtb3VzZW91dCI9PT1lfHwicG9pbnRlcm91dCI9PT1lLCEoaSYmbiE9PXRhJiYocz1uLnJlbGF0ZWRUYXJnZXR8fG4uZnJvbUVsZW1lbnQpJiYoZVAocyl8fHNbZWtdKSkmJih1fHxpKSYmKGk9bC53aW5kb3c9PT1sP2w6KGk9bC5vd25lckRvY3VtZW50KT9pLmRlZmF1bHRWaWV3fHxpLnBhcmVudFdpbmRvdzp3aW5kb3csdT8ocz1uLnJlbGF0ZWRUYXJnZXR8fG4udG9FbGVtZW50LHU9cixudWxsIT09KHM9cz9lUChzKTpudWxsKSYmKGY9dGQocyksYz1zLnRhZyxzIT09Znx8NSE9PWMmJjI3IT09YyYmNiE9PWMpJiYocz1udWxsKSk6KHU9bnVsbCxzPXIpLHUhPT1zKSl7aWYoYz1pQyxtPSJvbk1vdXNlTGVhdmUiLGQ9Im9uTW91c2VFbnRlciIsaD0ibW91c2UiLCgicG9pbnRlcm91dCI9PT1lfHwicG9pbnRlcm92ZXIiPT09ZSkmJihjPWlPLG09Im9uUG9pbnRlckxlYXZlIixkPSJvblBvaW50ZXJFbnRlciIsaD0icG9pbnRlciIpLGY9bnVsbD09dT9pOmVfKHUpLHA9bnVsbD09cz9pOmVfKHMpLChpPW5ldyBjKG0saCsibGVhdmUiLHUsbixsKSkudGFyZ2V0PWYsaS5yZWxhdGVkVGFyZ2V0PXAsbT1udWxsLGVQKGwpPT09ciYmKChjPW5ldyBjKGQsaCsiZW50ZXIiLHMsbixsKSkudGFyZ2V0PXAsYy5yZWxhdGVkVGFyZ2V0PWYsbT1jKSxmPW0sdSYmcyl0Ontmb3IoYz11LGQ9cyxoPTAscD1jO3A7cD1zbihwKSloKys7Zm9yKHA9MCxtPWQ7bTttPXNuKG0pKXArKztmb3IoOzA8aC1wOyljPXNuKGMpLGgtLTtmb3IoOzA8cC1oOylkPXNuKGQpLHAtLTtmb3IoO2gtLTspe2lmKGM9PT1kfHxudWxsIT09ZCYmYz09PWQuYWx0ZXJuYXRlKWJyZWFrIHQ7Yz1zbihjKSxkPXNuKGQpfWM9bnVsbH1lbHNlIGM9bnVsbDtudWxsIT09dSYmc3IobyxpLHUsYywhMSksbnVsbCE9PXMmJm51bGwhPT1mJiZzcihvLGYscyxjLCEwKX1lOntpZigic2VsZWN0Ij09PSh1PShpPXI/ZV8ocik6d2luZG93KS5ub2RlTmFtZSYmaS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKXx8ImlucHV0Ij09PXUmJiJmaWxlIj09PWkudHlwZSl2YXIgZyx5PXVrO2Vsc2UgaWYodWgoaSkpe2lmKHV3KXk9dV87ZWxzZXt5PXVQO3ZhciB2PXV6fX1lbHNlKHU9aS5ub2RlTmFtZSkmJiJpbnB1dCI9PT11LnRvTG93ZXJDYXNlKCkmJigiY2hlY2tib3giPT09aS50eXBlfHwicmFkaW8iPT09aS50eXBlKSYmKHk9dU4pO2lmKHkmJih5PXkoZSxyKSkpe3VtKG8seSxuLGwpO2JyZWFrIGV9diYmdihlLGksciksImZvY3Vzb3V0Ij09PWUmJnImJiJudW1iZXIiPT09aS50eXBlJiZudWxsIT1yLm1lbW9pemVkUHJvcHMudmFsdWUmJmUyKGksIm51bWJlciIsaS52YWx1ZSl9c3dpdGNoKHY9cj9lXyhyKTp3aW5kb3csZSl7Y2FzZSJmb2N1c2luIjoodWgodil8fCJ0cnVlIj09PXYuY29udGVudEVkaXRhYmxlKSYmKHVSPXYsdU89cix1QT1udWxsKTticmVhaztjYXNlImZvY3Vzb3V0Ijp1QT11Tz11Uj1udWxsO2JyZWFrO2Nhc2UibW91c2Vkb3duIjp1ST0hMDticmVhaztjYXNlImNvbnRleHRtZW51IjpjYXNlIm1vdXNldXAiOmNhc2UiZHJhZ2VuZCI6dUk9ITEsdVUobyxuLGwpO2JyZWFrO2Nhc2Uic2VsZWN0aW9uY2hhbmdlIjppZih1RClicmVhaztjYXNlImtleWRvd24iOmNhc2Uia2V5dXAiOnVVKG8sbixsKX1pZih1YSl0Ontzd2l0Y2goZSl7Y2FzZSJjb21wb3NpdGlvbnN0YXJ0Ijp2YXIgYj0ib25Db21wb3NpdGlvblN0YXJ0IjticmVhayB0O2Nhc2UiY29tcG9zaXRpb25lbmQiOmI9Im9uQ29tcG9zaXRpb25FbmQiO2JyZWFrIHQ7Y2FzZSJjb21wb3NpdGlvbnVwZGF0ZSI6Yj0ib25Db21wb3NpdGlvblVwZGF0ZSI7YnJlYWsgdH1iPXZvaWQgMH1lbHNlIHVkP3VjKGUsbikmJihiPSJvbkNvbXBvc2l0aW9uRW5kIik6ImtleWRvd24iPT09ZSYmMjI5PT09bi5rZXlDb2RlJiYoYj0ib25Db21wb3NpdGlvblN0YXJ0Iik7YiYmKHV1JiYia28iIT09bi5sb2NhbGUmJih1ZHx8Im9uQ29tcG9zaXRpb25TdGFydCIhPT1iPyJvbkNvbXBvc2l0aW9uRW5kIj09PWImJnVkJiYoZz11cigpKToodXQ9InZhbHVlImluKHVlPWwpP3VlLnZhbHVlOnVlLnRleHRDb250ZW50LHVkPSEwKSksMDwodj1zdChyLGIpKS5sZW5ndGgmJihiPW5ldyBpXyhiLGUsbnVsbCxuLGwpLG8ucHVzaCh7ZXZlbnQ6YixsaXN0ZW5lcnM6dn0pLGc/Yi5kYXRhPWc6bnVsbCE9PShnPXVmKG4pKSYmKGIuZGF0YT1nKSkpLChnPXVpP2Z1bmN0aW9uKGUsdCl7c3dpdGNoKGUpe2Nhc2UiY29tcG9zaXRpb25lbmQiOnJldHVybiB1Zih0KTtjYXNlImtleXByZXNzIjppZigzMiE9PXQud2hpY2gpcmV0dXJuIG51bGw7cmV0dXJuIHVzPSEwLCIgIjtjYXNlInRleHRJbnB1dCI6cmV0dXJuIiAiPT09KGU9dC5kYXRhKSYmdXM/bnVsbDplO2RlZmF1bHQ6cmV0dXJuIG51bGx9fShlLG4pOmZ1bmN0aW9uKGUsdCl7aWYodWQpcmV0dXJuImNvbXBvc2l0aW9uZW5kIj09PWV8fCF1YSYmdWMoZSx0KT8oZT11cigpLHVuPXV0PXVlPW51bGwsdWQ9ITEsZSk6bnVsbDtzd2l0Y2goZSl7Y2FzZSJwYXN0ZSI6ZGVmYXVsdDpyZXR1cm4gbnVsbDtjYXNlImtleXByZXNzIjppZighKHQuY3RybEtleXx8dC5hbHRLZXl8fHQubWV0YUtleSl8fHQuY3RybEtleSYmdC5hbHRLZXkpe2lmKHQuY2hhciYmMTx0LmNoYXIubGVuZ3RoKXJldHVybiB0LmNoYXI7aWYodC53aGljaClyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0LndoaWNoKX1yZXR1cm4gbnVsbDtjYXNlImNvbXBvc2l0aW9uZW5kIjpyZXR1cm4gdXUmJiJrbyIhPT10LmxvY2FsZT9udWxsOnQuZGF0YX19KGUsbikpJiYwPChyPXN0KHIsIm9uQmVmb3JlSW5wdXQiKSkubGVuZ3RoJiYobD1uZXcgaV8oIm9uQmVmb3JlSW5wdXQiLCJiZWZvcmVpbnB1dCIsbnVsbCxuLGwpLG8ucHVzaCh7ZXZlbnQ6bCxsaXN0ZW5lcnM6cn0pLGwuZGF0YT1nKX11MyhvLHQpfSl9ZnVuY3Rpb24gc2UoZSx0LG4pe3JldHVybntpbnN0YW5jZTplLGxpc3RlbmVyOnQsY3VycmVudFRhcmdldDpufX1mdW5jdGlvbiBzdChlLHQpe2Zvcih2YXIgbj10KyJDYXB0dXJlIixyPVtdO251bGwhPT1lOyl7dmFyIGw9ZSxhPWwuc3RhdGVOb2RlOzUhPT0obD1sLnRhZykmJjI2IT09bCYmMjchPT1sfHxudWxsPT09YXx8KG51bGwhPShsPWlsKGUsbikpJiZyLnVuc2hpZnQoc2UoZSxsLGEpKSxudWxsIT0obD1pbChlLHQpKSYmci5wdXNoKHNlKGUsbCxhKSkpLGU9ZS5yZXR1cm59cmV0dXJuIHJ9ZnVuY3Rpb24gc24oZSl7aWYobnVsbD09PWUpcmV0dXJuIG51bGw7ZG8gZT1lLnJldHVybjt3aGlsZShlJiY1IT09ZS50YWcmJjI3IT09ZS50YWcpO3JldHVybiBlfHxudWxsfWZ1bmN0aW9uIHNyKGUsdCxuLHIsbCl7Zm9yKHZhciBhPXQuX3JlYWN0TmFtZSxvPVtdO251bGwhPT1uJiZuIT09cjspe3ZhciBpPW4sdT1pLmFsdGVybmF0ZSxzPWkuc3RhdGVOb2RlO2lmKGk9aS50YWcsbnVsbCE9PXUmJnU9PT1yKWJyZWFrOzUhPT1pJiYyNiE9PWkmJjI3IT09aXx8bnVsbD09PXN8fCh1PXMsbD9udWxsIT0ocz1pbChuLGEpKSYmby51bnNoaWZ0KHNlKG4scyx1KSk6bHx8bnVsbCE9KHM9aWwobixhKSkmJm8ucHVzaChzZShuLHMsdSkpKSxuPW4ucmV0dXJufTAhPT1vLmxlbmd0aCYmZS5wdXNoKHtldmVudDp0LGxpc3RlbmVyczpvfSl9dmFyIHNsPS9cclxuPy9nLHNhPS9cdTAwMDB8XHVGRkZEL2c7ZnVuY3Rpb24gc28oZSl7cmV0dXJuKCJzdHJpbmciPT10eXBlb2YgZT9lOiIiK2UpLnJlcGxhY2Uoc2wsIlxuIikucmVwbGFjZShzYSwiIil9ZnVuY3Rpb24gc2koZSx0LG4pe2lmKHQ9c28odCksc28oZSkhPT10JiZuKXRocm93IEVycm9yKGkoNDI1KSl9ZnVuY3Rpb24gc3UoKXt9ZnVuY3Rpb24gc3MoZSx0LG4scixsKXtzd2l0Y2gobil7Y2FzZSJjaGlsZHJlbiI6InN0cmluZyI9PXR5cGVvZiByPyJib2R5Ij09PXR8fCJ0ZXh0YXJlYSI9PT10JiYiIj09PXJ8fHRlKGUscik6Im51bWJlciI9PXR5cGVvZiByJiYiYm9keSIhPT10JiZ0ZShlLCIiK3IpO2JyZWFrO2Nhc2UiY2xhc3NOYW1lIjplVihlLCJjbGFzcyIscik7YnJlYWs7Y2FzZSJ0YWJJbmRleCI6ZVYoZSwidGFiaW5kZXgiLHIpO2JyZWFrO2Nhc2UiZGlyIjpjYXNlInJvbGUiOmNhc2Uidmlld0JveCI6Y2FzZSJ3aWR0aCI6Y2FzZSJoZWlnaHQiOmVWKGUsbixyKTticmVhaztjYXNlInN0eWxlIjp0bihlLHIpO2JyZWFrO2Nhc2Uic3JjIjpjYXNlImhyZWYiOmNhc2UiYWN0aW9uIjpjYXNlImZvcm1BY3Rpb24iOmlmKG51bGw9PXJ8fCJmdW5jdGlvbiI9PXR5cGVvZiByfHwic3ltYm9sIj09dHlwZW9mIHJ8fCJib29sZWFuIj09dHlwZW9mIHIpe2UucmVtb3ZlQXR0cmlidXRlKG4pO2JyZWFrfWUuc2V0QXR0cmlidXRlKG4sIiIrcik7YnJlYWs7Y2FzZSJvbkNsaWNrIjpudWxsIT1yJiYoZS5vbmNsaWNrPXN1KTticmVhaztjYXNlIm9uU2Nyb2xsIjpudWxsIT1yJiZ1NCgic2Nyb2xsIixlKTticmVhaztjYXNlImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIjppZihudWxsIT1yKXtpZigib2JqZWN0IiE9dHlwZW9mIHJ8fCEoIl9faHRtbCJpbiByKSl0aHJvdyBFcnJvcihpKDYxKSk7aWYobnVsbCE9KHI9ci5fX2h0bWwpKXtpZihudWxsIT1sLmNoaWxkcmVuKXRocm93IEVycm9yKGkoNjApKTtlOShlLHIpfX1icmVhaztjYXNlIm11bHRpcGxlIjplLm11bHRpcGxlPXImJiJmdW5jdGlvbiIhPXR5cGVvZiByJiYic3ltYm9sIiE9dHlwZW9mIHI7YnJlYWs7Y2FzZSJtdXRlZCI6ZS5tdXRlZD1yJiYiZnVuY3Rpb24iIT10eXBlb2YgciYmInN5bWJvbCIhPXR5cGVvZiByO2JyZWFrO2Nhc2Uic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIjpjYXNlInN1cHByZXNzSHlkcmF0aW9uV2FybmluZyI6Y2FzZSJkZWZhdWx0VmFsdWUiOmNhc2UiZGVmYXVsdENoZWNrZWQiOmNhc2UiaW5uZXJIVE1MIjpjYXNlImF1dG9Gb2N1cyI6YnJlYWs7Y2FzZSJ4bGlua0hyZWYiOmlmKG51bGw9PXJ8fCJmdW5jdGlvbiI9PXR5cGVvZiByfHwiYm9vbGVhbiI9PXR5cGVvZiByfHwic3ltYm9sIj09dHlwZW9mIHIpe2UucmVtb3ZlQXR0cmlidXRlKCJ4bGluazpocmVmIik7YnJlYWt9ZS5zZXRBdHRyaWJ1dGVOUygiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIsInhsaW5rOmhyZWYiLCIiK3IpO2JyZWFrO2Nhc2UiY29udGVudEVkaXRhYmxlIjpjYXNlInNwZWxsQ2hlY2siOmNhc2UiZHJhZ2dhYmxlIjpjYXNlInZhbHVlIjpjYXNlImF1dG9SZXZlcnNlIjpjYXNlImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQiOmNhc2UiZm9jdXNhYmxlIjpjYXNlInByZXNlcnZlQWxwaGEiOm51bGwhPXImJiJmdW5jdGlvbiIhPXR5cGVvZiByJiYic3ltYm9sIiE9dHlwZW9mIHI/ZS5zZXRBdHRyaWJ1dGUobiwiIityKTplLnJlbW92ZUF0dHJpYnV0ZShuKTticmVhaztjYXNlImFsbG93RnVsbFNjcmVlbiI6Y2FzZSJhc3luYyI6Y2FzZSJhdXRvUGxheSI6Y2FzZSJjb250cm9scyI6Y2FzZSJkZWZhdWx0IjpjYXNlImRlZmVyIjpjYXNlImRpc2FibGVkIjpjYXNlImRpc2FibGVQaWN0dXJlSW5QaWN0dXJlIjpjYXNlImRpc2FibGVSZW1vdGVQbGF5YmFjayI6Y2FzZSJmb3JtTm9WYWxpZGF0ZSI6Y2FzZSJoaWRkZW4iOmNhc2UibG9vcCI6Y2FzZSJub01vZHVsZSI6Y2FzZSJub1ZhbGlkYXRlIjpjYXNlIm9wZW4iOmNhc2UicGxheXNJbmxpbmUiOmNhc2UicmVhZE9ubHkiOmNhc2UicmVxdWlyZWQiOmNhc2UicmV2ZXJzZWQiOmNhc2Uic2NvcGVkIjpjYXNlInNlYW1sZXNzIjpjYXNlIml0ZW1TY29wZSI6ciYmImZ1bmN0aW9uIiE9dHlwZW9mIHImJiJzeW1ib2wiIT10eXBlb2Ygcj9lLnNldEF0dHJpYnV0ZShuLCIiKTplLnJlbW92ZUF0dHJpYnV0ZShuKTticmVhaztjYXNlImNhcHR1cmUiOmNhc2UiZG93bmxvYWQiOiEwPT09cj9lLnNldEF0dHJpYnV0ZShuLCIiKTohMSE9PXImJm51bGwhPXImJiJmdW5jdGlvbiIhPXR5cGVvZiByJiYic3ltYm9sIiE9dHlwZW9mIHI/ZS5zZXRBdHRyaWJ1dGUobixyKTplLnJlbW92ZUF0dHJpYnV0ZShuKTticmVhaztjYXNlImNvbHMiOmNhc2Uicm93cyI6Y2FzZSJzaXplIjpjYXNlInNwYW4iOm51bGwhPXImJiJmdW5jdGlvbiIhPXR5cGVvZiByJiYic3ltYm9sIiE9dHlwZW9mIHImJiFpc05hTihyKSYmMTw9cj9lLnNldEF0dHJpYnV0ZShuLHIpOmUucmVtb3ZlQXR0cmlidXRlKG4pO2JyZWFrO2Nhc2Uicm93U3BhbiI6Y2FzZSJzdGFydCI6bnVsbD09cnx8ImZ1bmN0aW9uIj09dHlwZW9mIHJ8fCJzeW1ib2wiPT10eXBlb2Ygcnx8aXNOYU4ocik/ZS5yZW1vdmVBdHRyaWJ1dGUobik6ZS5zZXRBdHRyaWJ1dGUobixyKTticmVhaztjYXNlInhsaW5rQWN0dWF0ZSI6ZSQoZSwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIsInhsaW5rOmFjdHVhdGUiLHIpO2JyZWFrO2Nhc2UieGxpbmtBcmNyb2xlIjplJChlLCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiwieGxpbms6YXJjcm9sZSIscik7YnJlYWs7Y2FzZSJ4bGlua1JvbGUiOmUkKGUsImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiLCJ4bGluazpyb2xlIixyKTticmVhaztjYXNlInhsaW5rU2hvdyI6ZSQoZSwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIsInhsaW5rOnNob3ciLHIpO2JyZWFrO2Nhc2UieGxpbmtUaXRsZSI6ZSQoZSwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIsInhsaW5rOnRpdGxlIixyKTticmVhaztjYXNlInhsaW5rVHlwZSI6ZSQoZSwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIsInhsaW5rOnR5cGUiLHIpO2JyZWFrO2Nhc2UieG1sQmFzZSI6ZSQoZSwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlIiwieG1sOmJhc2UiLHIpO2JyZWFrO2Nhc2UieG1sTGFuZyI6ZSQoZSwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlIiwieG1sOmxhbmciLHIpO2JyZWFrO2Nhc2UieG1sU3BhY2UiOmUkKGUsImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSIsInhtbDpzcGFjZSIscik7YnJlYWs7Y2FzZSJpcyI6ZVEoZSwiaXMiLHIpO2JyZWFrO2RlZmF1bHQ6MjxuLmxlbmd0aCYmKCJvIj09PW5bMF18fCJPIj09PW5bMF0pJiYoIm4iPT09blsxXXx8Ik4iPT09blsxXSl8fGVRKGUsbD10bC5nZXQobil8fG4scil9fWZ1bmN0aW9uIHNjKGUsdCxuLHIsbCl7c3dpdGNoKG4pe2Nhc2Uic3R5bGUiOnRuKGUscik7YnJlYWs7Y2FzZSJkYW5nZXJvdXNseVNldElubmVySFRNTCI6aWYobnVsbCE9cil7aWYoIm9iamVjdCIhPXR5cGVvZiByfHwhKCJfX2h0bWwiaW4gcikpdGhyb3cgRXJyb3IoaSg2MSkpO2lmKG51bGwhPSh0PXIuX19odG1sKSl7aWYobnVsbCE9bC5jaGlsZHJlbil0aHJvdyBFcnJvcihpKDYwKSk7ZTkoZSx0KX19YnJlYWs7Y2FzZSJjaGlsZHJlbiI6InN0cmluZyI9PXR5cGVvZiByP3RlKGUscik6Im51bWJlciI9PXR5cGVvZiByJiZ0ZShlLCIiK3IpO2JyZWFrO2Nhc2Uib25TY3JvbGwiOm51bGwhPXImJnU0KCJzY3JvbGwiLGUpO2JyZWFrO2Nhc2Uib25DbGljayI6bnVsbCE9ciYmKGUub25jbGljaz1zdSk7YnJlYWs7Y2FzZSJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmciOmNhc2Uic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nIjpjYXNlImlubmVySFRNTCI6YnJlYWs7ZGVmYXVsdDplRC5oYXNPd25Qcm9wZXJ0eShuKXx8KCJib29sZWFuIj09dHlwZW9mIHImJihyPSIiK3IpLGVRKGUsbixyKSl9fWZ1bmN0aW9uIHNmKGUsdCxuKXtzd2l0Y2godCl7Y2FzZSJkaXYiOmNhc2Uic3BhbiI6Y2FzZSJzdmciOmNhc2UicGF0aCI6Y2FzZSJhIjpjYXNlImciOmNhc2UicCI6Y2FzZSJsaSI6YnJlYWs7Y2FzZSJpbnB1dCI6dTQoImludmFsaWQiLGUpO3ZhciByPW51bGwsbD1udWxsLGE9bnVsbCxvPW51bGwsdT1udWxsLHM9bnVsbDtmb3IoZiBpbiBuKWlmKG4uaGFzT3duUHJvcGVydHkoZikpe3ZhciBjPW5bZl07aWYobnVsbCE9Yylzd2l0Y2goZil7Y2FzZSJuYW1lIjpyPWM7YnJlYWs7Y2FzZSJ0eXBlIjpsPWM7YnJlYWs7Y2FzZSJjaGVja2VkIjp1PWM7YnJlYWs7Y2FzZSJkZWZhdWx0Q2hlY2tlZCI6cz1jO2JyZWFrO2Nhc2UidmFsdWUiOmE9YzticmVhaztjYXNlImRlZmF1bHRWYWx1ZSI6bz1jO2JyZWFrO2Nhc2UiY2hpbGRyZW4iOmNhc2UiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiOmlmKG51bGwhPWMpdGhyb3cgRXJyb3IoaSgxMzcsdCkpO2JyZWFrO2RlZmF1bHQ6c3MoZSx0LGYsYyxuKX19ZTEoZSxhLG8sdSxzLGwsciwhMSksZVkoZSk7cmV0dXJuO2Nhc2Uic2VsZWN0Ijp1NCgiaW52YWxpZCIsZSk7dmFyIGY9bD1hPW51bGw7Zm9yKHIgaW4gbilpZihuLmhhc093blByb3BlcnR5KHIpJiZudWxsIT0obz1uW3JdKSlzd2l0Y2gocil7Y2FzZSJ2YWx1ZSI6YT1vO2JyZWFrO2Nhc2UiZGVmYXVsdFZhbHVlIjpsPW87YnJlYWs7Y2FzZSJtdWx0aXBsZSI6Zj1vO2RlZmF1bHQ6c3MoZSx0LHIsbyxuKX10PWEsbj1sLGUubXVsdGlwbGU9ISFmLG51bGwhPXQ/ZTQoZSwhIWYsdCwhMSk6bnVsbCE9biYmZTQoZSwhIWYsbiwhMCk7cmV0dXJuO2Nhc2UidGV4dGFyZWEiOmZvcihsIGluIHU0KCJpbnZhbGlkIixlKSxhPXI9Zj1udWxsLG4paWYobi5oYXNPd25Qcm9wZXJ0eShsKSYmbnVsbCE9KG89bltsXSkpc3dpdGNoKGwpe2Nhc2UidmFsdWUiOmY9bzticmVhaztjYXNlImRlZmF1bHRWYWx1ZSI6cj1vO2JyZWFrO2Nhc2UiY2hpbGRyZW4iOmE9bzticmVhaztjYXNlImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIjppZihudWxsIT1vKXRocm93IEVycm9yKGkoOTEpKTticmVhaztkZWZhdWx0OnNzKGUsdCxsLG8sbil9ZTYoZSxmLHIsYSksZVkoZSk7cmV0dXJuO2Nhc2Uib3B0aW9uIjpmb3IobyBpbiBuKW4uaGFzT3duUHJvcGVydHkobykmJm51bGwhPShmPW5bb10pJiYoInNlbGVjdGVkIj09PW8/ZS5zZWxlY3RlZD1mJiYiZnVuY3Rpb24iIT10eXBlb2YgZiYmInN5bWJvbCIhPXR5cGVvZiBmOnNzKGUsdCxvLGYsbikpO3JldHVybjtjYXNlImRpYWxvZyI6dTQoImNhbmNlbCIsZSksdTQoImNsb3NlIixlKTticmVhaztjYXNlImlmcmFtZSI6Y2FzZSJvYmplY3QiOnU0KCJsb2FkIixlKTticmVhaztjYXNlInZpZGVvIjpjYXNlImF1ZGlvIjpmb3IoZj0wO2Y8dTAubGVuZ3RoO2YrKyl1NCh1MFtmXSxlKTticmVhaztjYXNlImltYWdlIjp1NCgiZXJyb3IiLGUpLHU0KCJsb2FkIixlKTticmVhaztjYXNlImRldGFpbHMiOnU0KCJ0b2dnbGUiLGUpO2JyZWFrO2Nhc2UiZW1iZWQiOmNhc2Uic291cmNlIjpjYXNlImltZyI6Y2FzZSJsaW5rIjp1NCgiZXJyb3IiLGUpLHU0KCJsb2FkIixlKTtjYXNlImFyZWEiOmNhc2UiYmFzZSI6Y2FzZSJiciI6Y2FzZSJjb2wiOmNhc2UiaHIiOmNhc2Uia2V5Z2VuIjpjYXNlIm1ldGEiOmNhc2UicGFyYW0iOmNhc2UidHJhY2siOmNhc2Uid2JyIjpjYXNlIm1lbnVpdGVtIjpmb3IodSBpbiBuKWlmKG4uaGFzT3duUHJvcGVydHkodSkmJm51bGwhPShmPW5bdV0pKXN3aXRjaCh1KXtjYXNlImNoaWxkcmVuIjpjYXNlImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIjp0aHJvdyBFcnJvcihpKDEzNyx0KSk7ZGVmYXVsdDpzcyhlLHQsdSxmLG4pfXJldHVybjtkZWZhdWx0OmlmKHRyKHQpKXtmb3IocyBpbiBuKW4uaGFzT3duUHJvcGVydHkocykmJm51bGwhPShmPW5bc10pJiZzYyhlLHQscyxmLG4pO3JldHVybn19Zm9yKGEgaW4gbiluLmhhc093blByb3BlcnR5KGEpJiZudWxsIT0oZj1uW2FdKSYmc3MoZSx0LGEsZixuKX1mdW5jdGlvbiBzZChlLHQsbixyLGwpe3N3aXRjaChuKXtjYXNlImRpdiI6Y2FzZSJzcGFuIjpjYXNlInN2ZyI6Y2FzZSJwYXRoIjpjYXNlImEiOmNhc2UiZyI6Y2FzZSJwIjpjYXNlImxpIjpicmVhaztjYXNlImlucHV0Ijp2YXIgYT1sLm5hbWUsbz1sLnR5cGUsdT1sLnZhbHVlLHM9bC5kZWZhdWx0VmFsdWU7cj1yLmRlZmF1bHRWYWx1ZTtmb3IodmFyIGM9bC5jaGVja2VkLGY9bC5kZWZhdWx0Q2hlY2tlZCxkPTA7ZDx0Lmxlbmd0aDtkKz0yKXt2YXIgcD10W2RdLGg9dFtkKzFdO3N3aXRjaChwKXtjYXNlInR5cGUiOmNhc2UibmFtZSI6Y2FzZSJjaGVja2VkIjpjYXNlImRlZmF1bHRDaGVja2VkIjpjYXNlInZhbHVlIjpjYXNlImRlZmF1bHRWYWx1ZSI6YnJlYWs7Y2FzZSJjaGlsZHJlbiI6Y2FzZSJkYW5nZXJvdXNseVNldElubmVySFRNTCI6aWYobnVsbCE9aCl0aHJvdyBFcnJvcihpKDEzNyxuKSk7YnJlYWs7ZGVmYXVsdDpzcyhlLG4scCxoLGwpfX1lMChlLHUscyxyLGMsZixvLGEpO3JldHVybjtjYXNlInNlbGVjdCI6Zm9yKGE9bC52YWx1ZSxvPWwuZGVmYXVsdFZhbHVlLHU9bC5tdWx0aXBsZSxzPXIubXVsdGlwbGUscj0wO3I8dC5sZW5ndGg7cis9MiljPXRbcl0sZj10W3IrMV0sInZhbHVlIj09PWN8fHNzKGUsbixjLGYsbCk7bnVsbCE9YT9lNChlLCEhdSxhLCExKTohIXMhPSEhdSYmKG51bGwhPW8/ZTQoZSwhIXUsbywhMCk6ZTQoZSwhIXUsdT9bXToiIiwhMSkpO3JldHVybjtjYXNlInRleHRhcmVhIjpmb3IodT0wLGE9bC52YWx1ZSxvPWwuZGVmYXVsdFZhbHVlO3U8dC5sZW5ndGg7dSs9Milzd2l0Y2gocz10W3VdLHI9dFt1KzFdLHMpe2Nhc2UidmFsdWUiOmNhc2UiY2hpbGRyZW4iOmJyZWFrO2Nhc2UiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiOmlmKG51bGwhPXIpdGhyb3cgRXJyb3IoaSg5MSkpO2JyZWFrO2RlZmF1bHQ6c3MoZSxuLHMscixsKX1lOChlLGEsbyk7cmV0dXJuO2Nhc2Uib3B0aW9uIjpmb3IoYT0wO2E8dC5sZW5ndGg7YSs9Mikobz10W2FdLHU9dFthKzFdLCJzZWxlY3RlZCI9PT1vKT9lLnNlbGVjdGVkPXUmJiJmdW5jdGlvbiIhPXR5cGVvZiB1JiYic3ltYm9sIiE9dHlwZW9mIHU6c3MoZSxuLG8sdSxsKTtyZXR1cm47Y2FzZSJpbWciOmNhc2UibGluayI6Y2FzZSJhcmVhIjpjYXNlImJhc2UiOmNhc2UiYnIiOmNhc2UiY29sIjpjYXNlImVtYmVkIjpjYXNlImhyIjpjYXNlImtleWdlbiI6Y2FzZSJtZXRhIjpjYXNlInBhcmFtIjpjYXNlInNvdXJjZSI6Y2FzZSJ0cmFjayI6Y2FzZSJ3YnIiOmNhc2UibWVudWl0ZW0iOmZvcihhPTA7YTx0Lmxlbmd0aDthKz0yKXN3aXRjaChvPXRbYV0sdT10W2ErMV0sbyl7Y2FzZSJjaGlsZHJlbiI6Y2FzZSJkYW5nZXJvdXNseVNldElubmVySFRNTCI6aWYobnVsbCE9dSl0aHJvdyBFcnJvcihpKDEzNyxuKSk7YnJlYWs7ZGVmYXVsdDpzcyhlLG4sbyx1LGwpfXJldHVybjtkZWZhdWx0OmlmKHRyKG4pKXtmb3IoYT0wO2E8dC5sZW5ndGg7YSs9MilzYyhlLG4sdFthXSx0W2ErMV0sbCk7cmV0dXJufX1mb3IoYT0wO2E8dC5sZW5ndGg7YSs9MilzcyhlLG4sdFthXSx0W2ErMV0sbCl9dmFyIHNwPW51bGwsc2g9bnVsbDtmdW5jdGlvbiBzbShlKXtyZXR1cm4gOT09PWUubm9kZVR5cGU/ZTplLm93bmVyRG9jdW1lbnR9ZnVuY3Rpb24gc2coZSl7c3dpdGNoKGUpe2Nhc2UiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciOnJldHVybiAxO2Nhc2UiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCI6cmV0dXJuIDI7ZGVmYXVsdDpyZXR1cm4gMH19ZnVuY3Rpb24gc3koZSx0KXtpZigwPT09ZSlzd2l0Y2godCl7Y2FzZSJzdmciOnJldHVybiAxO2Nhc2UibWF0aCI6cmV0dXJuIDI7ZGVmYXVsdDpyZXR1cm4gMH1yZXR1cm4gMT09PWUmJiJmb3JlaWduT2JqZWN0Ij09PXQ/MDplfWZ1bmN0aW9uIHN2KGUsdCl7cmV0dXJuInRleHRhcmVhIj09PWV8fCJub3NjcmlwdCI9PT1lfHwic3RyaW5nIj09dHlwZW9mIHQuY2hpbGRyZW58fCJudW1iZXIiPT10eXBlb2YgdC5jaGlsZHJlbnx8Im9iamVjdCI9PXR5cGVvZiB0LmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiZudWxsIT09dC5kYW5nZXJvdXNseVNldElubmVySFRNTCYmbnVsbCE9dC5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWx9dmFyIHNiPSJmdW5jdGlvbiI9PXR5cGVvZiBzZXRUaW1lb3V0P3NldFRpbWVvdXQ6dm9pZCAwLHNrPSJmdW5jdGlvbiI9PXR5cGVvZiBjbGVhclRpbWVvdXQ/Y2xlYXJUaW1lb3V0OnZvaWQgMCxzdz0iZnVuY3Rpb24iPT10eXBlb2YgUHJvbWlzZT9Qcm9taXNlOnZvaWQgMCxzUz0iZnVuY3Rpb24iPT10eXBlb2YgcXVldWVNaWNyb3Rhc2s/cXVldWVNaWNyb3Rhc2s6dm9pZCAwIT09c3c/ZnVuY3Rpb24oZSl7cmV0dXJuIHN3LnJlc29sdmUobnVsbCkudGhlbihlKS5jYXRjaChzRSl9OnNiO2Z1bmN0aW9uIHNFKGUpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0aHJvdyBlfSl9ZnVuY3Rpb24gc0MoZSx0KXt2YXIgbj10LHI9MDtkb3t2YXIgbD1uLm5leHRTaWJsaW5nO2lmKGUucmVtb3ZlQ2hpbGQobiksbCYmOD09PWwubm9kZVR5cGUpe2lmKCIvJCI9PT0obj1sLmRhdGEpKXtpZigwPT09cil7ZS5yZW1vdmVDaGlsZChsKSxpMSh0KTtyZXR1cm59ci0tfWVsc2UiJCIhPT1uJiYiJD8iIT09biYmIiQhIiE9PW58fHIrK31uPWx9d2hpbGUobik7aTEodCl9ZnVuY3Rpb24gc3goZSl7dmFyIHQ9ZS5ub2RlVHlwZTtpZig5PT09dClzeihlKTtlbHNlIGlmKDE9PT10KXN3aXRjaChlLm5vZGVOYW1lKXtjYXNlIkhFQUQiOmNhc2UiSFRNTCI6Y2FzZSJCT0RZIjpzeihlKTticmVhaztkZWZhdWx0OmUudGV4dENvbnRlbnQ9IiJ9fWZ1bmN0aW9uIHN6KGUpe3ZhciB0PWUuZmlyc3RDaGlsZDtmb3IodCYmMTA9PT10Lm5vZGVUeXBlJiYodD10Lm5leHRTaWJsaW5nKTt0Oyl7dmFyIG49dDtzd2l0Y2godD10Lm5leHRTaWJsaW5nLG4ubm9kZU5hbWUpe2Nhc2UiSFRNTCI6Y2FzZSJIRUFEIjpjYXNlIkJPRFkiOnN6KG4pLGV6KG4pO2NvbnRpbnVlO2Nhc2UiU0NSSVBUIjpjYXNlIlNUWUxFIjpjb250aW51ZTtjYXNlIkxJTksiOmlmKCJzdHlsZXNoZWV0Ij09PW4ucmVsLnRvTG93ZXJDYXNlKCkpY29udGludWV9ZS5yZW1vdmVDaGlsZChuKX19ZnVuY3Rpb24gc1AoZSl7Zm9yKDtudWxsIT1lO2U9ZS5uZXh0U2libGluZyl7dmFyIHQ9ZS5ub2RlVHlwZTtpZigxPT09dHx8Mz09PXQpYnJlYWs7aWYoOD09PXQpe2lmKCIkIj09PSh0PWUuZGF0YSl8fCIkISI9PT10fHwiJD8iPT09dClicmVhaztpZigiLyQiPT09dClyZXR1cm4gbnVsbH19cmV0dXJuIGV9ZnVuY3Rpb24gc04oZSl7ZT1lLnByZXZpb3VzU2libGluZztmb3IodmFyIHQ9MDtlOyl7aWYoOD09PWUubm9kZVR5cGUpe3ZhciBuPWUuZGF0YTtpZigiJCI9PT1ufHwiJCEiPT09bnx8IiQ/Ij09PW4pe2lmKDA9PT10KXJldHVybiBlO3QtLX1lbHNlIi8kIj09PW4mJnQrK31lPWUucHJldmlvdXNTaWJsaW5nfXJldHVybiBudWxsfWZ1bmN0aW9uIHNfKGUsdCxuKXtzd2l0Y2godD1zbShuKSxlKXtjYXNlImh0bWwiOmlmKCEoZT10LmRvY3VtZW50RWxlbWVudCkpdGhyb3cgRXJyb3IoaSg0NTIpKTtyZXR1cm4gZTtjYXNlImhlYWQiOmlmKCEoZT10LmhlYWQpKXRocm93IEVycm9yKGkoNDUzKSk7cmV0dXJuIGU7Y2FzZSJib2R5IjppZighKGU9dC5ib2R5KSl0aHJvdyBFcnJvcihpKDQ1NCkpO3JldHVybiBlO2RlZmF1bHQ6dGhyb3cgRXJyb3IoaSg0NTEpKX19dmFyIHNMPW5ldyBNYXAsc1Q9bmV3IFNldDtmdW5jdGlvbiBzTShlKXtyZXR1cm4iZnVuY3Rpb24iPT10eXBlb2YgZS5nZXRSb290Tm9kZT9lLmdldFJvb3ROb2RlKCk6ZS5vd25lckRvY3VtZW50fXZhciBzRj17cHJlZmV0Y2hETlM6ZnVuY3Rpb24oZSl7c0QoImRucy1wcmVmZXRjaCIsbnVsbCxlKX0scHJlY29ubmVjdDpmdW5jdGlvbihlLHQpe3NEKCJwcmVjb25uZWN0IixudWxsPT10fHwic3RyaW5nIiE9dHlwZW9mIHQuY3Jvc3NPcmlnaW4/bnVsbDoidXNlLWNyZWRlbnRpYWxzIj09PXQuY3Jvc3NPcmlnaW4/InVzZS1jcmVkZW50aWFscyI6IiIsZSl9LHByZWxvYWQ6ZnVuY3Rpb24oZSx0KXt2YXIgbj1kb2N1bWVudDtpZigic3RyaW5nIj09dHlwZW9mIGUmJmUmJiJvYmplY3QiPT10eXBlb2YgdCYmbnVsbCE9PXQmJiJzdHJpbmciPT10eXBlb2YgdC5hcyYmdC5hcyYmbil7dmFyIHI9dC5hcyxsPSdsaW5rW3JlbD0icHJlbG9hZCJdW2FzPSInK2VKKHIpKyciXSc7aWYoImltYWdlIj09PXIpe3ZhciBhPXQuaW1hZ2VTcmNTZXQsbz10LmltYWdlU2l6ZXM7InN0cmluZyI9PXR5cGVvZiBhJiYiIiE9PWE/KGwrPSdbaW1hZ2VzcmNzZXQ9IicrZUooYSkrJyJdJywic3RyaW5nIj09dHlwZW9mIG8mJihsKz0nW2ltYWdlc2l6ZXM9IicrZUoobykrJyJdJykpOmwrPSdbaHJlZj0iJytlSihlKSsnIl0nfWVsc2UgbCs9J1tocmVmPSInK2VKKGUpKyciXSc7c3dpdGNoKGE9bCxyKXtjYXNlInN0eWxlIjphPXNSKGUpO2JyZWFrO2Nhc2Uic2NyaXB0IjphPXNJKGUpfXNMLmhhcyhhKXx8KGU9e3JlbDoicHJlbG9hZCIsYXM6cixocmVmOiJpbWFnZSI9PT1yJiZ0LmltYWdlU3JjU2V0P3ZvaWQgMDplLGNyb3NzT3JpZ2luOiJmb250Ij09PXI/IiI6dC5jcm9zc09yaWdpbixpbnRlZ3JpdHk6dC5pbnRlZ3JpdHksdHlwZTp0LnR5cGUsbm9uY2U6dC5ub25jZSxmZXRjaFByaW9yaXR5OnQuZmV0Y2hQcmlvcml0eSxpbWFnZVNyY1NldDp0LmltYWdlU3JjU2V0LGltYWdlU2l6ZXM6dC5pbWFnZVNpemVzLHJlZmVycmVyUG9saWN5OnQucmVmZXJyZXJQb2xpY3l9LHNMLnNldChhLGUpLG51bGwhPT1uLnF1ZXJ5U2VsZWN0b3IobCl8fCJzdHlsZSI9PT1yJiZuLnF1ZXJ5U2VsZWN0b3Ioc08oYSkpfHwic2NyaXB0Ij09PXImJm4ucXVlcnlTZWxlY3Rvcigic2NyaXB0W2FzeW5jXSIrYSl8fChzZihyPW4uY3JlYXRlRWxlbWVudCgibGluayIpLCJsaW5rIixlKSxlTShyKSxuLmhlYWQuYXBwZW5kQ2hpbGQocikpKX19LHByZWluaXQ6ZnVuY3Rpb24oZSx0KXt2YXIgbj1kb2N1bWVudDtpZigic3RyaW5nIj09dHlwZW9mIGUmJmUmJiJvYmplY3QiPT10eXBlb2YgdCYmbnVsbCE9PXQpc3dpdGNoKHQuYXMpe2Nhc2Uic3R5bGUiOnZhciByPWVUKG4pLmhvaXN0YWJsZVN0eWxlcyxsPXNSKGUpLGE9dC5wcmVjZWRlbmNlfHwiZGVmYXVsdCIsbz1yLmdldChsKTtpZihvKWJyZWFrO3ZhciBpPXtsb2FkaW5nOjAscHJlbG9hZDpudWxsfTtpZihvPW4ucXVlcnlTZWxlY3RvcihzTyhsKSkpaS5sb2FkaW5nPTE7ZWxzZXtlPXtyZWw6InN0eWxlc2hlZXQiLGhyZWY6ZSwiZGF0YS1wcmVjZWRlbmNlIjphLGNyb3NzT3JpZ2luOnQuY3Jvc3NPcmlnaW4saW50ZWdyaXR5OnQuaW50ZWdyaXR5LGZldGNoUHJpb3JpdHk6dC5mZXRjaFByaW9yaXR5fSwodD1zTC5nZXQobCkpJiZzUShlLHQpO3ZhciB1PW89bi5jcmVhdGVFbGVtZW50KCJsaW5rIik7ZU0odSksc2YodSwibGluayIsZSksdS5fcD1uZXcgUHJvbWlzZShmdW5jdGlvbihlLHQpe3Uub25sb2FkPWUsdS5vbmVycm9yPXR9KSx1LmFkZEV2ZW50TGlzdGVuZXIoImxvYWQiLGZ1bmN0aW9uKCl7aS5sb2FkaW5nfD0xfSksdS5hZGRFdmVudExpc3RlbmVyKCJlcnJvciIsZnVuY3Rpb24oKXtpLmxvYWRpbmd8PTJ9KSxpLmxvYWRpbmd8PTQsc0IobyxhLG4pfW89e3R5cGU6InN0eWxlc2hlZXQiLGluc3RhbmNlOm8sY291bnQ6MSxzdGF0ZTppfSxyLnNldChsLG8pO2JyZWFrO2Nhc2Uic2NyaXB0IjpyPWVUKG4pLmhvaXN0YWJsZVNjcmlwdHMsbD1zSShlKSwoYT1yLmdldChsKSl8fCgoYT1uLnF1ZXJ5U2VsZWN0b3IoInNjcmlwdFthc3luY10iK2wpKXx8KGU9e3NyYzplLGFzeW5jOiEwLGNyb3NzT3JpZ2luOnQuY3Jvc3NPcmlnaW4saW50ZWdyaXR5OnQuaW50ZWdyaXR5LG5vbmNlOnQubm9uY2UsZmV0Y2hQcmlvcml0eTp0LmZldGNoUHJpb3JpdHl9LCh0PXNMLmdldChsKSkmJnNWKGUsdCksZU0oYT1uLmNyZWF0ZUVsZW1lbnQoInNjcmlwdCIpKSxzZihhLCJsaW5rIixlKSxuLmhlYWQuYXBwZW5kQ2hpbGQoYSkpLGE9e3R5cGU6InNjcmlwdCIsaW5zdGFuY2U6YSxjb3VudDoxLHN0YXRlOm51bGx9LHIuc2V0KGwsYSkpfX19O2Z1bmN0aW9uIHNEKGUsdCxuKXt2YXIgcj1kb2N1bWVudDtpZigic3RyaW5nIj09dHlwZW9mIG4mJm4pe3ZhciBsPWVKKG4pO2w9J2xpbmtbcmVsPSInK2UrJyJdW2hyZWY9IicrbCsnIl0nLCJzdHJpbmciPT10eXBlb2YgdCYmKGwrPSdbY3Jvc3NvcmlnaW49IicrdCsnIl0nKSxzVC5oYXMobCl8fChzVC5hZGQobCksZT17cmVsOmUsY3Jvc3NPcmlnaW46dCxocmVmOm59LG51bGw9PT1yLnF1ZXJ5U2VsZWN0b3IobCkmJihzZih0PXIuY3JlYXRlRWxlbWVudCgibGluayIpLCJsaW5rIixlKSxlTSh0KSxyLmhlYWQuYXBwZW5kQ2hpbGQodCkpKX19ZnVuY3Rpb24gc1IoZSl7cmV0dXJuJ2hyZWY9IicrZUooZSkrJyInfWZ1bmN0aW9uIHNPKGUpe3JldHVybidsaW5rW3JlbD0ic3R5bGVzaGVldCJdWycrZSsiXSJ9ZnVuY3Rpb24gc0EoZSl7cmV0dXJuIHUoe30sZSx7ImRhdGEtcHJlY2VkZW5jZSI6ZS5wcmVjZWRlbmNlLHByZWNlZGVuY2U6bnVsbH0pfWZ1bmN0aW9uIHNJKGUpe3JldHVybidbc3JjPSInK2VKKGUpKyciXSd9ZnVuY3Rpb24gc1UoZSx0LG4pe2lmKHQuY291bnQrKyxudWxsPT09dC5pbnN0YW5jZSlzd2l0Y2godC50eXBlKXtjYXNlInN0eWxlIjp2YXIgcj1lLnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlW2RhdGEtaHJlZn49IicrZUoobi5ocmVmKSsnIl0nKTtpZihyKXJldHVybiB0Lmluc3RhbmNlPXIsZU0ocikscjt2YXIgbD11KHt9LG4seyJkYXRhLWhyZWYiOm4uaHJlZiwiZGF0YS1wcmVjZWRlbmNlIjpuLnByZWNlZGVuY2UsaHJlZjpudWxsLHByZWNlZGVuY2U6bnVsbH0pO3JldHVybiBlTShyPShlLm93bmVyRG9jdW1lbnR8fGUpLmNyZWF0ZUVsZW1lbnQoInN0eWxlIikpLHNmKHIsInN0eWxlIixsKSxzQihyLG4ucHJlY2VkZW5jZSxlKSx0Lmluc3RhbmNlPXI7Y2FzZSJzdHlsZXNoZWV0IjpsPXNSKG4uaHJlZik7dmFyIGE9ZS5xdWVyeVNlbGVjdG9yKHNPKGwpKTtpZihhKXJldHVybiB0Lmluc3RhbmNlPWEsZU0oYSksYTtyPXNBKG4pLChsPXNMLmdldChsKSkmJnNRKHIsbCksZU0oYT0oZS5vd25lckRvY3VtZW50fHxlKS5jcmVhdGVFbGVtZW50KCJsaW5rIikpO3ZhciBvPWE7cmV0dXJuIG8uX3A9bmV3IFByb21pc2UoZnVuY3Rpb24oZSx0KXtvLm9ubG9hZD1lLG8ub25lcnJvcj10fSksc2YoYSwibGluayIsciksdC5zdGF0ZS5sb2FkaW5nfD00LHNCKGEsbi5wcmVjZWRlbmNlLGUpLHQuaW5zdGFuY2U9YTtjYXNlInNjcmlwdCI6aWYoYT1zSShuLnNyYyksbD1lLnF1ZXJ5U2VsZWN0b3IoInNjcmlwdFthc3luY10iK2EpKXJldHVybiB0Lmluc3RhbmNlPWwsZU0obCksbDtyZXR1cm4gcj1uLChsPXNMLmdldChhKSkmJnNWKHI9dSh7fSxuKSxsKSxlTShsPShlPWUub3duZXJEb2N1bWVudHx8ZSkuY3JlYXRlRWxlbWVudCgic2NyaXB0IikpLHNmKGwsImxpbmsiLHIpLGUuaGVhZC5hcHBlbmRDaGlsZChsKSx0Lmluc3RhbmNlPWw7Y2FzZSJ2b2lkIjpyZXR1cm4gbnVsbDtkZWZhdWx0OnRocm93IEVycm9yKGkoNDQzLHQudHlwZSkpfWVsc2Uic3R5bGVzaGVldCI9PT10LnR5cGUmJjA9PSg0JnQuc3RhdGUubG9hZGluZykmJihyPXQuaW5zdGFuY2UsdC5zdGF0ZS5sb2FkaW5nfD00LHNCKHIsbi5wcmVjZWRlbmNlLGUpKTtyZXR1cm4gdC5pbnN0YW5jZX1mdW5jdGlvbiBzQihlLHQsbil7Zm9yKHZhciByPW4ucXVlcnlTZWxlY3RvckFsbCgnbGlua1tyZWw9InN0eWxlc2hlZXQiXVtkYXRhLXByZWNlZGVuY2VdLHN0eWxlW2RhdGEtcHJlY2VkZW5jZV0nKSxsPXIubGVuZ3RoP3Jbci5sZW5ndGgtMV06bnVsbCxhPWwsbz0wO288ci5sZW5ndGg7bysrKXt2YXIgaT1yW29dO2lmKGkuZGF0YXNldC5wcmVjZWRlbmNlPT09dClhPWk7ZWxzZSBpZihhIT09bClicmVha31hP2EucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZSxhLm5leHRTaWJsaW5nKToodD05PT09bi5ub2RlVHlwZT9uLmhlYWQ6bikuaW5zZXJ0QmVmb3JlKGUsdC5maXJzdENoaWxkKX1mdW5jdGlvbiBzUShlLHQpe251bGw9PWUuY3Jvc3NPcmlnaW4mJihlLmNyb3NzT3JpZ2luPXQuY3Jvc3NPcmlnaW4pLG51bGw9PWUucmVmZXJyZXJQb2xpY3kmJihlLnJlZmVycmVyUG9saWN5PXQucmVmZXJyZXJQb2xpY3kpLG51bGw9PWUudGl0bGUmJihlLnRpdGxlPXQudGl0bGUpfWZ1bmN0aW9uIHNWKGUsdCl7bnVsbD09ZS5jcm9zc09yaWdpbiYmKGUuY3Jvc3NPcmlnaW49dC5jcm9zc09yaWdpbiksbnVsbD09ZS5yZWZlcnJlclBvbGljeSYmKGUucmVmZXJyZXJQb2xpY3k9dC5yZWZlcnJlclBvbGljeSksbnVsbD09ZS5pbnRlZ3JpdHkmJihlLnJlZmVycmVyUG9saWN5PXQuaW50ZWdyaXR5KX12YXIgcyQ9bnVsbDtmdW5jdGlvbiBzVyhlLHQsbil7aWYobnVsbD09PXMkKXt2YXIgcj1uZXcgTWFwLGw9cyQ9bmV3IE1hcDtsLnNldChuLHIpfWVsc2Uocj0obD1zJCkuZ2V0KG4pKXx8KHI9bmV3IE1hcCxsLnNldChuLHIpKTtpZihyLmhhcyhlKSlyZXR1cm4gcjtmb3Ioci5zZXQoZSxudWxsKSxuPW4uZ2V0RWxlbWVudHNCeVRhZ05hbWUoZSksbD0wO2w8bi5sZW5ndGg7bCsrKXt2YXIgYT1uW2xdO2lmKCEoYVtleF18fGFbZXZdfHwibGluayI9PT1lJiYic3R5bGVzaGVldCI9PT1hLmdldEF0dHJpYnV0ZSgicmVsIikpJiYiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIT09YS5uYW1lc3BhY2VVUkkpe3ZhciBvPWEuZ2V0QXR0cmlidXRlKHQpfHwiIjtvPWUrbzt2YXIgaT1yLmdldChvKTtpP2kucHVzaChhKTpyLnNldChvLFthXSl9fXJldHVybiByfWZ1bmN0aW9uIHNqKGUsdCxuKXsoZT1lLm93bmVyRG9jdW1lbnR8fGUpLmhlYWQuaW5zZXJ0QmVmb3JlKG4sInRpdGxlIj09PXQ/ZS5xdWVyeVNlbGVjdG9yKCJoZWFkID4gdGl0bGUiKTpudWxsKX12YXIgc0g9bnVsbDtmdW5jdGlvbiBzcSgpe31mdW5jdGlvbiBzSygpe2lmKHRoaXMuY291bnQtLSwwPT09dGhpcy5jb3VudCl7aWYodGhpcy5zdHlsZXNoZWV0cylzWCh0aGlzLHRoaXMuc3R5bGVzaGVldHMpO2Vsc2UgaWYodGhpcy51bnN1c3BlbmQpe3ZhciBlPXRoaXMudW5zdXNwZW5kO3RoaXMudW5zdXNwZW5kPW51bGwsZSgpfX19dmFyIHNZPW51bGw7ZnVuY3Rpb24gc1goZSx0KXtlLnN0eWxlc2hlZXRzPW51bGwsbnVsbCE9PWUudW5zdXNwZW5kJiYoZS5jb3VudCsrLHNZPW5ldyBNYXAsdC5mb3JFYWNoKHNHLGUpLHNZPW51bGwsc0suY2FsbChlKSl9ZnVuY3Rpb24gc0coZSx0KXtpZighKDQmdC5zdGF0ZS5sb2FkaW5nKSl7dmFyIG49c1kuZ2V0KGUpO2lmKG4pdmFyIHI9bi5nZXQoImxhc3QiKTtlbHNle249bmV3IE1hcCxzWS5zZXQoZSxuKTtmb3IodmFyIGw9ZS5xdWVyeVNlbGVjdG9yQWxsKCJsaW5rW2RhdGEtcHJlY2VkZW5jZV0sc3R5bGVbZGF0YS1wcmVjZWRlbmNlXSIpLGE9MDthPGwubGVuZ3RoO2ErKyl7dmFyIG89bFthXTsoImxpbmsiPT09by5ub2RlTmFtZXx8Im5vdCBhbGwiIT09by5nZXRBdHRyaWJ1dGUoIm1lZGlhIikpJiYobi5zZXQoInAiK28uZGF0YXNldC5wcmVjZWRlbmNlLG8pLHI9byl9ciYmbi5zZXQoImxhc3QiLHIpfW89KGw9dC5pbnN0YW5jZSkuZ2V0QXR0cmlidXRlKCJkYXRhLXByZWNlZGVuY2UiKSwoYT1uLmdldCgicCIrbyl8fHIpPT09ciYmbi5zZXQoImxhc3QiLGwpLG4uc2V0KG8sbCksdGhpcy5jb3VudCsrLHI9c0suYmluZCh0aGlzKSxsLmFkZEV2ZW50TGlzdGVuZXIoImxvYWQiLHIpLGwuYWRkRXZlbnRMaXN0ZW5lcigiZXJyb3IiLHIpLGE/YS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShsLGEubmV4dFNpYmxpbmcpOihlPTk9PT1lLm5vZGVUeXBlP2UuaGVhZDplKS5pbnNlcnRCZWZvcmUobCxlLmZpcnN0Q2hpbGQpLHQuc3RhdGUubG9hZGluZ3w9NH19dmFyIHNaPW8uRGlzcGF0Y2hlcjsidW5kZWZpbmVkIiE9dHlwZW9mIGRvY3VtZW50JiYoc1ouY3VycmVudD1zRik7dmFyIHNKPSJmdW5jdGlvbiI9PXR5cGVvZiByZXBvcnRFcnJvcj9yZXBvcnRFcnJvcjpmdW5jdGlvbihlKXtjb25zb2xlLmVycm9yKGUpfTtmdW5jdGlvbiBzMChlKXt0aGlzLl9pbnRlcm5hbFJvb3Q9ZX1mdW5jdGlvbiBzMShlKXt0aGlzLl9pbnRlcm5hbFJvb3Q9ZX1mdW5jdGlvbiBzMihlKXtyZXR1cm4hKCFlfHwxIT09ZS5ub2RlVHlwZSYmOSE9PWUubm9kZVR5cGUmJjExIT09ZS5ub2RlVHlwZSl9ZnVuY3Rpb24gczMoZSl7cmV0dXJuISghZXx8MSE9PWUubm9kZVR5cGUmJjkhPT1lLm5vZGVUeXBlJiYxMSE9PWUubm9kZVR5cGUmJig4IT09ZS5ub2RlVHlwZXx8IiByZWFjdC1tb3VudC1wb2ludC11bnN0YWJsZSAiIT09ZS5ub2RlVmFsdWUpKX1mdW5jdGlvbiBzNCgpe31mdW5jdGlvbiBzOChlLHQsbixyLGwpe3ZhciBhPW4uX3JlYWN0Um9vdENvbnRhaW5lcjtpZihhKXt2YXIgbz1hO2lmKCJmdW5jdGlvbiI9PXR5cGVvZiBsKXt2YXIgaT1sO2w9ZnVuY3Rpb24oKXt2YXIgZT1vNShvKTtpLmNhbGwoZSl9fW82KHQsbyxlLGwpfWVsc2Ugbz1mdW5jdGlvbihlLHQsbixyLGwpe2lmKGwpe2lmKCJmdW5jdGlvbiI9PXR5cGVvZiByKXt2YXIgYT1yO3I9ZnVuY3Rpb24oKXt2YXIgZT1vNShvKTthLmNhbGwoZSl9fXZhciBvPW84KHQscixlLDAsbnVsbCwhMSwhMSwiIixzNCk7cmV0dXJuIGUuX3JlYWN0Um9vdENvbnRhaW5lcj1vLGVbZWtdPW8uY3VycmVudCx1NSg4PT09ZS5ub2RlVHlwZT9lLnBhcmVudE5vZGU6ZSksb0UoKSxvfWlmKHN4KGUpLCJmdW5jdGlvbiI9PXR5cGVvZiByKXt2YXIgaT1yO3I9ZnVuY3Rpb24oKXt2YXIgZT1vNSh1KTtpLmNhbGwoZSl9fXZhciB1PW8zKGUsMCwhMSxudWxsLG51bGwsITEsITEsIiIsczQpO3JldHVybiBlLl9yZWFjdFJvb3RDb250YWluZXI9dSxlW2VrXT11LmN1cnJlbnQsdTUoOD09PWUubm9kZVR5cGU/ZS5wYXJlbnROb2RlOmUpLG9FKGZ1bmN0aW9uKCl7bzYodCx1LG4scil9KSx1fShuLHQsZSxsLHIpO3JldHVybiBvNShvKX1zMS5wcm90b3R5cGUucmVuZGVyPXMwLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5faW50ZXJuYWxSb290O2lmKG51bGw9PT10KXRocm93IEVycm9yKGkoNDA5KSk7bzYoZSx0LG51bGwsbnVsbCl9LHMxLnByb3RvdHlwZS51bm1vdW50PXMwLnByb3RvdHlwZS51bm1vdW50PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5faW50ZXJuYWxSb290O2lmKG51bGwhPT1lKXt0aGlzLl9pbnRlcm5hbFJvb3Q9bnVsbDt2YXIgdD1lLmNvbnRhaW5lckluZm87b0UoZnVuY3Rpb24oKXtvNihudWxsLGUsbnVsbCxudWxsKX0pLHRbZWtdPW51bGx9fSxzMS5wcm90b3R5cGUudW5zdGFibGVfc2NoZWR1bGVIeWRyYXRpb249ZnVuY3Rpb24oZSl7aWYoZSl7dmFyIHQ9ZWg7ZT17YmxvY2tlZE9uOm51bGwsdGFyZ2V0OmUscHJpb3JpdHk6dH07Zm9yKHZhciBuPTA7bjxpSC5sZW5ndGgmJjAhPT10JiZ0PGlIW25dLnByaW9yaXR5O24rKyk7aUguc3BsaWNlKG4sMCxlKSwwPT09biYmaVgoZSl9fTt2YXIgczY9by5EaXNwYXRjaGVyO28uRXZlbnRzPVtlTixlXyxlTCx0Yyx0ZixvU107dmFyIHM1PXtmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTplUCxidW5kbGVUeXBlOjAsdmVyc2lvbjoiMTguMy4wLWNhbmFyeS05Mzc3ZTEwMTAtMjAyMzA3MTIiLHJlbmRlcmVyUGFja2FnZU5hbWU6InJlYWN0LWRvbSJ9LHM3PXtidW5kbGVUeXBlOnM1LmJ1bmRsZVR5cGUsdmVyc2lvbjpzNS52ZXJzaW9uLHJlbmRlcmVyUGFja2FnZU5hbWU6czUucmVuZGVyZXJQYWNrYWdlTmFtZSxyZW5kZXJlckNvbmZpZzpzNS5yZW5kZXJlckNvbmZpZyxvdmVycmlkZUhvb2tTdGF0ZTpudWxsLG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aDpudWxsLG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aDpudWxsLG92ZXJyaWRlUHJvcHM6bnVsbCxvdmVycmlkZVByb3BzRGVsZXRlUGF0aDpudWxsLG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoOm51bGwsc2V0RXJyb3JIYW5kbGVyOm51bGwsc2V0U3VzcGVuc2VIYW5kbGVyOm51bGwsc2NoZWR1bGVVcGRhdGU6bnVsbCxjdXJyZW50RGlzcGF0Y2hlclJlZjpzLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PT0oZT10bShlKSk/bnVsbDplLnN0YXRlTm9kZX0sZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6czUuZmluZEZpYmVyQnlIb3N0SW5zdGFuY2V8fGZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LGZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaDpudWxsLHNjaGVkdWxlUmVmcmVzaDpudWxsLHNjaGVkdWxlUm9vdDpudWxsLHNldFJlZnJlc2hIYW5kbGVyOm51bGwsZ2V0Q3VycmVudEZpYmVyOm51bGwscmVjb25jaWxlclZlcnNpb246IjE4LjMuMC1jYW5hcnktOTM3N2UxMDEwLTIwMjMwNzEyIn07aWYoInVuZGVmaW5lZCIhPXR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pe3ZhciBzOT1fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187aWYoIXM5LmlzRGlzYWJsZWQmJnM5LnN1cHBvcnRzRmliZXIpdHJ5e0o9czkuaW5qZWN0KHM3KSxlZT1zOX1jYXRjaChlKXt9fXQuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ9byx0LmNyZWF0ZVBvcnRhbD1mdW5jdGlvbihlLHQpe3ZhciBuPTI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpudWxsO2lmKCFzMih0KSl0aHJvdyBFcnJvcihpKDIwMCkpO3JldHVybiBmdW5jdGlvbihlLHQsbil7dmFyIHI9Mzxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOm51bGw7cmV0dXJueyQkdHlwZW9mOmcsa2V5Om51bGw9PXI/bnVsbDoiIityLGNoaWxkcmVuOmUsY29udGFpbmVySW5mbzp0LGltcGxlbWVudGF0aW9uOm51bGx9fShlLHQsbnVsbCxuKX0sdC5jcmVhdGVSb290PWZ1bmN0aW9uKGUsdCl7aWYoIXMyKGUpKXRocm93IEVycm9yKGkoMjk5KSk7dmFyIG49ITEscj0iIixsPXNKO3JldHVybiBudWxsIT10JiYoITA9PT10LnVuc3RhYmxlX3N0cmljdE1vZGUmJihuPSEwKSx2b2lkIDAhPT10LmlkZW50aWZpZXJQcmVmaXgmJihyPXQuaWRlbnRpZmllclByZWZpeCksdm9pZCAwIT09dC5vblJlY292ZXJhYmxlRXJyb3ImJihsPXQub25SZWNvdmVyYWJsZUVycm9yKSksdD1vMyhlLDEsITEsbnVsbCxudWxsLG4sITEscixsKSxlW2VrXT10LmN1cnJlbnQsc1ouY3VycmVudD1zRix1NSg4PT09ZS5ub2RlVHlwZT9lLnBhcmVudE5vZGU6ZSksbmV3IHMwKHQpfSx0LmZpbmRET01Ob2RlPWZ1bmN0aW9uKGUpe2lmKG51bGw9PWUpcmV0dXJuIG51bGw7aWYoMT09PWUubm9kZVR5cGUpcmV0dXJuIGU7dmFyIHQ9ZS5fcmVhY3RJbnRlcm5hbHM7aWYodm9pZCAwPT09dCl7aWYoImZ1bmN0aW9uIj09dHlwZW9mIGUucmVuZGVyKXRocm93IEVycm9yKGkoMTg4KSk7dGhyb3cgRXJyb3IoaSgyNjgsZT1PYmplY3Qua2V5cyhlKS5qb2luKCIsIikpKX1yZXR1cm4gZT1udWxsPT09KGU9dG0odCkpP251bGw6ZS5zdGF0ZU5vZGV9LHQuZmx1c2hTeW5jPWZ1bmN0aW9uKGUpe3JldHVybiBvRShlKX0sdC5oeWRyYXRlPWZ1bmN0aW9uKGUsdCxuKXtpZighczModCkpdGhyb3cgRXJyb3IoaSgyMDApKTtyZXR1cm4gczgobnVsbCxlLHQsITAsbil9LHQuaHlkcmF0ZVJvb3Q9ZnVuY3Rpb24oZSx0LG4pe2lmKCFzMihlKSl0aHJvdyBFcnJvcihpKDQwNSkpO3ZhciByPSExLGw9IiIsYT1zSjtyZXR1cm4gbnVsbCE9biYmKCEwPT09bi51bnN0YWJsZV9zdHJpY3RNb2RlJiYocj0hMCksdm9pZCAwIT09bi5pZGVudGlmaWVyUHJlZml4JiYobD1uLmlkZW50aWZpZXJQcmVmaXgpLHZvaWQgMCE9PW4ub25SZWNvdmVyYWJsZUVycm9yJiYoYT1uLm9uUmVjb3ZlcmFibGVFcnJvcikpLHQ9bzgodCxudWxsLGUsMSxudWxsIT1uP246bnVsbCxyLCExLGwsYSksZVtla109dC5jdXJyZW50LHNaLmN1cnJlbnQ9c0YsdTUoZSksbmV3IHMxKHQpfSx0LnByZWNvbm5lY3Q9ZnVuY3Rpb24oZSx0KXt2YXIgbj1zNi5jdXJyZW50O24mJm4ucHJlY29ubmVjdChlLHQpfSx0LnByZWZldGNoRE5TPWZ1bmN0aW9uKGUpe3ZhciB0PXM2LmN1cnJlbnQ7dCYmdC5wcmVmZXRjaEROUyhlKX0sdC5wcmVpbml0PWZ1bmN0aW9uKGUsdCl7dmFyIG49czYuY3VycmVudDtuJiZuLnByZWluaXQoZSx0KX0sdC5wcmVsb2FkPWZ1bmN0aW9uKGUsdCl7dmFyIG49czYuY3VycmVudDtuJiZuLnByZWxvYWQoZSx0KX0sdC5yZW5kZXI9ZnVuY3Rpb24oZSx0LG4pe2lmKCFzMyh0KSl0aHJvdyBFcnJvcihpKDIwMCkpO3JldHVybiBzOChudWxsLGUsdCwhMSxuKX0sdC51bm1vdW50Q29tcG9uZW50QXROb2RlPWZ1bmN0aW9uKGUpe2lmKCFzMyhlKSl0aHJvdyBFcnJvcihpKDQwKSk7cmV0dXJuISFlLl9yZWFjdFJvb3RDb250YWluZXImJihvRShmdW5jdGlvbigpe3M4KG51bGwsbnVsbCxlLCExLGZ1bmN0aW9uKCl7ZS5fcmVhY3RSb290Q29udGFpbmVyPW51bGwsZVtla109bnVsbH0pfSksITApfSx0LnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzPW9TLHQudW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI9ZnVuY3Rpb24oZSx0LG4scil7aWYoIXMzKG4pKXRocm93IEVycm9yKGkoMjAwKSk7aWYobnVsbD09ZXx8dm9pZCAwPT09ZS5fcmVhY3RJbnRlcm5hbHMpdGhyb3cgRXJyb3IoaSgzOCkpO3JldHVybiBzOChlLHQsbiwhMSxyKX0sdC52ZXJzaW9uPSIxOC4zLjAtY2FuYXJ5LTkzNzdlMTAxMC0yMDIzMDcxMiJ9fV0pOw==\")\nassets.set(\"/_next/static/chunks/framework-8883d1e9be70c3da.js\", \"data:application/javascript;base64,InVzZSBzdHJpY3QiOyhzZWxmLndlYnBhY2tDaHVua19OX0U9c2VsZi53ZWJwYWNrQ2h1bmtfTl9FfHxbXSkucHVzaChbWzc3NF0sezQ0NDg6ZnVuY3Rpb24oZSxuLHQpey8qKgogKiBAbGljZW5zZSBSZWFjdAogKiByZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanMKICoKICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuCiAqCiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZQogKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuCiAqL3ZhciByLGwsYSx1LG8saSxzPXQoNzI5NCksYz10KDM4NDApO2Z1bmN0aW9uIGYoZSl7Zm9yKHZhciBuPSJodHRwczovL3JlYWN0anMub3JnL2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudD0iK2UsdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspbis9IiZhcmdzW109IitlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW3RdKTtyZXR1cm4iTWluaWZpZWQgUmVhY3QgZXJyb3IgIyIrZSsiOyB2aXNpdCAiK24rIiBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuIn12YXIgZD1uZXcgU2V0LHA9e307ZnVuY3Rpb24gbShlLG4pe2goZSxuKSxoKGUrIkNhcHR1cmUiLG4pfWZ1bmN0aW9uIGgoZSxuKXtmb3IocFtlXT1uLGU9MDtlPG4ubGVuZ3RoO2UrKylkLmFkZChuW2VdKX12YXIgZz0hKCJ1bmRlZmluZWQiPT10eXBlb2Ygd2luZG93fHx2b2lkIDA9PT13aW5kb3cuZG9jdW1lbnR8fHZvaWQgMD09PXdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KSx2PU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkseT0vXls6QS1aX2Etelx1MDBDMC1cdTAwRDZcdTAwRDgtXHUwMEY2XHUwMEY4LVx1MDJGRlx1MDM3MC1cdTAzN0RcdTAzN0YtXHUxRkZGXHUyMDBDLVx1MjAwRFx1MjA3MC1cdTIxOEZcdTJDMDAtXHUyRkVGXHUzMDAxLVx1RDdGRlx1RjkwMC1cdUZEQ0ZcdUZERjAtXHVGRkZEXVs6QS1aX2Etelx1MDBDMC1cdTAwRDZcdTAwRDgtXHUwMEY2XHUwMEY4LVx1MDJGRlx1MDM3MC1cdTAzN0RcdTAzN0YtXHUxRkZGXHUyMDBDLVx1MjAwRFx1MjA3MC1cdTIxOEZcdTJDMDAtXHUyRkVGXHUzMDAxLVx1RDdGRlx1RjkwMC1cdUZEQ0ZcdUZERjAtXHVGRkZEXC0uMC05XHUwMEI3XHUwMzAwLVx1MDM2Rlx1MjAzRi1cdTIwNDBdKiQvLGI9e30saz17fTtmdW5jdGlvbiB3KGUsbix0LHIsbCxhLHUpe3RoaXMuYWNjZXB0c0Jvb2xlYW5zPTI9PT1ufHwzPT09bnx8ND09PW4sdGhpcy5hdHRyaWJ1dGVOYW1lPXIsdGhpcy5hdHRyaWJ1dGVOYW1lc3BhY2U9bCx0aGlzLm11c3RVc2VQcm9wZXJ0eT10LHRoaXMucHJvcGVydHlOYW1lPWUsdGhpcy50eXBlPW4sdGhpcy5zYW5pdGl6ZVVSTD1hLHRoaXMucmVtb3ZlRW1wdHlTdHJpbmc9dX12YXIgUz17fTsiY2hpbGRyZW4gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgZGVmYXVsdFZhbHVlIGRlZmF1bHRDaGVja2VkIGlubmVySFRNTCBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nIHN0eWxlIi5zcGxpdCgiICIpLmZvckVhY2goZnVuY3Rpb24oZSl7U1tlXT1uZXcgdyhlLDAsITEsZSxudWxsLCExLCExKX0pLFtbImFjY2VwdENoYXJzZXQiLCJhY2NlcHQtY2hhcnNldCJdLFsiY2xhc3NOYW1lIiwiY2xhc3MiXSxbImh0bWxGb3IiLCJmb3IiXSxbImh0dHBFcXVpdiIsImh0dHAtZXF1aXYiXV0uZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgbj1lWzBdO1Nbbl09bmV3IHcobiwxLCExLGVbMV0sbnVsbCwhMSwhMSl9KSxbImNvbnRlbnRFZGl0YWJsZSIsImRyYWdnYWJsZSIsInNwZWxsQ2hlY2siLCJ2YWx1ZSJdLmZvckVhY2goZnVuY3Rpb24oZSl7U1tlXT1uZXcgdyhlLDIsITEsZS50b0xvd2VyQ2FzZSgpLG51bGwsITEsITEpfSksWyJhdXRvUmV2ZXJzZSIsImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQiLCJmb2N1c2FibGUiLCJwcmVzZXJ2ZUFscGhhIl0uZm9yRWFjaChmdW5jdGlvbihlKXtTW2VdPW5ldyB3KGUsMiwhMSxlLG51bGwsITEsITEpfSksImFsbG93RnVsbFNjcmVlbiBhc3luYyBhdXRvRm9jdXMgYXV0b1BsYXkgY29udHJvbHMgZGVmYXVsdCBkZWZlciBkaXNhYmxlZCBkaXNhYmxlUGljdHVyZUluUGljdHVyZSBkaXNhYmxlUmVtb3RlUGxheWJhY2sgZm9ybU5vVmFsaWRhdGUgaGlkZGVuIGxvb3Agbm9Nb2R1bGUgbm9WYWxpZGF0ZSBvcGVuIHBsYXlzSW5saW5lIHJlYWRPbmx5IHJlcXVpcmVkIHJldmVyc2VkIHNjb3BlZCBzZWFtbGVzcyBpdGVtU2NvcGUiLnNwbGl0KCIgIikuZm9yRWFjaChmdW5jdGlvbihlKXtTW2VdPW5ldyB3KGUsMywhMSxlLnRvTG93ZXJDYXNlKCksbnVsbCwhMSwhMSl9KSxbImNoZWNrZWQiLCJtdWx0aXBsZSIsIm11dGVkIiwic2VsZWN0ZWQiXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe1NbZV09bmV3IHcoZSwzLCEwLGUsbnVsbCwhMSwhMSl9KSxbImNhcHR1cmUiLCJkb3dubG9hZCJdLmZvckVhY2goZnVuY3Rpb24oZSl7U1tlXT1uZXcgdyhlLDQsITEsZSxudWxsLCExLCExKX0pLFsiY29scyIsInJvd3MiLCJzaXplIiwic3BhbiJdLmZvckVhY2goZnVuY3Rpb24oZSl7U1tlXT1uZXcgdyhlLDYsITEsZSxudWxsLCExLCExKX0pLFsicm93U3BhbiIsInN0YXJ0Il0uZm9yRWFjaChmdW5jdGlvbihlKXtTW2VdPW5ldyB3KGUsNSwhMSxlLnRvTG93ZXJDYXNlKCksbnVsbCwhMSwhMSl9KTt2YXIgeD0vW1wtOl0oW2Etel0pL2c7ZnVuY3Rpb24gRShlKXtyZXR1cm4gZVsxXS50b1VwcGVyQ2FzZSgpfWZ1bmN0aW9uIEMoZSxuLHQscil7dmFyIGwsYT1TLmhhc093blByb3BlcnR5KG4pP1Nbbl06bnVsbDsobnVsbCE9PWE/MCE9PWEudHlwZTpyfHwhKDI8bi5sZW5ndGgpfHwibyIhPT1uWzBdJiYiTyIhPT1uWzBdfHwibiIhPT1uWzFdJiYiTiIhPT1uWzFdKSYmKGZ1bmN0aW9uKGUsbix0LHIpe2lmKG51bGw9PW58fGZ1bmN0aW9uKGUsbix0LHIpe2lmKG51bGwhPT10JiYwPT09dC50eXBlKXJldHVybiExO3N3aXRjaCh0eXBlb2Ygbil7Y2FzZSJmdW5jdGlvbiI6Y2FzZSJzeW1ib2wiOnJldHVybiEwO2Nhc2UiYm9vbGVhbiI6aWYocilyZXR1cm4hMTtpZihudWxsIT09dClyZXR1cm4hdC5hY2NlcHRzQm9vbGVhbnM7cmV0dXJuImRhdGEtIiE9PShlPWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLDUpKSYmImFyaWEtIiE9PWU7ZGVmYXVsdDpyZXR1cm4hMX19KGUsbix0LHIpKXJldHVybiEwO2lmKHIpcmV0dXJuITE7aWYobnVsbCE9PXQpc3dpdGNoKHQudHlwZSl7Y2FzZSAzOnJldHVybiFuO2Nhc2UgNDpyZXR1cm4hMT09PW47Y2FzZSA1OnJldHVybiBpc05hTihuKTtjYXNlIDY6cmV0dXJuIGlzTmFOKG4pfHwxPm59cmV0dXJuITF9KG4sdCxhLHIpJiYodD1udWxsKSxyfHxudWxsPT09YT8obD1uLCghIXYuY2FsbChrLGwpfHwhdi5jYWxsKGIsbCkmJih5LnRlc3QobCk/a1tsXT0hMDooYltsXT0hMCwhMSkpKSYmKG51bGw9PT10P2UucmVtb3ZlQXR0cmlidXRlKG4pOmUuc2V0QXR0cmlidXRlKG4sIiIrdCkpKTphLm11c3RVc2VQcm9wZXJ0eT9lW2EucHJvcGVydHlOYW1lXT1udWxsPT09dD8zIT09YS50eXBlJiYiIjp0OihuPWEuYXR0cmlidXRlTmFtZSxyPWEuYXR0cmlidXRlTmFtZXNwYWNlLG51bGw9PT10P2UucmVtb3ZlQXR0cmlidXRlKG4pOih0PTM9PT0oYT1hLnR5cGUpfHw0PT09YSYmITA9PT10PyIiOiIiK3Qscj9lLnNldEF0dHJpYnV0ZU5TKHIsbix0KTplLnNldEF0dHJpYnV0ZShuLHQpKSkpfSJhY2NlbnQtaGVpZ2h0IGFsaWdubWVudC1iYXNlbGluZSBhcmFiaWMtZm9ybSBiYXNlbGluZS1zaGlmdCBjYXAtaGVpZ2h0IGNsaXAtcGF0aCBjbGlwLXJ1bGUgY29sb3ItaW50ZXJwb2xhdGlvbiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMgY29sb3ItcHJvZmlsZSBjb2xvci1yZW5kZXJpbmcgZG9taW5hbnQtYmFzZWxpbmUgZW5hYmxlLWJhY2tncm91bmQgZmlsbC1vcGFjaXR5IGZpbGwtcnVsZSBmbG9vZC1jb2xvciBmbG9vZC1vcGFjaXR5IGZvbnQtZmFtaWx5IGZvbnQtc2l6ZSBmb250LXNpemUtYWRqdXN0IGZvbnQtc3RyZXRjaCBmb250LXN0eWxlIGZvbnQtdmFyaWFudCBmb250LXdlaWdodCBnbHlwaC1uYW1lIGdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwgZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwgaG9yaXotYWR2LXggaG9yaXotb3JpZ2luLXggaW1hZ2UtcmVuZGVyaW5nIGxldHRlci1zcGFjaW5nIGxpZ2h0aW5nLWNvbG9yIG1hcmtlci1lbmQgbWFya2VyLW1pZCBtYXJrZXItc3RhcnQgb3ZlcmxpbmUtcG9zaXRpb24gb3ZlcmxpbmUtdGhpY2tuZXNzIHBhaW50LW9yZGVyIHBhbm9zZS0xIHBvaW50ZXItZXZlbnRzIHJlbmRlcmluZy1pbnRlbnQgc2hhcGUtcmVuZGVyaW5nIHN0b3AtY29sb3Igc3RvcC1vcGFjaXR5IHN0cmlrZXRocm91Z2gtcG9zaXRpb24gc3RyaWtldGhyb3VnaC10aGlja25lc3Mgc3Ryb2tlLWRhc2hhcnJheSBzdHJva2UtZGFzaG9mZnNldCBzdHJva2UtbGluZWNhcCBzdHJva2UtbGluZWpvaW4gc3Ryb2tlLW1pdGVybGltaXQgc3Ryb2tlLW9wYWNpdHkgc3Ryb2tlLXdpZHRoIHRleHQtYW5jaG9yIHRleHQtZGVjb3JhdGlvbiB0ZXh0LXJlbmRlcmluZyB1bmRlcmxpbmUtcG9zaXRpb24gdW5kZXJsaW5lLXRoaWNrbmVzcyB1bmljb2RlLWJpZGkgdW5pY29kZS1yYW5nZSB1bml0cy1wZXItZW0gdi1hbHBoYWJldGljIHYtaGFuZ2luZyB2LWlkZW9ncmFwaGljIHYtbWF0aGVtYXRpY2FsIHZlY3Rvci1lZmZlY3QgdmVydC1hZHYteSB2ZXJ0LW9yaWdpbi14IHZlcnQtb3JpZ2luLXkgd29yZC1zcGFjaW5nIHdyaXRpbmctbW9kZSB4bWxuczp4bGluayB4LWhlaWdodCIuc3BsaXQoIiAiKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciBuPWUucmVwbGFjZSh4LEUpO1Nbbl09bmV3IHcobiwxLCExLGUsbnVsbCwhMSwhMSl9KSwieGxpbms6YWN0dWF0ZSB4bGluazphcmNyb2xlIHhsaW5rOnJvbGUgeGxpbms6c2hvdyB4bGluazp0aXRsZSB4bGluazp0eXBlIi5zcGxpdCgiICIpLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIG49ZS5yZXBsYWNlKHgsRSk7U1tuXT1uZXcgdyhuLDEsITEsZSwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIsITEsITEpfSksWyJ4bWw6YmFzZSIsInhtbDpsYW5nIiwieG1sOnNwYWNlIl0uZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgbj1lLnJlcGxhY2UoeCxFKTtTW25dPW5ldyB3KG4sMSwhMSxlLCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UiLCExLCExKX0pLFsidGFiSW5kZXgiLCJjcm9zc09yaWdpbiJdLmZvckVhY2goZnVuY3Rpb24oZSl7U1tlXT1uZXcgdyhlLDEsITEsZS50b0xvd2VyQ2FzZSgpLG51bGwsITEsITEpfSksUy54bGlua0hyZWY9bmV3IHcoInhsaW5rSHJlZiIsMSwhMSwieGxpbms6aHJlZiIsImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiLCEwLCExKSxbInNyYyIsImhyZWYiLCJhY3Rpb24iLCJmb3JtQWN0aW9uIl0uZm9yRWFjaChmdW5jdGlvbihlKXtTW2VdPW5ldyB3KGUsMSwhMSxlLnRvTG93ZXJDYXNlKCksbnVsbCwhMCwhMCl9KTt2YXIgXz1zLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELFA9U3ltYm9sLmZvcigicmVhY3QuZWxlbWVudCIpLE49U3ltYm9sLmZvcigicmVhY3QucG9ydGFsIiksej1TeW1ib2wuZm9yKCJyZWFjdC5mcmFnbWVudCIpLFQ9U3ltYm9sLmZvcigicmVhY3Quc3RyaWN0X21vZGUiKSxMPVN5bWJvbC5mb3IoInJlYWN0LnByb2ZpbGVyIiksUj1TeW1ib2wuZm9yKCJyZWFjdC5wcm92aWRlciIpLE09U3ltYm9sLmZvcigicmVhY3QuY29udGV4dCIpLEY9U3ltYm9sLmZvcigicmVhY3QuZm9yd2FyZF9yZWYiKSxPPVN5bWJvbC5mb3IoInJlYWN0LnN1c3BlbnNlIiksRD1TeW1ib2wuZm9yKCJyZWFjdC5zdXNwZW5zZV9saXN0IiksST1TeW1ib2wuZm9yKCJyZWFjdC5tZW1vIiksVT1TeW1ib2wuZm9yKCJyZWFjdC5sYXp5Iik7U3ltYm9sLmZvcigicmVhY3Quc2NvcGUiKSxTeW1ib2wuZm9yKCJyZWFjdC5kZWJ1Z190cmFjZV9tb2RlIik7dmFyIFY9U3ltYm9sLmZvcigicmVhY3Qub2Zmc2NyZWVuIik7U3ltYm9sLmZvcigicmVhY3QubGVnYWN5X2hpZGRlbiIpLFN5bWJvbC5mb3IoInJlYWN0LmNhY2hlIiksU3ltYm9sLmZvcigicmVhY3QudHJhY2luZ19tYXJrZXIiKTt2YXIgQT1TeW1ib2wuaXRlcmF0b3I7ZnVuY3Rpb24gJChlKXtyZXR1cm4gbnVsbD09PWV8fCJvYmplY3QiIT10eXBlb2YgZT9udWxsOiJmdW5jdGlvbiI9PXR5cGVvZihlPUEmJmVbQV18fGVbIkBAaXRlcmF0b3IiXSk/ZTpudWxsfXZhciBqLEI9T2JqZWN0LmFzc2lnbjtmdW5jdGlvbiBIKGUpe2lmKHZvaWQgMD09PWopdHJ5e3Rocm93IEVycm9yKCl9Y2F0Y2goZSl7dmFyIG49ZS5zdGFjay50cmltKCkubWF0Y2goL1xuKCAqKGF0ICk/KS8pO2o9biYmblsxXXx8IiJ9cmV0dXJuIlxuIitqK2V9dmFyIFc9ITE7ZnVuY3Rpb24gUShlLG4pe2lmKCFlfHxXKXJldHVybiIiO1c9ITA7dmFyIHQ9RXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7RXJyb3IucHJlcGFyZVN0YWNrVHJhY2U9dm9pZCAwO3RyeXtpZihuKXtpZihuPWZ1bmN0aW9uKCl7dGhyb3cgRXJyb3IoKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KG4ucHJvdG90eXBlLCJwcm9wcyIse3NldDpmdW5jdGlvbigpe3Rocm93IEVycm9yKCl9fSksIm9iamVjdCI9PXR5cGVvZiBSZWZsZWN0JiZSZWZsZWN0LmNvbnN0cnVjdCl7dHJ5e1JlZmxlY3QuY29uc3RydWN0KG4sW10pfWNhdGNoKGUpe3ZhciByPWV9UmVmbGVjdC5jb25zdHJ1Y3QoZSxbXSxuKX1lbHNle3RyeXtuLmNhbGwoKX1jYXRjaChlKXtyPWV9ZS5jYWxsKG4ucHJvdG90eXBlKX19ZWxzZXt0cnl7dGhyb3cgRXJyb3IoKX1jYXRjaChlKXtyPWV9ZSgpfX1jYXRjaChuKXtpZihuJiZyJiYic3RyaW5nIj09dHlwZW9mIG4uc3RhY2spe2Zvcih2YXIgbD1uLnN0YWNrLnNwbGl0KCJcbiIpLGE9ci5zdGFjay5zcGxpdCgiXG4iKSx1PWwubGVuZ3RoLTEsbz1hLmxlbmd0aC0xOzE8PXUmJjA8PW8mJmxbdV0hPT1hW29dOylvLS07Zm9yKDsxPD11JiYwPD1vO3UtLSxvLS0paWYobFt1XSE9PWFbb10pe2lmKDEhPT11fHwxIT09bylkbyBpZih1LS0sMD4tLW98fGxbdV0hPT1hW29dKXt2YXIgaT0iXG4iK2xbdV0ucmVwbGFjZSgiIGF0IG5ldyAiLCIgYXQgIik7cmV0dXJuIGUuZGlzcGxheU5hbWUmJmkuaW5jbHVkZXMoIjxhbm9ueW1vdXM+IikmJihpPWkucmVwbGFjZSgiPGFub255bW91cz4iLGUuZGlzcGxheU5hbWUpKSxpfXdoaWxlKDE8PXUmJjA8PW8pO2JyZWFrfX19ZmluYWxseXtXPSExLEVycm9yLnByZXBhcmVTdGFja1RyYWNlPXR9cmV0dXJuKGU9ZT9lLmRpc3BsYXlOYW1lfHxlLm5hbWU6IiIpP0goZSk6IiJ9ZnVuY3Rpb24gcShlKXtzd2l0Y2godHlwZW9mIGUpe2Nhc2UiYm9vbGVhbiI6Y2FzZSJudW1iZXIiOmNhc2Uic3RyaW5nIjpjYXNlInVuZGVmaW5lZCI6Y2FzZSJvYmplY3QiOnJldHVybiBlO2RlZmF1bHQ6cmV0dXJuIiJ9fWZ1bmN0aW9uIEsoZSl7dmFyIG49ZS50eXBlO3JldHVybihlPWUubm9kZU5hbWUpJiYiaW5wdXQiPT09ZS50b0xvd2VyQ2FzZSgpJiYoImNoZWNrYm94Ij09PW58fCJyYWRpbyI9PT1uKX1mdW5jdGlvbiBZKGUpe2UuX3ZhbHVlVHJhY2tlcnx8KGUuX3ZhbHVlVHJhY2tlcj1mdW5jdGlvbihlKXt2YXIgbj1LKGUpPyJjaGVja2VkIjoidmFsdWUiLHQ9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSxuKSxyPSIiK2Vbbl07aWYoIWUuaGFzT3duUHJvcGVydHkobikmJnZvaWQgMCE9PXQmJiJmdW5jdGlvbiI9PXR5cGVvZiB0LmdldCYmImZ1bmN0aW9uIj09dHlwZW9mIHQuc2V0KXt2YXIgbD10LmdldCxhPXQuc2V0O3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGwuY2FsbCh0aGlzKX0sc2V0OmZ1bmN0aW9uKGUpe3I9IiIrZSxhLmNhbGwodGhpcyxlKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLHtlbnVtZXJhYmxlOnQuZW51bWVyYWJsZX0pLHtnZXRWYWx1ZTpmdW5jdGlvbigpe3JldHVybiByfSxzZXRWYWx1ZTpmdW5jdGlvbihlKXtyPSIiK2V9LHN0b3BUcmFja2luZzpmdW5jdGlvbigpe2UuX3ZhbHVlVHJhY2tlcj1udWxsLGRlbGV0ZSBlW25dfX19fShlKSl9ZnVuY3Rpb24gWChlKXtpZighZSlyZXR1cm4hMTt2YXIgbj1lLl92YWx1ZVRyYWNrZXI7aWYoIW4pcmV0dXJuITA7dmFyIHQ9bi5nZXRWYWx1ZSgpLHI9IiI7cmV0dXJuIGUmJihyPUsoZSk/ZS5jaGVja2VkPyJ0cnVlIjoiZmFsc2UiOmUudmFsdWUpLChlPXIpIT09dCYmKG4uc2V0VmFsdWUoZSksITApfWZ1bmN0aW9uIEcoZSl7aWYodm9pZCAwPT09KGU9ZXx8KCJ1bmRlZmluZWQiIT10eXBlb2YgZG9jdW1lbnQ/ZG9jdW1lbnQ6dm9pZCAwKSkpcmV0dXJuIG51bGw7dHJ5e3JldHVybiBlLmFjdGl2ZUVsZW1lbnR8fGUuYm9keX1jYXRjaChuKXtyZXR1cm4gZS5ib2R5fX1mdW5jdGlvbiBaKGUsbil7dmFyIHQ9bi5jaGVja2VkO3JldHVybiBCKHt9LG4se2RlZmF1bHRDaGVja2VkOnZvaWQgMCxkZWZhdWx0VmFsdWU6dm9pZCAwLHZhbHVlOnZvaWQgMCxjaGVja2VkOm51bGwhPXQ/dDplLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWR9KX1mdW5jdGlvbiBKKGUsbil7dmFyIHQ9bnVsbD09bi5kZWZhdWx0VmFsdWU/IiI6bi5kZWZhdWx0VmFsdWUscj1udWxsIT1uLmNoZWNrZWQ/bi5jaGVja2VkOm4uZGVmYXVsdENoZWNrZWQ7dD1xKG51bGwhPW4udmFsdWU/bi52YWx1ZTp0KSxlLl93cmFwcGVyU3RhdGU9e2luaXRpYWxDaGVja2VkOnIsaW5pdGlhbFZhbHVlOnQsY29udHJvbGxlZDoiY2hlY2tib3giPT09bi50eXBlfHwicmFkaW8iPT09bi50eXBlP251bGwhPW4uY2hlY2tlZDpudWxsIT1uLnZhbHVlfX1mdW5jdGlvbiBlZShlLG4pe251bGwhPShuPW4uY2hlY2tlZCkmJkMoZSwiY2hlY2tlZCIsbiwhMSl9ZnVuY3Rpb24gZW4oZSxuKXtlZShlLG4pO3ZhciB0PXEobi52YWx1ZSkscj1uLnR5cGU7aWYobnVsbCE9dCkibnVtYmVyIj09PXI/KDA9PT10JiYiIj09PWUudmFsdWV8fGUudmFsdWUhPXQpJiYoZS52YWx1ZT0iIit0KTplLnZhbHVlIT09IiIrdCYmKGUudmFsdWU9IiIrdCk7ZWxzZSBpZigic3VibWl0Ij09PXJ8fCJyZXNldCI9PT1yKXtlLnJlbW92ZUF0dHJpYnV0ZSgidmFsdWUiKTtyZXR1cm59bi5oYXNPd25Qcm9wZXJ0eSgidmFsdWUiKT9lcihlLG4udHlwZSx0KTpuLmhhc093blByb3BlcnR5KCJkZWZhdWx0VmFsdWUiKSYmZXIoZSxuLnR5cGUscShuLmRlZmF1bHRWYWx1ZSkpLG51bGw9PW4uY2hlY2tlZCYmbnVsbCE9bi5kZWZhdWx0Q2hlY2tlZCYmKGUuZGVmYXVsdENoZWNrZWQ9ISFuLmRlZmF1bHRDaGVja2VkKX1mdW5jdGlvbiBldChlLG4sdCl7aWYobi5oYXNPd25Qcm9wZXJ0eSgidmFsdWUiKXx8bi5oYXNPd25Qcm9wZXJ0eSgiZGVmYXVsdFZhbHVlIikpe3ZhciByPW4udHlwZTtpZighKCJzdWJtaXQiIT09ciYmInJlc2V0IiE9PXJ8fHZvaWQgMCE9PW4udmFsdWUmJm51bGwhPT1uLnZhbHVlKSlyZXR1cm47bj0iIitlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLHR8fG49PT1lLnZhbHVlfHwoZS52YWx1ZT1uKSxlLmRlZmF1bHRWYWx1ZT1ufSIiIT09KHQ9ZS5uYW1lKSYmKGUubmFtZT0iIiksZS5kZWZhdWx0Q2hlY2tlZD0hIWUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZCwiIiE9PXQmJihlLm5hbWU9dCl9ZnVuY3Rpb24gZXIoZSxuLHQpeygibnVtYmVyIiE9PW58fEcoZS5vd25lckRvY3VtZW50KSE9PWUpJiYobnVsbD09dD9lLmRlZmF1bHRWYWx1ZT0iIitlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlOmUuZGVmYXVsdFZhbHVlIT09IiIrdCYmKGUuZGVmYXVsdFZhbHVlPSIiK3QpKX12YXIgZWw9QXJyYXkuaXNBcnJheTtmdW5jdGlvbiBlYShlLG4sdCxyKXtpZihlPWUub3B0aW9ucyxuKXtuPXt9O2Zvcih2YXIgbD0wO2w8dC5sZW5ndGg7bCsrKW5bIiQiK3RbbF1dPSEwO2Zvcih0PTA7dDxlLmxlbmd0aDt0KyspbD1uLmhhc093blByb3BlcnR5KCIkIitlW3RdLnZhbHVlKSxlW3RdLnNlbGVjdGVkIT09bCYmKGVbdF0uc2VsZWN0ZWQ9bCksbCYmciYmKGVbdF0uZGVmYXVsdFNlbGVjdGVkPSEwKX1lbHNle2ZvcihsPTAsdD0iIitxKHQpLG49bnVsbDtsPGUubGVuZ3RoO2wrKyl7aWYoZVtsXS52YWx1ZT09PXQpe2VbbF0uc2VsZWN0ZWQ9ITAsciYmKGVbbF0uZGVmYXVsdFNlbGVjdGVkPSEwKTtyZXR1cm59bnVsbCE9PW58fGVbbF0uZGlzYWJsZWR8fChuPWVbbF0pfW51bGwhPT1uJiYobi5zZWxlY3RlZD0hMCl9fWZ1bmN0aW9uIGV1KGUsbil7aWYobnVsbCE9bi5kYW5nZXJvdXNseVNldElubmVySFRNTCl0aHJvdyBFcnJvcihmKDkxKSk7cmV0dXJuIEIoe30sbix7dmFsdWU6dm9pZCAwLGRlZmF1bHRWYWx1ZTp2b2lkIDAsY2hpbGRyZW46IiIrZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZX0pfWZ1bmN0aW9uIGVvKGUsbil7dmFyIHQ9bi52YWx1ZTtpZihudWxsPT10KXtpZih0PW4uY2hpbGRyZW4sbj1uLmRlZmF1bHRWYWx1ZSxudWxsIT10KXtpZihudWxsIT1uKXRocm93IEVycm9yKGYoOTIpKTtpZihlbCh0KSl7aWYoMTx0Lmxlbmd0aCl0aHJvdyBFcnJvcihmKDkzKSk7dD10WzBdfW49dH1udWxsPT1uJiYobj0iIiksdD1ufWUuX3dyYXBwZXJTdGF0ZT17aW5pdGlhbFZhbHVlOnEodCl9fWZ1bmN0aW9uIGVpKGUsbil7dmFyIHQ9cShuLnZhbHVlKSxyPXEobi5kZWZhdWx0VmFsdWUpO251bGwhPXQmJigodD0iIit0KSE9PWUudmFsdWUmJihlLnZhbHVlPXQpLG51bGw9PW4uZGVmYXVsdFZhbHVlJiZlLmRlZmF1bHRWYWx1ZSE9PXQmJihlLmRlZmF1bHRWYWx1ZT10KSksbnVsbCE9ciYmKGUuZGVmYXVsdFZhbHVlPSIiK3IpfWZ1bmN0aW9uIGVzKGUpe3ZhciBuPWUudGV4dENvbnRlbnQ7bj09PWUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUmJiIiIT09biYmbnVsbCE9PW4mJihlLnZhbHVlPW4pfWZ1bmN0aW9uIGVjKGUpe3N3aXRjaChlKXtjYXNlInN2ZyI6cmV0dXJuImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIjtjYXNlIm1hdGgiOnJldHVybiJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MIjtkZWZhdWx0OnJldHVybiJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIn19ZnVuY3Rpb24gZWYoZSxuKXtyZXR1cm4gbnVsbD09ZXx8Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPT09ZT9lYyhuKToiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPT09ZSYmImZvcmVpZ25PYmplY3QiPT09bj8iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI6ZX12YXIgZWQsZXAsZW09KGVkPWZ1bmN0aW9uKGUsbil7aWYoImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiE9PWUubmFtZXNwYWNlVVJJfHwiaW5uZXJIVE1MImluIGUpZS5pbm5lckhUTUw9bjtlbHNle2ZvcigoZXA9ZXB8fGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpKS5pbm5lckhUTUw9Ijxzdmc+IituLnZhbHVlT2YoKS50b1N0cmluZygpKyI8L3N2Zz4iLG49ZXAuZmlyc3RDaGlsZDtlLmZpcnN0Q2hpbGQ7KWUucmVtb3ZlQ2hpbGQoZS5maXJzdENoaWxkKTtmb3IoO24uZmlyc3RDaGlsZDspZS5hcHBlbmRDaGlsZChuLmZpcnN0Q2hpbGQpfX0sInVuZGVmaW5lZCIhPXR5cGVvZiBNU0FwcCYmTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24/ZnVuY3Rpb24oZSxuLHQscil7TVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24oKXtyZXR1cm4gZWQoZSxuLHQscil9KX06ZWQpO2Z1bmN0aW9uIGVoKGUsbil7aWYobil7dmFyIHQ9ZS5maXJzdENoaWxkO2lmKHQmJnQ9PT1lLmxhc3RDaGlsZCYmMz09PXQubm9kZVR5cGUpe3Qubm9kZVZhbHVlPW47cmV0dXJufX1lLnRleHRDb250ZW50PW59dmFyIGVnPXthbmltYXRpb25JdGVyYXRpb25Db3VudDohMCxhc3BlY3RSYXRpbzohMCxib3JkZXJJbWFnZU91dHNldDohMCxib3JkZXJJbWFnZVNsaWNlOiEwLGJvcmRlckltYWdlV2lkdGg6ITAsYm94RmxleDohMCxib3hGbGV4R3JvdXA6ITAsYm94T3JkaW5hbEdyb3VwOiEwLGNvbHVtbkNvdW50OiEwLGNvbHVtbnM6ITAsZmxleDohMCxmbGV4R3JvdzohMCxmbGV4UG9zaXRpdmU6ITAsZmxleFNocmluazohMCxmbGV4TmVnYXRpdmU6ITAsZmxleE9yZGVyOiEwLGdyaWRBcmVhOiEwLGdyaWRSb3c6ITAsZ3JpZFJvd0VuZDohMCxncmlkUm93U3BhbjohMCxncmlkUm93U3RhcnQ6ITAsZ3JpZENvbHVtbjohMCxncmlkQ29sdW1uRW5kOiEwLGdyaWRDb2x1bW5TcGFuOiEwLGdyaWRDb2x1bW5TdGFydDohMCxmb250V2VpZ2h0OiEwLGxpbmVDbGFtcDohMCxsaW5lSGVpZ2h0OiEwLG9wYWNpdHk6ITAsb3JkZXI6ITAsb3JwaGFuczohMCx0YWJTaXplOiEwLHdpZG93czohMCx6SW5kZXg6ITAsem9vbTohMCxmaWxsT3BhY2l0eTohMCxmbG9vZE9wYWNpdHk6ITAsc3RvcE9wYWNpdHk6ITAsc3Ryb2tlRGFzaGFycmF5OiEwLHN0cm9rZURhc2hvZmZzZXQ6ITAsc3Ryb2tlTWl0ZXJsaW1pdDohMCxzdHJva2VPcGFjaXR5OiEwLHN0cm9rZVdpZHRoOiEwfSxldj1bIldlYmtpdCIsIm1zIiwiTW96IiwiTyJdO2Z1bmN0aW9uIGV5KGUsbix0KXtyZXR1cm4gbnVsbD09bnx8ImJvb2xlYW4iPT10eXBlb2Ygbnx8IiI9PT1uPyIiOnR8fCJudW1iZXIiIT10eXBlb2Ygbnx8MD09PW58fGVnLmhhc093blByb3BlcnR5KGUpJiZlZ1tlXT8oIiIrbikudHJpbSgpOm4rInB4In1mdW5jdGlvbiBlYihlLG4pe2Zvcih2YXIgdCBpbiBlPWUuc3R5bGUsbilpZihuLmhhc093blByb3BlcnR5KHQpKXt2YXIgcj0wPT09dC5pbmRleE9mKCItLSIpLGw9ZXkodCxuW3RdLHIpOyJmbG9hdCI9PT10JiYodD0iY3NzRmxvYXQiKSxyP2Uuc2V0UHJvcGVydHkodCxsKTplW3RdPWx9fU9iamVjdC5rZXlzKGVnKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2V2LmZvckVhY2goZnVuY3Rpb24obil7ZWdbbj1uK2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zdWJzdHJpbmcoMSldPWVnW2VdfSl9KTt2YXIgZWs9Qih7bWVudWl0ZW06ITB9LHthcmVhOiEwLGJhc2U6ITAsYnI6ITAsY29sOiEwLGVtYmVkOiEwLGhyOiEwLGltZzohMCxpbnB1dDohMCxrZXlnZW46ITAsbGluazohMCxtZXRhOiEwLHBhcmFtOiEwLHNvdXJjZTohMCx0cmFjazohMCx3YnI6ITB9KTtmdW5jdGlvbiBldyhlLG4pe2lmKG4pe2lmKGVrW2VdJiYobnVsbCE9bi5jaGlsZHJlbnx8bnVsbCE9bi5kYW5nZXJvdXNseVNldElubmVySFRNTCkpdGhyb3cgRXJyb3IoZigxMzcsZSkpO2lmKG51bGwhPW4uZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpe2lmKG51bGwhPW4uY2hpbGRyZW4pdGhyb3cgRXJyb3IoZig2MCkpO2lmKCJvYmplY3QiIT10eXBlb2Ygbi5kYW5nZXJvdXNseVNldElubmVySFRNTHx8ISgiX19odG1sImluIG4uZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpKXRocm93IEVycm9yKGYoNjEpKX1pZihudWxsIT1uLnN0eWxlJiYib2JqZWN0IiE9dHlwZW9mIG4uc3R5bGUpdGhyb3cgRXJyb3IoZig2MikpfX1mdW5jdGlvbiBlUyhlLG4pe2lmKC0xPT09ZS5pbmRleE9mKCItIikpcmV0dXJuInN0cmluZyI9PXR5cGVvZiBuLmlzO3N3aXRjaChlKXtjYXNlImFubm90YXRpb24teG1sIjpjYXNlImNvbG9yLXByb2ZpbGUiOmNhc2UiZm9udC1mYWNlIjpjYXNlImZvbnQtZmFjZS1zcmMiOmNhc2UiZm9udC1mYWNlLXVyaSI6Y2FzZSJmb250LWZhY2UtZm9ybWF0IjpjYXNlImZvbnQtZmFjZS1uYW1lIjpjYXNlIm1pc3NpbmctZ2x5cGgiOnJldHVybiExO2RlZmF1bHQ6cmV0dXJuITB9fXZhciBleD1udWxsO2Z1bmN0aW9uIGVFKGUpe3JldHVybihlPWUudGFyZ2V0fHxlLnNyY0VsZW1lbnR8fHdpbmRvdykuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQmJihlPWUuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpLDM9PT1lLm5vZGVUeXBlP2UucGFyZW50Tm9kZTplfXZhciBlQz1udWxsLGVfPW51bGwsZVA9bnVsbDtmdW5jdGlvbiBlTihlKXtpZihlPXJEKGUpKXtpZigiZnVuY3Rpb24iIT10eXBlb2YgZUMpdGhyb3cgRXJyb3IoZigyODApKTt2YXIgbj1lLnN0YXRlTm9kZTtuJiYobj1yVShuKSxlQyhlLnN0YXRlTm9kZSxlLnR5cGUsbikpfX1mdW5jdGlvbiBleihlKXtlXz9lUD9lUC5wdXNoKGUpOmVQPVtlXTplXz1lfWZ1bmN0aW9uIGVUKCl7aWYoZV8pe3ZhciBlPWVfLG49ZVA7aWYoZVA9ZV89bnVsbCxlTihlKSxuKWZvcihlPTA7ZTxuLmxlbmd0aDtlKyspZU4obltlXSl9fWZ1bmN0aW9uIGVMKGUsbil7cmV0dXJuIGUobil9ZnVuY3Rpb24gZVIoKXt9dmFyIGVNPSExO2Z1bmN0aW9uIGVGKGUsbix0KXtpZihlTSlyZXR1cm4gZShuLHQpO2VNPSEwO3RyeXtyZXR1cm4gZUwoZSxuLHQpfWZpbmFsbHl7ZU09ITEsKG51bGwhPT1lX3x8bnVsbCE9PWVQKSYmKGVSKCksZVQoKSl9fWZ1bmN0aW9uIGVPKGUsbil7dmFyIHQ9ZS5zdGF0ZU5vZGU7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7dmFyIHI9clUodCk7aWYobnVsbD09PXIpcmV0dXJuIG51bGw7c3dpdGNoKHQ9cltuXSxuKXtjYXNlIm9uQ2xpY2siOmNhc2Uib25DbGlja0NhcHR1cmUiOmNhc2Uib25Eb3VibGVDbGljayI6Y2FzZSJvbkRvdWJsZUNsaWNrQ2FwdHVyZSI6Y2FzZSJvbk1vdXNlRG93biI6Y2FzZSJvbk1vdXNlRG93bkNhcHR1cmUiOmNhc2Uib25Nb3VzZU1vdmUiOmNhc2Uib25Nb3VzZU1vdmVDYXB0dXJlIjpjYXNlIm9uTW91c2VVcCI6Y2FzZSJvbk1vdXNlVXBDYXB0dXJlIjpjYXNlIm9uTW91c2VFbnRlciI6KHI9IXIuZGlzYWJsZWQpfHwocj0hKCJidXR0b24iPT09KGU9ZS50eXBlKXx8ImlucHV0Ij09PWV8fCJzZWxlY3QiPT09ZXx8InRleHRhcmVhIj09PWUpKSxlPSFyO2JyZWFrO2RlZmF1bHQ6ZT0hMX1pZihlKXJldHVybiBudWxsO2lmKHQmJiJmdW5jdGlvbiIhPXR5cGVvZiB0KXRocm93IEVycm9yKGYoMjMxLG4sdHlwZW9mIHQpKTtyZXR1cm4gdH12YXIgZUQ9ITE7aWYoZyl0cnl7dmFyIGVJPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlSSwicGFzc2l2ZSIse2dldDpmdW5jdGlvbigpe2VEPSEwfX0pLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCJ0ZXN0IixlSSxlSSksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoInRlc3QiLGVJLGVJKX1jYXRjaChlKXtlRD0hMX1mdW5jdGlvbiBlVShlLG4sdCxyLGwsYSx1LG8saSl7dmFyIHM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDMpO3RyeXtuLmFwcGx5KHQscyl9Y2F0Y2goZSl7dGhpcy5vbkVycm9yKGUpfX12YXIgZVY9ITEsZUE9bnVsbCxlJD0hMSxlaj1udWxsLGVCPXtvbkVycm9yOmZ1bmN0aW9uKGUpe2VWPSEwLGVBPWV9fTtmdW5jdGlvbiBlSChlLG4sdCxyLGwsYSx1LG8saSl7ZVY9ITEsZUE9bnVsbCxlVS5hcHBseShlQixhcmd1bWVudHMpfWZ1bmN0aW9uIGVXKGUpe3ZhciBuPWUsdD1lO2lmKGUuYWx0ZXJuYXRlKWZvcig7bi5yZXR1cm47KW49bi5yZXR1cm47ZWxzZXtlPW47ZG8gMCE9KDQwOTgmKG49ZSkuZmxhZ3MpJiYodD1uLnJldHVybiksZT1uLnJldHVybjt3aGlsZShlKX1yZXR1cm4gMz09PW4udGFnP3Q6bnVsbH1mdW5jdGlvbiBlUShlKXtpZigxMz09PWUudGFnKXt2YXIgbj1lLm1lbW9pemVkU3RhdGU7aWYobnVsbD09PW4mJm51bGwhPT0oZT1lLmFsdGVybmF0ZSkmJihuPWUubWVtb2l6ZWRTdGF0ZSksbnVsbCE9PW4pcmV0dXJuIG4uZGVoeWRyYXRlZH1yZXR1cm4gbnVsbH1mdW5jdGlvbiBlcShlKXtpZihlVyhlKSE9PWUpdGhyb3cgRXJyb3IoZigxODgpKX1mdW5jdGlvbiBlSyhlKXtyZXR1cm4gbnVsbCE9PShlPWZ1bmN0aW9uKGUpe3ZhciBuPWUuYWx0ZXJuYXRlO2lmKCFuKXtpZihudWxsPT09KG49ZVcoZSkpKXRocm93IEVycm9yKGYoMTg4KSk7cmV0dXJuIG4hPT1lP251bGw6ZX1mb3IodmFyIHQ9ZSxyPW47Oyl7dmFyIGw9dC5yZXR1cm47aWYobnVsbD09PWwpYnJlYWs7dmFyIGE9bC5hbHRlcm5hdGU7aWYobnVsbD09PWEpe2lmKG51bGwhPT0ocj1sLnJldHVybikpe3Q9cjtjb250aW51ZX1icmVha31pZihsLmNoaWxkPT09YS5jaGlsZCl7Zm9yKGE9bC5jaGlsZDthOyl7aWYoYT09PXQpcmV0dXJuIGVxKGwpLGU7aWYoYT09PXIpcmV0dXJuIGVxKGwpLG47YT1hLnNpYmxpbmd9dGhyb3cgRXJyb3IoZigxODgpKX1pZih0LnJldHVybiE9PXIucmV0dXJuKXQ9bCxyPWE7ZWxzZXtmb3IodmFyIHU9ITEsbz1sLmNoaWxkO287KXtpZihvPT09dCl7dT0hMCx0PWwscj1hO2JyZWFrfWlmKG89PT1yKXt1PSEwLHI9bCx0PWE7YnJlYWt9bz1vLnNpYmxpbmd9aWYoIXUpe2ZvcihvPWEuY2hpbGQ7bzspe2lmKG89PT10KXt1PSEwLHQ9YSxyPWw7YnJlYWt9aWYobz09PXIpe3U9ITAscj1hLHQ9bDticmVha31vPW8uc2libGluZ31pZighdSl0aHJvdyBFcnJvcihmKDE4OSkpfX1pZih0LmFsdGVybmF0ZSE9PXIpdGhyb3cgRXJyb3IoZigxOTApKX1pZigzIT09dC50YWcpdGhyb3cgRXJyb3IoZigxODgpKTtyZXR1cm4gdC5zdGF0ZU5vZGUuY3VycmVudD09PXQ/ZTpufShlKSk/ZnVuY3Rpb24gZShuKXtpZig1PT09bi50YWd8fDY9PT1uLnRhZylyZXR1cm4gbjtmb3Iobj1uLmNoaWxkO251bGwhPT1uOyl7dmFyIHQ9ZShuKTtpZihudWxsIT09dClyZXR1cm4gdDtuPW4uc2libGluZ31yZXR1cm4gbnVsbH0oZSk6bnVsbH12YXIgZVk9Yy51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrLGVYPWMudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2ssZUc9Yy51bnN0YWJsZV9zaG91bGRZaWVsZCxlWj1jLnVuc3RhYmxlX3JlcXVlc3RQYWludCxlSj1jLnVuc3RhYmxlX25vdyxlMD1jLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsLGUxPWMudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHksZTI9Yy51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSxlMz1jLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LGU0PWMudW5zdGFibGVfTG93UHJpb3JpdHksZTg9Yy51bnN0YWJsZV9JZGxlUHJpb3JpdHksZTY9bnVsbCxlNT1udWxsLGU5PU1hdGguY2x6MzI/TWF0aC5jbHozMjpmdW5jdGlvbihlKXtyZXR1cm4gMD09KGU+Pj49MCk/MzI6MzEtKGU3KGUpL25lfDApfDB9LGU3PU1hdGgubG9nLG5lPU1hdGguTE4yLG5uPTY0LG50PTQxOTQzMDQ7ZnVuY3Rpb24gbnIoZSl7c3dpdGNoKGUmLWUpe2Nhc2UgMTpyZXR1cm4gMTtjYXNlIDI6cmV0dXJuIDI7Y2FzZSA0OnJldHVybiA0O2Nhc2UgODpyZXR1cm4gODtjYXNlIDE2OnJldHVybiAxNjtjYXNlIDMyOnJldHVybiAzMjtjYXNlIDY0OmNhc2UgMTI4OmNhc2UgMjU2OmNhc2UgNTEyOmNhc2UgMTAyNDpjYXNlIDIwNDg6Y2FzZSA0MDk2OmNhc2UgODE5MjpjYXNlIDE2Mzg0OmNhc2UgMzI3Njg6Y2FzZSA2NTUzNjpjYXNlIDEzMTA3MjpjYXNlIDI2MjE0NDpjYXNlIDUyNDI4ODpjYXNlIDEwNDg1NzY6Y2FzZSAyMDk3MTUyOnJldHVybiA0MTk0MjQwJmU7Y2FzZSA0MTk0MzA0OmNhc2UgODM4ODYwODpjYXNlIDE2Nzc3MjE2OmNhc2UgMzM1NTQ0MzI6Y2FzZSA2NzEwODg2NDpyZXR1cm4gMTMwMDIzNDI0JmU7Y2FzZSAxMzQyMTc3Mjg6cmV0dXJuIDEzNDIxNzcyODtjYXNlIDI2ODQzNTQ1NjpyZXR1cm4gMjY4NDM1NDU2O2Nhc2UgNTM2ODcwOTEyOnJldHVybiA1MzY4NzA5MTI7Y2FzZSAxMDczNzQxODI0OnJldHVybiAxMDczNzQxODI0O2RlZmF1bHQ6cmV0dXJuIGV9fWZ1bmN0aW9uIG5sKGUsbil7dmFyIHQ9ZS5wZW5kaW5nTGFuZXM7aWYoMD09PXQpcmV0dXJuIDA7dmFyIHI9MCxsPWUuc3VzcGVuZGVkTGFuZXMsYT1lLnBpbmdlZExhbmVzLHU9MjY4NDM1NDU1JnQ7aWYoMCE9PXUpe3ZhciBvPXUmfmw7MCE9PW8/cj1ucihvKTowIT0oYSY9dSkmJihyPW5yKGEpKX1lbHNlIDAhPSh1PXQmfmwpP3I9bnIodSk6MCE9PWEmJihyPW5yKGEpKTtpZigwPT09cilyZXR1cm4gMDtpZigwIT09biYmbiE9PXImJjA9PShuJmwpJiYoKGw9ciYtcik+PShhPW4mLW4pfHwxNj09PWwmJjAhPSg0MTk0MjQwJmEpKSlyZXR1cm4gbjtpZigwIT0oNCZyKSYmKHJ8PTE2JnQpLDAhPT0obj1lLmVudGFuZ2xlZExhbmVzKSlmb3IoZT1lLmVudGFuZ2xlbWVudHMsbiY9cjswPG47KWw9MTw8KHQ9MzEtZTkobikpLHJ8PWVbdF0sbiY9fmw7cmV0dXJuIHJ9ZnVuY3Rpb24gbmEoZSl7cmV0dXJuIDAhPShlPS0xMDczNzQxODI1JmUucGVuZGluZ0xhbmVzKT9lOjEwNzM3NDE4MjQmZT8xMDczNzQxODI0OjB9ZnVuY3Rpb24gbnUoKXt2YXIgZT1ubjtyZXR1cm4gMD09KDQxOTQyNDAmKG5uPDw9MSkpJiYobm49NjQpLGV9ZnVuY3Rpb24gbm8oZSl7Zm9yKHZhciBuPVtdLHQ9MDszMT50O3QrKyluLnB1c2goZSk7cmV0dXJuIG59ZnVuY3Rpb24gbmkoZSxuLHQpe2UucGVuZGluZ0xhbmVzfD1uLDUzNjg3MDkxMiE9PW4mJihlLnN1c3BlbmRlZExhbmVzPTAsZS5waW5nZWRMYW5lcz0wKSwoZT1lLmV2ZW50VGltZXMpW249MzEtZTkobildPXR9ZnVuY3Rpb24gbnMoZSxuKXt2YXIgdD1lLmVudGFuZ2xlZExhbmVzfD1uO2ZvcihlPWUuZW50YW5nbGVtZW50czt0Oyl7dmFyIHI9MzEtZTkodCksbD0xPDxyO2wmbnxlW3JdJm4mJihlW3JdfD1uKSx0Jj1+bH19dmFyIG5jPTA7ZnVuY3Rpb24gbmYoZSl7cmV0dXJuIDE8KGUmPS1lKT80PGU/MCE9KDI2ODQzNTQ1NSZlKT8xNjo1MzY4NzA5MTI6NDoxfXZhciBuZCxucCxubSxuaCxuZyxudj0hMSxueT1bXSxuYj1udWxsLG5rPW51bGwsbnc9bnVsbCxuUz1uZXcgTWFwLG54PW5ldyBNYXAsbkU9W10sbkM9Im1vdXNlZG93biBtb3VzZXVwIHRvdWNoY2FuY2VsIHRvdWNoZW5kIHRvdWNoc3RhcnQgYXV4Y2xpY2sgZGJsY2xpY2sgcG9pbnRlcmNhbmNlbCBwb2ludGVyZG93biBwb2ludGVydXAgZHJhZ2VuZCBkcmFnc3RhcnQgZHJvcCBjb21wb3NpdGlvbmVuZCBjb21wb3NpdGlvbnN0YXJ0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgaW5wdXQgdGV4dElucHV0IGNvcHkgY3V0IHBhc3RlIGNsaWNrIGNoYW5nZSBjb250ZXh0bWVudSByZXNldCBzdWJtaXQiLnNwbGl0KCIgIik7ZnVuY3Rpb24gbl8oZSxuKXtzd2l0Y2goZSl7Y2FzZSJmb2N1c2luIjpjYXNlImZvY3Vzb3V0IjpuYj1udWxsO2JyZWFrO2Nhc2UiZHJhZ2VudGVyIjpjYXNlImRyYWdsZWF2ZSI6bms9bnVsbDticmVhaztjYXNlIm1vdXNlb3ZlciI6Y2FzZSJtb3VzZW91dCI6bnc9bnVsbDticmVhaztjYXNlInBvaW50ZXJvdmVyIjpjYXNlInBvaW50ZXJvdXQiOm5TLmRlbGV0ZShuLnBvaW50ZXJJZCk7YnJlYWs7Y2FzZSJnb3Rwb2ludGVyY2FwdHVyZSI6Y2FzZSJsb3N0cG9pbnRlcmNhcHR1cmUiOm54LmRlbGV0ZShuLnBvaW50ZXJJZCl9fWZ1bmN0aW9uIG5QKGUsbix0LHIsbCxhKXtyZXR1cm4gbnVsbD09PWV8fGUubmF0aXZlRXZlbnQhPT1hPyhlPXtibG9ja2VkT246bixkb21FdmVudE5hbWU6dCxldmVudFN5c3RlbUZsYWdzOnIsbmF0aXZlRXZlbnQ6YSx0YXJnZXRDb250YWluZXJzOltsXX0sbnVsbCE9PW4mJm51bGwhPT0obj1yRChuKSkmJm5wKG4pKTooZS5ldmVudFN5c3RlbUZsYWdzfD1yLG49ZS50YXJnZXRDb250YWluZXJzLG51bGwhPT1sJiYtMT09PW4uaW5kZXhPZihsKSYmbi5wdXNoKGwpKSxlfWZ1bmN0aW9uIG5OKGUpe3ZhciBuPXJPKGUudGFyZ2V0KTtpZihudWxsIT09bil7dmFyIHQ9ZVcobik7aWYobnVsbCE9PXQpe2lmKDEzPT09KG49dC50YWcpKXtpZihudWxsIT09KG49ZVEodCkpKXtlLmJsb2NrZWRPbj1uLG5nKGUucHJpb3JpdHksZnVuY3Rpb24oKXtubSh0KX0pO3JldHVybn19ZWxzZSBpZigzPT09biYmdC5zdGF0ZU5vZGUuY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZCl7ZS5ibG9ja2VkT249Mz09PXQudGFnP3Quc3RhdGVOb2RlLmNvbnRhaW5lckluZm86bnVsbDtyZXR1cm59fX1lLmJsb2NrZWRPbj1udWxsfWZ1bmN0aW9uIG56KGUpe2lmKG51bGwhPT1lLmJsb2NrZWRPbilyZXR1cm4hMTtmb3IodmFyIG49ZS50YXJnZXRDb250YWluZXJzOzA8bi5sZW5ndGg7KXt2YXIgdD1uQShlLmRvbUV2ZW50TmFtZSxlLmV2ZW50U3lzdGVtRmxhZ3MsblswXSxlLm5hdGl2ZUV2ZW50KTtpZihudWxsIT09dClyZXR1cm4gbnVsbCE9PShuPXJEKHQpKSYmbnAobiksZS5ibG9ja2VkT249dCwhMTt2YXIgcj1uZXcodD1lLm5hdGl2ZUV2ZW50KS5jb25zdHJ1Y3Rvcih0LnR5cGUsdCk7ZXg9cix0LnRhcmdldC5kaXNwYXRjaEV2ZW50KHIpLGV4PW51bGwsbi5zaGlmdCgpfXJldHVybiEwfWZ1bmN0aW9uIG5UKGUsbix0KXtueihlKSYmdC5kZWxldGUobil9ZnVuY3Rpb24gbkwoKXtudj0hMSxudWxsIT09bmImJm56KG5iKSYmKG5iPW51bGwpLG51bGwhPT1uayYmbnoobmspJiYobms9bnVsbCksbnVsbCE9PW53JiZueihudykmJihudz1udWxsKSxuUy5mb3JFYWNoKG5UKSxueC5mb3JFYWNoKG5UKX1mdW5jdGlvbiBuUihlLG4pe2UuYmxvY2tlZE9uPT09biYmKGUuYmxvY2tlZE9uPW51bGwsbnZ8fChudj0hMCxjLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2soYy51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSxuTCkpKX1mdW5jdGlvbiBuTShlKXtmdW5jdGlvbiBuKG4pe3JldHVybiBuUihuLGUpfWlmKDA8bnkubGVuZ3RoKXtuUihueVswXSxlKTtmb3IodmFyIHQ9MTt0PG55Lmxlbmd0aDt0Kyspe3ZhciByPW55W3RdO3IuYmxvY2tlZE9uPT09ZSYmKHIuYmxvY2tlZE9uPW51bGwpfX1mb3IobnVsbCE9PW5iJiZuUihuYixlKSxudWxsIT09bmsmJm5SKG5rLGUpLG51bGwhPT1udyYmblIobncsZSksblMuZm9yRWFjaChuKSxueC5mb3JFYWNoKG4pLHQ9MDt0PG5FLmxlbmd0aDt0KyspKHI9bkVbdF0pLmJsb2NrZWRPbj09PWUmJihyLmJsb2NrZWRPbj1udWxsKTtmb3IoOzA8bkUubGVuZ3RoJiZudWxsPT09KHQ9bkVbMF0pLmJsb2NrZWRPbjspbk4odCksbnVsbD09PXQuYmxvY2tlZE9uJiZuRS5zaGlmdCgpfXZhciBuRj1fLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLG5PPSEwO2Z1bmN0aW9uIG5EKGUsbix0LHIpe3ZhciBsPW5jLGE9bkYudHJhbnNpdGlvbjtuRi50cmFuc2l0aW9uPW51bGw7dHJ5e25jPTEsblUoZSxuLHQscil9ZmluYWxseXtuYz1sLG5GLnRyYW5zaXRpb249YX19ZnVuY3Rpb24gbkkoZSxuLHQscil7dmFyIGw9bmMsYT1uRi50cmFuc2l0aW9uO25GLnRyYW5zaXRpb249bnVsbDt0cnl7bmM9NCxuVShlLG4sdCxyKX1maW5hbGx5e25jPWwsbkYudHJhbnNpdGlvbj1hfX1mdW5jdGlvbiBuVShlLG4sdCxyKXtpZihuTyl7dmFyIGw9bkEoZSxuLHQscik7aWYobnVsbD09PWwpcm8oZSxuLHIsblYsdCksbl8oZSxyKTtlbHNlIGlmKGZ1bmN0aW9uKGUsbix0LHIsbCl7c3dpdGNoKG4pe2Nhc2UiZm9jdXNpbiI6cmV0dXJuIG5iPW5QKG5iLGUsbix0LHIsbCksITA7Y2FzZSJkcmFnZW50ZXIiOnJldHVybiBuaz1uUChuayxlLG4sdCxyLGwpLCEwO2Nhc2UibW91c2VvdmVyIjpyZXR1cm4gbnc9blAobncsZSxuLHQscixsKSwhMDtjYXNlInBvaW50ZXJvdmVyIjp2YXIgYT1sLnBvaW50ZXJJZDtyZXR1cm4gblMuc2V0KGEsblAoblMuZ2V0KGEpfHxudWxsLGUsbix0LHIsbCkpLCEwO2Nhc2UiZ290cG9pbnRlcmNhcHR1cmUiOnJldHVybiBhPWwucG9pbnRlcklkLG54LnNldChhLG5QKG54LmdldChhKXx8bnVsbCxlLG4sdCxyLGwpKSwhMH1yZXR1cm4hMX0obCxlLG4sdCxyKSlyLnN0b3BQcm9wYWdhdGlvbigpO2Vsc2UgaWYobl8oZSxyKSw0Jm4mJi0xPG5DLmluZGV4T2YoZSkpe2Zvcig7bnVsbCE9PWw7KXt2YXIgYT1yRChsKTtpZihudWxsIT09YSYmbmQoYSksbnVsbD09PShhPW5BKGUsbix0LHIpKSYmcm8oZSxuLHIsblYsdCksYT09PWwpYnJlYWs7bD1hfW51bGwhPT1sJiZyLnN0b3BQcm9wYWdhdGlvbigpfWVsc2Ugcm8oZSxuLHIsbnVsbCx0KX19dmFyIG5WPW51bGw7ZnVuY3Rpb24gbkEoZSxuLHQscil7aWYoblY9bnVsbCxudWxsIT09KGU9ck8oZT1lRShyKSkpKXtpZihudWxsPT09KG49ZVcoZSkpKWU9bnVsbDtlbHNlIGlmKDEzPT09KHQ9bi50YWcpKXtpZihudWxsIT09KGU9ZVEobikpKXJldHVybiBlO2U9bnVsbH1lbHNlIGlmKDM9PT10KXtpZihuLnN0YXRlTm9kZS5jdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkKXJldHVybiAzPT09bi50YWc/bi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbzpudWxsO2U9bnVsbH1lbHNlIG4hPT1lJiYoZT1udWxsKX1yZXR1cm4gblY9ZSxudWxsfWZ1bmN0aW9uIG4kKGUpe3N3aXRjaChlKXtjYXNlImNhbmNlbCI6Y2FzZSJjbGljayI6Y2FzZSJjbG9zZSI6Y2FzZSJjb250ZXh0bWVudSI6Y2FzZSJjb3B5IjpjYXNlImN1dCI6Y2FzZSJhdXhjbGljayI6Y2FzZSJkYmxjbGljayI6Y2FzZSJkcmFnZW5kIjpjYXNlImRyYWdzdGFydCI6Y2FzZSJkcm9wIjpjYXNlImZvY3VzaW4iOmNhc2UiZm9jdXNvdXQiOmNhc2UiaW5wdXQiOmNhc2UiaW52YWxpZCI6Y2FzZSJrZXlkb3duIjpjYXNlImtleXByZXNzIjpjYXNlImtleXVwIjpjYXNlIm1vdXNlZG93biI6Y2FzZSJtb3VzZXVwIjpjYXNlInBhc3RlIjpjYXNlInBhdXNlIjpjYXNlInBsYXkiOmNhc2UicG9pbnRlcmNhbmNlbCI6Y2FzZSJwb2ludGVyZG93biI6Y2FzZSJwb2ludGVydXAiOmNhc2UicmF0ZWNoYW5nZSI6Y2FzZSJyZXNldCI6Y2FzZSJyZXNpemUiOmNhc2Uic2Vla2VkIjpjYXNlInN1Ym1pdCI6Y2FzZSJ0b3VjaGNhbmNlbCI6Y2FzZSJ0b3VjaGVuZCI6Y2FzZSJ0b3VjaHN0YXJ0IjpjYXNlInZvbHVtZWNoYW5nZSI6Y2FzZSJjaGFuZ2UiOmNhc2Uic2VsZWN0aW9uY2hhbmdlIjpjYXNlInRleHRJbnB1dCI6Y2FzZSJjb21wb3NpdGlvbnN0YXJ0IjpjYXNlImNvbXBvc2l0aW9uZW5kIjpjYXNlImNvbXBvc2l0aW9udXBkYXRlIjpjYXNlImJlZm9yZWJsdXIiOmNhc2UiYWZ0ZXJibHVyIjpjYXNlImJlZm9yZWlucHV0IjpjYXNlImJsdXIiOmNhc2UiZnVsbHNjcmVlbmNoYW5nZSI6Y2FzZSJmb2N1cyI6Y2FzZSJoYXNoY2hhbmdlIjpjYXNlInBvcHN0YXRlIjpjYXNlInNlbGVjdCI6Y2FzZSJzZWxlY3RzdGFydCI6cmV0dXJuIDE7Y2FzZSJkcmFnIjpjYXNlImRyYWdlbnRlciI6Y2FzZSJkcmFnZXhpdCI6Y2FzZSJkcmFnbGVhdmUiOmNhc2UiZHJhZ292ZXIiOmNhc2UibW91c2Vtb3ZlIjpjYXNlIm1vdXNlb3V0IjpjYXNlIm1vdXNlb3ZlciI6Y2FzZSJwb2ludGVybW92ZSI6Y2FzZSJwb2ludGVyb3V0IjpjYXNlInBvaW50ZXJvdmVyIjpjYXNlInNjcm9sbCI6Y2FzZSJ0b2dnbGUiOmNhc2UidG91Y2htb3ZlIjpjYXNlIndoZWVsIjpjYXNlIm1vdXNlZW50ZXIiOmNhc2UibW91c2VsZWF2ZSI6Y2FzZSJwb2ludGVyZW50ZXIiOmNhc2UicG9pbnRlcmxlYXZlIjpyZXR1cm4gNDtjYXNlIm1lc3NhZ2UiOnN3aXRjaChlMCgpKXtjYXNlIGUxOnJldHVybiAxO2Nhc2UgZTI6cmV0dXJuIDQ7Y2FzZSBlMzpjYXNlIGU0OnJldHVybiAxNjtjYXNlIGU4OnJldHVybiA1MzY4NzA5MTI7ZGVmYXVsdDpyZXR1cm4gMTZ9ZGVmYXVsdDpyZXR1cm4gMTZ9fXZhciBuaj1udWxsLG5CPW51bGwsbkg9bnVsbDtmdW5jdGlvbiBuVygpe2lmKG5IKXJldHVybiBuSDt2YXIgZSxuLHQ9bkIscj10Lmxlbmd0aCxsPSJ2YWx1ZSJpbiBuaj9uai52YWx1ZTpuai50ZXh0Q29udGVudCxhPWwubGVuZ3RoO2ZvcihlPTA7ZTxyJiZ0W2VdPT09bFtlXTtlKyspO3ZhciB1PXItZTtmb3Iobj0xO248PXUmJnRbci1uXT09PWxbYS1uXTtuKyspO3JldHVybiBuSD1sLnNsaWNlKGUsMTxuPzEtbjp2b2lkIDApfWZ1bmN0aW9uIG5RKGUpe3ZhciBuPWUua2V5Q29kZTtyZXR1cm4iY2hhckNvZGUiaW4gZT8wPT09KGU9ZS5jaGFyQ29kZSkmJjEzPT09biYmKGU9MTMpOmU9biwxMD09PWUmJihlPTEzKSwzMjw9ZXx8MTM9PT1lP2U6MH1mdW5jdGlvbiBucSgpe3JldHVybiEwfWZ1bmN0aW9uIG5LKCl7cmV0dXJuITF9ZnVuY3Rpb24gblkoZSl7ZnVuY3Rpb24gbihuLHQscixsLGEpe2Zvcih2YXIgdSBpbiB0aGlzLl9yZWFjdE5hbWU9bix0aGlzLl90YXJnZXRJbnN0PXIsdGhpcy50eXBlPXQsdGhpcy5uYXRpdmVFdmVudD1sLHRoaXMudGFyZ2V0PWEsdGhpcy5jdXJyZW50VGFyZ2V0PW51bGwsZSllLmhhc093blByb3BlcnR5KHUpJiYobj1lW3VdLHRoaXNbdV09bj9uKGwpOmxbdV0pO3JldHVybiB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD0obnVsbCE9bC5kZWZhdWx0UHJldmVudGVkP2wuZGVmYXVsdFByZXZlbnRlZDohMT09PWwucmV0dXJuVmFsdWUpP25xOm5LLHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQ9bkssdGhpc31yZXR1cm4gQihuLnByb3RvdHlwZSx7cHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXt0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ9ITA7dmFyIGU9dGhpcy5uYXRpdmVFdmVudDtlJiYoZS5wcmV2ZW50RGVmYXVsdD9lLnByZXZlbnREZWZhdWx0KCk6InVua25vd24iIT10eXBlb2YgZS5yZXR1cm5WYWx1ZSYmKGUucmV0dXJuVmFsdWU9ITEpLHRoaXMuaXNEZWZhdWx0UHJldmVudGVkPW5xKX0sc3RvcFByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5uYXRpdmVFdmVudDtlJiYoZS5zdG9wUHJvcGFnYXRpb24/ZS5zdG9wUHJvcGFnYXRpb24oKToidW5rbm93biIhPXR5cGVvZiBlLmNhbmNlbEJ1YmJsZSYmKGUuY2FuY2VsQnViYmxlPSEwKSx0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPW5xKX0scGVyc2lzdDpmdW5jdGlvbigpe30saXNQZXJzaXN0ZW50Om5xfSksbn12YXIgblgsbkcsblosbko9e2V2ZW50UGhhc2U6MCxidWJibGVzOjAsY2FuY2VsYWJsZTowLHRpbWVTdGFtcDpmdW5jdGlvbihlKXtyZXR1cm4gZS50aW1lU3RhbXB8fERhdGUubm93KCl9LGRlZmF1bHRQcmV2ZW50ZWQ6MCxpc1RydXN0ZWQ6MH0sbjA9blkobkopLG4xPUIoe30sbkose3ZpZXc6MCxkZXRhaWw6MH0pLG4yPW5ZKG4xKSxuMz1CKHt9LG4xLHtzY3JlZW5YOjAsc2NyZWVuWTowLGNsaWVudFg6MCxjbGllbnRZOjAscGFnZVg6MCxwYWdlWTowLGN0cmxLZXk6MCxzaGlmdEtleTowLGFsdEtleTowLG1ldGFLZXk6MCxnZXRNb2RpZmllclN0YXRlOnRsLGJ1dHRvbjowLGJ1dHRvbnM6MCxyZWxhdGVkVGFyZ2V0OmZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lLnJlbGF0ZWRUYXJnZXQ/ZS5mcm9tRWxlbWVudD09PWUuc3JjRWxlbWVudD9lLnRvRWxlbWVudDplLmZyb21FbGVtZW50OmUucmVsYXRlZFRhcmdldH0sbW92ZW1lbnRYOmZ1bmN0aW9uKGUpe3JldHVybiJtb3ZlbWVudFgiaW4gZT9lLm1vdmVtZW50WDooZSE9PW5aJiYoblomJiJtb3VzZW1vdmUiPT09ZS50eXBlPyhuWD1lLnNjcmVlblgtblouc2NyZWVuWCxuRz1lLnNjcmVlblktblouc2NyZWVuWSk6bkc9blg9MCxuWj1lKSxuWCl9LG1vdmVtZW50WTpmdW5jdGlvbihlKXtyZXR1cm4ibW92ZW1lbnRZImluIGU/ZS5tb3ZlbWVudFk6bkd9fSksbjQ9blkobjMpLG44PW5ZKEIoe30sbjMse2RhdGFUcmFuc2ZlcjowfSkpLG42PW5ZKEIoe30sbjEse3JlbGF0ZWRUYXJnZXQ6MH0pKSxuNT1uWShCKHt9LG5KLHthbmltYXRpb25OYW1lOjAsZWxhcHNlZFRpbWU6MCxwc2V1ZG9FbGVtZW50OjB9KSksbjk9blkoQih7fSxuSix7Y2xpcGJvYXJkRGF0YTpmdW5jdGlvbihlKXtyZXR1cm4iY2xpcGJvYXJkRGF0YSJpbiBlP2UuY2xpcGJvYXJkRGF0YTp3aW5kb3cuY2xpcGJvYXJkRGF0YX19KSksbjc9blkoQih7fSxuSix7ZGF0YTowfSkpLHRlPXtFc2M6IkVzY2FwZSIsU3BhY2ViYXI6IiAiLExlZnQ6IkFycm93TGVmdCIsVXA6IkFycm93VXAiLFJpZ2h0OiJBcnJvd1JpZ2h0IixEb3duOiJBcnJvd0Rvd24iLERlbDoiRGVsZXRlIixXaW46Ik9TIixNZW51OiJDb250ZXh0TWVudSIsQXBwczoiQ29udGV4dE1lbnUiLFNjcm9sbDoiU2Nyb2xsTG9jayIsTW96UHJpbnRhYmxlS2V5OiJVbmlkZW50aWZpZWQifSx0bj17ODoiQmFja3NwYWNlIiw5OiJUYWIiLDEyOiJDbGVhciIsMTM6IkVudGVyIiwxNjoiU2hpZnQiLDE3OiJDb250cm9sIiwxODoiQWx0IiwxOToiUGF1c2UiLDIwOiJDYXBzTG9jayIsMjc6IkVzY2FwZSIsMzI6IiAiLDMzOiJQYWdlVXAiLDM0OiJQYWdlRG93biIsMzU6IkVuZCIsMzY6IkhvbWUiLDM3OiJBcnJvd0xlZnQiLDM4OiJBcnJvd1VwIiwzOToiQXJyb3dSaWdodCIsNDA6IkFycm93RG93biIsNDU6Ikluc2VydCIsNDY6IkRlbGV0ZSIsMTEyOiJGMSIsMTEzOiJGMiIsMTE0OiJGMyIsMTE1OiJGNCIsMTE2OiJGNSIsMTE3OiJGNiIsMTE4OiJGNyIsMTE5OiJGOCIsMTIwOiJGOSIsMTIxOiJGMTAiLDEyMjoiRjExIiwxMjM6IkYxMiIsMTQ0OiJOdW1Mb2NrIiwxNDU6IlNjcm9sbExvY2siLDIyNDoiTWV0YSJ9LHR0PXtBbHQ6ImFsdEtleSIsQ29udHJvbDoiY3RybEtleSIsTWV0YToibWV0YUtleSIsU2hpZnQ6InNoaWZ0S2V5In07ZnVuY3Rpb24gdHIoZSl7dmFyIG49dGhpcy5uYXRpdmVFdmVudDtyZXR1cm4gbi5nZXRNb2RpZmllclN0YXRlP24uZ2V0TW9kaWZpZXJTdGF0ZShlKTohIShlPXR0W2VdKSYmISFuW2VdfWZ1bmN0aW9uIHRsKCl7cmV0dXJuIHRyfXZhciB0YT1uWShCKHt9LG4xLHtrZXk6ZnVuY3Rpb24oZSl7aWYoZS5rZXkpe3ZhciBuPXRlW2Uua2V5XXx8ZS5rZXk7aWYoIlVuaWRlbnRpZmllZCIhPT1uKXJldHVybiBufXJldHVybiJrZXlwcmVzcyI9PT1lLnR5cGU/MTM9PT0oZT1uUShlKSk/IkVudGVyIjpTdHJpbmcuZnJvbUNoYXJDb2RlKGUpOiJrZXlkb3duIj09PWUudHlwZXx8ImtleXVwIj09PWUudHlwZT90bltlLmtleUNvZGVdfHwiVW5pZGVudGlmaWVkIjoiIn0sY29kZTowLGxvY2F0aW9uOjAsY3RybEtleTowLHNoaWZ0S2V5OjAsYWx0S2V5OjAsbWV0YUtleTowLHJlcGVhdDowLGxvY2FsZTowLGdldE1vZGlmaWVyU3RhdGU6dGwsY2hhckNvZGU6ZnVuY3Rpb24oZSl7cmV0dXJuImtleXByZXNzIj09PWUudHlwZT9uUShlKTowfSxrZXlDb2RlOmZ1bmN0aW9uKGUpe3JldHVybiJrZXlkb3duIj09PWUudHlwZXx8ImtleXVwIj09PWUudHlwZT9lLmtleUNvZGU6MH0sd2hpY2g6ZnVuY3Rpb24oZSl7cmV0dXJuImtleXByZXNzIj09PWUudHlwZT9uUShlKToia2V5ZG93biI9PT1lLnR5cGV8fCJrZXl1cCI9PT1lLnR5cGU/ZS5rZXlDb2RlOjB9fSkpLHR1PW5ZKEIoe30sbjMse3BvaW50ZXJJZDowLHdpZHRoOjAsaGVpZ2h0OjAscHJlc3N1cmU6MCx0YW5nZW50aWFsUHJlc3N1cmU6MCx0aWx0WDowLHRpbHRZOjAsdHdpc3Q6MCxwb2ludGVyVHlwZTowLGlzUHJpbWFyeTowfSkpLHRvPW5ZKEIoe30sbjEse3RvdWNoZXM6MCx0YXJnZXRUb3VjaGVzOjAsY2hhbmdlZFRvdWNoZXM6MCxhbHRLZXk6MCxtZXRhS2V5OjAsY3RybEtleTowLHNoaWZ0S2V5OjAsZ2V0TW9kaWZpZXJTdGF0ZTp0bH0pKSx0aT1uWShCKHt9LG5KLHtwcm9wZXJ0eU5hbWU6MCxlbGFwc2VkVGltZTowLHBzZXVkb0VsZW1lbnQ6MH0pKSx0cz1uWShCKHt9LG4zLHtkZWx0YVg6ZnVuY3Rpb24oZSl7cmV0dXJuImRlbHRhWCJpbiBlP2UuZGVsdGFYOiJ3aGVlbERlbHRhWCJpbiBlPy1lLndoZWVsRGVsdGFYOjB9LGRlbHRhWTpmdW5jdGlvbihlKXtyZXR1cm4iZGVsdGFZImluIGU/ZS5kZWx0YVk6IndoZWVsRGVsdGFZImluIGU/LWUud2hlZWxEZWx0YVk6IndoZWVsRGVsdGEiaW4gZT8tZS53aGVlbERlbHRhOjB9LGRlbHRhWjowLGRlbHRhTW9kZTowfSkpLHRjPVs5LDEzLDI3LDMyXSx0Zj1nJiYiQ29tcG9zaXRpb25FdmVudCJpbiB3aW5kb3csdGQ9bnVsbDtnJiYiZG9jdW1lbnRNb2RlImluIGRvY3VtZW50JiYodGQ9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTt2YXIgdHA9ZyYmIlRleHRFdmVudCJpbiB3aW5kb3cmJiF0ZCx0bT1nJiYoIXRmfHx0ZCYmODx0ZCYmMTE+PXRkKSx0aD0hMTtmdW5jdGlvbiB0ZyhlLG4pe3N3aXRjaChlKXtjYXNlImtleXVwIjpyZXR1cm4gLTEhPT10Yy5pbmRleE9mKG4ua2V5Q29kZSk7Y2FzZSJrZXlkb3duIjpyZXR1cm4gMjI5IT09bi5rZXlDb2RlO2Nhc2Uia2V5cHJlc3MiOmNhc2UibW91c2Vkb3duIjpjYXNlImZvY3Vzb3V0IjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiB0dihlKXtyZXR1cm4ib2JqZWN0Ij09dHlwZW9mKGU9ZS5kZXRhaWwpJiYiZGF0YSJpbiBlP2UuZGF0YTpudWxsfXZhciB0eT0hMSx0Yj17Y29sb3I6ITAsZGF0ZTohMCxkYXRldGltZTohMCwiZGF0ZXRpbWUtbG9jYWwiOiEwLGVtYWlsOiEwLG1vbnRoOiEwLG51bWJlcjohMCxwYXNzd29yZDohMCxyYW5nZTohMCxzZWFyY2g6ITAsdGVsOiEwLHRleHQ6ITAsdGltZTohMCx1cmw6ITAsd2VlazohMH07ZnVuY3Rpb24gdGsoZSl7dmFyIG49ZSYmZS5ub2RlTmFtZSYmZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVybiJpbnB1dCI9PT1uPyEhdGJbZS50eXBlXToidGV4dGFyZWEiPT09bn1mdW5jdGlvbiB0dyhlLG4sdCxyKXtleihyKSwwPChuPXJzKG4sIm9uQ2hhbmdlIikpLmxlbmd0aCYmKHQ9bmV3IG4wKCJvbkNoYW5nZSIsImNoYW5nZSIsbnVsbCx0LHIpLGUucHVzaCh7ZXZlbnQ6dCxsaXN0ZW5lcnM6bn0pKX12YXIgdFM9bnVsbCx0eD1udWxsO2Z1bmN0aW9uIHRFKGUpe3JuKGUsMCl9ZnVuY3Rpb24gdEMoZSl7aWYoWChySShlKSkpcmV0dXJuIGV9ZnVuY3Rpb24gdF8oZSxuKXtpZigiY2hhbmdlIj09PWUpcmV0dXJuIG59dmFyIHRQPSExO2lmKGcpe2lmKGcpe3ZhciB0Tj0ib25pbnB1dCJpbiBkb2N1bWVudDtpZighdE4pe3ZhciB0ej1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTt0ei5zZXRBdHRyaWJ1dGUoIm9uaW5wdXQiLCJyZXR1cm47IiksdE49ImZ1bmN0aW9uIj09dHlwZW9mIHR6Lm9uaW5wdXR9cj10Tn1lbHNlIHI9ITE7dFA9ciYmKCFkb2N1bWVudC5kb2N1bWVudE1vZGV8fDk8ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKX1mdW5jdGlvbiB0VCgpe3RTJiYodFMuZGV0YWNoRXZlbnQoIm9ucHJvcGVydHljaGFuZ2UiLHRMKSx0eD10Uz1udWxsKX1mdW5jdGlvbiB0TChlKXtpZigidmFsdWUiPT09ZS5wcm9wZXJ0eU5hbWUmJnRDKHR4KSl7dmFyIG49W107dHcobix0eCxlLGVFKGUpKSxlRih0RSxuKX19ZnVuY3Rpb24gdFIoZSxuLHQpeyJmb2N1c2luIj09PWU/KHRUKCksdFM9bix0eD10LHRTLmF0dGFjaEV2ZW50KCJvbnByb3BlcnR5Y2hhbmdlIix0TCkpOiJmb2N1c291dCI9PT1lJiZ0VCgpfWZ1bmN0aW9uIHRNKGUpe2lmKCJzZWxlY3Rpb25jaGFuZ2UiPT09ZXx8ImtleXVwIj09PWV8fCJrZXlkb3duIj09PWUpcmV0dXJuIHRDKHR4KX1mdW5jdGlvbiB0RihlLG4pe2lmKCJjbGljayI9PT1lKXJldHVybiB0QyhuKX1mdW5jdGlvbiB0TyhlLG4pe2lmKCJpbnB1dCI9PT1lfHwiY2hhbmdlIj09PWUpcmV0dXJuIHRDKG4pfXZhciB0RD0iZnVuY3Rpb24iPT10eXBlb2YgT2JqZWN0LmlzP09iamVjdC5pczpmdW5jdGlvbihlLG4pe3JldHVybiBlPT09biYmKDAhPT1lfHwxL2U9PTEvbil8fGUhPWUmJm4hPW59O2Z1bmN0aW9uIHRJKGUsbil7aWYodEQoZSxuKSlyZXR1cm4hMDtpZigib2JqZWN0IiE9dHlwZW9mIGV8fG51bGw9PT1lfHwib2JqZWN0IiE9dHlwZW9mIG58fG51bGw9PT1uKXJldHVybiExO3ZhciB0PU9iamVjdC5rZXlzKGUpLHI9T2JqZWN0LmtleXMobik7aWYodC5sZW5ndGghPT1yLmxlbmd0aClyZXR1cm4hMTtmb3Iocj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbD10W3JdO2lmKCF2LmNhbGwobixsKXx8IXREKGVbbF0sbltsXSkpcmV0dXJuITF9cmV0dXJuITB9ZnVuY3Rpb24gdFUoZSl7Zm9yKDtlJiZlLmZpcnN0Q2hpbGQ7KWU9ZS5maXJzdENoaWxkO3JldHVybiBlfWZ1bmN0aW9uIHRWKGUsbil7dmFyIHQscj10VShlKTtmb3IoZT0wO3I7KXtpZigzPT09ci5ub2RlVHlwZSl7aWYodD1lK3IudGV4dENvbnRlbnQubGVuZ3RoLGU8PW4mJnQ+PW4pcmV0dXJue25vZGU6cixvZmZzZXQ6bi1lfTtlPXR9ZTp7Zm9yKDtyOyl7aWYoci5uZXh0U2libGluZyl7cj1yLm5leHRTaWJsaW5nO2JyZWFrIGV9cj1yLnBhcmVudE5vZGV9cj12b2lkIDB9cj10VShyKX19ZnVuY3Rpb24gdEEoKXtmb3IodmFyIGU9d2luZG93LG49RygpO24gaW5zdGFuY2VvZiBlLkhUTUxJRnJhbWVFbGVtZW50Oyl7dHJ5e3ZhciB0PSJzdHJpbmciPT10eXBlb2Ygbi5jb250ZW50V2luZG93LmxvY2F0aW9uLmhyZWZ9Y2F0Y2goZSl7dD0hMX1pZih0KWU9bi5jb250ZW50V2luZG93O2Vsc2UgYnJlYWs7bj1HKGUuZG9jdW1lbnQpfXJldHVybiBufWZ1bmN0aW9uIHQkKGUpe3ZhciBuPWUmJmUubm9kZU5hbWUmJmUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gbiYmKCJpbnB1dCI9PT1uJiYoInRleHQiPT09ZS50eXBlfHwic2VhcmNoIj09PWUudHlwZXx8InRlbCI9PT1lLnR5cGV8fCJ1cmwiPT09ZS50eXBlfHwicGFzc3dvcmQiPT09ZS50eXBlKXx8InRleHRhcmVhIj09PW58fCJ0cnVlIj09PWUuY29udGVudEVkaXRhYmxlKX12YXIgdGo9ZyYmImRvY3VtZW50TW9kZSJpbiBkb2N1bWVudCYmMTE+PWRvY3VtZW50LmRvY3VtZW50TW9kZSx0Qj1udWxsLHRIPW51bGwsdFc9bnVsbCx0UT0hMTtmdW5jdGlvbiB0cShlLG4sdCl7dmFyIHI9dC53aW5kb3c9PT10P3QuZG9jdW1lbnQ6OT09PXQubm9kZVR5cGU/dDp0Lm93bmVyRG9jdW1lbnQ7dFF8fG51bGw9PXRCfHx0QiE9PUcocil8fChyPSJzZWxlY3Rpb25TdGFydCJpbihyPXRCKSYmdCQocik/e3N0YXJ0OnIuc2VsZWN0aW9uU3RhcnQsZW5kOnIuc2VsZWN0aW9uRW5kfTp7YW5jaG9yTm9kZToocj0oci5vd25lckRvY3VtZW50JiZyLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXd8fHdpbmRvdykuZ2V0U2VsZWN0aW9uKCkpLmFuY2hvck5vZGUsYW5jaG9yT2Zmc2V0OnIuYW5jaG9yT2Zmc2V0LGZvY3VzTm9kZTpyLmZvY3VzTm9kZSxmb2N1c09mZnNldDpyLmZvY3VzT2Zmc2V0fSx0VyYmdEkodFcscil8fCh0Vz1yLDA8KHI9cnModEgsIm9uU2VsZWN0IikpLmxlbmd0aCYmKG49bmV3IG4wKCJvblNlbGVjdCIsInNlbGVjdCIsbnVsbCxuLHQpLGUucHVzaCh7ZXZlbnQ6bixsaXN0ZW5lcnM6cn0pLG4udGFyZ2V0PXRCKSkpfWZ1bmN0aW9uIHRLKGUsbil7dmFyIHQ9e307cmV0dXJuIHRbZS50b0xvd2VyQ2FzZSgpXT1uLnRvTG93ZXJDYXNlKCksdFsiV2Via2l0IitlXT0id2Via2l0IituLHRbIk1veiIrZV09Im1veiIrbix0fXZhciB0WT17YW5pbWF0aW9uZW5kOnRLKCJBbmltYXRpb24iLCJBbmltYXRpb25FbmQiKSxhbmltYXRpb25pdGVyYXRpb246dEsoIkFuaW1hdGlvbiIsIkFuaW1hdGlvbkl0ZXJhdGlvbiIpLGFuaW1hdGlvbnN0YXJ0OnRLKCJBbmltYXRpb24iLCJBbmltYXRpb25TdGFydCIpLHRyYW5zaXRpb25lbmQ6dEsoIlRyYW5zaXRpb24iLCJUcmFuc2l0aW9uRW5kIil9LHRYPXt9LHRHPXt9O2Z1bmN0aW9uIHRaKGUpe2lmKHRYW2VdKXJldHVybiB0WFtlXTtpZighdFlbZV0pcmV0dXJuIGU7dmFyIG4sdD10WVtlXTtmb3IobiBpbiB0KWlmKHQuaGFzT3duUHJvcGVydHkobikmJm4gaW4gdEcpcmV0dXJuIHRYW2VdPXRbbl07cmV0dXJuIGV9ZyYmKHRHPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLnN0eWxlLCJBbmltYXRpb25FdmVudCJpbiB3aW5kb3d8fChkZWxldGUgdFkuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbixkZWxldGUgdFkuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbixkZWxldGUgdFkuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uKSwiVHJhbnNpdGlvbkV2ZW50ImluIHdpbmRvd3x8ZGVsZXRlIHRZLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbik7dmFyIHRKPXRaKCJhbmltYXRpb25lbmQiKSx0MD10WigiYW5pbWF0aW9uaXRlcmF0aW9uIiksdDE9dFooImFuaW1hdGlvbnN0YXJ0IiksdDI9dFooInRyYW5zaXRpb25lbmQiKSx0Mz1uZXcgTWFwLHQ0PSJhYm9ydCBhdXhDbGljayBjYW5jZWwgY2FuUGxheSBjYW5QbGF5VGhyb3VnaCBjbGljayBjbG9zZSBjb250ZXh0TWVudSBjb3B5IGN1dCBkcmFnIGRyYWdFbmQgZHJhZ0VudGVyIGRyYWdFeGl0IGRyYWdMZWF2ZSBkcmFnT3ZlciBkcmFnU3RhcnQgZHJvcCBkdXJhdGlvbkNoYW5nZSBlbXB0aWVkIGVuY3J5cHRlZCBlbmRlZCBlcnJvciBnb3RQb2ludGVyQ2FwdHVyZSBpbnB1dCBpbnZhbGlkIGtleURvd24ga2V5UHJlc3Mga2V5VXAgbG9hZCBsb2FkZWREYXRhIGxvYWRlZE1ldGFkYXRhIGxvYWRTdGFydCBsb3N0UG9pbnRlckNhcHR1cmUgbW91c2VEb3duIG1vdXNlTW92ZSBtb3VzZU91dCBtb3VzZU92ZXIgbW91c2VVcCBwYXN0ZSBwYXVzZSBwbGF5IHBsYXlpbmcgcG9pbnRlckNhbmNlbCBwb2ludGVyRG93biBwb2ludGVyTW92ZSBwb2ludGVyT3V0IHBvaW50ZXJPdmVyIHBvaW50ZXJVcCBwcm9ncmVzcyByYXRlQ2hhbmdlIHJlc2V0IHJlc2l6ZSBzZWVrZWQgc2Vla2luZyBzdGFsbGVkIHN1Ym1pdCBzdXNwZW5kIHRpbWVVcGRhdGUgdG91Y2hDYW5jZWwgdG91Y2hFbmQgdG91Y2hTdGFydCB2b2x1bWVDaGFuZ2Ugc2Nyb2xsIHRvZ2dsZSB0b3VjaE1vdmUgd2FpdGluZyB3aGVlbCIuc3BsaXQoIiAiKTtmdW5jdGlvbiB0OChlLG4pe3QzLnNldChlLG4pLG0obixbZV0pfWZvcih2YXIgdDY9MDt0Njx0NC5sZW5ndGg7dDYrKyl7dmFyIHQ1PXQ0W3Q2XTt0OCh0NS50b0xvd2VyQ2FzZSgpLCJvbiIrKHQ1WzBdLnRvVXBwZXJDYXNlKCkrdDUuc2xpY2UoMSkpKX10OCh0Siwib25BbmltYXRpb25FbmQiKSx0OCh0MCwib25BbmltYXRpb25JdGVyYXRpb24iKSx0OCh0MSwib25BbmltYXRpb25TdGFydCIpLHQ4KCJkYmxjbGljayIsIm9uRG91YmxlQ2xpY2siKSx0OCgiZm9jdXNpbiIsIm9uRm9jdXMiKSx0OCgiZm9jdXNvdXQiLCJvbkJsdXIiKSx0OCh0Miwib25UcmFuc2l0aW9uRW5kIiksaCgib25Nb3VzZUVudGVyIixbIm1vdXNlb3V0IiwibW91c2VvdmVyIl0pLGgoIm9uTW91c2VMZWF2ZSIsWyJtb3VzZW91dCIsIm1vdXNlb3ZlciJdKSxoKCJvblBvaW50ZXJFbnRlciIsWyJwb2ludGVyb3V0IiwicG9pbnRlcm92ZXIiXSksaCgib25Qb2ludGVyTGVhdmUiLFsicG9pbnRlcm91dCIsInBvaW50ZXJvdmVyIl0pLG0oIm9uQ2hhbmdlIiwiY2hhbmdlIGNsaWNrIGZvY3VzaW4gZm9jdXNvdXQgaW5wdXQga2V5ZG93biBrZXl1cCBzZWxlY3Rpb25jaGFuZ2UiLnNwbGl0KCIgIikpLG0oIm9uU2VsZWN0IiwiZm9jdXNvdXQgY29udGV4dG1lbnUgZHJhZ2VuZCBmb2N1c2luIGtleWRvd24ga2V5dXAgbW91c2Vkb3duIG1vdXNldXAgc2VsZWN0aW9uY2hhbmdlIi5zcGxpdCgiICIpKSxtKCJvbkJlZm9yZUlucHV0IixbImNvbXBvc2l0aW9uZW5kIiwia2V5cHJlc3MiLCJ0ZXh0SW5wdXQiLCJwYXN0ZSJdKSxtKCJvbkNvbXBvc2l0aW9uRW5kIiwiY29tcG9zaXRpb25lbmQgZm9jdXNvdXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd24iLnNwbGl0KCIgIikpLG0oIm9uQ29tcG9zaXRpb25TdGFydCIsImNvbXBvc2l0aW9uc3RhcnQgZm9jdXNvdXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd24iLnNwbGl0KCIgIikpLG0oIm9uQ29tcG9zaXRpb25VcGRhdGUiLCJjb21wb3NpdGlvbnVwZGF0ZSBmb2N1c291dCBrZXlkb3duIGtleXByZXNzIGtleXVwIG1vdXNlZG93biIuc3BsaXQoIiAiKSk7dmFyIHQ5PSJhYm9ydCBjYW5wbGF5IGNhbnBsYXl0aHJvdWdoIGR1cmF0aW9uY2hhbmdlIGVtcHRpZWQgZW5jcnlwdGVkIGVuZGVkIGVycm9yIGxvYWRlZGRhdGEgbG9hZGVkbWV0YWRhdGEgbG9hZHN0YXJ0IHBhdXNlIHBsYXkgcGxheWluZyBwcm9ncmVzcyByYXRlY2hhbmdlIHJlc2l6ZSBzZWVrZWQgc2Vla2luZyBzdGFsbGVkIHN1c3BlbmQgdGltZXVwZGF0ZSB2b2x1bWVjaGFuZ2Ugd2FpdGluZyIuc3BsaXQoIiAiKSx0Nz1uZXcgU2V0KCJjYW5jZWwgY2xvc2UgaW52YWxpZCBsb2FkIHNjcm9sbCB0b2dnbGUiLnNwbGl0KCIgIikuY29uY2F0KHQ5KSk7ZnVuY3Rpb24gcmUoZSxuLHQpe3ZhciByPWUudHlwZXx8InVua25vd24tZXZlbnQiO2UuY3VycmVudFRhcmdldD10LGZ1bmN0aW9uKGUsbix0LHIsbCxhLHUsbyxpKXtpZihlSC5hcHBseSh0aGlzLGFyZ3VtZW50cyksZVYpe2lmKGVWKXt2YXIgcz1lQTtlVj0hMSxlQT1udWxsfWVsc2UgdGhyb3cgRXJyb3IoZigxOTgpKTtlJHx8KGUkPSEwLGVqPXMpfX0ocixuLHZvaWQgMCxlKSxlLmN1cnJlbnRUYXJnZXQ9bnVsbH1mdW5jdGlvbiBybihlLG4pe249MCE9KDQmbik7Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDt0Kyspe3ZhciByPWVbdF0sbD1yLmV2ZW50O3I9ci5saXN0ZW5lcnM7ZTp7dmFyIGE9dm9pZCAwO2lmKG4pZm9yKHZhciB1PXIubGVuZ3RoLTE7MDw9dTt1LS0pe3ZhciBvPXJbdV0saT1vLmluc3RhbmNlLHM9by5jdXJyZW50VGFyZ2V0O2lmKG89by5saXN0ZW5lcixpIT09YSYmbC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKWJyZWFrIGU7cmUobCxvLHMpLGE9aX1lbHNlIGZvcih1PTA7dTxyLmxlbmd0aDt1Kyspe2lmKGk9KG89clt1XSkuaW5zdGFuY2Uscz1vLmN1cnJlbnRUYXJnZXQsbz1vLmxpc3RlbmVyLGkhPT1hJiZsLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpYnJlYWsgZTtyZShsLG8scyksYT1pfX19aWYoZSQpdGhyb3cgZT1laixlJD0hMSxlaj1udWxsLGV9ZnVuY3Rpb24gcnQoZSxuKXt2YXIgdD1uW3JSXTt2b2lkIDA9PT10JiYodD1uW3JSXT1uZXcgU2V0KTt2YXIgcj1lKyJfX2J1YmJsZSI7dC5oYXMocil8fChydShuLGUsMiwhMSksdC5hZGQocikpfWZ1bmN0aW9uIHJyKGUsbix0KXt2YXIgcj0wO24mJihyfD00KSxydSh0LGUscixuKX12YXIgcmw9Il9yZWFjdExpc3RlbmluZyIrTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7ZnVuY3Rpb24gcmEoZSl7aWYoIWVbcmxdKXtlW3JsXT0hMCxkLmZvckVhY2goZnVuY3Rpb24obil7InNlbGVjdGlvbmNoYW5nZSIhPT1uJiYodDcuaGFzKG4pfHxycihuLCExLGUpLHJyKG4sITAsZSkpfSk7dmFyIG49OT09PWUubm9kZVR5cGU/ZTplLm93bmVyRG9jdW1lbnQ7bnVsbD09PW58fG5bcmxdfHwobltybF09ITAscnIoInNlbGVjdGlvbmNoYW5nZSIsITEsbikpfX1mdW5jdGlvbiBydShlLG4sdCxyKXtzd2l0Y2gobiQobikpe2Nhc2UgMTp2YXIgbD1uRDticmVhaztjYXNlIDQ6bD1uSTticmVhaztkZWZhdWx0Omw9blV9dD1sLmJpbmQobnVsbCxuLHQsZSksbD12b2lkIDAsZUQmJigidG91Y2hzdGFydCI9PT1ufHwidG91Y2htb3ZlIj09PW58fCJ3aGVlbCI9PT1uKSYmKGw9ITApLHI/dm9pZCAwIT09bD9lLmFkZEV2ZW50TGlzdGVuZXIobix0LHtjYXB0dXJlOiEwLHBhc3NpdmU6bH0pOmUuYWRkRXZlbnRMaXN0ZW5lcihuLHQsITApOnZvaWQgMCE9PWw/ZS5hZGRFdmVudExpc3RlbmVyKG4sdCx7cGFzc2l2ZTpsfSk6ZS5hZGRFdmVudExpc3RlbmVyKG4sdCwhMSl9ZnVuY3Rpb24gcm8oZSxuLHQscixsKXt2YXIgYT1yO2lmKDA9PSgxJm4pJiYwPT0oMiZuKSYmbnVsbCE9PXIpZTpmb3IoOzspe2lmKG51bGw9PT1yKXJldHVybjt2YXIgdT1yLnRhZztpZigzPT09dXx8ND09PXUpe3ZhciBvPXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87aWYobz09PWx8fDg9PT1vLm5vZGVUeXBlJiZvLnBhcmVudE5vZGU9PT1sKWJyZWFrO2lmKDQ9PT11KWZvcih1PXIucmV0dXJuO251bGwhPT11Oyl7dmFyIGk9dS50YWc7aWYoKDM9PT1pfHw0PT09aSkmJigoaT11LnN0YXRlTm9kZS5jb250YWluZXJJbmZvKT09PWx8fDg9PT1pLm5vZGVUeXBlJiZpLnBhcmVudE5vZGU9PT1sKSlyZXR1cm47dT11LnJldHVybn1mb3IoO251bGwhPT1vOyl7aWYobnVsbD09PSh1PXJPKG8pKSlyZXR1cm47aWYoNT09PShpPXUudGFnKXx8Nj09PWkpe3I9YT11O2NvbnRpbnVlIGV9bz1vLnBhcmVudE5vZGV9fXI9ci5yZXR1cm59ZUYoZnVuY3Rpb24oKXt2YXIgcj1hLGw9ZUUodCksdT1bXTtlOnt2YXIgbz10My5nZXQoZSk7aWYodm9pZCAwIT09byl7dmFyIGk9bjAscz1lO3N3aXRjaChlKXtjYXNlImtleXByZXNzIjppZigwPT09blEodCkpYnJlYWsgZTtjYXNlImtleWRvd24iOmNhc2Uia2V5dXAiOmk9dGE7YnJlYWs7Y2FzZSJmb2N1c2luIjpzPSJmb2N1cyIsaT1uNjticmVhaztjYXNlImZvY3Vzb3V0IjpzPSJibHVyIixpPW42O2JyZWFrO2Nhc2UiYmVmb3JlYmx1ciI6Y2FzZSJhZnRlcmJsdXIiOmk9bjY7YnJlYWs7Y2FzZSJjbGljayI6aWYoMj09PXQuYnV0dG9uKWJyZWFrIGU7Y2FzZSJhdXhjbGljayI6Y2FzZSJkYmxjbGljayI6Y2FzZSJtb3VzZWRvd24iOmNhc2UibW91c2Vtb3ZlIjpjYXNlIm1vdXNldXAiOmNhc2UibW91c2VvdXQiOmNhc2UibW91c2VvdmVyIjpjYXNlImNvbnRleHRtZW51IjppPW40O2JyZWFrO2Nhc2UiZHJhZyI6Y2FzZSJkcmFnZW5kIjpjYXNlImRyYWdlbnRlciI6Y2FzZSJkcmFnZXhpdCI6Y2FzZSJkcmFnbGVhdmUiOmNhc2UiZHJhZ292ZXIiOmNhc2UiZHJhZ3N0YXJ0IjpjYXNlImRyb3AiOmk9bjg7YnJlYWs7Y2FzZSJ0b3VjaGNhbmNlbCI6Y2FzZSJ0b3VjaGVuZCI6Y2FzZSJ0b3VjaG1vdmUiOmNhc2UidG91Y2hzdGFydCI6aT10bzticmVhaztjYXNlIHRKOmNhc2UgdDA6Y2FzZSB0MTppPW41O2JyZWFrO2Nhc2UgdDI6aT10aTticmVhaztjYXNlInNjcm9sbCI6aT1uMjticmVhaztjYXNlIndoZWVsIjppPXRzO2JyZWFrO2Nhc2UiY29weSI6Y2FzZSJjdXQiOmNhc2UicGFzdGUiOmk9bjk7YnJlYWs7Y2FzZSJnb3Rwb2ludGVyY2FwdHVyZSI6Y2FzZSJsb3N0cG9pbnRlcmNhcHR1cmUiOmNhc2UicG9pbnRlcmNhbmNlbCI6Y2FzZSJwb2ludGVyZG93biI6Y2FzZSJwb2ludGVybW92ZSI6Y2FzZSJwb2ludGVyb3V0IjpjYXNlInBvaW50ZXJvdmVyIjpjYXNlInBvaW50ZXJ1cCI6aT10dX12YXIgYz0wIT0oNCZuKSxmPSFjJiYic2Nyb2xsIj09PWUsZD1jP251bGwhPT1vP28rIkNhcHR1cmUiOm51bGw6bztjPVtdO2Zvcih2YXIgcCxtPXI7bnVsbCE9PW07KXt2YXIgaD0ocD1tKS5zdGF0ZU5vZGU7aWYoNT09PXAudGFnJiZudWxsIT09aCYmKHA9aCxudWxsIT09ZCYmbnVsbCE9KGg9ZU8obSxkKSkmJmMucHVzaChyaShtLGgscCkpKSxmKWJyZWFrO209bS5yZXR1cm59MDxjLmxlbmd0aCYmKG89bmV3IGkobyxzLG51bGwsdCxsKSx1LnB1c2goe2V2ZW50Om8sbGlzdGVuZXJzOmN9KSl9fWlmKDA9PSg3Jm4pKXtpZihvPSJtb3VzZW92ZXIiPT09ZXx8InBvaW50ZXJvdmVyIj09PWUsaT0ibW91c2VvdXQiPT09ZXx8InBvaW50ZXJvdXQiPT09ZSwhKG8mJnQhPT1leCYmKHM9dC5yZWxhdGVkVGFyZ2V0fHx0LmZyb21FbGVtZW50KSYmKHJPKHMpfHxzW3JMXSkpJiYoaXx8bykmJihvPWwud2luZG93PT09bD9sOihvPWwub3duZXJEb2N1bWVudCk/by5kZWZhdWx0Vmlld3x8by5wYXJlbnRXaW5kb3c6d2luZG93LGk/KHM9dC5yZWxhdGVkVGFyZ2V0fHx0LnRvRWxlbWVudCxpPXIsbnVsbCE9PShzPXM/ck8ocyk6bnVsbCkmJihmPWVXKHMpLHMhPT1mfHw1IT09cy50YWcmJjYhPT1zLnRhZykmJihzPW51bGwpKTooaT1udWxsLHM9ciksaSE9PXMpKXtpZihjPW40LGg9Im9uTW91c2VMZWF2ZSIsZD0ib25Nb3VzZUVudGVyIixtPSJtb3VzZSIsKCJwb2ludGVyb3V0Ij09PWV8fCJwb2ludGVyb3ZlciI9PT1lKSYmKGM9dHUsaD0ib25Qb2ludGVyTGVhdmUiLGQ9Im9uUG9pbnRlckVudGVyIixtPSJwb2ludGVyIiksZj1udWxsPT1pP286ckkoaSkscD1udWxsPT1zP286ckkocyksKG89bmV3IGMoaCxtKyJsZWF2ZSIsaSx0LGwpKS50YXJnZXQ9ZixvLnJlbGF0ZWRUYXJnZXQ9cCxoPW51bGwsck8obCk9PT1yJiYoKGM9bmV3IGMoZCxtKyJlbnRlciIscyx0LGwpKS50YXJnZXQ9cCxjLnJlbGF0ZWRUYXJnZXQ9ZixoPWMpLGY9aCxpJiZzKW46e2ZvcihjPWksZD1zLG09MCxwPWM7cDtwPXJjKHApKW0rKztmb3IocD0wLGg9ZDtoO2g9cmMoaCkpcCsrO2Zvcig7MDxtLXA7KWM9cmMoYyksbS0tO2Zvcig7MDxwLW07KWQ9cmMoZCkscC0tO2Zvcig7bS0tOyl7aWYoYz09PWR8fG51bGwhPT1kJiZjPT09ZC5hbHRlcm5hdGUpYnJlYWsgbjtjPXJjKGMpLGQ9cmMoZCl9Yz1udWxsfWVsc2UgYz1udWxsO251bGwhPT1pJiZyZih1LG8saSxjLCExKSxudWxsIT09cyYmbnVsbCE9PWYmJnJmKHUsZixzLGMsITApfWU6e2lmKCJzZWxlY3QiPT09KGk9KG89cj9ySShyKTp3aW5kb3cpLm5vZGVOYW1lJiZvLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpfHwiaW5wdXQiPT09aSYmImZpbGUiPT09by50eXBlKXZhciBnLHY9dF87ZWxzZSBpZih0ayhvKSl7aWYodFApdj10TztlbHNle3Y9dE07dmFyIHk9dFJ9fWVsc2UoaT1vLm5vZGVOYW1lKSYmImlucHV0Ij09PWkudG9Mb3dlckNhc2UoKSYmKCJjaGVja2JveCI9PT1vLnR5cGV8fCJyYWRpbyI9PT1vLnR5cGUpJiYodj10Rik7aWYodiYmKHY9dihlLHIpKSl7dHcodSx2LHQsbCk7YnJlYWsgZX15JiZ5KGUsbyxyKSwiZm9jdXNvdXQiPT09ZSYmKHk9by5fd3JhcHBlclN0YXRlKSYmeS5jb250cm9sbGVkJiYibnVtYmVyIj09PW8udHlwZSYmZXIobywibnVtYmVyIixvLnZhbHVlKX1zd2l0Y2goeT1yP3JJKHIpOndpbmRvdyxlKXtjYXNlImZvY3VzaW4iOih0ayh5KXx8InRydWUiPT09eS5jb250ZW50RWRpdGFibGUpJiYodEI9eSx0SD1yLHRXPW51bGwpO2JyZWFrO2Nhc2UiZm9jdXNvdXQiOnRXPXRIPXRCPW51bGw7YnJlYWs7Y2FzZSJtb3VzZWRvd24iOnRRPSEwO2JyZWFrO2Nhc2UiY29udGV4dG1lbnUiOmNhc2UibW91c2V1cCI6Y2FzZSJkcmFnZW5kIjp0UT0hMSx0cSh1LHQsbCk7YnJlYWs7Y2FzZSJzZWxlY3Rpb25jaGFuZ2UiOmlmKHRqKWJyZWFrO2Nhc2Uia2V5ZG93biI6Y2FzZSJrZXl1cCI6dHEodSx0LGwpfWlmKHRmKW46e3N3aXRjaChlKXtjYXNlImNvbXBvc2l0aW9uc3RhcnQiOnZhciBiPSJvbkNvbXBvc2l0aW9uU3RhcnQiO2JyZWFrIG47Y2FzZSJjb21wb3NpdGlvbmVuZCI6Yj0ib25Db21wb3NpdGlvbkVuZCI7YnJlYWsgbjtjYXNlImNvbXBvc2l0aW9udXBkYXRlIjpiPSJvbkNvbXBvc2l0aW9uVXBkYXRlIjticmVhayBufWI9dm9pZCAwfWVsc2UgdHk/dGcoZSx0KSYmKGI9Im9uQ29tcG9zaXRpb25FbmQiKToia2V5ZG93biI9PT1lJiYyMjk9PT10LmtleUNvZGUmJihiPSJvbkNvbXBvc2l0aW9uU3RhcnQiKTtiJiYodG0mJiJrbyIhPT10LmxvY2FsZSYmKHR5fHwib25Db21wb3NpdGlvblN0YXJ0IiE9PWI/Im9uQ29tcG9zaXRpb25FbmQiPT09YiYmdHkmJihnPW5XKCkpOihuQj0idmFsdWUiaW4obmo9bCk/bmoudmFsdWU6bmoudGV4dENvbnRlbnQsdHk9ITApKSwwPCh5PXJzKHIsYikpLmxlbmd0aCYmKGI9bmV3IG43KGIsZSxudWxsLHQsbCksdS5wdXNoKHtldmVudDpiLGxpc3RlbmVyczp5fSksZz9iLmRhdGE9ZzpudWxsIT09KGc9dHYodCkpJiYoYi5kYXRhPWcpKSksKGc9dHA/ZnVuY3Rpb24oZSxuKXtzd2l0Y2goZSl7Y2FzZSJjb21wb3NpdGlvbmVuZCI6cmV0dXJuIHR2KG4pO2Nhc2Uia2V5cHJlc3MiOmlmKDMyIT09bi53aGljaClyZXR1cm4gbnVsbDtyZXR1cm4gdGg9ITAsIiAiO2Nhc2UidGV4dElucHV0IjpyZXR1cm4iICI9PT0oZT1uLmRhdGEpJiZ0aD9udWxsOmU7ZGVmYXVsdDpyZXR1cm4gbnVsbH19KGUsdCk6ZnVuY3Rpb24oZSxuKXtpZih0eSlyZXR1cm4iY29tcG9zaXRpb25lbmQiPT09ZXx8IXRmJiZ0ZyhlLG4pPyhlPW5XKCksbkg9bkI9bmo9bnVsbCx0eT0hMSxlKTpudWxsO3N3aXRjaChlKXtjYXNlInBhc3RlIjpkZWZhdWx0OnJldHVybiBudWxsO2Nhc2Uia2V5cHJlc3MiOmlmKCEobi5jdHJsS2V5fHxuLmFsdEtleXx8bi5tZXRhS2V5KXx8bi5jdHJsS2V5JiZuLmFsdEtleSl7aWYobi5jaGFyJiYxPG4uY2hhci5sZW5ndGgpcmV0dXJuIG4uY2hhcjtpZihuLndoaWNoKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG4ud2hpY2gpfXJldHVybiBudWxsO2Nhc2UiY29tcG9zaXRpb25lbmQiOnJldHVybiB0bSYmImtvIiE9PW4ubG9jYWxlP251bGw6bi5kYXRhfX0oZSx0KSkmJjA8KHI9cnMociwib25CZWZvcmVJbnB1dCIpKS5sZW5ndGgmJihsPW5ldyBuNygib25CZWZvcmVJbnB1dCIsImJlZm9yZWlucHV0IixudWxsLHQsbCksdS5wdXNoKHtldmVudDpsLGxpc3RlbmVyczpyfSksbC5kYXRhPWcpfXJuKHUsbil9KX1mdW5jdGlvbiByaShlLG4sdCl7cmV0dXJue2luc3RhbmNlOmUsbGlzdGVuZXI6bixjdXJyZW50VGFyZ2V0OnR9fWZ1bmN0aW9uIHJzKGUsbil7Zm9yKHZhciB0PW4rIkNhcHR1cmUiLHI9W107bnVsbCE9PWU7KXt2YXIgbD1lLGE9bC5zdGF0ZU5vZGU7NT09PWwudGFnJiZudWxsIT09YSYmKGw9YSxudWxsIT0oYT1lTyhlLHQpKSYmci51bnNoaWZ0KHJpKGUsYSxsKSksbnVsbCE9KGE9ZU8oZSxuKSkmJnIucHVzaChyaShlLGEsbCkpKSxlPWUucmV0dXJufXJldHVybiByfWZ1bmN0aW9uIHJjKGUpe2lmKG51bGw9PT1lKXJldHVybiBudWxsO2RvIGU9ZS5yZXR1cm47d2hpbGUoZSYmNSE9PWUudGFnKTtyZXR1cm4gZXx8bnVsbH1mdW5jdGlvbiByZihlLG4sdCxyLGwpe2Zvcih2YXIgYT1uLl9yZWFjdE5hbWUsdT1bXTtudWxsIT09dCYmdCE9PXI7KXt2YXIgbz10LGk9by5hbHRlcm5hdGUscz1vLnN0YXRlTm9kZTtpZihudWxsIT09aSYmaT09PXIpYnJlYWs7NT09PW8udGFnJiZudWxsIT09cyYmKG89cyxsP251bGwhPShpPWVPKHQsYSkpJiZ1LnVuc2hpZnQocmkodCxpLG8pKTpsfHxudWxsIT0oaT1lTyh0LGEpKSYmdS5wdXNoKHJpKHQsaSxvKSkpLHQ9dC5yZXR1cm59MCE9PXUubGVuZ3RoJiZlLnB1c2goe2V2ZW50Om4sbGlzdGVuZXJzOnV9KX12YXIgcmQ9L1xyXG4/L2cscnA9L1x1MDAwMHxcdUZGRkQvZztmdW5jdGlvbiBybShlKXtyZXR1cm4oInN0cmluZyI9PXR5cGVvZiBlP2U6IiIrZSkucmVwbGFjZShyZCwiXG4iKS5yZXBsYWNlKHJwLCIiKX1mdW5jdGlvbiByaChlLG4sdCl7aWYobj1ybShuKSxybShlKSE9PW4mJnQpdGhyb3cgRXJyb3IoZig0MjUpKX1mdW5jdGlvbiByZygpe312YXIgcnY9bnVsbCxyeT1udWxsO2Z1bmN0aW9uIHJiKGUsbil7cmV0dXJuInRleHRhcmVhIj09PWV8fCJub3NjcmlwdCI9PT1lfHwic3RyaW5nIj09dHlwZW9mIG4uY2hpbGRyZW58fCJudW1iZXIiPT10eXBlb2Ygbi5jaGlsZHJlbnx8Im9iamVjdCI9PXR5cGVvZiBuLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiZudWxsIT09bi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmbnVsbCE9bi5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWx9dmFyIHJrPSJmdW5jdGlvbiI9PXR5cGVvZiBzZXRUaW1lb3V0P3NldFRpbWVvdXQ6dm9pZCAwLHJ3PSJmdW5jdGlvbiI9PXR5cGVvZiBjbGVhclRpbWVvdXQ/Y2xlYXJUaW1lb3V0OnZvaWQgMCxyUz0iZnVuY3Rpb24iPT10eXBlb2YgUHJvbWlzZT9Qcm9taXNlOnZvaWQgMCxyeD0iZnVuY3Rpb24iPT10eXBlb2YgcXVldWVNaWNyb3Rhc2s/cXVldWVNaWNyb3Rhc2s6dm9pZCAwIT09clM/ZnVuY3Rpb24oZSl7cmV0dXJuIHJTLnJlc29sdmUobnVsbCkudGhlbihlKS5jYXRjaChyRSl9OnJrO2Z1bmN0aW9uIHJFKGUpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0aHJvdyBlfSl9ZnVuY3Rpb24gckMoZSxuKXt2YXIgdD1uLHI9MDtkb3t2YXIgbD10Lm5leHRTaWJsaW5nO2lmKGUucmVtb3ZlQ2hpbGQodCksbCYmOD09PWwubm9kZVR5cGUpe2lmKCIvJCI9PT0odD1sLmRhdGEpKXtpZigwPT09cil7ZS5yZW1vdmVDaGlsZChsKSxuTShuKTtyZXR1cm59ci0tfWVsc2UiJCIhPT10JiYiJD8iIT09dCYmIiQhIiE9PXR8fHIrK310PWx9d2hpbGUodCk7bk0obil9ZnVuY3Rpb24gcl8oZSl7Zm9yKDtudWxsIT1lO2U9ZS5uZXh0U2libGluZyl7dmFyIG49ZS5ub2RlVHlwZTtpZigxPT09bnx8Mz09PW4pYnJlYWs7aWYoOD09PW4pe2lmKCIkIj09PShuPWUuZGF0YSl8fCIkISI9PT1ufHwiJD8iPT09bilicmVhaztpZigiLyQiPT09bilyZXR1cm4gbnVsbH19cmV0dXJuIGV9ZnVuY3Rpb24gclAoZSl7ZT1lLnByZXZpb3VzU2libGluZztmb3IodmFyIG49MDtlOyl7aWYoOD09PWUubm9kZVR5cGUpe3ZhciB0PWUuZGF0YTtpZigiJCI9PT10fHwiJCEiPT09dHx8IiQ/Ij09PXQpe2lmKDA9PT1uKXJldHVybiBlO24tLX1lbHNlIi8kIj09PXQmJm4rK31lPWUucHJldmlvdXNTaWJsaW5nfXJldHVybiBudWxsfXZhciByTj1NYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKSxyej0iX19yZWFjdEZpYmVyJCIrck4sclQ9Il9fcmVhY3RQcm9wcyQiK3JOLHJMPSJfX3JlYWN0Q29udGFpbmVyJCIrck4sclI9Il9fcmVhY3RFdmVudHMkIityTixyTT0iX19yZWFjdExpc3RlbmVycyQiK3JOLHJGPSJfX3JlYWN0SGFuZGxlcyQiK3JOO2Z1bmN0aW9uIHJPKGUpe3ZhciBuPWVbcnpdO2lmKG4pcmV0dXJuIG47Zm9yKHZhciB0PWUucGFyZW50Tm9kZTt0Oyl7aWYobj10W3JMXXx8dFtyel0pe2lmKHQ9bi5hbHRlcm5hdGUsbnVsbCE9PW4uY2hpbGR8fG51bGwhPT10JiZudWxsIT09dC5jaGlsZClmb3IoZT1yUChlKTtudWxsIT09ZTspe2lmKHQ9ZVtyel0pcmV0dXJuIHQ7ZT1yUChlKX1yZXR1cm4gbn10PShlPXQpLnBhcmVudE5vZGV9cmV0dXJuIG51bGx9ZnVuY3Rpb24gckQoZSl7cmV0dXJuKGU9ZVtyel18fGVbckxdKSYmKDU9PT1lLnRhZ3x8Nj09PWUudGFnfHwxMz09PWUudGFnfHwzPT09ZS50YWcpP2U6bnVsbH1mdW5jdGlvbiBySShlKXtpZig1PT09ZS50YWd8fDY9PT1lLnRhZylyZXR1cm4gZS5zdGF0ZU5vZGU7dGhyb3cgRXJyb3IoZigzMykpfWZ1bmN0aW9uIHJVKGUpe3JldHVybiBlW3JUXXx8bnVsbH12YXIgclY9W10sckE9LTE7ZnVuY3Rpb24gciQoZSl7cmV0dXJue2N1cnJlbnQ6ZX19ZnVuY3Rpb24gcmooZSl7MD5yQXx8KGUuY3VycmVudD1yVltyQV0sclZbckFdPW51bGwsckEtLSl9ZnVuY3Rpb24gckIoZSxuKXtyVlsrK3JBXT1lLmN1cnJlbnQsZS5jdXJyZW50PW59dmFyIHJIPXt9LHJXPXIkKHJIKSxyUT1yJCghMSkscnE9ckg7ZnVuY3Rpb24gcksoZSxuKXt2YXIgdD1lLnR5cGUuY29udGV4dFR5cGVzO2lmKCF0KXJldHVybiBySDt2YXIgcj1lLnN0YXRlTm9kZTtpZihyJiZyLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9PT1uKXJldHVybiByLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O3ZhciBsLGE9e307Zm9yKGwgaW4gdClhW2xdPW5bbF07cmV0dXJuIHImJigoZT1lLnN0YXRlTm9kZSkuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dD1uLGUuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ9YSksYX1mdW5jdGlvbiByWShlKXtyZXR1cm4gbnVsbCE9KGU9ZS5jaGlsZENvbnRleHRUeXBlcyl9ZnVuY3Rpb24gclgoKXtyaihyUSkscmooclcpfWZ1bmN0aW9uIHJHKGUsbix0KXtpZihyVy5jdXJyZW50IT09ckgpdGhyb3cgRXJyb3IoZigxNjgpKTtyQihyVyxuKSxyQihyUSx0KX1mdW5jdGlvbiByWihlLG4sdCl7dmFyIHI9ZS5zdGF0ZU5vZGU7aWYobj1uLmNoaWxkQ29udGV4dFR5cGVzLCJmdW5jdGlvbiIhPXR5cGVvZiByLmdldENoaWxkQ29udGV4dClyZXR1cm4gdDtmb3IodmFyIGwgaW4gcj1yLmdldENoaWxkQ29udGV4dCgpKWlmKCEobCBpbiBuKSl0aHJvdyBFcnJvcihmKDEwOCxmdW5jdGlvbihlKXt2YXIgbj1lLnR5cGU7c3dpdGNoKGUudGFnKXtjYXNlIDI0OnJldHVybiJDYWNoZSI7Y2FzZSA5OnJldHVybihuLmRpc3BsYXlOYW1lfHwiQ29udGV4dCIpKyIuQ29uc3VtZXIiO2Nhc2UgMTA6cmV0dXJuKG4uX2NvbnRleHQuZGlzcGxheU5hbWV8fCJDb250ZXh0IikrIi5Qcm92aWRlciI7Y2FzZSAxODpyZXR1cm4iRGVoeWRyYXRlZEZyYWdtZW50IjtjYXNlIDExOnJldHVybiBlPShlPW4ucmVuZGVyKS5kaXNwbGF5TmFtZXx8ZS5uYW1lfHwiIixuLmRpc3BsYXlOYW1lfHwoIiIhPT1lPyJGb3J3YXJkUmVmKCIrZSsiKSI6IkZvcndhcmRSZWYiKTtjYXNlIDc6cmV0dXJuIkZyYWdtZW50IjtjYXNlIDU6cmV0dXJuIG47Y2FzZSA0OnJldHVybiJQb3J0YWwiO2Nhc2UgMzpyZXR1cm4iUm9vdCI7Y2FzZSA2OnJldHVybiJUZXh0IjtjYXNlIDE2OnJldHVybiBmdW5jdGlvbiBlKG4pe2lmKG51bGw9PW4pcmV0dXJuIG51bGw7aWYoImZ1bmN0aW9uIj09dHlwZW9mIG4pcmV0dXJuIG4uZGlzcGxheU5hbWV8fG4ubmFtZXx8bnVsbDtpZigic3RyaW5nIj09dHlwZW9mIG4pcmV0dXJuIG47c3dpdGNoKG4pe2Nhc2UgejpyZXR1cm4iRnJhZ21lbnQiO2Nhc2UgTjpyZXR1cm4iUG9ydGFsIjtjYXNlIEw6cmV0dXJuIlByb2ZpbGVyIjtjYXNlIFQ6cmV0dXJuIlN0cmljdE1vZGUiO2Nhc2UgTzpyZXR1cm4iU3VzcGVuc2UiO2Nhc2UgRDpyZXR1cm4iU3VzcGVuc2VMaXN0In1pZigib2JqZWN0Ij09dHlwZW9mIG4pc3dpdGNoKG4uJCR0eXBlb2Ype2Nhc2UgTTpyZXR1cm4obi5kaXNwbGF5TmFtZXx8IkNvbnRleHQiKSsiLkNvbnN1bWVyIjtjYXNlIFI6cmV0dXJuKG4uX2NvbnRleHQuZGlzcGxheU5hbWV8fCJDb250ZXh0IikrIi5Qcm92aWRlciI7Y2FzZSBGOnZhciB0PW4ucmVuZGVyO3JldHVybihuPW4uZGlzcGxheU5hbWUpfHwobj0iIiE9PShuPXQuZGlzcGxheU5hbWV8fHQubmFtZXx8IiIpPyJGb3J3YXJkUmVmKCIrbisiKSI6IkZvcndhcmRSZWYiKSxuO2Nhc2UgSTpyZXR1cm4gbnVsbCE9PSh0PW4uZGlzcGxheU5hbWV8fG51bGwpP3Q6ZShuLnR5cGUpfHwiTWVtbyI7Y2FzZSBVOnQ9bi5fcGF5bG9hZCxuPW4uX2luaXQ7dHJ5e3JldHVybiBlKG4odCkpfWNhdGNoKGUpe319cmV0dXJuIG51bGx9KG4pO2Nhc2UgODpyZXR1cm4gbj09PVQ/IlN0cmljdE1vZGUiOiJNb2RlIjtjYXNlIDIyOnJldHVybiJPZmZzY3JlZW4iO2Nhc2UgMTI6cmV0dXJuIlByb2ZpbGVyIjtjYXNlIDIxOnJldHVybiJTY29wZSI7Y2FzZSAxMzpyZXR1cm4iU3VzcGVuc2UiO2Nhc2UgMTk6cmV0dXJuIlN1c3BlbnNlTGlzdCI7Y2FzZSAyNTpyZXR1cm4iVHJhY2luZ01hcmtlciI7Y2FzZSAxOmNhc2UgMDpjYXNlIDE3OmNhc2UgMjpjYXNlIDE0OmNhc2UgMTU6aWYoImZ1bmN0aW9uIj09dHlwZW9mIG4pcmV0dXJuIG4uZGlzcGxheU5hbWV8fG4ubmFtZXx8bnVsbDtpZigic3RyaW5nIj09dHlwZW9mIG4pcmV0dXJuIG59cmV0dXJuIG51bGx9KGUpfHwiVW5rbm93biIsbCkpO3JldHVybiBCKHt9LHQscil9ZnVuY3Rpb24gckooZSl7cmV0dXJuIGU9KGU9ZS5zdGF0ZU5vZGUpJiZlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0fHxySCxycT1yVy5jdXJyZW50LHJCKHJXLGUpLHJCKHJRLHJRLmN1cnJlbnQpLCEwfWZ1bmN0aW9uIHIwKGUsbix0KXt2YXIgcj1lLnN0YXRlTm9kZTtpZighcil0aHJvdyBFcnJvcihmKDE2OSkpO3Q/KGU9clooZSxuLHJxKSxyLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0PWUscmooclEpLHJqKHJXKSxyQihyVyxlKSk6cmooclEpLHJCKHJRLHQpfXZhciByMT1udWxsLHIyPSExLHIzPSExO2Z1bmN0aW9uIHI0KCl7aWYoIXIzJiZudWxsIT09cjEpe3IzPSEwO3ZhciBlPTAsbj1uYzt0cnl7dmFyIHQ9cjE7Zm9yKG5jPTE7ZTx0Lmxlbmd0aDtlKyspe3ZhciByPXRbZV07ZG8gcj1yKCEwKTt3aGlsZShudWxsIT09cil9cjE9bnVsbCxyMj0hMX1jYXRjaChuKXt0aHJvdyBudWxsIT09cjEmJihyMT1yMS5zbGljZShlKzEpKSxlWShlMSxyNCksbn1maW5hbGx5e25jPW4scjM9ITF9fXJldHVybiBudWxsfXZhciByOD1bXSxyNj0wLHI1PW51bGwscjk9MCxyNz1bXSxsZT0wLGxuPW51bGwsbHQ9MSxscj0iIjtmdW5jdGlvbiBsbChlLG4pe3I4W3I2KytdPXI5LHI4W3I2KytdPXI1LHI1PWUscjk9bn1mdW5jdGlvbiBsYShlLG4sdCl7cjdbbGUrK109bHQscjdbbGUrK109bHIscjdbbGUrK109bG4sbG49ZTt2YXIgcj1sdDtlPWxyO3ZhciBsPTMyLWU5KHIpLTE7ciY9figxPDxsKSx0Kz0xO3ZhciBhPTMyLWU5KG4pK2w7aWYoMzA8YSl7dmFyIHU9bC1sJTU7YT0ociYoMTw8dSktMSkudG9TdHJpbmcoMzIpLHI+Pj11LGwtPXUsbHQ9MTw8MzItZTkobikrbHx0PDxsfHIsbHI9YStlfWVsc2UgbHQ9MTw8YXx0PDxsfHIsbHI9ZX1mdW5jdGlvbiBsdShlKXtudWxsIT09ZS5yZXR1cm4mJihsbChlLDEpLGxhKGUsMSwwKSl9ZnVuY3Rpb24gbG8oZSl7Zm9yKDtlPT09cjU7KXI1PXI4Wy0tcjZdLHI4W3I2XT1udWxsLHI5PXI4Wy0tcjZdLHI4W3I2XT1udWxsO2Zvcig7ZT09PWxuOylsbj1yN1stLWxlXSxyN1tsZV09bnVsbCxscj1yN1stLWxlXSxyN1tsZV09bnVsbCxsdD1yN1stLWxlXSxyN1tsZV09bnVsbH12YXIgbGk9bnVsbCxscz1udWxsLGxjPSExLGxmPW51bGw7ZnVuY3Rpb24gbGQoZSxuKXt2YXIgdD1vUSg1LG51bGwsbnVsbCwwKTt0LmVsZW1lbnRUeXBlPSJERUxFVEVEIix0LnN0YXRlTm9kZT1uLHQucmV0dXJuPWUsbnVsbD09PShuPWUuZGVsZXRpb25zKT8oZS5kZWxldGlvbnM9W3RdLGUuZmxhZ3N8PTE2KTpuLnB1c2godCl9ZnVuY3Rpb24gbHAoZSxuKXtzd2l0Y2goZS50YWcpe2Nhc2UgNTp2YXIgdD1lLnR5cGU7cmV0dXJuIG51bGwhPT0obj0xIT09bi5ub2RlVHlwZXx8dC50b0xvd2VyQ2FzZSgpIT09bi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpP251bGw6bikmJihlLnN0YXRlTm9kZT1uLGxpPWUsbHM9cl8obi5maXJzdENoaWxkKSwhMCk7Y2FzZSA2OnJldHVybiBudWxsIT09KG49IiI9PT1lLnBlbmRpbmdQcm9wc3x8MyE9PW4ubm9kZVR5cGU/bnVsbDpuKSYmKGUuc3RhdGVOb2RlPW4sbGk9ZSxscz1udWxsLCEwKTtjYXNlIDEzOnJldHVybiBudWxsIT09KG49OCE9PW4ubm9kZVR5cGU/bnVsbDpuKSYmKHQ9bnVsbCE9PWxuP3tpZDpsdCxvdmVyZmxvdzpscn06bnVsbCxlLm1lbW9pemVkU3RhdGU9e2RlaHlkcmF0ZWQ6bix0cmVlQ29udGV4dDp0LHJldHJ5TGFuZToxMDczNzQxODI0fSwodD1vUSgxOCxudWxsLG51bGwsMCkpLnN0YXRlTm9kZT1uLHQucmV0dXJuPWUsZS5jaGlsZD10LGxpPWUsbHM9bnVsbCwhMCk7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gbG0oZSl7cmV0dXJuIDAhPSgxJmUubW9kZSkmJjA9PSgxMjgmZS5mbGFncyl9ZnVuY3Rpb24gbGgoZSl7aWYobGMpe3ZhciBuPWxzO2lmKG4pe3ZhciB0PW47aWYoIWxwKGUsbikpe2lmKGxtKGUpKXRocm93IEVycm9yKGYoNDE4KSk7bj1yXyh0Lm5leHRTaWJsaW5nKTt2YXIgcj1saTtuJiZscChlLG4pP2xkKHIsdCk6KGUuZmxhZ3M9LTQwOTcmZS5mbGFnc3wyLGxjPSExLGxpPWUpfX1lbHNle2lmKGxtKGUpKXRocm93IEVycm9yKGYoNDE4KSk7ZS5mbGFncz0tNDA5NyZlLmZsYWdzfDIsbGM9ITEsbGk9ZX19fWZ1bmN0aW9uIGxnKGUpe2ZvcihlPWUucmV0dXJuO251bGwhPT1lJiY1IT09ZS50YWcmJjMhPT1lLnRhZyYmMTMhPT1lLnRhZzspZT1lLnJldHVybjtsaT1lfWZ1bmN0aW9uIGx2KGUpe2lmKGUhPT1saSlyZXR1cm4hMTtpZighbGMpcmV0dXJuIGxnKGUpLGxjPSEwLCExO2lmKChuPTMhPT1lLnRhZykmJiEobj01IT09ZS50YWcpJiYobj0iaGVhZCIhPT0obj1lLnR5cGUpJiYiYm9keSIhPT1uJiYhcmIoZS50eXBlLGUubWVtb2l6ZWRQcm9wcykpLG4mJihuPWxzKSl7aWYobG0oZSkpdGhyb3cgbHkoKSxFcnJvcihmKDQxOCkpO2Zvcig7bjspbGQoZSxuKSxuPXJfKG4ubmV4dFNpYmxpbmcpfWlmKGxnKGUpLDEzPT09ZS50YWcpe2lmKCEoZT1udWxsIT09KGU9ZS5tZW1vaXplZFN0YXRlKT9lLmRlaHlkcmF0ZWQ6bnVsbCkpdGhyb3cgRXJyb3IoZigzMTcpKTtlOntmb3Iobj0wLGU9ZS5uZXh0U2libGluZztlOyl7aWYoOD09PWUubm9kZVR5cGUpe3ZhciBuLHQ9ZS5kYXRhO2lmKCIvJCI9PT10KXtpZigwPT09bil7bHM9cl8oZS5uZXh0U2libGluZyk7YnJlYWsgZX1uLS19ZWxzZSIkIiE9PXQmJiIkISIhPT10JiYiJD8iIT09dHx8bisrfWU9ZS5uZXh0U2libGluZ31scz1udWxsfX1lbHNlIGxzPWxpP3JfKGUuc3RhdGVOb2RlLm5leHRTaWJsaW5nKTpudWxsO3JldHVybiEwfWZ1bmN0aW9uIGx5KCl7Zm9yKHZhciBlPWxzO2U7KWU9cl8oZS5uZXh0U2libGluZyl9ZnVuY3Rpb24gbGIoKXtscz1saT1udWxsLGxjPSExfWZ1bmN0aW9uIGxrKGUpe251bGw9PT1sZj9sZj1bZV06bGYucHVzaChlKX12YXIgbHc9Xy5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZztmdW5jdGlvbiBsUyhlLG4pe2lmKGUmJmUuZGVmYXVsdFByb3BzKWZvcih2YXIgdCBpbiBuPUIoe30sbiksZT1lLmRlZmF1bHRQcm9wcyl2b2lkIDA9PT1uW3RdJiYoblt0XT1lW3RdKTtyZXR1cm4gbn12YXIgbHg9ciQobnVsbCksbEU9bnVsbCxsQz1udWxsLGxfPW51bGw7ZnVuY3Rpb24gbFAoKXtsXz1sQz1sRT1udWxsfWZ1bmN0aW9uIGxOKGUpe3ZhciBuPWx4LmN1cnJlbnQ7cmoobHgpLGUuX2N1cnJlbnRWYWx1ZT1ufWZ1bmN0aW9uIGx6KGUsbix0KXtmb3IoO251bGwhPT1lOyl7dmFyIHI9ZS5hbHRlcm5hdGU7aWYoKGUuY2hpbGRMYW5lcyZuKSE9PW4/KGUuY2hpbGRMYW5lc3w9bixudWxsIT09ciYmKHIuY2hpbGRMYW5lc3w9bikpOm51bGwhPT1yJiYoci5jaGlsZExhbmVzJm4pIT09biYmKHIuY2hpbGRMYW5lc3w9biksZT09PXQpYnJlYWs7ZT1lLnJldHVybn19ZnVuY3Rpb24gbFQoZSxuKXtsRT1lLGxfPWxDPW51bGwsbnVsbCE9PShlPWUuZGVwZW5kZW5jaWVzKSYmbnVsbCE9PWUuZmlyc3RDb250ZXh0JiYoMCE9KGUubGFuZXMmbikmJih1YT0hMCksZS5maXJzdENvbnRleHQ9bnVsbCl9ZnVuY3Rpb24gbEwoZSl7dmFyIG49ZS5fY3VycmVudFZhbHVlO2lmKGxfIT09ZSl7aWYoZT17Y29udGV4dDplLG1lbW9pemVkVmFsdWU6bixuZXh0Om51bGx9LG51bGw9PT1sQyl7aWYobnVsbD09PWxFKXRocm93IEVycm9yKGYoMzA4KSk7bEM9ZSxsRS5kZXBlbmRlbmNpZXM9e2xhbmVzOjAsZmlyc3RDb250ZXh0OmV9fWVsc2UgbEM9bEMubmV4dD1lfXJldHVybiBufXZhciBsUj1udWxsO2Z1bmN0aW9uIGxNKGUpe251bGw9PT1sUj9sUj1bZV06bFIucHVzaChlKX1mdW5jdGlvbiBsRihlLG4sdCxyKXt2YXIgbD1uLmludGVybGVhdmVkO3JldHVybiBudWxsPT09bD8odC5uZXh0PXQsbE0obikpOih0Lm5leHQ9bC5uZXh0LGwubmV4dD10KSxuLmludGVybGVhdmVkPXQsbE8oZSxyKX1mdW5jdGlvbiBsTyhlLG4pe2UubGFuZXN8PW47dmFyIHQ9ZS5hbHRlcm5hdGU7Zm9yKG51bGwhPT10JiYodC5sYW5lc3w9biksdD1lLGU9ZS5yZXR1cm47bnVsbCE9PWU7KWUuY2hpbGRMYW5lc3w9bixudWxsIT09KHQ9ZS5hbHRlcm5hdGUpJiYodC5jaGlsZExhbmVzfD1uKSx0PWUsZT1lLnJldHVybjtyZXR1cm4gMz09PXQudGFnP3Quc3RhdGVOb2RlOm51bGx9dmFyIGxEPSExO2Z1bmN0aW9uIGxJKGUpe2UudXBkYXRlUXVldWU9e2Jhc2VTdGF0ZTplLm1lbW9pemVkU3RhdGUsZmlyc3RCYXNlVXBkYXRlOm51bGwsbGFzdEJhc2VVcGRhdGU6bnVsbCxzaGFyZWQ6e3BlbmRpbmc6bnVsbCxpbnRlcmxlYXZlZDpudWxsLGxhbmVzOjB9LGVmZmVjdHM6bnVsbH19ZnVuY3Rpb24gbFUoZSxuKXtlPWUudXBkYXRlUXVldWUsbi51cGRhdGVRdWV1ZT09PWUmJihuLnVwZGF0ZVF1ZXVlPXtiYXNlU3RhdGU6ZS5iYXNlU3RhdGUsZmlyc3RCYXNlVXBkYXRlOmUuZmlyc3RCYXNlVXBkYXRlLGxhc3RCYXNlVXBkYXRlOmUubGFzdEJhc2VVcGRhdGUsc2hhcmVkOmUuc2hhcmVkLGVmZmVjdHM6ZS5lZmZlY3RzfSl9ZnVuY3Rpb24gbFYoZSxuKXtyZXR1cm57ZXZlbnRUaW1lOmUsbGFuZTpuLHRhZzowLHBheWxvYWQ6bnVsbCxjYWxsYmFjazpudWxsLG5leHQ6bnVsbH19ZnVuY3Rpb24gbEEoZSxuLHQpe3ZhciByPWUudXBkYXRlUXVldWU7aWYobnVsbD09PXIpcmV0dXJuIG51bGw7aWYocj1yLnNoYXJlZCwwIT0oMiZ1Mikpe3ZhciBsPXIucGVuZGluZztyZXR1cm4gbnVsbD09PWw/bi5uZXh0PW46KG4ubmV4dD1sLm5leHQsbC5uZXh0PW4pLHIucGVuZGluZz1uLGxPKGUsdCl9cmV0dXJuIG51bGw9PT0obD1yLmludGVybGVhdmVkKT8obi5uZXh0PW4sbE0ocikpOihuLm5leHQ9bC5uZXh0LGwubmV4dD1uKSxyLmludGVybGVhdmVkPW4sbE8oZSx0KX1mdW5jdGlvbiBsJChlLG4sdCl7aWYobnVsbCE9PShuPW4udXBkYXRlUXVldWUpJiYobj1uLnNoYXJlZCwwIT0oNDE5NDI0MCZ0KSkpe3ZhciByPW4ubGFuZXM7ciY9ZS5wZW5kaW5nTGFuZXMsdHw9cixuLmxhbmVzPXQsbnMoZSx0KX19ZnVuY3Rpb24gbGooZSxuKXt2YXIgdD1lLnVwZGF0ZVF1ZXVlLHI9ZS5hbHRlcm5hdGU7aWYobnVsbCE9PXImJnQ9PT0ocj1yLnVwZGF0ZVF1ZXVlKSl7dmFyIGw9bnVsbCxhPW51bGw7aWYobnVsbCE9PSh0PXQuZmlyc3RCYXNlVXBkYXRlKSl7ZG97dmFyIHU9e2V2ZW50VGltZTp0LmV2ZW50VGltZSxsYW5lOnQubGFuZSx0YWc6dC50YWcscGF5bG9hZDp0LnBheWxvYWQsY2FsbGJhY2s6dC5jYWxsYmFjayxuZXh0Om51bGx9O251bGw9PT1hP2w9YT11OmE9YS5uZXh0PXUsdD10Lm5leHR9d2hpbGUobnVsbCE9PXQpO251bGw9PT1hP2w9YT1uOmE9YS5uZXh0PW59ZWxzZSBsPWE9bjt0PXtiYXNlU3RhdGU6ci5iYXNlU3RhdGUsZmlyc3RCYXNlVXBkYXRlOmwsbGFzdEJhc2VVcGRhdGU6YSxzaGFyZWQ6ci5zaGFyZWQsZWZmZWN0czpyLmVmZmVjdHN9LGUudXBkYXRlUXVldWU9dDtyZXR1cm59bnVsbD09PShlPXQubGFzdEJhc2VVcGRhdGUpP3QuZmlyc3RCYXNlVXBkYXRlPW46ZS5uZXh0PW4sdC5sYXN0QmFzZVVwZGF0ZT1ufWZ1bmN0aW9uIGxCKGUsbix0LHIpe3ZhciBsPWUudXBkYXRlUXVldWU7bEQ9ITE7dmFyIGE9bC5maXJzdEJhc2VVcGRhdGUsdT1sLmxhc3RCYXNlVXBkYXRlLG89bC5zaGFyZWQucGVuZGluZztpZihudWxsIT09byl7bC5zaGFyZWQucGVuZGluZz1udWxsO3ZhciBpPW8scz1pLm5leHQ7aS5uZXh0PW51bGwsbnVsbD09PXU/YT1zOnUubmV4dD1zLHU9aTt2YXIgYz1lLmFsdGVybmF0ZTtudWxsIT09YyYmKG89KGM9Yy51cGRhdGVRdWV1ZSkubGFzdEJhc2VVcGRhdGUpIT09dSYmKG51bGw9PT1vP2MuZmlyc3RCYXNlVXBkYXRlPXM6by5uZXh0PXMsYy5sYXN0QmFzZVVwZGF0ZT1pKX1pZihudWxsIT09YSl7dmFyIGY9bC5iYXNlU3RhdGU7Zm9yKHU9MCxjPXM9aT1udWxsLG89YTs7KXt2YXIgZD1vLmxhbmUscD1vLmV2ZW50VGltZTtpZigociZkKT09PWQpe251bGwhPT1jJiYoYz1jLm5leHQ9e2V2ZW50VGltZTpwLGxhbmU6MCx0YWc6by50YWcscGF5bG9hZDpvLnBheWxvYWQsY2FsbGJhY2s6by5jYWxsYmFjayxuZXh0Om51bGx9KTtlOnt2YXIgbT1lLGg9bztzd2l0Y2goZD1uLHA9dCxoLnRhZyl7Y2FzZSAxOmlmKCJmdW5jdGlvbiI9PXR5cGVvZihtPWgucGF5bG9hZCkpe2Y9bS5jYWxsKHAsZixkKTticmVhayBlfWY9bTticmVhayBlO2Nhc2UgMzptLmZsYWdzPS02NTUzNyZtLmZsYWdzfDEyODtjYXNlIDA6aWYobnVsbD09KGQ9ImZ1bmN0aW9uIj09dHlwZW9mKG09aC5wYXlsb2FkKT9tLmNhbGwocCxmLGQpOm0pKWJyZWFrIGU7Zj1CKHt9LGYsZCk7YnJlYWsgZTtjYXNlIDI6bEQ9ITB9fW51bGwhPT1vLmNhbGxiYWNrJiYwIT09by5sYW5lJiYoZS5mbGFnc3w9NjQsbnVsbD09PShkPWwuZWZmZWN0cyk/bC5lZmZlY3RzPVtvXTpkLnB1c2gobykpfWVsc2UgcD17ZXZlbnRUaW1lOnAsbGFuZTpkLHRhZzpvLnRhZyxwYXlsb2FkOm8ucGF5bG9hZCxjYWxsYmFjazpvLmNhbGxiYWNrLG5leHQ6bnVsbH0sbnVsbD09PWM/KHM9Yz1wLGk9Zik6Yz1jLm5leHQ9cCx1fD1kO2lmKG51bGw9PT0obz1vLm5leHQpKXtpZihudWxsPT09KG89bC5zaGFyZWQucGVuZGluZykpYnJlYWs7bz0oZD1vKS5uZXh0LGQubmV4dD1udWxsLGwubGFzdEJhc2VVcGRhdGU9ZCxsLnNoYXJlZC5wZW5kaW5nPW51bGx9fWlmKG51bGw9PT1jJiYoaT1mKSxsLmJhc2VTdGF0ZT1pLGwuZmlyc3RCYXNlVXBkYXRlPXMsbC5sYXN0QmFzZVVwZGF0ZT1jLG51bGwhPT0obj1sLnNoYXJlZC5pbnRlcmxlYXZlZCkpe2w9bjtkbyB1fD1sLmxhbmUsbD1sLm5leHQ7d2hpbGUobCE9PW4pfWVsc2UgbnVsbD09PWEmJihsLnNoYXJlZC5sYW5lcz0wKTtvZXw9dSxlLmxhbmVzPXUsZS5tZW1vaXplZFN0YXRlPWZ9fWZ1bmN0aW9uIGxIKGUsbix0KXtpZihlPW4uZWZmZWN0cyxuLmVmZmVjdHM9bnVsbCxudWxsIT09ZSlmb3Iobj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dLGw9ci5jYWxsYmFjaztpZihudWxsIT09bCl7aWYoci5jYWxsYmFjaz1udWxsLHI9dCwiZnVuY3Rpb24iIT10eXBlb2YgbCl0aHJvdyBFcnJvcihmKDE5MSxsKSk7bC5jYWxsKHIpfX19dmFyIGxXPShuZXcgcy5Db21wb25lbnQpLnJlZnM7ZnVuY3Rpb24gbFEoZSxuLHQscil7bj1lLm1lbW9pemVkU3RhdGUsdD1udWxsPT0odD10KHIsbikpP246Qih7fSxuLHQpLGUubWVtb2l6ZWRTdGF0ZT10LDA9PT1lLmxhbmVzJiYoZS51cGRhdGVRdWV1ZS5iYXNlU3RhdGU9dCl9dmFyIGxxPXtpc01vdW50ZWQ6ZnVuY3Rpb24oZSl7cmV0dXJuISEoZT1lLl9yZWFjdEludGVybmFscykmJmVXKGUpPT09ZX0sZW5xdWV1ZVNldFN0YXRlOmZ1bmN0aW9uKGUsbix0KXtlPWUuX3JlYWN0SW50ZXJuYWxzO3ZhciByPW95KCksbD1vYihlKSxhPWxWKHIsbCk7YS5wYXlsb2FkPW4sbnVsbCE9dCYmKGEuY2FsbGJhY2s9dCksbnVsbCE9PShuPWxBKGUsYSxsKSkmJihvayhuLGUsbCxyKSxsJChuLGUsbCkpfSxlbnF1ZXVlUmVwbGFjZVN0YXRlOmZ1bmN0aW9uKGUsbix0KXtlPWUuX3JlYWN0SW50ZXJuYWxzO3ZhciByPW95KCksbD1vYihlKSxhPWxWKHIsbCk7YS50YWc9MSxhLnBheWxvYWQ9bixudWxsIT10JiYoYS5jYWxsYmFjaz10KSxudWxsIT09KG49bEEoZSxhLGwpKSYmKG9rKG4sZSxsLHIpLGwkKG4sZSxsKSl9LGVucXVldWVGb3JjZVVwZGF0ZTpmdW5jdGlvbihlLG4pe2U9ZS5fcmVhY3RJbnRlcm5hbHM7dmFyIHQ9b3koKSxyPW9iKGUpLGw9bFYodCxyKTtsLnRhZz0yLG51bGwhPW4mJihsLmNhbGxiYWNrPW4pLG51bGwhPT0obj1sQShlLGwscikpJiYob2sobixlLHIsdCksbCQobixlLHIpKX19O2Z1bmN0aW9uIGxLKGUsbix0LHIsbCxhLHUpe3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZihlPWUuc3RhdGVOb2RlKS5zaG91bGRDb21wb25lbnRVcGRhdGU/ZS5zaG91bGRDb21wb25lbnRVcGRhdGUocixhLHUpOiFuLnByb3RvdHlwZXx8IW4ucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50fHwhdEkodCxyKXx8IXRJKGwsYSl9ZnVuY3Rpb24gbFkoZSxuLHQpe3ZhciByPSExLGw9ckgsYT1uLmNvbnRleHRUeXBlO3JldHVybiJvYmplY3QiPT10eXBlb2YgYSYmbnVsbCE9PWE/YT1sTChhKToobD1yWShuKT9ycTpyVy5jdXJyZW50LGE9KHI9bnVsbCE9KHI9bi5jb250ZXh0VHlwZXMpKT9ySyhlLGwpOnJIKSxuPW5ldyBuKHQsYSksZS5tZW1vaXplZFN0YXRlPW51bGwhPT1uLnN0YXRlJiZ2b2lkIDAhPT1uLnN0YXRlP24uc3RhdGU6bnVsbCxuLnVwZGF0ZXI9bHEsZS5zdGF0ZU5vZGU9bixuLl9yZWFjdEludGVybmFscz1lLHImJigoZT1lLnN0YXRlTm9kZSkuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dD1sLGUuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ9YSksbn1mdW5jdGlvbiBsWChlLG4sdCxyKXtlPW4uc3RhdGUsImZ1bmN0aW9uIj09dHlwZW9mIG4uY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyYmbi5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHQsciksImZ1bmN0aW9uIj09dHlwZW9mIG4uVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJm4uVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHModCxyKSxuLnN0YXRlIT09ZSYmbHEuZW5xdWV1ZVJlcGxhY2VTdGF0ZShuLG4uc3RhdGUsbnVsbCl9ZnVuY3Rpb24gbEcoZSxuLHQscil7dmFyIGw9ZS5zdGF0ZU5vZGU7bC5wcm9wcz10LGwuc3RhdGU9ZS5tZW1vaXplZFN0YXRlLGwucmVmcz1sVyxsSShlKTt2YXIgYT1uLmNvbnRleHRUeXBlOyJvYmplY3QiPT10eXBlb2YgYSYmbnVsbCE9PWE/bC5jb250ZXh0PWxMKGEpOihhPXJZKG4pP3JxOnJXLmN1cnJlbnQsbC5jb250ZXh0PXJLKGUsYSkpLGwuc3RhdGU9ZS5tZW1vaXplZFN0YXRlLCJmdW5jdGlvbiI9PXR5cGVvZihhPW4uZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKSYmKGxRKGUsbixhLHQpLGwuc3RhdGU9ZS5tZW1vaXplZFN0YXRlKSwiZnVuY3Rpb24iPT10eXBlb2Ygbi5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHN8fCJmdW5jdGlvbiI9PXR5cGVvZiBsLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlfHwiZnVuY3Rpb24iIT10eXBlb2YgbC5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JiYiZnVuY3Rpb24iIT10eXBlb2YgbC5jb21wb25lbnRXaWxsTW91bnR8fChuPWwuc3RhdGUsImZ1bmN0aW9uIj09dHlwZW9mIGwuY29tcG9uZW50V2lsbE1vdW50JiZsLmNvbXBvbmVudFdpbGxNb3VudCgpLCJmdW5jdGlvbiI9PXR5cGVvZiBsLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQmJmwuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpLG4hPT1sLnN0YXRlJiZscS5lbnF1ZXVlUmVwbGFjZVN0YXRlKGwsbC5zdGF0ZSxudWxsKSxsQihlLHQsbCxyKSxsLnN0YXRlPWUubWVtb2l6ZWRTdGF0ZSksImZ1bmN0aW9uIj09dHlwZW9mIGwuY29tcG9uZW50RGlkTW91bnQmJihlLmZsYWdzfD00MTk0MzA4KX1mdW5jdGlvbiBsWihlLG4sdCl7aWYobnVsbCE9PShlPXQucmVmKSYmImZ1bmN0aW9uIiE9dHlwZW9mIGUmJiJvYmplY3QiIT10eXBlb2YgZSl7aWYodC5fb3duZXIpe2lmKHQ9dC5fb3duZXIpe2lmKDEhPT10LnRhZyl0aHJvdyBFcnJvcihmKDMwOSkpO3ZhciByPXQuc3RhdGVOb2RlfWlmKCFyKXRocm93IEVycm9yKGYoMTQ3LGUpKTt2YXIgbD1yLGE9IiIrZTtyZXR1cm4gbnVsbCE9PW4mJm51bGwhPT1uLnJlZiYmImZ1bmN0aW9uIj09dHlwZW9mIG4ucmVmJiZuLnJlZi5fc3RyaW5nUmVmPT09YT9uLnJlZjooKG49ZnVuY3Rpb24oZSl7dmFyIG49bC5yZWZzO249PT1sVyYmKG49bC5yZWZzPXt9KSxudWxsPT09ZT9kZWxldGUgblthXTpuW2FdPWV9KS5fc3RyaW5nUmVmPWEsbil9aWYoInN0cmluZyIhPXR5cGVvZiBlKXRocm93IEVycm9yKGYoMjg0KSk7aWYoIXQuX293bmVyKXRocm93IEVycm9yKGYoMjkwLGUpKX1yZXR1cm4gZX1mdW5jdGlvbiBsSihlLG4pe3Rocm93IEVycm9yKGYoMzEsIltvYmplY3QgT2JqZWN0XSI9PT0oZT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobikpPyJvYmplY3Qgd2l0aCBrZXlzIHsiK09iamVjdC5rZXlzKG4pLmpvaW4oIiwgIikrIn0iOmUpKX1mdW5jdGlvbiBsMChlKXtyZXR1cm4oMCxlLl9pbml0KShlLl9wYXlsb2FkKX1mdW5jdGlvbiBsMShlKXtmdW5jdGlvbiBuKG4sdCl7aWYoZSl7dmFyIHI9bi5kZWxldGlvbnM7bnVsbD09PXI/KG4uZGVsZXRpb25zPVt0XSxuLmZsYWdzfD0xNik6ci5wdXNoKHQpfX1mdW5jdGlvbiB0KHQscil7aWYoIWUpcmV0dXJuIG51bGw7Zm9yKDtudWxsIT09cjspbih0LHIpLHI9ci5zaWJsaW5nO3JldHVybiBudWxsfWZ1bmN0aW9uIHIoZSxuKXtmb3IoZT1uZXcgTWFwO251bGwhPT1uOyludWxsIT09bi5rZXk/ZS5zZXQobi5rZXksbik6ZS5zZXQobi5pbmRleCxuKSxuPW4uc2libGluZztyZXR1cm4gZX1mdW5jdGlvbiBsKGUsbil7cmV0dXJuKGU9b0soZSxuKSkuaW5kZXg9MCxlLnNpYmxpbmc9bnVsbCxlfWZ1bmN0aW9uIGEobix0LHIpe3JldHVybihuLmluZGV4PXIsZSk/bnVsbCE9PShyPW4uYWx0ZXJuYXRlKT8ocj1yLmluZGV4KTx0PyhuLmZsYWdzfD0yLHQpOnI6KG4uZmxhZ3N8PTIsdCk6KG4uZmxhZ3N8PTEwNDg1NzYsdCl9ZnVuY3Rpb24gdShuKXtyZXR1cm4gZSYmbnVsbD09PW4uYWx0ZXJuYXRlJiYobi5mbGFnc3w9Miksbn1mdW5jdGlvbiBvKGUsbix0LHIpe3JldHVybiBudWxsPT09bnx8NiE9PW4udGFnPyhuPW9aKHQsZS5tb2RlLHIpKS5yZXR1cm49ZToobj1sKG4sdCkpLnJldHVybj1lLG59ZnVuY3Rpb24gaShlLG4sdCxyKXt2YXIgYT10LnR5cGU7cmV0dXJuIGE9PT16P2MoZSxuLHQucHJvcHMuY2hpbGRyZW4scix0LmtleSk6KG51bGwhPT1uJiYobi5lbGVtZW50VHlwZT09PWF8fCJvYmplY3QiPT10eXBlb2YgYSYmbnVsbCE9PWEmJmEuJCR0eXBlb2Y9PT1VJiZsMChhKT09PW4udHlwZSk/KHI9bChuLHQucHJvcHMpKS5yZWY9bFooZSxuLHQpOihyPW9ZKHQudHlwZSx0LmtleSx0LnByb3BzLG51bGwsZS5tb2RlLHIpKS5yZWY9bFooZSxuLHQpLHIucmV0dXJuPWUscil9ZnVuY3Rpb24gcyhlLG4sdCxyKXtyZXR1cm4gbnVsbD09PW58fDQhPT1uLnRhZ3x8bi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyE9PXQuY29udGFpbmVySW5mb3x8bi5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24hPT10LmltcGxlbWVudGF0aW9uPyhuPW9KKHQsZS5tb2RlLHIpKS5yZXR1cm49ZToobj1sKG4sdC5jaGlsZHJlbnx8W10pKS5yZXR1cm49ZSxufWZ1bmN0aW9uIGMoZSxuLHQscixhKXtyZXR1cm4gbnVsbD09PW58fDchPT1uLnRhZz8obj1vWCh0LGUubW9kZSxyLGEpKS5yZXR1cm49ZToobj1sKG4sdCkpLnJldHVybj1lLG59ZnVuY3Rpb24gZChlLG4sdCl7aWYoInN0cmluZyI9PXR5cGVvZiBuJiYiIiE9PW58fCJudW1iZXIiPT10eXBlb2YgbilyZXR1cm4obj1vWigiIituLGUubW9kZSx0KSkucmV0dXJuPWUsbjtpZigib2JqZWN0Ij09dHlwZW9mIG4mJm51bGwhPT1uKXtzd2l0Y2gobi4kJHR5cGVvZil7Y2FzZSBQOnJldHVybih0PW9ZKG4udHlwZSxuLmtleSxuLnByb3BzLG51bGwsZS5tb2RlLHQpKS5yZWY9bFooZSxudWxsLG4pLHQucmV0dXJuPWUsdDtjYXNlIE46cmV0dXJuKG49b0oobixlLm1vZGUsdCkpLnJldHVybj1lLG47Y2FzZSBVOnZhciByPW4uX2luaXQ7cmV0dXJuIGQoZSxyKG4uX3BheWxvYWQpLHQpfWlmKGVsKG4pfHwkKG4pKXJldHVybihuPW9YKG4sZS5tb2RlLHQsbnVsbCkpLnJldHVybj1lLG47bEooZSxuKX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBwKGUsbix0LHIpe3ZhciBsPW51bGwhPT1uP24ua2V5Om51bGw7aWYoInN0cmluZyI9PXR5cGVvZiB0JiYiIiE9PXR8fCJudW1iZXIiPT10eXBlb2YgdClyZXR1cm4gbnVsbCE9PWw/bnVsbDpvKGUsbiwiIit0LHIpO2lmKCJvYmplY3QiPT10eXBlb2YgdCYmbnVsbCE9PXQpe3N3aXRjaCh0LiQkdHlwZW9mKXtjYXNlIFA6cmV0dXJuIHQua2V5PT09bD9pKGUsbix0LHIpOm51bGw7Y2FzZSBOOnJldHVybiB0LmtleT09PWw/cyhlLG4sdCxyKTpudWxsO2Nhc2UgVTpyZXR1cm4gcChlLG4sKGw9dC5faW5pdCkodC5fcGF5bG9hZCkscil9aWYoZWwodCl8fCQodCkpcmV0dXJuIG51bGwhPT1sP251bGw6YyhlLG4sdCxyLG51bGwpO2xKKGUsdCl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gbShlLG4sdCxyLGwpe2lmKCJzdHJpbmciPT10eXBlb2YgciYmIiIhPT1yfHwibnVtYmVyIj09dHlwZW9mIHIpcmV0dXJuIG8obixlPWUuZ2V0KHQpfHxudWxsLCIiK3IsbCk7aWYoIm9iamVjdCI9PXR5cGVvZiByJiZudWxsIT09cil7c3dpdGNoKHIuJCR0eXBlb2Ype2Nhc2UgUDpyZXR1cm4gaShuLGU9ZS5nZXQobnVsbD09PXIua2V5P3Q6ci5rZXkpfHxudWxsLHIsbCk7Y2FzZSBOOnJldHVybiBzKG4sZT1lLmdldChudWxsPT09ci5rZXk/dDpyLmtleSl8fG51bGwscixsKTtjYXNlIFU6cmV0dXJuIG0oZSxuLHQsKDAsci5faW5pdCkoci5fcGF5bG9hZCksbCl9aWYoZWwocil8fCQocikpcmV0dXJuIGMobixlPWUuZ2V0KHQpfHxudWxsLHIsbCxudWxsKTtsSihuLHIpfXJldHVybiBudWxsfXJldHVybiBmdW5jdGlvbiBvKGkscyxjLGgpe2lmKCJvYmplY3QiPT10eXBlb2YgYyYmbnVsbCE9PWMmJmMudHlwZT09PXomJm51bGw9PT1jLmtleSYmKGM9Yy5wcm9wcy5jaGlsZHJlbiksIm9iamVjdCI9PXR5cGVvZiBjJiZudWxsIT09Yyl7c3dpdGNoKGMuJCR0eXBlb2Ype2Nhc2UgUDplOntmb3IodmFyIGc9Yy5rZXksdj1zO251bGwhPT12Oyl7aWYodi5rZXk9PT1nKXtpZigoZz1jLnR5cGUpPT09eil7aWYoNz09PXYudGFnKXt0KGksdi5zaWJsaW5nKSwocz1sKHYsYy5wcm9wcy5jaGlsZHJlbikpLnJldHVybj1pLGk9czticmVhayBlfX1lbHNlIGlmKHYuZWxlbWVudFR5cGU9PT1nfHwib2JqZWN0Ij09dHlwZW9mIGcmJm51bGwhPT1nJiZnLiQkdHlwZW9mPT09VSYmbDAoZyk9PT12LnR5cGUpe3QoaSx2LnNpYmxpbmcpLChzPWwodixjLnByb3BzKSkucmVmPWxaKGksdixjKSxzLnJldHVybj1pLGk9czticmVhayBlfXQoaSx2KTticmVha31uKGksdiksdj12LnNpYmxpbmd9Yy50eXBlPT09ej8oKHM9b1goYy5wcm9wcy5jaGlsZHJlbixpLm1vZGUsaCxjLmtleSkpLnJldHVybj1pLGk9cyk6KChoPW9ZKGMudHlwZSxjLmtleSxjLnByb3BzLG51bGwsaS5tb2RlLGgpKS5yZWY9bFooaSxzLGMpLGgucmV0dXJuPWksaT1oKX1yZXR1cm4gdShpKTtjYXNlIE46ZTp7Zm9yKHY9Yy5rZXk7bnVsbCE9PXM7KXtpZihzLmtleT09PXYpe2lmKDQ9PT1zLnRhZyYmcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbz09PWMuY29udGFpbmVySW5mbyYmcy5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb249PT1jLmltcGxlbWVudGF0aW9uKXt0KGkscy5zaWJsaW5nKSwocz1sKHMsYy5jaGlsZHJlbnx8W10pKS5yZXR1cm49aSxpPXM7YnJlYWsgZX10KGkscyk7YnJlYWt9bihpLHMpLHM9cy5zaWJsaW5nfShzPW9KKGMsaS5tb2RlLGgpKS5yZXR1cm49aSxpPXN9cmV0dXJuIHUoaSk7Y2FzZSBVOnJldHVybiBvKGkscywodj1jLl9pbml0KShjLl9wYXlsb2FkKSxoKX1pZihlbChjKSlyZXR1cm4gZnVuY3Rpb24obCx1LG8saSl7Zm9yKHZhciBzPW51bGwsYz1udWxsLGY9dSxoPXU9MCxnPW51bGw7bnVsbCE9PWYmJmg8by5sZW5ndGg7aCsrKXtmLmluZGV4Pmg/KGc9ZixmPW51bGwpOmc9Zi5zaWJsaW5nO3ZhciB2PXAobCxmLG9baF0saSk7aWYobnVsbD09PXYpe251bGw9PT1mJiYoZj1nKTticmVha31lJiZmJiZudWxsPT09di5hbHRlcm5hdGUmJm4obCxmKSx1PWEodix1LGgpLG51bGw9PT1jP3M9djpjLnNpYmxpbmc9dixjPXYsZj1nfWlmKGg9PT1vLmxlbmd0aClyZXR1cm4gdChsLGYpLGxjJiZsbChsLGgpLHM7aWYobnVsbD09PWYpe2Zvcig7aDxvLmxlbmd0aDtoKyspbnVsbCE9PShmPWQobCxvW2hdLGkpKSYmKHU9YShmLHUsaCksbnVsbD09PWM/cz1mOmMuc2libGluZz1mLGM9Zik7cmV0dXJuIGxjJiZsbChsLGgpLHN9Zm9yKGY9cihsLGYpO2g8by5sZW5ndGg7aCsrKW51bGwhPT0oZz1tKGYsbCxoLG9baF0saSkpJiYoZSYmbnVsbCE9PWcuYWx0ZXJuYXRlJiZmLmRlbGV0ZShudWxsPT09Zy5rZXk/aDpnLmtleSksdT1hKGcsdSxoKSxudWxsPT09Yz9zPWc6Yy5zaWJsaW5nPWcsYz1nKTtyZXR1cm4gZSYmZi5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBuKGwsZSl9KSxsYyYmbGwobCxoKSxzfShpLHMsYyxoKTtpZigkKGMpKXJldHVybiBmdW5jdGlvbihsLHUsbyxpKXt2YXIgcz0kKG8pO2lmKCJmdW5jdGlvbiIhPXR5cGVvZiBzKXRocm93IEVycm9yKGYoMTUwKSk7aWYobnVsbD09KG89cy5jYWxsKG8pKSl0aHJvdyBFcnJvcihmKDE1MSkpO2Zvcih2YXIgYz1zPW51bGwsaD11LGc9dT0wLHY9bnVsbCx5PW8ubmV4dCgpO251bGwhPT1oJiYheS5kb25lO2crKyx5PW8ubmV4dCgpKXtoLmluZGV4Pmc/KHY9aCxoPW51bGwpOnY9aC5zaWJsaW5nO3ZhciBiPXAobCxoLHkudmFsdWUsaSk7aWYobnVsbD09PWIpe251bGw9PT1oJiYoaD12KTticmVha31lJiZoJiZudWxsPT09Yi5hbHRlcm5hdGUmJm4obCxoKSx1PWEoYix1LGcpLG51bGw9PT1jP3M9YjpjLnNpYmxpbmc9YixjPWIsaD12fWlmKHkuZG9uZSlyZXR1cm4gdChsLGgpLGxjJiZsbChsLGcpLHM7aWYobnVsbD09PWgpe2Zvcig7IXkuZG9uZTtnKysseT1vLm5leHQoKSludWxsIT09KHk9ZChsLHkudmFsdWUsaSkpJiYodT1hKHksdSxnKSxudWxsPT09Yz9zPXk6Yy5zaWJsaW5nPXksYz15KTtyZXR1cm4gbGMmJmxsKGwsZyksc31mb3IoaD1yKGwsaCk7IXkuZG9uZTtnKysseT1vLm5leHQoKSludWxsIT09KHk9bShoLGwsZyx5LnZhbHVlLGkpKSYmKGUmJm51bGwhPT15LmFsdGVybmF0ZSYmaC5kZWxldGUobnVsbD09PXkua2V5P2c6eS5rZXkpLHU9YSh5LHUsZyksbnVsbD09PWM/cz15OmMuc2libGluZz15LGM9eSk7cmV0dXJuIGUmJmguZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gbihsLGUpfSksbGMmJmxsKGwsZyksc30oaSxzLGMsaCk7bEooaSxjKX1yZXR1cm4ic3RyaW5nIj09dHlwZW9mIGMmJiIiIT09Y3x8Im51bWJlciI9PXR5cGVvZiBjPyhjPSIiK2MsbnVsbCE9PXMmJjY9PT1zLnRhZz8odChpLHMuc2libGluZyksKHM9bChzLGMpKS5yZXR1cm49aSk6KHQoaSxzKSwocz1vWihjLGkubW9kZSxoKSkucmV0dXJuPWkpLHUoaT1zKSk6dChpLHMpfX12YXIgbDI9bDEoITApLGwzPWwxKCExKSxsND17fSxsOD1yJChsNCksbDY9ciQobDQpLGw1PXIkKGw0KTtmdW5jdGlvbiBsOShlKXtpZihlPT09bDQpdGhyb3cgRXJyb3IoZigxNzQpKTtyZXR1cm4gZX1mdW5jdGlvbiBsNyhlLG4pe3N3aXRjaChyQihsNSxuKSxyQihsNixlKSxyQihsOCxsNCksZT1uLm5vZGVUeXBlKXtjYXNlIDk6Y2FzZSAxMTpuPShuPW4uZG9jdW1lbnRFbGVtZW50KT9uLm5hbWVzcGFjZVVSSTplZihudWxsLCIiKTticmVhaztkZWZhdWx0Om49KGU9OD09PWU/bi5wYXJlbnROb2RlOm4pLm5hbWVzcGFjZVVSSXx8bnVsbCxlPWUudGFnTmFtZSxuPWVmKG4sZSl9cmoobDgpLHJCKGw4LG4pfWZ1bmN0aW9uIGFlKCl7cmoobDgpLHJqKGw2KSxyaihsNSl9ZnVuY3Rpb24gYW4oZSl7bDkobDUuY3VycmVudCk7dmFyIG49bDkobDguY3VycmVudCksdD1lZihuLGUudHlwZSk7biE9PXQmJihyQihsNixlKSxyQihsOCx0KSl9ZnVuY3Rpb24gYXQoZSl7bDYuY3VycmVudD09PWUmJihyaihsOCkscmoobDYpKX12YXIgYXI9ciQoMCk7ZnVuY3Rpb24gYWwoZSl7Zm9yKHZhciBuPWU7bnVsbCE9PW47KXtpZigxMz09PW4udGFnKXt2YXIgdD1uLm1lbW9pemVkU3RhdGU7aWYobnVsbCE9PXQmJihudWxsPT09KHQ9dC5kZWh5ZHJhdGVkKXx8IiQ/Ij09PXQuZGF0YXx8IiQhIj09PXQuZGF0YSkpcmV0dXJuIG59ZWxzZSBpZigxOT09PW4udGFnJiZ2b2lkIDAhPT1uLm1lbW9pemVkUHJvcHMucmV2ZWFsT3JkZXIpe2lmKDAhPSgxMjgmbi5mbGFncykpcmV0dXJuIG59ZWxzZSBpZihudWxsIT09bi5jaGlsZCl7bi5jaGlsZC5yZXR1cm49bixuPW4uY2hpbGQ7Y29udGludWV9aWYobj09PWUpYnJlYWs7Zm9yKDtudWxsPT09bi5zaWJsaW5nOyl7aWYobnVsbD09PW4ucmV0dXJufHxuLnJldHVybj09PWUpcmV0dXJuIG51bGw7bj1uLnJldHVybn1uLnNpYmxpbmcucmV0dXJuPW4ucmV0dXJuLG49bi5zaWJsaW5nfXJldHVybiBudWxsfXZhciBhYT1bXTtmdW5jdGlvbiBhdSgpe2Zvcih2YXIgZT0wO2U8YWEubGVuZ3RoO2UrKylhYVtlXS5fd29ya0luUHJvZ3Jlc3NWZXJzaW9uUHJpbWFyeT1udWxsO2FhLmxlbmd0aD0wfXZhciBhbz1fLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsYWk9Xy5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxhcz0wLGFjPW51bGwsYWY9bnVsbCxhZD1udWxsLGFwPSExLGFtPSExLGFoPTAsYWc9MDtmdW5jdGlvbiBhdigpe3Rocm93IEVycm9yKGYoMzIxKSl9ZnVuY3Rpb24gYXkoZSxuKXtpZihudWxsPT09bilyZXR1cm4hMTtmb3IodmFyIHQ9MDt0PG4ubGVuZ3RoJiZ0PGUubGVuZ3RoO3QrKylpZighdEQoZVt0XSxuW3RdKSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBhYihlLG4sdCxyLGwsYSl7aWYoYXM9YSxhYz1uLG4ubWVtb2l6ZWRTdGF0ZT1udWxsLG4udXBkYXRlUXVldWU9bnVsbCxuLmxhbmVzPTAsYW8uY3VycmVudD1udWxsPT09ZXx8bnVsbD09PWUubWVtb2l6ZWRTdGF0ZT9hMjphMyxlPXQocixsKSxhbSl7YT0wO2Rve2lmKGFtPSExLGFoPTAsMjU8PWEpdGhyb3cgRXJyb3IoZigzMDEpKTthKz0xLGFkPWFmPW51bGwsbi51cGRhdGVRdWV1ZT1udWxsLGFvLmN1cnJlbnQ9YTQsZT10KHIsbCl9d2hpbGUoYW0pfWlmKGFvLmN1cnJlbnQ9YTEsbj1udWxsIT09YWYmJm51bGwhPT1hZi5uZXh0LGFzPTAsYWQ9YWY9YWM9bnVsbCxhcD0hMSxuKXRocm93IEVycm9yKGYoMzAwKSk7cmV0dXJuIGV9ZnVuY3Rpb24gYWsoKXt2YXIgZT0wIT09YWg7cmV0dXJuIGFoPTAsZX1mdW5jdGlvbiBhdygpe3ZhciBlPXttZW1vaXplZFN0YXRlOm51bGwsYmFzZVN0YXRlOm51bGwsYmFzZVF1ZXVlOm51bGwscXVldWU6bnVsbCxuZXh0Om51bGx9O3JldHVybiBudWxsPT09YWQ/YWMubWVtb2l6ZWRTdGF0ZT1hZD1lOmFkPWFkLm5leHQ9ZSxhZH1mdW5jdGlvbiBhUygpe2lmKG51bGw9PT1hZil7dmFyIGU9YWMuYWx0ZXJuYXRlO2U9bnVsbCE9PWU/ZS5tZW1vaXplZFN0YXRlOm51bGx9ZWxzZSBlPWFmLm5leHQ7dmFyIG49bnVsbD09PWFkP2FjLm1lbW9pemVkU3RhdGU6YWQubmV4dDtpZihudWxsIT09bilhZD1uLGFmPWU7ZWxzZXtpZihudWxsPT09ZSl0aHJvdyBFcnJvcihmKDMxMCkpO2U9e21lbW9pemVkU3RhdGU6KGFmPWUpLm1lbW9pemVkU3RhdGUsYmFzZVN0YXRlOmFmLmJhc2VTdGF0ZSxiYXNlUXVldWU6YWYuYmFzZVF1ZXVlLHF1ZXVlOmFmLnF1ZXVlLG5leHQ6bnVsbH0sbnVsbD09PWFkP2FjLm1lbW9pemVkU3RhdGU9YWQ9ZTphZD1hZC5uZXh0PWV9cmV0dXJuIGFkfWZ1bmN0aW9uIGF4KGUsbil7cmV0dXJuImZ1bmN0aW9uIj09dHlwZW9mIG4/bihlKTpufWZ1bmN0aW9uIGFFKGUpe3ZhciBuPWFTKCksdD1uLnF1ZXVlO2lmKG51bGw9PT10KXRocm93IEVycm9yKGYoMzExKSk7dC5sYXN0UmVuZGVyZWRSZWR1Y2VyPWU7dmFyIHI9YWYsbD1yLmJhc2VRdWV1ZSxhPXQucGVuZGluZztpZihudWxsIT09YSl7aWYobnVsbCE9PWwpe3ZhciB1PWwubmV4dDtsLm5leHQ9YS5uZXh0LGEubmV4dD11fXIuYmFzZVF1ZXVlPWw9YSx0LnBlbmRpbmc9bnVsbH1pZihudWxsIT09bCl7YT1sLm5leHQscj1yLmJhc2VTdGF0ZTt2YXIgbz11PW51bGwsaT1udWxsLHM9YTtkb3t2YXIgYz1zLmxhbmU7aWYoKGFzJmMpPT09YyludWxsIT09aSYmKGk9aS5uZXh0PXtsYW5lOjAsYWN0aW9uOnMuYWN0aW9uLGhhc0VhZ2VyU3RhdGU6cy5oYXNFYWdlclN0YXRlLGVhZ2VyU3RhdGU6cy5lYWdlclN0YXRlLG5leHQ6bnVsbH0pLHI9cy5oYXNFYWdlclN0YXRlP3MuZWFnZXJTdGF0ZTplKHIscy5hY3Rpb24pO2Vsc2V7dmFyIGQ9e2xhbmU6YyxhY3Rpb246cy5hY3Rpb24saGFzRWFnZXJTdGF0ZTpzLmhhc0VhZ2VyU3RhdGUsZWFnZXJTdGF0ZTpzLmVhZ2VyU3RhdGUsbmV4dDpudWxsfTtudWxsPT09aT8obz1pPWQsdT1yKTppPWkubmV4dD1kLGFjLmxhbmVzfD1jLG9lfD1jfXM9cy5uZXh0fXdoaWxlKG51bGwhPT1zJiZzIT09YSk7bnVsbD09PWk/dT1yOmkubmV4dD1vLHREKHIsbi5tZW1vaXplZFN0YXRlKXx8KHVhPSEwKSxuLm1lbW9pemVkU3RhdGU9cixuLmJhc2VTdGF0ZT11LG4uYmFzZVF1ZXVlPWksdC5sYXN0UmVuZGVyZWRTdGF0ZT1yfWlmKG51bGwhPT0oZT10LmludGVybGVhdmVkKSl7bD1lO2RvIGE9bC5sYW5lLGFjLmxhbmVzfD1hLG9lfD1hLGw9bC5uZXh0O3doaWxlKGwhPT1lKX1lbHNlIG51bGw9PT1sJiYodC5sYW5lcz0wKTtyZXR1cm5bbi5tZW1vaXplZFN0YXRlLHQuZGlzcGF0Y2hdfWZ1bmN0aW9uIGFDKGUpe3ZhciBuPWFTKCksdD1uLnF1ZXVlO2lmKG51bGw9PT10KXRocm93IEVycm9yKGYoMzExKSk7dC5sYXN0UmVuZGVyZWRSZWR1Y2VyPWU7dmFyIHI9dC5kaXNwYXRjaCxsPXQucGVuZGluZyxhPW4ubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09bCl7dC5wZW5kaW5nPW51bGw7dmFyIHU9bD1sLm5leHQ7ZG8gYT1lKGEsdS5hY3Rpb24pLHU9dS5uZXh0O3doaWxlKHUhPT1sKTt0RChhLG4ubWVtb2l6ZWRTdGF0ZSl8fCh1YT0hMCksbi5tZW1vaXplZFN0YXRlPWEsbnVsbD09PW4uYmFzZVF1ZXVlJiYobi5iYXNlU3RhdGU9YSksdC5sYXN0UmVuZGVyZWRTdGF0ZT1hfXJldHVyblthLHJdfWZ1bmN0aW9uIGFfKCl7fWZ1bmN0aW9uIGFQKGUsbil7dmFyIHQ9YWMscj1hUygpLGw9bigpLGE9IXREKHIubWVtb2l6ZWRTdGF0ZSxsKTtpZihhJiYoci5tZW1vaXplZFN0YXRlPWwsdWE9ITApLHI9ci5xdWV1ZSxhVihhVC5iaW5kKG51bGwsdCxyLGUpLFtlXSksci5nZXRTbmFwc2hvdCE9PW58fGF8fG51bGwhPT1hZCYmMSZhZC5tZW1vaXplZFN0YXRlLnRhZyl7aWYodC5mbGFnc3w9MjA0OCxhRig5LGF6LmJpbmQobnVsbCx0LHIsbCxuKSx2b2lkIDAsbnVsbCksbnVsbD09PXUzKXRocm93IEVycm9yKGYoMzQ5KSk7MCE9KDMwJmFzKXx8YU4odCxuLGwpfXJldHVybiBsfWZ1bmN0aW9uIGFOKGUsbix0KXtlLmZsYWdzfD0xNjM4NCxlPXtnZXRTbmFwc2hvdDpuLHZhbHVlOnR9LG51bGw9PT0obj1hYy51cGRhdGVRdWV1ZSk/KG49e2xhc3RFZmZlY3Q6bnVsbCxzdG9yZXM6bnVsbH0sYWMudXBkYXRlUXVldWU9bixuLnN0b3Jlcz1bZV0pOm51bGw9PT0odD1uLnN0b3Jlcyk/bi5zdG9yZXM9W2VdOnQucHVzaChlKX1mdW5jdGlvbiBheihlLG4sdCxyKXtuLnZhbHVlPXQsbi5nZXRTbmFwc2hvdD1yLGFMKG4pJiZhUihlKX1mdW5jdGlvbiBhVChlLG4sdCl7cmV0dXJuIHQoZnVuY3Rpb24oKXthTChuKSYmYVIoZSl9KX1mdW5jdGlvbiBhTChlKXt2YXIgbj1lLmdldFNuYXBzaG90O2U9ZS52YWx1ZTt0cnl7dmFyIHQ9bigpO3JldHVybiF0RChlLHQpfWNhdGNoKGUpe3JldHVybiEwfX1mdW5jdGlvbiBhUihlKXt2YXIgbj1sTyhlLDEpO251bGwhPT1uJiZvayhuLGUsMSwtMSl9ZnVuY3Rpb24gYU0oZSl7dmFyIG49YXcoKTtyZXR1cm4iZnVuY3Rpb24iPT10eXBlb2YgZSYmKGU9ZSgpKSxuLm1lbW9pemVkU3RhdGU9bi5iYXNlU3RhdGU9ZSxlPXtwZW5kaW5nOm51bGwsaW50ZXJsZWF2ZWQ6bnVsbCxsYW5lczowLGRpc3BhdGNoOm51bGwsbGFzdFJlbmRlcmVkUmVkdWNlcjpheCxsYXN0UmVuZGVyZWRTdGF0ZTplfSxuLnF1ZXVlPWUsZT1lLmRpc3BhdGNoPWFHLmJpbmQobnVsbCxhYyxlKSxbbi5tZW1vaXplZFN0YXRlLGVdfWZ1bmN0aW9uIGFGKGUsbix0LHIpe3JldHVybiBlPXt0YWc6ZSxjcmVhdGU6bixkZXN0cm95OnQsZGVwczpyLG5leHQ6bnVsbH0sbnVsbD09PShuPWFjLnVwZGF0ZVF1ZXVlKT8obj17bGFzdEVmZmVjdDpudWxsLHN0b3JlczpudWxsfSxhYy51cGRhdGVRdWV1ZT1uLG4ubGFzdEVmZmVjdD1lLm5leHQ9ZSk6bnVsbD09PSh0PW4ubGFzdEVmZmVjdCk/bi5sYXN0RWZmZWN0PWUubmV4dD1lOihyPXQubmV4dCx0Lm5leHQ9ZSxlLm5leHQ9cixuLmxhc3RFZmZlY3Q9ZSksZX1mdW5jdGlvbiBhTygpe3JldHVybiBhUygpLm1lbW9pemVkU3RhdGV9ZnVuY3Rpb24gYUQoZSxuLHQscil7dmFyIGw9YXcoKTthYy5mbGFnc3w9ZSxsLm1lbW9pemVkU3RhdGU9YUYoMXxuLHQsdm9pZCAwLHZvaWQgMD09PXI/bnVsbDpyKX1mdW5jdGlvbiBhSShlLG4sdCxyKXt2YXIgbD1hUygpO3I9dm9pZCAwPT09cj9udWxsOnI7dmFyIGE9dm9pZCAwO2lmKG51bGwhPT1hZil7dmFyIHU9YWYubWVtb2l6ZWRTdGF0ZTtpZihhPXUuZGVzdHJveSxudWxsIT09ciYmYXkocix1LmRlcHMpKXtsLm1lbW9pemVkU3RhdGU9YUYobix0LGEscik7cmV0dXJufX1hYy5mbGFnc3w9ZSxsLm1lbW9pemVkU3RhdGU9YUYoMXxuLHQsYSxyKX1mdW5jdGlvbiBhVShlLG4pe3JldHVybiBhRCg4MzkwNjU2LDgsZSxuKX1mdW5jdGlvbiBhVihlLG4pe3JldHVybiBhSSgyMDQ4LDgsZSxuKX1mdW5jdGlvbiBhQShlLG4pe3JldHVybiBhSSg0LDIsZSxuKX1mdW5jdGlvbiBhJChlLG4pe3JldHVybiBhSSg0LDQsZSxuKX1mdW5jdGlvbiBhaihlLG4pe3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZiBuPyhuKGU9ZSgpKSxmdW5jdGlvbigpe24obnVsbCl9KTpudWxsIT1uPyhlPWUoKSxuLmN1cnJlbnQ9ZSxmdW5jdGlvbigpe24uY3VycmVudD1udWxsfSk6dm9pZCAwfWZ1bmN0aW9uIGFCKGUsbix0KXtyZXR1cm4gdD1udWxsIT10P3QuY29uY2F0KFtlXSk6bnVsbCxhSSg0LDQsYWouYmluZChudWxsLG4sZSksdCl9ZnVuY3Rpb24gYUgoKXt9ZnVuY3Rpb24gYVcoZSxuKXt2YXIgdD1hUygpO249dm9pZCAwPT09bj9udWxsOm47dmFyIHI9dC5tZW1vaXplZFN0YXRlO3JldHVybiBudWxsIT09ciYmbnVsbCE9PW4mJmF5KG4sclsxXSk/clswXToodC5tZW1vaXplZFN0YXRlPVtlLG5dLGUpfWZ1bmN0aW9uIGFRKGUsbil7dmFyIHQ9YVMoKTtuPXZvaWQgMD09PW4/bnVsbDpuO3ZhciByPXQubWVtb2l6ZWRTdGF0ZTtyZXR1cm4gbnVsbCE9PXImJm51bGwhPT1uJiZheShuLHJbMV0pP3JbMF06KGU9ZSgpLHQubWVtb2l6ZWRTdGF0ZT1bZSxuXSxlKX1mdW5jdGlvbiBhcShlLG4sdCl7cmV0dXJuIDA9PSgyMSZhcyk/KGUuYmFzZVN0YXRlJiYoZS5iYXNlU3RhdGU9ITEsdWE9ITApLGUubWVtb2l6ZWRTdGF0ZT10KToodEQodCxuKXx8KHQ9bnUoKSxhYy5sYW5lc3w9dCxvZXw9dCxlLmJhc2VTdGF0ZT0hMCksbil9ZnVuY3Rpb24gYUsoZSxuKXt2YXIgdD1uYztuYz0wIT09dCYmND50P3Q6NCxlKCEwKTt2YXIgcj1haS50cmFuc2l0aW9uO2FpLnRyYW5zaXRpb249e307dHJ5e2UoITEpLG4oKX1maW5hbGx5e25jPXQsYWkudHJhbnNpdGlvbj1yfX1mdW5jdGlvbiBhWSgpe3JldHVybiBhUygpLm1lbW9pemVkU3RhdGV9ZnVuY3Rpb24gYVgoZSxuLHQpe3ZhciByPW9iKGUpO3Q9e2xhbmU6cixhY3Rpb246dCxoYXNFYWdlclN0YXRlOiExLGVhZ2VyU3RhdGU6bnVsbCxuZXh0Om51bGx9LGFaKGUpP2FKKG4sdCk6bnVsbCE9PSh0PWxGKGUsbix0LHIpKSYmKG9rKHQsZSxyLG95KCkpLGEwKHQsbixyKSl9ZnVuY3Rpb24gYUcoZSxuLHQpe3ZhciByPW9iKGUpLGw9e2xhbmU6cixhY3Rpb246dCxoYXNFYWdlclN0YXRlOiExLGVhZ2VyU3RhdGU6bnVsbCxuZXh0Om51bGx9O2lmKGFaKGUpKWFKKG4sbCk7ZWxzZXt2YXIgYT1lLmFsdGVybmF0ZTtpZigwPT09ZS5sYW5lcyYmKG51bGw9PT1hfHwwPT09YS5sYW5lcykmJm51bGwhPT0oYT1uLmxhc3RSZW5kZXJlZFJlZHVjZXIpKXRyeXt2YXIgdT1uLmxhc3RSZW5kZXJlZFN0YXRlLG89YSh1LHQpO2lmKGwuaGFzRWFnZXJTdGF0ZT0hMCxsLmVhZ2VyU3RhdGU9byx0RChvLHUpKXt2YXIgaT1uLmludGVybGVhdmVkO251bGw9PT1pPyhsLm5leHQ9bCxsTShuKSk6KGwubmV4dD1pLm5leHQsaS5uZXh0PWwpLG4uaW50ZXJsZWF2ZWQ9bDtyZXR1cm59fWNhdGNoKGUpe31maW5hbGx5e31udWxsIT09KHQ9bEYoZSxuLGwscikpJiYob2sodCxlLHIsbD1veSgpKSxhMCh0LG4scikpfX1mdW5jdGlvbiBhWihlKXt2YXIgbj1lLmFsdGVybmF0ZTtyZXR1cm4gZT09PWFjfHxudWxsIT09biYmbj09PWFjfWZ1bmN0aW9uIGFKKGUsbil7YW09YXA9ITA7dmFyIHQ9ZS5wZW5kaW5nO251bGw9PT10P24ubmV4dD1uOihuLm5leHQ9dC5uZXh0LHQubmV4dD1uKSxlLnBlbmRpbmc9bn1mdW5jdGlvbiBhMChlLG4sdCl7aWYoMCE9KDQxOTQyNDAmdCkpe3ZhciByPW4ubGFuZXM7ciY9ZS5wZW5kaW5nTGFuZXMsdHw9cixuLmxhbmVzPXQsbnMoZSx0KX19dmFyIGExPXtyZWFkQ29udGV4dDpsTCx1c2VDYWxsYmFjazphdix1c2VDb250ZXh0OmF2LHVzZUVmZmVjdDphdix1c2VJbXBlcmF0aXZlSGFuZGxlOmF2LHVzZUluc2VydGlvbkVmZmVjdDphdix1c2VMYXlvdXRFZmZlY3Q6YXYsdXNlTWVtbzphdix1c2VSZWR1Y2VyOmF2LHVzZVJlZjphdix1c2VTdGF0ZTphdix1c2VEZWJ1Z1ZhbHVlOmF2LHVzZURlZmVycmVkVmFsdWU6YXYsdXNlVHJhbnNpdGlvbjphdix1c2VNdXRhYmxlU291cmNlOmF2LHVzZVN5bmNFeHRlcm5hbFN0b3JlOmF2LHVzZUlkOmF2LHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjohMX0sYTI9e3JlYWRDb250ZXh0OmxMLHVzZUNhbGxiYWNrOmZ1bmN0aW9uKGUsbil7cmV0dXJuIGF3KCkubWVtb2l6ZWRTdGF0ZT1bZSx2b2lkIDA9PT1uP251bGw6bl0sZX0sdXNlQ29udGV4dDpsTCx1c2VFZmZlY3Q6YVUsdXNlSW1wZXJhdGl2ZUhhbmRsZTpmdW5jdGlvbihlLG4sdCl7cmV0dXJuIHQ9bnVsbCE9dD90LmNvbmNhdChbZV0pOm51bGwsYUQoNDE5NDMwOCw0LGFqLmJpbmQobnVsbCxuLGUpLHQpfSx1c2VMYXlvdXRFZmZlY3Q6ZnVuY3Rpb24oZSxuKXtyZXR1cm4gYUQoNDE5NDMwOCw0LGUsbil9LHVzZUluc2VydGlvbkVmZmVjdDpmdW5jdGlvbihlLG4pe3JldHVybiBhRCg0LDIsZSxuKX0sdXNlTWVtbzpmdW5jdGlvbihlLG4pe3ZhciB0PWF3KCk7cmV0dXJuIG49dm9pZCAwPT09bj9udWxsOm4sZT1lKCksdC5tZW1vaXplZFN0YXRlPVtlLG5dLGV9LHVzZVJlZHVjZXI6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPWF3KCk7cmV0dXJuIG49dm9pZCAwIT09dD90KG4pOm4sci5tZW1vaXplZFN0YXRlPXIuYmFzZVN0YXRlPW4sZT17cGVuZGluZzpudWxsLGludGVybGVhdmVkOm51bGwsbGFuZXM6MCxkaXNwYXRjaDpudWxsLGxhc3RSZW5kZXJlZFJlZHVjZXI6ZSxsYXN0UmVuZGVyZWRTdGF0ZTpufSxyLnF1ZXVlPWUsZT1lLmRpc3BhdGNoPWFYLmJpbmQobnVsbCxhYyxlKSxbci5tZW1vaXplZFN0YXRlLGVdfSx1c2VSZWY6ZnVuY3Rpb24oZSl7cmV0dXJuIGU9e2N1cnJlbnQ6ZX0sYXcoKS5tZW1vaXplZFN0YXRlPWV9LHVzZVN0YXRlOmFNLHVzZURlYnVnVmFsdWU6YUgsdXNlRGVmZXJyZWRWYWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gYXcoKS5tZW1vaXplZFN0YXRlPWV9LHVzZVRyYW5zaXRpb246ZnVuY3Rpb24oKXt2YXIgZT1hTSghMSksbj1lWzBdO3JldHVybiBlPWFLLmJpbmQobnVsbCxlWzFdKSxhdygpLm1lbW9pemVkU3RhdGU9ZSxbbixlXX0sdXNlTXV0YWJsZVNvdXJjZTpmdW5jdGlvbigpe30sdXNlU3luY0V4dGVybmFsU3RvcmU6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPWFjLGw9YXcoKTtpZihsYyl7aWYodm9pZCAwPT09dCl0aHJvdyBFcnJvcihmKDQwNykpO3Q9dCgpfWVsc2V7aWYodD1uKCksbnVsbD09PXUzKXRocm93IEVycm9yKGYoMzQ5KSk7MCE9KDMwJmFzKXx8YU4ocixuLHQpfWwubWVtb2l6ZWRTdGF0ZT10O3ZhciBhPXt2YWx1ZTp0LGdldFNuYXBzaG90Om59O3JldHVybiBsLnF1ZXVlPWEsYVUoYVQuYmluZChudWxsLHIsYSxlKSxbZV0pLHIuZmxhZ3N8PTIwNDgsYUYoOSxhei5iaW5kKG51bGwscixhLHQsbiksdm9pZCAwLG51bGwpLHR9LHVzZUlkOmZ1bmN0aW9uKCl7dmFyIGU9YXcoKSxuPXUzLmlkZW50aWZpZXJQcmVmaXg7aWYobGMpe3ZhciB0PWxyLHI9bHQ7bj0iOiIrbisiUiIrKHQ9KHImfigxPDwzMi1lOShyKS0xKSkudG9TdHJpbmcoMzIpK3QpLDA8KHQ9YWgrKykmJihuKz0iSCIrdC50b1N0cmluZygzMikpLG4rPSI6In1lbHNlIG49IjoiK24rInIiKyh0PWFnKyspLnRvU3RyaW5nKDMyKSsiOiI7cmV0dXJuIGUubWVtb2l6ZWRTdGF0ZT1ufSx1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6ITF9LGEzPXtyZWFkQ29udGV4dDpsTCx1c2VDYWxsYmFjazphVyx1c2VDb250ZXh0OmxMLHVzZUVmZmVjdDphVix1c2VJbXBlcmF0aXZlSGFuZGxlOmFCLHVzZUluc2VydGlvbkVmZmVjdDphQSx1c2VMYXlvdXRFZmZlY3Q6YSQsdXNlTWVtbzphUSx1c2VSZWR1Y2VyOmFFLHVzZVJlZjphTyx1c2VTdGF0ZTpmdW5jdGlvbigpe3JldHVybiBhRShheCl9LHVzZURlYnVnVmFsdWU6YUgsdXNlRGVmZXJyZWRWYWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gYXEoYVMoKSxhZi5tZW1vaXplZFN0YXRlLGUpfSx1c2VUcmFuc2l0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuW2FFKGF4KVswXSxhUygpLm1lbW9pemVkU3RhdGVdfSx1c2VNdXRhYmxlU291cmNlOmFfLHVzZVN5bmNFeHRlcm5hbFN0b3JlOmFQLHVzZUlkOmFZLHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjohMX0sYTQ9e3JlYWRDb250ZXh0OmxMLHVzZUNhbGxiYWNrOmFXLHVzZUNvbnRleHQ6bEwsdXNlRWZmZWN0OmFWLHVzZUltcGVyYXRpdmVIYW5kbGU6YUIsdXNlSW5zZXJ0aW9uRWZmZWN0OmFBLHVzZUxheW91dEVmZmVjdDphJCx1c2VNZW1vOmFRLHVzZVJlZHVjZXI6YUMsdXNlUmVmOmFPLHVzZVN0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuIGFDKGF4KX0sdXNlRGVidWdWYWx1ZTphSCx1c2VEZWZlcnJlZFZhbHVlOmZ1bmN0aW9uKGUpe3ZhciBuPWFTKCk7cmV0dXJuIG51bGw9PT1hZj9uLm1lbW9pemVkU3RhdGU9ZTphcShuLGFmLm1lbW9pemVkU3RhdGUsZSl9LHVzZVRyYW5zaXRpb246ZnVuY3Rpb24oKXtyZXR1cm5bYUMoYXgpWzBdLGFTKCkubWVtb2l6ZWRTdGF0ZV19LHVzZU11dGFibGVTb3VyY2U6YV8sdXNlU3luY0V4dGVybmFsU3RvcmU6YVAsdXNlSWQ6YVksdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiExfTtmdW5jdGlvbiBhOChlLG4pe3RyeXt2YXIgdD0iIixyPW47ZG8gdCs9ZnVuY3Rpb24oZSl7c3dpdGNoKGUudGFnKXtjYXNlIDU6cmV0dXJuIEgoZS50eXBlKTtjYXNlIDE2OnJldHVybiBIKCJMYXp5Iik7Y2FzZSAxMzpyZXR1cm4gSCgiU3VzcGVuc2UiKTtjYXNlIDE5OnJldHVybiBIKCJTdXNwZW5zZUxpc3QiKTtjYXNlIDA6Y2FzZSAyOmNhc2UgMTU6cmV0dXJuIGU9UShlLnR5cGUsITEpO2Nhc2UgMTE6cmV0dXJuIGU9UShlLnR5cGUucmVuZGVyLCExKTtjYXNlIDE6cmV0dXJuIGU9UShlLnR5cGUsITApO2RlZmF1bHQ6cmV0dXJuIiJ9fShyKSxyPXIucmV0dXJuO3doaWxlKHIpO3ZhciBsPXR9Y2F0Y2goZSl7bD0iXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiAiK2UubWVzc2FnZSsiXG4iK2Uuc3RhY2t9cmV0dXJue3ZhbHVlOmUsc291cmNlOm4sc3RhY2s6bCxkaWdlc3Q6bnVsbH19ZnVuY3Rpb24gYTYoZSxuLHQpe3JldHVybnt2YWx1ZTplLHNvdXJjZTpudWxsLHN0YWNrOm51bGwhPXQ/dDpudWxsLGRpZ2VzdDpudWxsIT1uP246bnVsbH19ZnVuY3Rpb24gYTUoZSxuKXt0cnl7Y29uc29sZS5lcnJvcihuLnZhbHVlKX1jYXRjaChlKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgZX0pfX12YXIgYTk9ImZ1bmN0aW9uIj09dHlwZW9mIFdlYWtNYXA/V2Vha01hcDpNYXA7ZnVuY3Rpb24gYTcoZSxuLHQpeyh0PWxWKC0xLHQpKS50YWc9Myx0LnBheWxvYWQ9e2VsZW1lbnQ6bnVsbH07dmFyIHI9bi52YWx1ZTtyZXR1cm4gdC5jYWxsYmFjaz1mdW5jdGlvbigpe29pfHwob2k9ITAsb3M9ciksYTUoZSxuKX0sdH1mdW5jdGlvbiB1ZShlLG4sdCl7KHQ9bFYoLTEsdCkpLnRhZz0zO3ZhciByPWUudHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I7aWYoImZ1bmN0aW9uIj09dHlwZW9mIHIpe3ZhciBsPW4udmFsdWU7dC5wYXlsb2FkPWZ1bmN0aW9uKCl7cmV0dXJuIHIobCl9LHQuY2FsbGJhY2s9ZnVuY3Rpb24oKXthNShlLG4pfX12YXIgYT1lLnN0YXRlTm9kZTtyZXR1cm4gbnVsbCE9PWEmJiJmdW5jdGlvbiI9PXR5cGVvZiBhLmNvbXBvbmVudERpZENhdGNoJiYodC5jYWxsYmFjaz1mdW5jdGlvbigpe2E1KGUsbiksImZ1bmN0aW9uIiE9dHlwZW9mIHImJihudWxsPT09b2M/b2M9bmV3IFNldChbdGhpc10pOm9jLmFkZCh0aGlzKSk7dmFyIHQ9bi5zdGFjazt0aGlzLmNvbXBvbmVudERpZENhdGNoKG4udmFsdWUse2NvbXBvbmVudFN0YWNrOm51bGwhPT10P3Q6IiJ9KX0pLHR9ZnVuY3Rpb24gdW4oZSxuLHQpe3ZhciByPWUucGluZ0NhY2hlO2lmKG51bGw9PT1yKXtyPWUucGluZ0NhY2hlPW5ldyBhOTt2YXIgbD1uZXcgU2V0O3Iuc2V0KG4sbCl9ZWxzZSB2b2lkIDA9PT0obD1yLmdldChuKSkmJihsPW5ldyBTZXQsci5zZXQobixsKSk7bC5oYXModCl8fChsLmFkZCh0KSxlPW8kLmJpbmQobnVsbCxlLG4sdCksbi50aGVuKGUsZSkpfWZ1bmN0aW9uIHV0KGUpe2Rve3ZhciBuO2lmKChuPTEzPT09ZS50YWcpJiYobj1udWxsPT09KG49ZS5tZW1vaXplZFN0YXRlKXx8bnVsbCE9PW4uZGVoeWRyYXRlZCksbilyZXR1cm4gZTtlPWUucmV0dXJufXdoaWxlKG51bGwhPT1lKTtyZXR1cm4gbnVsbH1mdW5jdGlvbiB1cihlLG4sdCxyLGwpe3JldHVybiAwPT0oMSZlLm1vZGUpP2U9PT1uP2UuZmxhZ3N8PTY1NTM2OihlLmZsYWdzfD0xMjgsdC5mbGFnc3w9MTMxMDcyLHQuZmxhZ3MmPS01MjgwNSwxPT09dC50YWcmJihudWxsPT09dC5hbHRlcm5hdGU/dC50YWc9MTc6KChuPWxWKC0xLDEpKS50YWc9MixsQSh0LG4sMSkpKSx0LmxhbmVzfD0xKTooZS5mbGFnc3w9NjU1MzYsZS5sYW5lcz1sKSxlfXZhciB1bD1fLlJlYWN0Q3VycmVudE93bmVyLHVhPSExO2Z1bmN0aW9uIHV1KGUsbix0LHIpe24uY2hpbGQ9bnVsbD09PWU/bDMobixudWxsLHQscik6bDIobixlLmNoaWxkLHQscil9ZnVuY3Rpb24gdW8oZSxuLHQscixsKXt0PXQucmVuZGVyO3ZhciBhPW4ucmVmO3JldHVybihsVChuLGwpLHI9YWIoZSxuLHQscixhLGwpLHQ9YWsoKSxudWxsPT09ZXx8dWEpPyhsYyYmdCYmbHUobiksbi5mbGFnc3w9MSx1dShlLG4scixsKSxuLmNoaWxkKToobi51cGRhdGVRdWV1ZT1lLnVwZGF0ZVF1ZXVlLG4uZmxhZ3MmPS0yMDUzLGUubGFuZXMmPX5sLHVfKGUsbixsKSl9ZnVuY3Rpb24gdWkoZSxuLHQscixsKXtpZihudWxsPT09ZSl7dmFyIGE9dC50eXBlO3JldHVybiJmdW5jdGlvbiIhPXR5cGVvZiBhfHxvcShhKXx8dm9pZCAwIT09YS5kZWZhdWx0UHJvcHN8fG51bGwhPT10LmNvbXBhcmV8fHZvaWQgMCE9PXQuZGVmYXVsdFByb3BzPygoZT1vWSh0LnR5cGUsbnVsbCxyLG4sbi5tb2RlLGwpKS5yZWY9bi5yZWYsZS5yZXR1cm49bixuLmNoaWxkPWUpOihuLnRhZz0xNSxuLnR5cGU9YSx1cyhlLG4sYSxyLGwpKX1pZihhPWUuY2hpbGQsMD09KGUubGFuZXMmbCkpe3ZhciB1PWEubWVtb2l6ZWRQcm9wcztpZigodD1udWxsIT09KHQ9dC5jb21wYXJlKT90OnRJKSh1LHIpJiZlLnJlZj09PW4ucmVmKXJldHVybiB1XyhlLG4sbCl9cmV0dXJuIG4uZmxhZ3N8PTEsKGU9b0soYSxyKSkucmVmPW4ucmVmLGUucmV0dXJuPW4sbi5jaGlsZD1lfWZ1bmN0aW9uIHVzKGUsbix0LHIsbCl7aWYobnVsbCE9PWUpe3ZhciBhPWUubWVtb2l6ZWRQcm9wcztpZih0SShhLHIpJiZlLnJlZj09PW4ucmVmKXtpZih1YT0hMSxuLnBlbmRpbmdQcm9wcz1yPWEsMD09KGUubGFuZXMmbCkpcmV0dXJuIG4ubGFuZXM9ZS5sYW5lcyx1XyhlLG4sbCk7MCE9KDEzMTA3MiZlLmZsYWdzKSYmKHVhPSEwKX19cmV0dXJuIHVkKGUsbix0LHIsbCl9ZnVuY3Rpb24gdWMoZSxuLHQpe3ZhciByPW4ucGVuZGluZ1Byb3BzLGw9ci5jaGlsZHJlbixhPW51bGwhPT1lP2UubWVtb2l6ZWRTdGF0ZTpudWxsO2lmKCJoaWRkZW4iPT09ci5tb2RlKXtpZigwPT0oMSZuLm1vZGUpKW4ubWVtb2l6ZWRTdGF0ZT17YmFzZUxhbmVzOjAsY2FjaGVQb29sOm51bGwsdHJhbnNpdGlvbnM6bnVsbH0sckIodTUsdTYpLHU2fD10O2Vsc2V7aWYoMD09KDEwNzM3NDE4MjQmdCkpcmV0dXJuIGU9bnVsbCE9PWE/YS5iYXNlTGFuZXN8dDp0LG4ubGFuZXM9bi5jaGlsZExhbmVzPTEwNzM3NDE4MjQsbi5tZW1vaXplZFN0YXRlPXtiYXNlTGFuZXM6ZSxjYWNoZVBvb2w6bnVsbCx0cmFuc2l0aW9uczpudWxsfSxuLnVwZGF0ZVF1ZXVlPW51bGwsckIodTUsdTYpLHU2fD1lLG51bGw7bi5tZW1vaXplZFN0YXRlPXtiYXNlTGFuZXM6MCxjYWNoZVBvb2w6bnVsbCx0cmFuc2l0aW9uczpudWxsfSxyPW51bGwhPT1hP2EuYmFzZUxhbmVzOnQsckIodTUsdTYpLHU2fD1yfX1lbHNlIG51bGwhPT1hPyhyPWEuYmFzZUxhbmVzfHQsbi5tZW1vaXplZFN0YXRlPW51bGwpOnI9dCxyQih1NSx1NiksdTZ8PXI7cmV0dXJuIHV1KGUsbixsLHQpLG4uY2hpbGR9ZnVuY3Rpb24gdWYoZSxuKXt2YXIgdD1uLnJlZjsobnVsbD09PWUmJm51bGwhPT10fHxudWxsIT09ZSYmZS5yZWYhPT10KSYmKG4uZmxhZ3N8PTUxMixuLmZsYWdzfD0yMDk3MTUyKX1mdW5jdGlvbiB1ZChlLG4sdCxyLGwpe3ZhciBhPXJZKHQpP3JxOnJXLmN1cnJlbnQ7cmV0dXJuKGE9cksobixhKSxsVChuLGwpLHQ9YWIoZSxuLHQscixhLGwpLHI9YWsoKSxudWxsPT09ZXx8dWEpPyhsYyYmciYmbHUobiksbi5mbGFnc3w9MSx1dShlLG4sdCxsKSxuLmNoaWxkKToobi51cGRhdGVRdWV1ZT1lLnVwZGF0ZVF1ZXVlLG4uZmxhZ3MmPS0yMDUzLGUubGFuZXMmPX5sLHVfKGUsbixsKSl9ZnVuY3Rpb24gdXAoZSxuLHQscixsKXtpZihyWSh0KSl7dmFyIGE9ITA7ckoobil9ZWxzZSBhPSExO2lmKGxUKG4sbCksbnVsbD09PW4uc3RhdGVOb2RlKXVDKGUsbiksbFkobix0LHIpLGxHKG4sdCxyLGwpLHI9ITA7ZWxzZSBpZihudWxsPT09ZSl7dmFyIHU9bi5zdGF0ZU5vZGUsbz1uLm1lbW9pemVkUHJvcHM7dS5wcm9wcz1vO3ZhciBpPXUuY29udGV4dCxzPXQuY29udGV4dFR5cGU7cz0ib2JqZWN0Ij09dHlwZW9mIHMmJm51bGwhPT1zP2xMKHMpOnJLKG4scz1yWSh0KT9ycTpyVy5jdXJyZW50KTt2YXIgYz10LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyxmPSJmdW5jdGlvbiI9PXR5cGVvZiBjfHwiZnVuY3Rpb24iPT10eXBlb2YgdS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtmfHwiZnVuY3Rpb24iIT10eXBlb2YgdS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyYmImZ1bmN0aW9uIiE9dHlwZW9mIHUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc3x8KG8hPT1yfHxpIT09cykmJmxYKG4sdSxyLHMpLGxEPSExO3ZhciBkPW4ubWVtb2l6ZWRTdGF0ZTt1LnN0YXRlPWQsbEIobixyLHUsbCksaT1uLm1lbW9pemVkU3RhdGUsbyE9PXJ8fGQhPT1pfHxyUS5jdXJyZW50fHxsRD8oImZ1bmN0aW9uIj09dHlwZW9mIGMmJihsUShuLHQsYyxyKSxpPW4ubWVtb2l6ZWRTdGF0ZSksKG89bER8fGxLKG4sdCxvLHIsZCxpLHMpKT8oZnx8ImZ1bmN0aW9uIiE9dHlwZW9mIHUuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCYmImZ1bmN0aW9uIiE9dHlwZW9mIHUuY29tcG9uZW50V2lsbE1vdW50fHwoImZ1bmN0aW9uIj09dHlwZW9mIHUuY29tcG9uZW50V2lsbE1vdW50JiZ1LmNvbXBvbmVudFdpbGxNb3VudCgpLCJmdW5jdGlvbiI9PXR5cGVvZiB1LlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQmJnUuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpKSwiZnVuY3Rpb24iPT10eXBlb2YgdS5jb21wb25lbnREaWRNb3VudCYmKG4uZmxhZ3N8PTQxOTQzMDgpKTooImZ1bmN0aW9uIj09dHlwZW9mIHUuY29tcG9uZW50RGlkTW91bnQmJihuLmZsYWdzfD00MTk0MzA4KSxuLm1lbW9pemVkUHJvcHM9cixuLm1lbW9pemVkU3RhdGU9aSksdS5wcm9wcz1yLHUuc3RhdGU9aSx1LmNvbnRleHQ9cyxyPW8pOigiZnVuY3Rpb24iPT10eXBlb2YgdS5jb21wb25lbnREaWRNb3VudCYmKG4uZmxhZ3N8PTQxOTQzMDgpLHI9ITEpfWVsc2V7dT1uLnN0YXRlTm9kZSxsVShlLG4pLG89bi5tZW1vaXplZFByb3BzLHM9bi50eXBlPT09bi5lbGVtZW50VHlwZT9vOmxTKG4udHlwZSxvKSx1LnByb3BzPXMsZj1uLnBlbmRpbmdQcm9wcyxkPXUuY29udGV4dCxpPSJvYmplY3QiPT10eXBlb2YoaT10LmNvbnRleHRUeXBlKSYmbnVsbCE9PWk/bEwoaSk6cksobixpPXJZKHQpP3JxOnJXLmN1cnJlbnQpO3ZhciBwPXQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOyhjPSJmdW5jdGlvbiI9PXR5cGVvZiBwfHwiZnVuY3Rpb24iPT10eXBlb2YgdS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSl8fCJmdW5jdGlvbiIhPXR5cGVvZiB1LlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiYiZnVuY3Rpb24iIT10eXBlb2YgdS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzfHwobyE9PWZ8fGQhPT1pKSYmbFgobix1LHIsaSksbEQ9ITEsZD1uLm1lbW9pemVkU3RhdGUsdS5zdGF0ZT1kLGxCKG4scix1LGwpO3ZhciBtPW4ubWVtb2l6ZWRTdGF0ZTtvIT09Znx8ZCE9PW18fHJRLmN1cnJlbnR8fGxEPygiZnVuY3Rpb24iPT10eXBlb2YgcCYmKGxRKG4sdCxwLHIpLG09bi5tZW1vaXplZFN0YXRlKSwocz1sRHx8bEsobix0LHMscixkLG0saSl8fCExKT8oY3x8ImZ1bmN0aW9uIiE9dHlwZW9mIHUuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUmJiJmdW5jdGlvbiIhPXR5cGVvZiB1LmNvbXBvbmVudFdpbGxVcGRhdGV8fCgiZnVuY3Rpb24iPT10eXBlb2YgdS5jb21wb25lbnRXaWxsVXBkYXRlJiZ1LmNvbXBvbmVudFdpbGxVcGRhdGUocixtLGkpLCJmdW5jdGlvbiI9PXR5cGVvZiB1LlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlJiZ1LlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlKHIsbSxpKSksImZ1bmN0aW9uIj09dHlwZW9mIHUuY29tcG9uZW50RGlkVXBkYXRlJiYobi5mbGFnc3w9NCksImZ1bmN0aW9uIj09dHlwZW9mIHUuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUmJihuLmZsYWdzfD0xMDI0KSk6KCJmdW5jdGlvbiIhPXR5cGVvZiB1LmNvbXBvbmVudERpZFVwZGF0ZXx8bz09PWUubWVtb2l6ZWRQcm9wcyYmZD09PWUubWVtb2l6ZWRTdGF0ZXx8KG4uZmxhZ3N8PTQpLCJmdW5jdGlvbiIhPXR5cGVvZiB1LmdldFNuYXBzaG90QmVmb3JlVXBkYXRlfHxvPT09ZS5tZW1vaXplZFByb3BzJiZkPT09ZS5tZW1vaXplZFN0YXRlfHwobi5mbGFnc3w9MTAyNCksbi5tZW1vaXplZFByb3BzPXIsbi5tZW1vaXplZFN0YXRlPW0pLHUucHJvcHM9cix1LnN0YXRlPW0sdS5jb250ZXh0PWkscj1zKTooImZ1bmN0aW9uIiE9dHlwZW9mIHUuY29tcG9uZW50RGlkVXBkYXRlfHxvPT09ZS5tZW1vaXplZFByb3BzJiZkPT09ZS5tZW1vaXplZFN0YXRlfHwobi5mbGFnc3w9NCksImZ1bmN0aW9uIiE9dHlwZW9mIHUuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGV8fG89PT1lLm1lbW9pemVkUHJvcHMmJmQ9PT1lLm1lbW9pemVkU3RhdGV8fChuLmZsYWdzfD0xMDI0KSxyPSExKX1yZXR1cm4gdW0oZSxuLHQscixhLGwpfWZ1bmN0aW9uIHVtKGUsbix0LHIsbCxhKXt1ZihlLG4pO3ZhciB1PTAhPSgxMjgmbi5mbGFncyk7aWYoIXImJiF1KXJldHVybiBsJiZyMChuLHQsITEpLHVfKGUsbixhKTtyPW4uc3RhdGVOb2RlLHVsLmN1cnJlbnQ9bjt2YXIgbz11JiYiZnVuY3Rpb24iIT10eXBlb2YgdC5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I/bnVsbDpyLnJlbmRlcigpO3JldHVybiBuLmZsYWdzfD0xLG51bGwhPT1lJiZ1PyhuLmNoaWxkPWwyKG4sZS5jaGlsZCxudWxsLGEpLG4uY2hpbGQ9bDIobixudWxsLG8sYSkpOnV1KGUsbixvLGEpLG4ubWVtb2l6ZWRTdGF0ZT1yLnN0YXRlLGwmJnIwKG4sdCwhMCksbi5jaGlsZH1mdW5jdGlvbiB1aChlKXt2YXIgbj1lLnN0YXRlTm9kZTtuLnBlbmRpbmdDb250ZXh0P3JHKGUsbi5wZW5kaW5nQ29udGV4dCxuLnBlbmRpbmdDb250ZXh0IT09bi5jb250ZXh0KTpuLmNvbnRleHQmJnJHKGUsbi5jb250ZXh0LCExKSxsNyhlLG4uY29udGFpbmVySW5mbyl9ZnVuY3Rpb24gdWcoZSxuLHQscixsKXtyZXR1cm4gbGIoKSxsayhsKSxuLmZsYWdzfD0yNTYsdXUoZSxuLHQsciksbi5jaGlsZH12YXIgdXY9e2RlaHlkcmF0ZWQ6bnVsbCx0cmVlQ29udGV4dDpudWxsLHJldHJ5TGFuZTowfTtmdW5jdGlvbiB1eShlKXtyZXR1cm57YmFzZUxhbmVzOmUsY2FjaGVQb29sOm51bGwsdHJhbnNpdGlvbnM6bnVsbH19ZnVuY3Rpb24gdWIoZSxuLHQpe3ZhciByLGw9bi5wZW5kaW5nUHJvcHMsYT1hci5jdXJyZW50LHU9ITEsbz0wIT0oMTI4Jm4uZmxhZ3MpO2lmKChyPW8pfHwocj0obnVsbD09PWV8fG51bGwhPT1lLm1lbW9pemVkU3RhdGUpJiYwIT0oMiZhKSkscj8odT0hMCxuLmZsYWdzJj0tMTI5KToobnVsbD09PWV8fG51bGwhPT1lLm1lbW9pemVkU3RhdGUpJiYoYXw9MSksckIoYXIsMSZhKSxudWxsPT09ZSlyZXR1cm4obGgobiksbnVsbCE9PShlPW4ubWVtb2l6ZWRTdGF0ZSkmJm51bGwhPT0oZT1lLmRlaHlkcmF0ZWQpKT8oMD09KDEmbi5tb2RlKT9uLmxhbmVzPTE6IiQhIj09PWUuZGF0YT9uLmxhbmVzPTg6bi5sYW5lcz0xMDczNzQxODI0LG51bGwpOihvPWwuY2hpbGRyZW4sZT1sLmZhbGxiYWNrLHU/KGw9bi5tb2RlLHU9bi5jaGlsZCxvPXttb2RlOiJoaWRkZW4iLGNoaWxkcmVuOm99LDA9PSgxJmwpJiZudWxsIT09dT8odS5jaGlsZExhbmVzPTAsdS5wZW5kaW5nUHJvcHM9byk6dT1vRyhvLGwsMCxudWxsKSxlPW9YKGUsbCx0LG51bGwpLHUucmV0dXJuPW4sZS5yZXR1cm49bix1LnNpYmxpbmc9ZSxuLmNoaWxkPXUsbi5jaGlsZC5tZW1vaXplZFN0YXRlPXV5KHQpLG4ubWVtb2l6ZWRTdGF0ZT11dixlKTp1ayhuLG8pKTtpZihudWxsIT09KGE9ZS5tZW1vaXplZFN0YXRlKSYmbnVsbCE9PShyPWEuZGVoeWRyYXRlZCkpcmV0dXJuIGZ1bmN0aW9uKGUsbix0LHIsbCxhLHUpe2lmKHQpcmV0dXJuIDI1NiZuLmZsYWdzPyhuLmZsYWdzJj0tMjU3LHV3KGUsbix1LHI9YTYoRXJyb3IoZig0MjIpKSkpKTpudWxsIT09bi5tZW1vaXplZFN0YXRlPyhuLmNoaWxkPWUuY2hpbGQsbi5mbGFnc3w9MTI4LG51bGwpOihhPXIuZmFsbGJhY2ssbD1uLm1vZGUscj1vRyh7bW9kZToidmlzaWJsZSIsY2hpbGRyZW46ci5jaGlsZHJlbn0sbCwwLG51bGwpLGE9b1goYSxsLHUsbnVsbCksYS5mbGFnc3w9MixyLnJldHVybj1uLGEucmV0dXJuPW4sci5zaWJsaW5nPWEsbi5jaGlsZD1yLDAhPSgxJm4ubW9kZSkmJmwyKG4sZS5jaGlsZCxudWxsLHUpLG4uY2hpbGQubWVtb2l6ZWRTdGF0ZT11eSh1KSxuLm1lbW9pemVkU3RhdGU9dXYsYSk7aWYoMD09KDEmbi5tb2RlKSlyZXR1cm4gdXcoZSxuLHUsbnVsbCk7aWYoIiQhIj09PWwuZGF0YSl7aWYocj1sLm5leHRTaWJsaW5nJiZsLm5leHRTaWJsaW5nLmRhdGFzZXQpdmFyIG89ci5kZ3N0O3JldHVybiByPW8scj1hNihhPUVycm9yKGYoNDE5KSkscix2b2lkIDApLHV3KGUsbix1LHIpfWlmKG89MCE9KHUmZS5jaGlsZExhbmVzKSx1YXx8byl7aWYobnVsbCE9PShyPXUzKSl7c3dpdGNoKHUmLXUpe2Nhc2UgNDpsPTI7YnJlYWs7Y2FzZSAxNjpsPTg7YnJlYWs7Y2FzZSA2NDpjYXNlIDEyODpjYXNlIDI1NjpjYXNlIDUxMjpjYXNlIDEwMjQ6Y2FzZSAyMDQ4OmNhc2UgNDA5NjpjYXNlIDgxOTI6Y2FzZSAxNjM4NDpjYXNlIDMyNzY4OmNhc2UgNjU1MzY6Y2FzZSAxMzEwNzI6Y2FzZSAyNjIxNDQ6Y2FzZSA1MjQyODg6Y2FzZSAxMDQ4NTc2OmNhc2UgMjA5NzE1MjpjYXNlIDQxOTQzMDQ6Y2FzZSA4Mzg4NjA4OmNhc2UgMTY3NzcyMTY6Y2FzZSAzMzU1NDQzMjpjYXNlIDY3MTA4ODY0Omw9MzI7YnJlYWs7Y2FzZSA1MzY4NzA5MTI6bD0yNjg0MzU0NTY7YnJlYWs7ZGVmYXVsdDpsPTB9MCE9PShsPTAhPShsJihyLnN1c3BlbmRlZExhbmVzfHUpKT8wOmwpJiZsIT09YS5yZXRyeUxhbmUmJihhLnJldHJ5TGFuZT1sLGxPKGUsbCksb2socixlLGwsLTEpKX1yZXR1cm4gb00oKSx1dyhlLG4sdSxyPWE2KEVycm9yKGYoNDIxKSkpKX1yZXR1cm4iJD8iPT09bC5kYXRhPyhuLmZsYWdzfD0xMjgsbi5jaGlsZD1lLmNoaWxkLG49b0IuYmluZChudWxsLGUpLGwuX3JlYWN0UmV0cnk9bixudWxsKTooZT1hLnRyZWVDb250ZXh0LGxzPXJfKGwubmV4dFNpYmxpbmcpLGxpPW4sbGM9ITAsbGY9bnVsbCxudWxsIT09ZSYmKHI3W2xlKytdPWx0LHI3W2xlKytdPWxyLHI3W2xlKytdPWxuLGx0PWUuaWQsbHI9ZS5vdmVyZmxvdyxsbj1uKSxuPXVrKG4sci5jaGlsZHJlbiksbi5mbGFnc3w9NDA5NixuKX0oZSxuLG8sbCxyLGEsdCk7aWYodSl7dT1sLmZhbGxiYWNrLG89bi5tb2RlLHI9KGE9ZS5jaGlsZCkuc2libGluZzt2YXIgaT17bW9kZToiaGlkZGVuIixjaGlsZHJlbjpsLmNoaWxkcmVufTtyZXR1cm4gMD09KDEmbykmJm4uY2hpbGQhPT1hPygobD1uLmNoaWxkKS5jaGlsZExhbmVzPTAsbC5wZW5kaW5nUHJvcHM9aSxuLmRlbGV0aW9ucz1udWxsKToobD1vSyhhLGkpKS5zdWJ0cmVlRmxhZ3M9MTQ2ODAwNjQmYS5zdWJ0cmVlRmxhZ3MsbnVsbCE9PXI/dT1vSyhyLHUpOih1PW9YKHUsbyx0LG51bGwpLHUuZmxhZ3N8PTIpLHUucmV0dXJuPW4sbC5yZXR1cm49bixsLnNpYmxpbmc9dSxuLmNoaWxkPWwsbD11LHU9bi5jaGlsZCxvPW51bGw9PT0obz1lLmNoaWxkLm1lbW9pemVkU3RhdGUpP3V5KHQpOntiYXNlTGFuZXM6by5iYXNlTGFuZXN8dCxjYWNoZVBvb2w6bnVsbCx0cmFuc2l0aW9uczpvLnRyYW5zaXRpb25zfSx1Lm1lbW9pemVkU3RhdGU9byx1LmNoaWxkTGFuZXM9ZS5jaGlsZExhbmVzJn50LG4ubWVtb2l6ZWRTdGF0ZT11dixsfXJldHVybiBlPSh1PWUuY2hpbGQpLnNpYmxpbmcsbD1vSyh1LHttb2RlOiJ2aXNpYmxlIixjaGlsZHJlbjpsLmNoaWxkcmVufSksMD09KDEmbi5tb2RlKSYmKGwubGFuZXM9dCksbC5yZXR1cm49bixsLnNpYmxpbmc9bnVsbCxudWxsIT09ZSYmKG51bGw9PT0odD1uLmRlbGV0aW9ucyk/KG4uZGVsZXRpb25zPVtlXSxuLmZsYWdzfD0xNik6dC5wdXNoKGUpKSxuLmNoaWxkPWwsbi5tZW1vaXplZFN0YXRlPW51bGwsbH1mdW5jdGlvbiB1ayhlLG4pe3JldHVybihuPW9HKHttb2RlOiJ2aXNpYmxlIixjaGlsZHJlbjpufSxlLm1vZGUsMCxudWxsKSkucmV0dXJuPWUsZS5jaGlsZD1ufWZ1bmN0aW9uIHV3KGUsbix0LHIpe3JldHVybiBudWxsIT09ciYmbGsociksbDIobixlLmNoaWxkLG51bGwsdCksZT11ayhuLG4ucGVuZGluZ1Byb3BzLmNoaWxkcmVuKSxlLmZsYWdzfD0yLG4ubWVtb2l6ZWRTdGF0ZT1udWxsLGV9ZnVuY3Rpb24gdVMoZSxuLHQpe2UubGFuZXN8PW47dmFyIHI9ZS5hbHRlcm5hdGU7bnVsbCE9PXImJihyLmxhbmVzfD1uKSxseihlLnJldHVybixuLHQpfWZ1bmN0aW9uIHV4KGUsbix0LHIsbCl7dmFyIGE9ZS5tZW1vaXplZFN0YXRlO251bGw9PT1hP2UubWVtb2l6ZWRTdGF0ZT17aXNCYWNrd2FyZHM6bixyZW5kZXJpbmc6bnVsbCxyZW5kZXJpbmdTdGFydFRpbWU6MCxsYXN0OnIsdGFpbDp0LHRhaWxNb2RlOmx9OihhLmlzQmFja3dhcmRzPW4sYS5yZW5kZXJpbmc9bnVsbCxhLnJlbmRlcmluZ1N0YXJ0VGltZT0wLGEubGFzdD1yLGEudGFpbD10LGEudGFpbE1vZGU9bCl9ZnVuY3Rpb24gdUUoZSxuLHQpe3ZhciByPW4ucGVuZGluZ1Byb3BzLGw9ci5yZXZlYWxPcmRlcixhPXIudGFpbDtpZih1dShlLG4sci5jaGlsZHJlbix0KSwwIT0oMiYocj1hci5jdXJyZW50KSkpcj0xJnJ8MixuLmZsYWdzfD0xMjg7ZWxzZXtpZihudWxsIT09ZSYmMCE9KDEyOCZlLmZsYWdzKSllOmZvcihlPW4uY2hpbGQ7bnVsbCE9PWU7KXtpZigxMz09PWUudGFnKW51bGwhPT1lLm1lbW9pemVkU3RhdGUmJnVTKGUsdCxuKTtlbHNlIGlmKDE5PT09ZS50YWcpdVMoZSx0LG4pO2Vsc2UgaWYobnVsbCE9PWUuY2hpbGQpe2UuY2hpbGQucmV0dXJuPWUsZT1lLmNoaWxkO2NvbnRpbnVlfWlmKGU9PT1uKWJyZWFrO2Zvcig7bnVsbD09PWUuc2libGluZzspe2lmKG51bGw9PT1lLnJldHVybnx8ZS5yZXR1cm49PT1uKWJyZWFrIGU7ZT1lLnJldHVybn1lLnNpYmxpbmcucmV0dXJuPWUucmV0dXJuLGU9ZS5zaWJsaW5nfXImPTF9aWYockIoYXIsciksMD09KDEmbi5tb2RlKSluLm1lbW9pemVkU3RhdGU9bnVsbDtlbHNlIHN3aXRjaChsKXtjYXNlImZvcndhcmRzIjpmb3IobD1udWxsLHQ9bi5jaGlsZDtudWxsIT09dDspbnVsbCE9PShlPXQuYWx0ZXJuYXRlKSYmbnVsbD09PWFsKGUpJiYobD10KSx0PXQuc2libGluZztudWxsPT09KHQ9bCk/KGw9bi5jaGlsZCxuLmNoaWxkPW51bGwpOihsPXQuc2libGluZyx0LnNpYmxpbmc9bnVsbCksdXgobiwhMSxsLHQsYSk7YnJlYWs7Y2FzZSJiYWNrd2FyZHMiOmZvcih0PW51bGwsbD1uLmNoaWxkLG4uY2hpbGQ9bnVsbDtudWxsIT09bDspe2lmKG51bGwhPT0oZT1sLmFsdGVybmF0ZSkmJm51bGw9PT1hbChlKSl7bi5jaGlsZD1sO2JyZWFrfWU9bC5zaWJsaW5nLGwuc2libGluZz10LHQ9bCxsPWV9dXgobiwhMCx0LG51bGwsYSk7YnJlYWs7Y2FzZSJ0b2dldGhlciI6dXgobiwhMSxudWxsLG51bGwsdm9pZCAwKTticmVhaztkZWZhdWx0Om4ubWVtb2l6ZWRTdGF0ZT1udWxsfXJldHVybiBuLmNoaWxkfWZ1bmN0aW9uIHVDKGUsbil7MD09KDEmbi5tb2RlKSYmbnVsbCE9PWUmJihlLmFsdGVybmF0ZT1udWxsLG4uYWx0ZXJuYXRlPW51bGwsbi5mbGFnc3w9Mil9ZnVuY3Rpb24gdV8oZSxuLHQpe2lmKG51bGwhPT1lJiYobi5kZXBlbmRlbmNpZXM9ZS5kZXBlbmRlbmNpZXMpLG9lfD1uLmxhbmVzLDA9PSh0Jm4uY2hpbGRMYW5lcykpcmV0dXJuIG51bGw7aWYobnVsbCE9PWUmJm4uY2hpbGQhPT1lLmNoaWxkKXRocm93IEVycm9yKGYoMTUzKSk7aWYobnVsbCE9PW4uY2hpbGQpe2Zvcih0PW9LKGU9bi5jaGlsZCxlLnBlbmRpbmdQcm9wcyksbi5jaGlsZD10LHQucmV0dXJuPW47bnVsbCE9PWUuc2libGluZzspZT1lLnNpYmxpbmcsKHQ9dC5zaWJsaW5nPW9LKGUsZS5wZW5kaW5nUHJvcHMpKS5yZXR1cm49bjt0LnNpYmxpbmc9bnVsbH1yZXR1cm4gbi5jaGlsZH1mdW5jdGlvbiB1UChlLG4pe2lmKCFsYylzd2l0Y2goZS50YWlsTW9kZSl7Y2FzZSJoaWRkZW4iOm49ZS50YWlsO2Zvcih2YXIgdD1udWxsO251bGwhPT1uOyludWxsIT09bi5hbHRlcm5hdGUmJih0PW4pLG49bi5zaWJsaW5nO251bGw9PT10P2UudGFpbD1udWxsOnQuc2libGluZz1udWxsO2JyZWFrO2Nhc2UiY29sbGFwc2VkIjp0PWUudGFpbDtmb3IodmFyIHI9bnVsbDtudWxsIT09dDspbnVsbCE9PXQuYWx0ZXJuYXRlJiYocj10KSx0PXQuc2libGluZztudWxsPT09cj9ufHxudWxsPT09ZS50YWlsP2UudGFpbD1udWxsOmUudGFpbC5zaWJsaW5nPW51bGw6ci5zaWJsaW5nPW51bGx9fWZ1bmN0aW9uIHVOKGUpe3ZhciBuPW51bGwhPT1lLmFsdGVybmF0ZSYmZS5hbHRlcm5hdGUuY2hpbGQ9PT1lLmNoaWxkLHQ9MCxyPTA7aWYobilmb3IodmFyIGw9ZS5jaGlsZDtudWxsIT09bDspdHw9bC5sYW5lc3xsLmNoaWxkTGFuZXMscnw9MTQ2ODAwNjQmbC5zdWJ0cmVlRmxhZ3Mscnw9MTQ2ODAwNjQmbC5mbGFncyxsLnJldHVybj1lLGw9bC5zaWJsaW5nO2Vsc2UgZm9yKGw9ZS5jaGlsZDtudWxsIT09bDspdHw9bC5sYW5lc3xsLmNoaWxkTGFuZXMscnw9bC5zdWJ0cmVlRmxhZ3Mscnw9bC5mbGFncyxsLnJldHVybj1lLGw9bC5zaWJsaW5nO3JldHVybiBlLnN1YnRyZWVGbGFnc3w9cixlLmNoaWxkTGFuZXM9dCxufWw9ZnVuY3Rpb24oZSxuKXtmb3IodmFyIHQ9bi5jaGlsZDtudWxsIT09dDspe2lmKDU9PT10LnRhZ3x8Nj09PXQudGFnKWUuYXBwZW5kQ2hpbGQodC5zdGF0ZU5vZGUpO2Vsc2UgaWYoNCE9PXQudGFnJiZudWxsIT09dC5jaGlsZCl7dC5jaGlsZC5yZXR1cm49dCx0PXQuY2hpbGQ7Y29udGludWV9aWYodD09PW4pYnJlYWs7Zm9yKDtudWxsPT09dC5zaWJsaW5nOyl7aWYobnVsbD09PXQucmV0dXJufHx0LnJldHVybj09PW4pcmV0dXJuO3Q9dC5yZXR1cm59dC5zaWJsaW5nLnJldHVybj10LnJldHVybix0PXQuc2libGluZ319LGE9ZnVuY3Rpb24oKXt9LHU9ZnVuY3Rpb24oZSxuLHQscil7dmFyIGw9ZS5tZW1vaXplZFByb3BzO2lmKGwhPT1yKXtlPW4uc3RhdGVOb2RlLGw5KGw4LmN1cnJlbnQpO3ZhciBhLHU9bnVsbDtzd2l0Y2godCl7Y2FzZSJpbnB1dCI6bD1aKGUsbCkscj1aKGUsciksdT1bXTticmVhaztjYXNlInNlbGVjdCI6bD1CKHt9LGwse3ZhbHVlOnZvaWQgMH0pLHI9Qih7fSxyLHt2YWx1ZTp2b2lkIDB9KSx1PVtdO2JyZWFrO2Nhc2UidGV4dGFyZWEiOmw9ZXUoZSxsKSxyPWV1KGUsciksdT1bXTticmVhaztkZWZhdWx0OiJmdW5jdGlvbiIhPXR5cGVvZiBsLm9uQ2xpY2smJiJmdW5jdGlvbiI9PXR5cGVvZiByLm9uQ2xpY2smJihlLm9uY2xpY2s9cmcpfWZvcihzIGluIGV3KHQsciksdD1udWxsLGwpaWYoIXIuaGFzT3duUHJvcGVydHkocykmJmwuaGFzT3duUHJvcGVydHkocykmJm51bGwhPWxbc10pe2lmKCJzdHlsZSI9PT1zKXt2YXIgbz1sW3NdO2ZvcihhIGluIG8pby5oYXNPd25Qcm9wZXJ0eShhKSYmKHR8fCh0PXt9KSx0W2FdPSIiKX1lbHNlImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiE9PXMmJiJjaGlsZHJlbiIhPT1zJiYic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIiE9PXMmJiJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmciIT09cyYmImF1dG9Gb2N1cyIhPT1zJiYocC5oYXNPd25Qcm9wZXJ0eShzKT91fHwodT1bXSk6KHU9dXx8W10pLnB1c2gocyxudWxsKSl9Zm9yKHMgaW4gcil7dmFyIGk9cltzXTtpZihvPW51bGwhPWw/bFtzXTp2b2lkIDAsci5oYXNPd25Qcm9wZXJ0eShzKSYmaSE9PW8mJihudWxsIT1pfHxudWxsIT1vKSl7aWYoInN0eWxlIj09PXMpe2lmKG8pe2ZvcihhIGluIG8pIW8uaGFzT3duUHJvcGVydHkoYSl8fGkmJmkuaGFzT3duUHJvcGVydHkoYSl8fCh0fHwodD17fSksdFthXT0iIik7Zm9yKGEgaW4gaSlpLmhhc093blByb3BlcnR5KGEpJiZvW2FdIT09aVthXSYmKHR8fCh0PXt9KSx0W2FdPWlbYV0pfWVsc2UgdHx8KHV8fCh1PVtdKSx1LnB1c2gocyx0KSksdD1pfWVsc2UiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiPT09cz8oaT1pP2kuX19odG1sOnZvaWQgMCxvPW8/by5fX2h0bWw6dm9pZCAwLG51bGwhPWkmJm8hPT1pJiYodT11fHxbXSkucHVzaChzLGkpKToiY2hpbGRyZW4iPT09cz8ic3RyaW5nIiE9dHlwZW9mIGkmJiJudW1iZXIiIT10eXBlb2YgaXx8KHU9dXx8W10pLnB1c2gocywiIitpKToic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIiE9PXMmJiJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmciIT09cyYmKHAuaGFzT3duUHJvcGVydHkocyk/KG51bGwhPWkmJiJvblNjcm9sbCI9PT1zJiZydCgic2Nyb2xsIixlKSx1fHxvPT09aXx8KHU9W10pKToodT11fHxbXSkucHVzaChzLGkpKX19dCYmKHU9dXx8W10pLnB1c2goInN0eWxlIix0KTt2YXIgcz11OyhuLnVwZGF0ZVF1ZXVlPXMpJiYobi5mbGFnc3w9NCl9fSxvPWZ1bmN0aW9uKGUsbix0LHIpe3QhPT1yJiYobi5mbGFnc3w9NCl9O3ZhciB1ej0hMSx1VD0hMSx1TD0iZnVuY3Rpb24iPT10eXBlb2YgV2Vha1NldD9XZWFrU2V0OlNldCx1Uj1udWxsO2Z1bmN0aW9uIHVNKGUsbil7dmFyIHQ9ZS5yZWY7aWYobnVsbCE9PXQpe2lmKCJmdW5jdGlvbiI9PXR5cGVvZiB0KXRyeXt0KG51bGwpfWNhdGNoKHQpe29BKGUsbix0KX1lbHNlIHQuY3VycmVudD1udWxsfX1mdW5jdGlvbiB1RihlLG4sdCl7dHJ5e3QoKX1jYXRjaCh0KXtvQShlLG4sdCl9fXZhciB1Tz0hMTtmdW5jdGlvbiB1RChlLG4sdCl7dmFyIHI9bi51cGRhdGVRdWV1ZTtpZihudWxsIT09KHI9bnVsbCE9PXI/ci5sYXN0RWZmZWN0Om51bGwpKXt2YXIgbD1yPXIubmV4dDtkb3tpZigobC50YWcmZSk9PT1lKXt2YXIgYT1sLmRlc3Ryb3k7bC5kZXN0cm95PXZvaWQgMCx2b2lkIDAhPT1hJiZ1RihuLHQsYSl9bD1sLm5leHR9d2hpbGUobCE9PXIpfX1mdW5jdGlvbiB1SShlLG4pe2lmKG51bGwhPT0obj1udWxsIT09KG49bi51cGRhdGVRdWV1ZSk/bi5sYXN0RWZmZWN0Om51bGwpKXt2YXIgdD1uPW4ubmV4dDtkb3tpZigodC50YWcmZSk9PT1lKXt2YXIgcj10LmNyZWF0ZTt0LmRlc3Ryb3k9cigpfXQ9dC5uZXh0fXdoaWxlKHQhPT1uKX19ZnVuY3Rpb24gdVUoZSl7dmFyIG49ZS5yZWY7aWYobnVsbCE9PW4pe3ZhciB0PWUuc3RhdGVOb2RlO2UudGFnLGU9dCwiZnVuY3Rpb24iPT10eXBlb2Ygbj9uKGUpOm4uY3VycmVudD1lfX1mdW5jdGlvbiB1VihlKXtyZXR1cm4gNT09PWUudGFnfHwzPT09ZS50YWd8fDQ9PT1lLnRhZ31mdW5jdGlvbiB1QShlKXtlOmZvcig7Oyl7Zm9yKDtudWxsPT09ZS5zaWJsaW5nOyl7aWYobnVsbD09PWUucmV0dXJufHx1VihlLnJldHVybikpcmV0dXJuIG51bGw7ZT1lLnJldHVybn1mb3IoZS5zaWJsaW5nLnJldHVybj1lLnJldHVybixlPWUuc2libGluZzs1IT09ZS50YWcmJjYhPT1lLnRhZyYmMTghPT1lLnRhZzspe2lmKDImZS5mbGFnc3x8bnVsbD09PWUuY2hpbGR8fDQ9PT1lLnRhZyljb250aW51ZSBlO2UuY2hpbGQucmV0dXJuPWUsZT1lLmNoaWxkfWlmKCEoMiZlLmZsYWdzKSlyZXR1cm4gZS5zdGF0ZU5vZGV9fXZhciB1JD1udWxsLHVqPSExO2Z1bmN0aW9uIHVCKGUsbix0KXtmb3IodD10LmNoaWxkO251bGwhPT10Oyl1SChlLG4sdCksdD10LnNpYmxpbmd9ZnVuY3Rpb24gdUgoZSxuLHQpe2lmKGU1JiYiZnVuY3Rpb24iPT10eXBlb2YgZTUub25Db21taXRGaWJlclVubW91bnQpdHJ5e2U1Lm9uQ29tbWl0RmliZXJVbm1vdW50KGU2LHQpfWNhdGNoKGUpe31zd2l0Y2godC50YWcpe2Nhc2UgNTp1VHx8dU0odCxuKTtjYXNlIDY6dmFyIHI9dSQsbD11ajt1JD1udWxsLHVCKGUsbix0KSx1JD1yLHVqPWwsbnVsbCE9PXUkJiYodWo/KGU9dSQsdD10LnN0YXRlTm9kZSw4PT09ZS5ub2RlVHlwZT9lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodCk6ZS5yZW1vdmVDaGlsZCh0KSk6dSQucmVtb3ZlQ2hpbGQodC5zdGF0ZU5vZGUpKTticmVhaztjYXNlIDE4Om51bGwhPT11JCYmKHVqPyhlPXUkLHQ9dC5zdGF0ZU5vZGUsOD09PWUubm9kZVR5cGU/ckMoZS5wYXJlbnROb2RlLHQpOjE9PT1lLm5vZGVUeXBlJiZyQyhlLHQpLG5NKGUpKTpyQyh1JCx0LnN0YXRlTm9kZSkpO2JyZWFrO2Nhc2UgNDpyPXUkLGw9dWosdSQ9dC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyx1aj0hMCx1QihlLG4sdCksdSQ9cix1aj1sO2JyZWFrO2Nhc2UgMDpjYXNlIDExOmNhc2UgMTQ6Y2FzZSAxNTppZighdVQmJm51bGwhPT0ocj10LnVwZGF0ZVF1ZXVlKSYmbnVsbCE9PShyPXIubGFzdEVmZmVjdCkpe2w9cj1yLm5leHQ7ZG97dmFyIGE9bCx1PWEuZGVzdHJveTthPWEudGFnLHZvaWQgMCE9PXUmJigwIT0oMiZhKT91Rih0LG4sdSk6MCE9KDQmYSkmJnVGKHQsbix1KSksbD1sLm5leHR9d2hpbGUobCE9PXIpfXVCKGUsbix0KTticmVhaztjYXNlIDE6aWYoIXVUJiYodU0odCxuKSwiZnVuY3Rpb24iPT10eXBlb2Yocj10LnN0YXRlTm9kZSkuY29tcG9uZW50V2lsbFVubW91bnQpKXRyeXtyLnByb3BzPXQubWVtb2l6ZWRQcm9wcyxyLnN0YXRlPXQubWVtb2l6ZWRTdGF0ZSxyLmNvbXBvbmVudFdpbGxVbm1vdW50KCl9Y2F0Y2goZSl7b0EodCxuLGUpfXVCKGUsbix0KTticmVhaztjYXNlIDIxOmRlZmF1bHQ6dUIoZSxuLHQpO2JyZWFrO2Nhc2UgMjI6MSZ0Lm1vZGU/KHVUPShyPXVUKXx8bnVsbCE9PXQubWVtb2l6ZWRTdGF0ZSx1QihlLG4sdCksdVQ9cik6dUIoZSxuLHQpfX1mdW5jdGlvbiB1VyhlKXt2YXIgbj1lLnVwZGF0ZVF1ZXVlO2lmKG51bGwhPT1uKXtlLnVwZGF0ZVF1ZXVlPW51bGw7dmFyIHQ9ZS5zdGF0ZU5vZGU7bnVsbD09PXQmJih0PWUuc3RhdGVOb2RlPW5ldyB1TCksbi5mb3JFYWNoKGZ1bmN0aW9uKG4pe3ZhciByPW9ILmJpbmQobnVsbCxlLG4pO3QuaGFzKG4pfHwodC5hZGQobiksbi50aGVuKHIscikpfSl9fWZ1bmN0aW9uIHVRKGUsbil7dmFyIHQ9bi5kZWxldGlvbnM7aWYobnVsbCE9PXQpZm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBsPXRbcl07dHJ5e3ZhciBhPW4sdT1hO2U6Zm9yKDtudWxsIT09dTspe3N3aXRjaCh1LnRhZyl7Y2FzZSA1OnUkPXUuc3RhdGVOb2RlLHVqPSExO2JyZWFrIGU7Y2FzZSAzOmNhc2UgNDp1JD11LnN0YXRlTm9kZS5jb250YWluZXJJbmZvLHVqPSEwO2JyZWFrIGV9dT11LnJldHVybn1pZihudWxsPT09dSQpdGhyb3cgRXJyb3IoZigxNjApKTt1SChlLGEsbCksdSQ9bnVsbCx1aj0hMTt2YXIgbz1sLmFsdGVybmF0ZTtudWxsIT09byYmKG8ucmV0dXJuPW51bGwpLGwucmV0dXJuPW51bGx9Y2F0Y2goZSl7b0EobCxuLGUpfX1pZigxMjg1NCZuLnN1YnRyZWVGbGFncylmb3Iobj1uLmNoaWxkO251bGwhPT1uOyl1cShuLGUpLG49bi5zaWJsaW5nfWZ1bmN0aW9uIHVxKGUsbil7dmFyIHQ9ZS5hbHRlcm5hdGUscj1lLmZsYWdzO3N3aXRjaChlLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNDpjYXNlIDE1OmlmKHVRKG4sZSksdUsoZSksNCZyKXt0cnl7dUQoMyxlLGUucmV0dXJuKSx1SSgzLGUpfWNhdGNoKG4pe29BKGUsZS5yZXR1cm4sbil9dHJ5e3VEKDUsZSxlLnJldHVybil9Y2F0Y2gobil7b0EoZSxlLnJldHVybixuKX19YnJlYWs7Y2FzZSAxOnVRKG4sZSksdUsoZSksNTEyJnImJm51bGwhPT10JiZ1TSh0LHQucmV0dXJuKTticmVhaztjYXNlIDU6aWYodVEobixlKSx1SyhlKSw1MTImciYmbnVsbCE9PXQmJnVNKHQsdC5yZXR1cm4pLDMyJmUuZmxhZ3Mpe3ZhciBsPWUuc3RhdGVOb2RlO3RyeXtlaChsLCIiKX1jYXRjaChuKXtvQShlLGUucmV0dXJuLG4pfX1pZig0JnImJm51bGwhPShsPWUuc3RhdGVOb2RlKSl7dmFyIGE9ZS5tZW1vaXplZFByb3BzLHU9bnVsbCE9PXQ/dC5tZW1vaXplZFByb3BzOmEsbz1lLnR5cGUsaT1lLnVwZGF0ZVF1ZXVlO2lmKGUudXBkYXRlUXVldWU9bnVsbCxudWxsIT09aSl0cnl7ImlucHV0Ij09PW8mJiJyYWRpbyI9PT1hLnR5cGUmJm51bGwhPWEubmFtZSYmZWUobCxhKSxlUyhvLHUpO3ZhciBzPWVTKG8sYSk7Zm9yKHU9MDt1PGkubGVuZ3RoO3UrPTIpe3ZhciBjPWlbdV0sZD1pW3UrMV07InN0eWxlIj09PWM/ZWIobCxkKToiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiPT09Yz9lbShsLGQpOiJjaGlsZHJlbiI9PT1jP2VoKGwsZCk6QyhsLGMsZCxzKX1zd2l0Y2gobyl7Y2FzZSJpbnB1dCI6ZW4obCxhKTticmVhaztjYXNlInRleHRhcmVhIjplaShsLGEpO2JyZWFrO2Nhc2Uic2VsZWN0Ijp2YXIgcD1sLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU7bC5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlPSEhYS5tdWx0aXBsZTt2YXIgbT1hLnZhbHVlO251bGwhPW0/ZWEobCwhIWEubXVsdGlwbGUsbSwhMSk6ISFhLm11bHRpcGxlIT09cCYmKG51bGwhPWEuZGVmYXVsdFZhbHVlP2VhKGwsISFhLm11bHRpcGxlLGEuZGVmYXVsdFZhbHVlLCEwKTplYShsLCEhYS5tdWx0aXBsZSxhLm11bHRpcGxlP1tdOiIiLCExKSl9bFtyVF09YX1jYXRjaChuKXtvQShlLGUucmV0dXJuLG4pfX1icmVhaztjYXNlIDY6aWYodVEobixlKSx1SyhlKSw0JnIpe2lmKG51bGw9PT1lLnN0YXRlTm9kZSl0aHJvdyBFcnJvcihmKDE2MikpO2w9ZS5zdGF0ZU5vZGUsYT1lLm1lbW9pemVkUHJvcHM7dHJ5e2wubm9kZVZhbHVlPWF9Y2F0Y2gobil7b0EoZSxlLnJldHVybixuKX19YnJlYWs7Y2FzZSAzOmlmKHVRKG4sZSksdUsoZSksNCZyJiZudWxsIT09dCYmdC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZCl0cnl7bk0obi5jb250YWluZXJJbmZvKX1jYXRjaChuKXtvQShlLGUucmV0dXJuLG4pfWJyZWFrO2Nhc2UgNDpkZWZhdWx0OnVRKG4sZSksdUsoZSk7YnJlYWs7Y2FzZSAxMzp1UShuLGUpLHVLKGUpLDgxOTImKGw9ZS5jaGlsZCkuZmxhZ3MmJihhPW51bGwhPT1sLm1lbW9pemVkU3RhdGUsbC5zdGF0ZU5vZGUuaXNIaWRkZW49YSxhJiYobnVsbD09PWwuYWx0ZXJuYXRlfHxudWxsPT09bC5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZSkmJihvYT1lSigpKSksNCZyJiZ1VyhlKTticmVhaztjYXNlIDIyOmlmKGM9bnVsbCE9PXQmJm51bGwhPT10Lm1lbW9pemVkU3RhdGUsMSZlLm1vZGU/KHVUPShzPXVUKXx8Yyx1UShuLGUpLHVUPXMpOnVRKG4sZSksdUsoZSksODE5MiZyKXtpZihzPW51bGwhPT1lLm1lbW9pemVkU3RhdGUsKGUuc3RhdGVOb2RlLmlzSGlkZGVuPXMpJiYhYyYmMCE9KDEmZS5tb2RlKSlmb3IodVI9ZSxjPWUuY2hpbGQ7bnVsbCE9PWM7KXtmb3IoZD11Uj1jO251bGwhPT11Ujspe3N3aXRjaChtPShwPXVSKS5jaGlsZCxwLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNDpjYXNlIDE1OnVEKDQscCxwLnJldHVybik7YnJlYWs7Y2FzZSAxOnVNKHAscC5yZXR1cm4pO3ZhciBoPXAuc3RhdGVOb2RlO2lmKCJmdW5jdGlvbiI9PXR5cGVvZiBoLmNvbXBvbmVudFdpbGxVbm1vdW50KXtyPXAsdD1wLnJldHVybjt0cnl7bj1yLGgucHJvcHM9bi5tZW1vaXplZFByb3BzLGguc3RhdGU9bi5tZW1vaXplZFN0YXRlLGguY29tcG9uZW50V2lsbFVubW91bnQoKX1jYXRjaChlKXtvQShyLHQsZSl9fWJyZWFrO2Nhc2UgNTp1TShwLHAucmV0dXJuKTticmVhaztjYXNlIDIyOmlmKG51bGwhPT1wLm1lbW9pemVkU3RhdGUpe3VYKGQpO2NvbnRpbnVlfX1udWxsIT09bT8obS5yZXR1cm49cCx1Uj1tKTp1WChkKX1jPWMuc2libGluZ31lOmZvcihjPW51bGwsZD1lOzspe2lmKDU9PT1kLnRhZyl7aWYobnVsbD09PWMpe2M9ZDt0cnl7bD1kLnN0YXRlTm9kZSxzPyhhPWwuc3R5bGUsImZ1bmN0aW9uIj09dHlwZW9mIGEuc2V0UHJvcGVydHk/YS5zZXRQcm9wZXJ0eSgiZGlzcGxheSIsIm5vbmUiLCJpbXBvcnRhbnQiKTphLmRpc3BsYXk9Im5vbmUiKToobz1kLnN0YXRlTm9kZSx1PW51bGwhPShpPWQubWVtb2l6ZWRQcm9wcy5zdHlsZSkmJmkuaGFzT3duUHJvcGVydHkoImRpc3BsYXkiKT9pLmRpc3BsYXk6bnVsbCxvLnN0eWxlLmRpc3BsYXk9ZXkoImRpc3BsYXkiLHUpKX1jYXRjaChuKXtvQShlLGUucmV0dXJuLG4pfX19ZWxzZSBpZig2PT09ZC50YWcpe2lmKG51bGw9PT1jKXRyeXtkLnN0YXRlTm9kZS5ub2RlVmFsdWU9cz8iIjpkLm1lbW9pemVkUHJvcHN9Y2F0Y2gobil7b0EoZSxlLnJldHVybixuKX19ZWxzZSBpZigoMjIhPT1kLnRhZyYmMjMhPT1kLnRhZ3x8bnVsbD09PWQubWVtb2l6ZWRTdGF0ZXx8ZD09PWUpJiZudWxsIT09ZC5jaGlsZCl7ZC5jaGlsZC5yZXR1cm49ZCxkPWQuY2hpbGQ7Y29udGludWV9aWYoZD09PWUpYnJlYWs7Zm9yKDtudWxsPT09ZC5zaWJsaW5nOyl7aWYobnVsbD09PWQucmV0dXJufHxkLnJldHVybj09PWUpYnJlYWsgZTtjPT09ZCYmKGM9bnVsbCksZD1kLnJldHVybn1jPT09ZCYmKGM9bnVsbCksZC5zaWJsaW5nLnJldHVybj1kLnJldHVybixkPWQuc2libGluZ319YnJlYWs7Y2FzZSAxOTp1UShuLGUpLHVLKGUpLDQmciYmdVcoZSk7Y2FzZSAyMTp9fWZ1bmN0aW9uIHVLKGUpe3ZhciBuPWUuZmxhZ3M7aWYoMiZuKXt0cnl7ZTp7Zm9yKHZhciB0PWUucmV0dXJuO251bGwhPT10Oyl7aWYodVYodCkpe3ZhciByPXQ7YnJlYWsgZX10PXQucmV0dXJufXRocm93IEVycm9yKGYoMTYwKSl9c3dpdGNoKHIudGFnKXtjYXNlIDU6dmFyIGw9ci5zdGF0ZU5vZGU7MzImci5mbGFncyYmKGVoKGwsIiIpLHIuZmxhZ3MmPS0zMyk7dmFyIGE9dUEoZSk7IWZ1bmN0aW9uIGUobix0LHIpe3ZhciBsPW4udGFnO2lmKDU9PT1sfHw2PT09bCluPW4uc3RhdGVOb2RlLHQ/ci5pbnNlcnRCZWZvcmUobix0KTpyLmFwcGVuZENoaWxkKG4pO2Vsc2UgaWYoNCE9PWwmJm51bGwhPT0obj1uLmNoaWxkKSlmb3IoZShuLHQsciksbj1uLnNpYmxpbmc7bnVsbCE9PW47KWUobix0LHIpLG49bi5zaWJsaW5nfShlLGEsbCk7YnJlYWs7Y2FzZSAzOmNhc2UgNDp2YXIgdT1yLnN0YXRlTm9kZS5jb250YWluZXJJbmZvLG89dUEoZSk7IWZ1bmN0aW9uIGUobix0LHIpe3ZhciBsPW4udGFnO2lmKDU9PT1sfHw2PT09bCluPW4uc3RhdGVOb2RlLHQ/OD09PXIubm9kZVR5cGU/ci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuLHQpOnIuaW5zZXJ0QmVmb3JlKG4sdCk6KDg9PT1yLm5vZGVUeXBlPyh0PXIucGFyZW50Tm9kZSkuaW5zZXJ0QmVmb3JlKG4scik6KHQ9cikuYXBwZW5kQ2hpbGQobiksbnVsbCE9KHI9ci5fcmVhY3RSb290Q29udGFpbmVyKXx8bnVsbCE9PXQub25jbGlja3x8KHQub25jbGljaz1yZykpO2Vsc2UgaWYoNCE9PWwmJm51bGwhPT0obj1uLmNoaWxkKSlmb3IoZShuLHQsciksbj1uLnNpYmxpbmc7bnVsbCE9PW47KWUobix0LHIpLG49bi5zaWJsaW5nfShlLG8sdSk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihmKDE2MSkpfX1jYXRjaChuKXtvQShlLGUucmV0dXJuLG4pfWUuZmxhZ3MmPS0zfTQwOTYmbiYmKGUuZmxhZ3MmPS00MDk3KX1mdW5jdGlvbiB1WShlKXtmb3IoO251bGwhPT11Ujspe3ZhciBuPXVSO2lmKDAhPSg4NzcyJm4uZmxhZ3MpKXt2YXIgdD1uLmFsdGVybmF0ZTt0cnl7aWYoMCE9KDg3NzImbi5mbGFncykpc3dpdGNoKG4udGFnKXtjYXNlIDA6Y2FzZSAxMTpjYXNlIDE1OnVUfHx1SSg1LG4pO2JyZWFrO2Nhc2UgMTp2YXIgcj1uLnN0YXRlTm9kZTtpZig0Jm4uZmxhZ3MmJiF1VCl7aWYobnVsbD09PXQpci5jb21wb25lbnREaWRNb3VudCgpO2Vsc2V7dmFyIGw9bi5lbGVtZW50VHlwZT09PW4udHlwZT90Lm1lbW9pemVkUHJvcHM6bFMobi50eXBlLHQubWVtb2l6ZWRQcm9wcyk7ci5jb21wb25lbnREaWRVcGRhdGUobCx0Lm1lbW9pemVkU3RhdGUsci5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSl9fXZhciBhPW4udXBkYXRlUXVldWU7bnVsbCE9PWEmJmxIKG4sYSxyKTticmVhaztjYXNlIDM6dmFyIHU9bi51cGRhdGVRdWV1ZTtpZihudWxsIT09dSl7aWYodD1udWxsLG51bGwhPT1uLmNoaWxkKXN3aXRjaChuLmNoaWxkLnRhZyl7Y2FzZSA1OmNhc2UgMTp0PW4uY2hpbGQuc3RhdGVOb2RlfWxIKG4sdSx0KX1icmVhaztjYXNlIDU6dmFyIG89bi5zdGF0ZU5vZGU7aWYobnVsbD09PXQmJjQmbi5mbGFncyl7dD1vO3ZhciBpPW4ubWVtb2l6ZWRQcm9wcztzd2l0Y2gobi50eXBlKXtjYXNlImJ1dHRvbiI6Y2FzZSJpbnB1dCI6Y2FzZSJzZWxlY3QiOmNhc2UidGV4dGFyZWEiOmkuYXV0b0ZvY3VzJiZ0LmZvY3VzKCk7YnJlYWs7Y2FzZSJpbWciOmkuc3JjJiYodC5zcmM9aS5zcmMpfX1icmVhaztjYXNlIDY6Y2FzZSA0OmNhc2UgMTI6Y2FzZSAxOTpjYXNlIDE3OmNhc2UgMjE6Y2FzZSAyMjpjYXNlIDIzOmNhc2UgMjU6YnJlYWs7Y2FzZSAxMzppZihudWxsPT09bi5tZW1vaXplZFN0YXRlKXt2YXIgcz1uLmFsdGVybmF0ZTtpZihudWxsIT09cyl7dmFyIGM9cy5tZW1vaXplZFN0YXRlO2lmKG51bGwhPT1jKXt2YXIgZD1jLmRlaHlkcmF0ZWQ7bnVsbCE9PWQmJm5NKGQpfX19YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihmKDE2MykpfXVUfHw1MTImbi5mbGFncyYmdVUobil9Y2F0Y2goZSl7b0EobixuLnJldHVybixlKX19aWYobj09PWUpe3VSPW51bGw7YnJlYWt9aWYobnVsbCE9PSh0PW4uc2libGluZykpe3QucmV0dXJuPW4ucmV0dXJuLHVSPXQ7YnJlYWt9dVI9bi5yZXR1cm59fWZ1bmN0aW9uIHVYKGUpe2Zvcig7bnVsbCE9PXVSOyl7dmFyIG49dVI7aWYobj09PWUpe3VSPW51bGw7YnJlYWt9dmFyIHQ9bi5zaWJsaW5nO2lmKG51bGwhPT10KXt0LnJldHVybj1uLnJldHVybix1Uj10O2JyZWFrfXVSPW4ucmV0dXJufX1mdW5jdGlvbiB1RyhlKXtmb3IoO251bGwhPT11Ujspe3ZhciBuPXVSO3RyeXtzd2l0Y2gobi50YWcpe2Nhc2UgMDpjYXNlIDExOmNhc2UgMTU6dmFyIHQ9bi5yZXR1cm47dHJ5e3VJKDQsbil9Y2F0Y2goZSl7b0Eobix0LGUpfWJyZWFrO2Nhc2UgMTp2YXIgcj1uLnN0YXRlTm9kZTtpZigiZnVuY3Rpb24iPT10eXBlb2Ygci5jb21wb25lbnREaWRNb3VudCl7dmFyIGw9bi5yZXR1cm47dHJ5e3IuY29tcG9uZW50RGlkTW91bnQoKX1jYXRjaChlKXtvQShuLGwsZSl9fXZhciBhPW4ucmV0dXJuO3RyeXt1VShuKX1jYXRjaChlKXtvQShuLGEsZSl9YnJlYWs7Y2FzZSA1OnZhciB1PW4ucmV0dXJuO3RyeXt1VShuKX1jYXRjaChlKXtvQShuLHUsZSl9fX1jYXRjaChlKXtvQShuLG4ucmV0dXJuLGUpfWlmKG49PT1lKXt1Uj1udWxsO2JyZWFrfXZhciBvPW4uc2libGluZztpZihudWxsIT09byl7by5yZXR1cm49bi5yZXR1cm4sdVI9bzticmVha311Uj1uLnJldHVybn19dmFyIHVaPU1hdGguY2VpbCx1Sj1fLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsdTA9Xy5SZWFjdEN1cnJlbnRPd25lcix1MT1fLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLHUyPTAsdTM9bnVsbCx1ND1udWxsLHU4PTAsdTY9MCx1NT1yJCgwKSx1OT0wLHU3PW51bGwsb2U9MCxvbj0wLG90PTAsb3I9bnVsbCxvbD1udWxsLG9hPTAsb3U9MS8wLG9vPW51bGwsb2k9ITEsb3M9bnVsbCxvYz1udWxsLG9mPSExLG9kPW51bGwsb3A9MCxvbT0wLG9oPW51bGwsb2c9LTEsb3Y9MDtmdW5jdGlvbiBveSgpe3JldHVybiAwIT0oNiZ1Mik/ZUooKTotMSE9PW9nP29nOm9nPWVKKCl9ZnVuY3Rpb24gb2IoZSl7cmV0dXJuIDA9PSgxJmUubW9kZSk/MTowIT0oMiZ1MikmJjAhPT11OD91OCYtdTg6bnVsbCE9PWx3LnRyYW5zaXRpb24/KDA9PT1vdiYmKG92PW51KCkpLG92KTowIT09KGU9bmMpP2U6ZT12b2lkIDA9PT0oZT13aW5kb3cuZXZlbnQpPzE2Om4kKGUudHlwZSl9ZnVuY3Rpb24gb2soZSxuLHQscil7aWYoNTA8b20pdGhyb3cgb209MCxvaD1udWxsLEVycm9yKGYoMTg1KSk7bmkoZSx0LHIpLCgwPT0oMiZ1Mil8fGUhPT11MykmJihlPT09dTMmJigwPT0oMiZ1MikmJihvbnw9dCksND09PXU5JiZvQyhlLHU4KSksb3coZSxyKSwxPT09dCYmMD09PXUyJiYwPT0oMSZuLm1vZGUpJiYob3U9ZUooKSs1MDAscjImJnI0KCkpKX1mdW5jdGlvbiBvdyhlLG4pe3ZhciB0LHIsbCxhPWUuY2FsbGJhY2tOb2RlOyFmdW5jdGlvbihlLG4pe2Zvcih2YXIgdD1lLnN1c3BlbmRlZExhbmVzLHI9ZS5waW5nZWRMYW5lcyxsPWUuZXhwaXJhdGlvblRpbWVzLGE9ZS5wZW5kaW5nTGFuZXM7MDxhOyl7dmFyIHU9MzEtZTkoYSksbz0xPDx1LGk9bFt1XTstMT09PWk/KDA9PShvJnQpfHwwIT0obyZyKSkmJihsW3VdPWZ1bmN0aW9uKGUsbil7c3dpdGNoKGUpe2Nhc2UgMTpjYXNlIDI6Y2FzZSA0OnJldHVybiBuKzI1MDtjYXNlIDg6Y2FzZSAxNjpjYXNlIDMyOmNhc2UgNjQ6Y2FzZSAxMjg6Y2FzZSAyNTY6Y2FzZSA1MTI6Y2FzZSAxMDI0OmNhc2UgMjA0ODpjYXNlIDQwOTY6Y2FzZSA4MTkyOmNhc2UgMTYzODQ6Y2FzZSAzMjc2ODpjYXNlIDY1NTM2OmNhc2UgMTMxMDcyOmNhc2UgMjYyMTQ0OmNhc2UgNTI0Mjg4OmNhc2UgMTA0ODU3NjpjYXNlIDIwOTcxNTI6cmV0dXJuIG4rNWUzO2RlZmF1bHQ6cmV0dXJuIC0xfX0obyxuKSk6aTw9biYmKGUuZXhwaXJlZExhbmVzfD1vKSxhJj1+b319KGUsbik7dmFyIHU9bmwoZSxlPT09dTM/dTg6MCk7aWYoMD09PXUpbnVsbCE9PWEmJmVYKGEpLGUuY2FsbGJhY2tOb2RlPW51bGwsZS5jYWxsYmFja1ByaW9yaXR5PTA7ZWxzZSBpZihuPXUmLXUsZS5jYWxsYmFja1ByaW9yaXR5IT09bil7aWYobnVsbCE9YSYmZVgoYSksMT09PW4pezswPT09ZS50YWcmJihyMj0hMCksdD1vXy5iaW5kKG51bGwsZSksbnVsbD09PXIxP3IxPVt0XTpyMS5wdXNoKHQpLHJ4KGZ1bmN0aW9uKCl7MD09KDYmdTIpJiZyNCgpfSksYT1udWxsfWVsc2V7c3dpdGNoKG5mKHUpKXtjYXNlIDE6YT1lMTticmVhaztjYXNlIDQ6YT1lMjticmVhaztjYXNlIDE2OmRlZmF1bHQ6YT1lMzticmVhaztjYXNlIDUzNjg3MDkxMjphPWU4fXI9YSxsPW9TLmJpbmQobnVsbCxlKSxhPWVZKHIsbCl9ZS5jYWxsYmFja1ByaW9yaXR5PW4sZS5jYWxsYmFja05vZGU9YX19ZnVuY3Rpb24gb1MoZSxuKXtpZihvZz0tMSxvdj0wLDAhPSg2JnUyKSl0aHJvdyBFcnJvcihmKDMyNykpO3ZhciB0PWUuY2FsbGJhY2tOb2RlO2lmKG9VKCkmJmUuY2FsbGJhY2tOb2RlIT09dClyZXR1cm4gbnVsbDt2YXIgcj1ubChlLGU9PT11Mz91ODowKTtpZigwPT09cilyZXR1cm4gbnVsbDtpZigwIT0oMzAmcil8fDAhPShyJmUuZXhwaXJlZExhbmVzKXx8biluPW9GKGUscik7ZWxzZXtuPXI7dmFyIGw9dTI7dTJ8PTI7dmFyIGE9b1IoKTtmb3IoKHUzIT09ZXx8dTghPT1uKSYmKG9vPW51bGwsb3U9ZUooKSs1MDAsb1QoZSxuKSk7Oyl0cnl7IWZ1bmN0aW9uKCl7Zm9yKDtudWxsIT09dTQmJiFlRygpOylvTyh1NCl9KCk7YnJlYWt9Y2F0Y2gobil7b0woZSxuKX1sUCgpLHVKLmN1cnJlbnQ9YSx1Mj1sLG51bGwhPT11ND9uPTA6KHUzPW51bGwsdTg9MCxuPXU5KX1pZigwIT09bil7aWYoMj09PW4mJjAhPT0obD1uYShlKSkmJihyPWwsbj1veChlLGwpKSwxPT09bil0aHJvdyB0PXU3LG9UKGUsMCksb0MoZSxyKSxvdyhlLGVKKCkpLHQ7aWYoNj09PW4pb0MoZSxyKTtlbHNle2lmKGw9ZS5jdXJyZW50LmFsdGVybmF0ZSwwPT0oMzAmcikmJiFmdW5jdGlvbihlKXtmb3IodmFyIG49ZTs7KXtpZigxNjM4NCZuLmZsYWdzKXt2YXIgdD1uLnVwZGF0ZVF1ZXVlO2lmKG51bGwhPT10JiZudWxsIT09KHQ9dC5zdG9yZXMpKWZvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbD10W3JdLGE9bC5nZXRTbmFwc2hvdDtsPWwudmFsdWU7dHJ5e2lmKCF0RChhKCksbCkpcmV0dXJuITF9Y2F0Y2goZSl7cmV0dXJuITF9fX1pZih0PW4uY2hpbGQsMTYzODQmbi5zdWJ0cmVlRmxhZ3MmJm51bGwhPT10KXQucmV0dXJuPW4sbj10O2Vsc2V7aWYobj09PWUpYnJlYWs7Zm9yKDtudWxsPT09bi5zaWJsaW5nOyl7aWYobnVsbD09PW4ucmV0dXJufHxuLnJldHVybj09PWUpcmV0dXJuITA7bj1uLnJldHVybn1uLnNpYmxpbmcucmV0dXJuPW4ucmV0dXJuLG49bi5zaWJsaW5nfX1yZXR1cm4hMH0obCkmJigyPT09KG49b0YoZSxyKSkmJjAhPT0oYT1uYShlKSkmJihyPWEsbj1veChlLGEpKSwxPT09bikpdGhyb3cgdD11NyxvVChlLDApLG9DKGUsciksb3coZSxlSigpKSx0O3N3aXRjaChlLmZpbmlzaGVkV29yaz1sLGUuZmluaXNoZWRMYW5lcz1yLG4pe2Nhc2UgMDpjYXNlIDE6dGhyb3cgRXJyb3IoZigzNDUpKTtjYXNlIDI6Y2FzZSA1Om9JKGUsb2wsb28pO2JyZWFrO2Nhc2UgMzppZihvQyhlLHIpLCgxMzAwMjM0MjQmcik9PT1yJiYxMDwobj1vYSs1MDAtZUooKSkpe2lmKDAhPT1ubChlLDApKWJyZWFrO2lmKCgobD1lLnN1c3BlbmRlZExhbmVzKSZyKSE9PXIpe295KCksZS5waW5nZWRMYW5lc3w9ZS5zdXNwZW5kZWRMYW5lcyZsO2JyZWFrfWUudGltZW91dEhhbmRsZT1yayhvSS5iaW5kKG51bGwsZSxvbCxvbyksbik7YnJlYWt9b0koZSxvbCxvbyk7YnJlYWs7Y2FzZSA0OmlmKG9DKGUsciksKDQxOTQyNDAmcik9PT1yKWJyZWFrO2ZvcihsPS0xLG49ZS5ldmVudFRpbWVzOzA8cjspe3ZhciB1PTMxLWU5KHIpO2E9MTw8dSwodT1uW3VdKT5sJiYobD11KSxyJj1+YX1pZihyPWwsMTA8KHI9KDEyMD4ocj1lSigpLXIpPzEyMDo0ODA+cj80ODA6MTA4MD5yPzEwODA6MTkyMD5yPzE5MjA6M2UzPnI/M2UzOjQzMjA+cj80MzIwOjE5NjAqdVooci8xOTYwKSktcikpe2UudGltZW91dEhhbmRsZT1yayhvSS5iaW5kKG51bGwsZSxvbCxvbykscik7YnJlYWt9b0koZSxvbCxvbyk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihmKDMyOSkpfX19cmV0dXJuIG93KGUsZUooKSksZS5jYWxsYmFja05vZGU9PT10P29TLmJpbmQobnVsbCxlKTpudWxsfWZ1bmN0aW9uIG94KGUsbil7dmFyIHQ9b3I7cmV0dXJuIGUuY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZCYmKG9UKGUsbikuZmxhZ3N8PTI1NiksMiE9PShlPW9GKGUsbikpJiYobj1vbCxvbD10LG51bGwhPT1uJiZvRShuKSksZX1mdW5jdGlvbiBvRShlKXtudWxsPT09b2w/b2w9ZTpvbC5wdXNoLmFwcGx5KG9sLGUpfWZ1bmN0aW9uIG9DKGUsbil7Zm9yKG4mPX5vdCxuJj1+b24sZS5zdXNwZW5kZWRMYW5lc3w9bixlLnBpbmdlZExhbmVzJj1+bixlPWUuZXhwaXJhdGlvblRpbWVzOzA8bjspe3ZhciB0PTMxLWU5KG4pLHI9MTw8dDtlW3RdPS0xLG4mPX5yfX1mdW5jdGlvbiBvXyhlKXtpZigwIT0oNiZ1MikpdGhyb3cgRXJyb3IoZigzMjcpKTtvVSgpO3ZhciBuPW5sKGUsMCk7aWYoMD09KDEmbikpcmV0dXJuIG93KGUsZUooKSksbnVsbDt2YXIgdD1vRihlLG4pO2lmKDAhPT1lLnRhZyYmMj09PXQpe3ZhciByPW5hKGUpOzAhPT1yJiYobj1yLHQ9b3goZSxyKSl9aWYoMT09PXQpdGhyb3cgdD11NyxvVChlLDApLG9DKGUsbiksb3coZSxlSigpKSx0O2lmKDY9PT10KXRocm93IEVycm9yKGYoMzQ1KSk7cmV0dXJuIGUuZmluaXNoZWRXb3JrPWUuY3VycmVudC5hbHRlcm5hdGUsZS5maW5pc2hlZExhbmVzPW4sb0koZSxvbCxvbyksb3coZSxlSigpKSxudWxsfWZ1bmN0aW9uIG9QKGUsbil7dmFyIHQ9dTI7dTJ8PTE7dHJ5e3JldHVybiBlKG4pfWZpbmFsbHl7MD09PSh1Mj10KSYmKG91PWVKKCkrNTAwLHIyJiZyNCgpKX19ZnVuY3Rpb24gb04oZSl7bnVsbCE9PW9kJiYwPT09b2QudGFnJiYwPT0oNiZ1MikmJm9VKCk7dmFyIG49dTI7dTJ8PTE7dmFyIHQ9dTEudHJhbnNpdGlvbixyPW5jO3RyeXtpZih1MS50cmFuc2l0aW9uPW51bGwsbmM9MSxlKXJldHVybiBlKCl9ZmluYWxseXtuYz1yLHUxLnRyYW5zaXRpb249dCwwPT0oNiYodTI9bikpJiZyNCgpfX1mdW5jdGlvbiBveigpe3U2PXU1LmN1cnJlbnQscmoodTUpfWZ1bmN0aW9uIG9UKGUsbil7ZS5maW5pc2hlZFdvcms9bnVsbCxlLmZpbmlzaGVkTGFuZXM9MDt2YXIgdD1lLnRpbWVvdXRIYW5kbGU7aWYoLTEhPT10JiYoZS50aW1lb3V0SGFuZGxlPS0xLHJ3KHQpKSxudWxsIT09dTQpZm9yKHQ9dTQucmV0dXJuO251bGwhPT10Oyl7dmFyIHI9dDtzd2l0Y2gobG8ociksci50YWcpe2Nhc2UgMTpudWxsIT0ocj1yLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMpJiZyWCgpO2JyZWFrO2Nhc2UgMzphZSgpLHJqKHJRKSxyaihyVyksYXUoKTticmVhaztjYXNlIDU6YXQocik7YnJlYWs7Y2FzZSA0OmFlKCk7YnJlYWs7Y2FzZSAxMzpjYXNlIDE5OnJqKGFyKTticmVhaztjYXNlIDEwOmxOKHIudHlwZS5fY29udGV4dCk7YnJlYWs7Y2FzZSAyMjpjYXNlIDIzOm96KCl9dD10LnJldHVybn1pZih1Mz1lLHU0PWU9b0soZS5jdXJyZW50LG51bGwpLHU4PXU2PW4sdTk9MCx1Nz1udWxsLG90PW9uPW9lPTAsb2w9b3I9bnVsbCxudWxsIT09bFIpe2ZvcihuPTA7bjxsUi5sZW5ndGg7bisrKWlmKG51bGwhPT0ocj0odD1sUltuXSkuaW50ZXJsZWF2ZWQpKXt0LmludGVybGVhdmVkPW51bGw7dmFyIGw9ci5uZXh0LGE9dC5wZW5kaW5nO2lmKG51bGwhPT1hKXt2YXIgdT1hLm5leHQ7YS5uZXh0PWwsci5uZXh0PXV9dC5wZW5kaW5nPXJ9bFI9bnVsbH1yZXR1cm4gZX1mdW5jdGlvbiBvTChlLG4pe2Zvcig7Oyl7dmFyIHQ9dTQ7dHJ5e2lmKGxQKCksYW8uY3VycmVudD1hMSxhcCl7Zm9yKHZhciByPWFjLm1lbW9pemVkU3RhdGU7bnVsbCE9PXI7KXt2YXIgbD1yLnF1ZXVlO251bGwhPT1sJiYobC5wZW5kaW5nPW51bGwpLHI9ci5uZXh0fWFwPSExfWlmKGFzPTAsYWQ9YWY9YWM9bnVsbCxhbT0hMSxhaD0wLHUwLmN1cnJlbnQ9bnVsbCxudWxsPT09dHx8bnVsbD09PXQucmV0dXJuKXt1OT0xLHU3PW4sdTQ9bnVsbDticmVha31lOnt2YXIgYT1lLHU9dC5yZXR1cm4sbz10LGk9bjtpZihuPXU4LG8uZmxhZ3N8PTMyNzY4LG51bGwhPT1pJiYib2JqZWN0Ij09dHlwZW9mIGkmJiJmdW5jdGlvbiI9PXR5cGVvZiBpLnRoZW4pe3ZhciBzPWksYz1vLGQ9Yy50YWc7aWYoMD09KDEmYy5tb2RlKSYmKDA9PT1kfHwxMT09PWR8fDE1PT09ZCkpe3ZhciBwPWMuYWx0ZXJuYXRlO3A/KGMudXBkYXRlUXVldWU9cC51cGRhdGVRdWV1ZSxjLm1lbW9pemVkU3RhdGU9cC5tZW1vaXplZFN0YXRlLGMubGFuZXM9cC5sYW5lcyk6KGMudXBkYXRlUXVldWU9bnVsbCxjLm1lbW9pemVkU3RhdGU9bnVsbCl9dmFyIG09dXQodSk7aWYobnVsbCE9PW0pe20uZmxhZ3MmPS0yNTcsdXIobSx1LG8sYSxuKSwxJm0ubW9kZSYmdW4oYSxzLG4pLG49bSxpPXM7dmFyIGg9bi51cGRhdGVRdWV1ZTtpZihudWxsPT09aCl7dmFyIGc9bmV3IFNldDtnLmFkZChpKSxuLnVwZGF0ZVF1ZXVlPWd9ZWxzZSBoLmFkZChpKTticmVhayBlfWlmKDA9PSgxJm4pKXt1bihhLHMsbiksb00oKTticmVhayBlfWk9RXJyb3IoZig0MjYpKX1lbHNlIGlmKGxjJiYxJm8ubW9kZSl7dmFyIHY9dXQodSk7aWYobnVsbCE9PXYpezA9PSg2NTUzNiZ2LmZsYWdzKSYmKHYuZmxhZ3N8PTI1NiksdXIodix1LG8sYSxuKSxsayhhOChpLG8pKTticmVhayBlfX1hPWk9YTgoaSxvKSw0IT09dTkmJih1OT0yKSxudWxsPT09b3I/b3I9W2FdOm9yLnB1c2goYSksYT11O2Rve3N3aXRjaChhLnRhZyl7Y2FzZSAzOmEuZmxhZ3N8PTY1NTM2LG4mPS1uLGEubGFuZXN8PW47dmFyIHk9YTcoYSxpLG4pO2xqKGEseSk7YnJlYWsgZTtjYXNlIDE6bz1pO3ZhciBiPWEudHlwZSxrPWEuc3RhdGVOb2RlO2lmKDA9PSgxMjgmYS5mbGFncykmJigiZnVuY3Rpb24iPT10eXBlb2YgYi5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3J8fG51bGwhPT1rJiYiZnVuY3Rpb24iPT10eXBlb2Ygay5jb21wb25lbnREaWRDYXRjaCYmKG51bGw9PT1vY3x8IW9jLmhhcyhrKSkpKXthLmZsYWdzfD02NTUzNixuJj0tbixhLmxhbmVzfD1uO3ZhciB3PXVlKGEsbyxuKTtsaihhLHcpO2JyZWFrIGV9fWE9YS5yZXR1cm59d2hpbGUobnVsbCE9PWEpfW9EKHQpfWNhdGNoKGUpe249ZSx1ND09PXQmJm51bGwhPT10JiYodTQ9dD10LnJldHVybik7Y29udGludWV9YnJlYWt9fWZ1bmN0aW9uIG9SKCl7dmFyIGU9dUouY3VycmVudDtyZXR1cm4gdUouY3VycmVudD1hMSxudWxsPT09ZT9hMTplfWZ1bmN0aW9uIG9NKCl7KDA9PT11OXx8Mz09PXU5fHwyPT09dTkpJiYodTk9NCksbnVsbD09PXUzfHwwPT0oMjY4NDM1NDU1Jm9lKSYmMD09KDI2ODQzNTQ1NSZvbil8fG9DKHUzLHU4KX1mdW5jdGlvbiBvRihlLG4pe3ZhciB0PXUyO3UyfD0yO3ZhciByPW9SKCk7Zm9yKCh1MyE9PWV8fHU4IT09bikmJihvbz1udWxsLG9UKGUsbikpOzspdHJ5eyFmdW5jdGlvbigpe2Zvcig7bnVsbCE9PXU0OylvTyh1NCl9KCk7YnJlYWt9Y2F0Y2gobil7b0woZSxuKX1pZihsUCgpLHUyPXQsdUouY3VycmVudD1yLG51bGwhPT11NCl0aHJvdyBFcnJvcihmKDI2MSkpO3JldHVybiB1Mz1udWxsLHU4PTAsdTl9ZnVuY3Rpb24gb08oZSl7dmFyIG49aShlLmFsdGVybmF0ZSxlLHU2KTtlLm1lbW9pemVkUHJvcHM9ZS5wZW5kaW5nUHJvcHMsbnVsbD09PW4/b0QoZSk6dTQ9bix1MC5jdXJyZW50PW51bGx9ZnVuY3Rpb24gb0QoZSl7dmFyIG49ZTtkb3t2YXIgdD1uLmFsdGVybmF0ZTtpZihlPW4ucmV0dXJuLDA9PSgzMjc2OCZuLmZsYWdzKSl7aWYobnVsbCE9PSh0PWZ1bmN0aW9uKGUsbix0KXt2YXIgcj1uLnBlbmRpbmdQcm9wcztzd2l0Y2gobG8obiksbi50YWcpe2Nhc2UgMjpjYXNlIDE2OmNhc2UgMTU6Y2FzZSAwOmNhc2UgMTE6Y2FzZSA3OmNhc2UgODpjYXNlIDEyOmNhc2UgOTpjYXNlIDE0OnJldHVybiB1TihuKSxudWxsO2Nhc2UgMTpjYXNlIDE3OnJldHVybiByWShuLnR5cGUpJiZyWCgpLHVOKG4pLG51bGw7Y2FzZSAzOnJldHVybiByPW4uc3RhdGVOb2RlLGFlKCkscmooclEpLHJqKHJXKSxhdSgpLHIucGVuZGluZ0NvbnRleHQmJihyLmNvbnRleHQ9ci5wZW5kaW5nQ29udGV4dCxyLnBlbmRpbmdDb250ZXh0PW51bGwpLChudWxsPT09ZXx8bnVsbD09PWUuY2hpbGQpJiYobHYobik/bi5mbGFnc3w9NDpudWxsPT09ZXx8ZS5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZCYmMD09KDI1NiZuLmZsYWdzKXx8KG4uZmxhZ3N8PTEwMjQsbnVsbCE9PWxmJiYob0UobGYpLGxmPW51bGwpKSksYShlLG4pLHVOKG4pLG51bGw7Y2FzZSA1OmF0KG4pO3ZhciBpPWw5KGw1LmN1cnJlbnQpO2lmKHQ9bi50eXBlLG51bGwhPT1lJiZudWxsIT1uLnN0YXRlTm9kZSl1KGUsbix0LHIsaSksZS5yZWYhPT1uLnJlZiYmKG4uZmxhZ3N8PTUxMixuLmZsYWdzfD0yMDk3MTUyKTtlbHNle2lmKCFyKXtpZihudWxsPT09bi5zdGF0ZU5vZGUpdGhyb3cgRXJyb3IoZigxNjYpKTtyZXR1cm4gdU4obiksbnVsbH1pZihlPWw5KGw4LmN1cnJlbnQpLGx2KG4pKXtyPW4uc3RhdGVOb2RlLHQ9bi50eXBlO3ZhciBzPW4ubWVtb2l6ZWRQcm9wcztzd2l0Y2gocltyel09bixyW3JUXT1zLGU9MCE9KDEmbi5tb2RlKSx0KXtjYXNlImRpYWxvZyI6cnQoImNhbmNlbCIscikscnQoImNsb3NlIixyKTticmVhaztjYXNlImlmcmFtZSI6Y2FzZSJvYmplY3QiOmNhc2UiZW1iZWQiOnJ0KCJsb2FkIixyKTticmVhaztjYXNlInZpZGVvIjpjYXNlImF1ZGlvIjpmb3IoaT0wO2k8dDkubGVuZ3RoO2krKylydCh0OVtpXSxyKTticmVhaztjYXNlInNvdXJjZSI6cnQoImVycm9yIixyKTticmVhaztjYXNlImltZyI6Y2FzZSJpbWFnZSI6Y2FzZSJsaW5rIjpydCgiZXJyb3IiLHIpLHJ0KCJsb2FkIixyKTticmVhaztjYXNlImRldGFpbHMiOnJ0KCJ0b2dnbGUiLHIpO2JyZWFrO2Nhc2UiaW5wdXQiOkoocixzKSxydCgiaW52YWxpZCIscik7YnJlYWs7Y2FzZSJzZWxlY3QiOnIuX3dyYXBwZXJTdGF0ZT17d2FzTXVsdGlwbGU6ISFzLm11bHRpcGxlfSxydCgiaW52YWxpZCIscik7YnJlYWs7Y2FzZSJ0ZXh0YXJlYSI6ZW8ocixzKSxydCgiaW52YWxpZCIscil9Zm9yKHZhciBjIGluIGV3KHQscyksaT1udWxsLHMpaWYocy5oYXNPd25Qcm9wZXJ0eShjKSl7dmFyIGQ9c1tjXTsiY2hpbGRyZW4iPT09Yz8ic3RyaW5nIj09dHlwZW9mIGQ/ci50ZXh0Q29udGVudCE9PWQmJighMCE9PXMuc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJiZyaChyLnRleHRDb250ZW50LGQsZSksaT1bImNoaWxkcmVuIixkXSk6Im51bWJlciI9PXR5cGVvZiBkJiZyLnRleHRDb250ZW50IT09IiIrZCYmKCEwIT09cy5zdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcmJnJoKHIudGV4dENvbnRlbnQsZCxlKSxpPVsiY2hpbGRyZW4iLCIiK2RdKTpwLmhhc093blByb3BlcnR5KGMpJiZudWxsIT1kJiYib25TY3JvbGwiPT09YyYmcnQoInNjcm9sbCIscil9c3dpdGNoKHQpe2Nhc2UiaW5wdXQiOlkociksZXQocixzLCEwKTticmVhaztjYXNlInRleHRhcmVhIjpZKHIpLGVzKHIpO2JyZWFrO2Nhc2Uic2VsZWN0IjpjYXNlIm9wdGlvbiI6YnJlYWs7ZGVmYXVsdDoiZnVuY3Rpb24iPT10eXBlb2Ygcy5vbkNsaWNrJiYoci5vbmNsaWNrPXJnKX1yPWksbi51cGRhdGVRdWV1ZT1yLG51bGwhPT1yJiYobi5mbGFnc3w9NCl9ZWxzZXtjPTk9PT1pLm5vZGVUeXBlP2k6aS5vd25lckRvY3VtZW50LCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj09PWUmJihlPWVjKHQpKSwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI9PT1lPyJzY3JpcHQiPT09dD8oKGU9Yy5jcmVhdGVFbGVtZW50KCJkaXYiKSkuaW5uZXJIVE1MPSI8c2NyaXB0Pjwvc2NyaXB0PiIsZT1lLnJlbW92ZUNoaWxkKGUuZmlyc3RDaGlsZCkpOiJzdHJpbmciPT10eXBlb2Ygci5pcz9lPWMuY3JlYXRlRWxlbWVudCh0LHtpczpyLmlzfSk6KGU9Yy5jcmVhdGVFbGVtZW50KHQpLCJzZWxlY3QiPT09dCYmKGM9ZSxyLm11bHRpcGxlP2MubXVsdGlwbGU9ITA6ci5zaXplJiYoYy5zaXplPXIuc2l6ZSkpKTplPWMuY3JlYXRlRWxlbWVudE5TKGUsdCksZVtyel09bixlW3JUXT1yLGwoZSxuLCExLCExKSxuLnN0YXRlTm9kZT1lO2U6e3N3aXRjaChjPWVTKHQsciksdCl7Y2FzZSJkaWFsb2ciOnJ0KCJjYW5jZWwiLGUpLHJ0KCJjbG9zZSIsZSksaT1yO2JyZWFrO2Nhc2UiaWZyYW1lIjpjYXNlIm9iamVjdCI6Y2FzZSJlbWJlZCI6cnQoImxvYWQiLGUpLGk9cjticmVhaztjYXNlInZpZGVvIjpjYXNlImF1ZGlvIjpmb3IoaT0wO2k8dDkubGVuZ3RoO2krKylydCh0OVtpXSxlKTtpPXI7YnJlYWs7Y2FzZSJzb3VyY2UiOnJ0KCJlcnJvciIsZSksaT1yO2JyZWFrO2Nhc2UiaW1nIjpjYXNlImltYWdlIjpjYXNlImxpbmsiOnJ0KCJlcnJvciIsZSkscnQoImxvYWQiLGUpLGk9cjticmVhaztjYXNlImRldGFpbHMiOnJ0KCJ0b2dnbGUiLGUpLGk9cjticmVhaztjYXNlImlucHV0IjpKKGUsciksaT1aKGUscikscnQoImludmFsaWQiLGUpO2JyZWFrO2Nhc2Uib3B0aW9uIjpkZWZhdWx0Omk9cjticmVhaztjYXNlInNlbGVjdCI6ZS5fd3JhcHBlclN0YXRlPXt3YXNNdWx0aXBsZTohIXIubXVsdGlwbGV9LGk9Qih7fSxyLHt2YWx1ZTp2b2lkIDB9KSxydCgiaW52YWxpZCIsZSk7YnJlYWs7Y2FzZSJ0ZXh0YXJlYSI6ZW8oZSxyKSxpPWV1KGUscikscnQoImludmFsaWQiLGUpfWZvcihzIGluIGV3KHQsaSksZD1pKWlmKGQuaGFzT3duUHJvcGVydHkocykpe3ZhciBtPWRbc107InN0eWxlIj09PXM/ZWIoZSxtKToiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiPT09cz9udWxsIT0obT1tP20uX19odG1sOnZvaWQgMCkmJmVtKGUsbSk6ImNoaWxkcmVuIj09PXM/InN0cmluZyI9PXR5cGVvZiBtPygidGV4dGFyZWEiIT09dHx8IiIhPT1tKSYmZWgoZSxtKToibnVtYmVyIj09dHlwZW9mIG0mJmVoKGUsIiIrbSk6InN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyIhPT1zJiYic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nIiE9PXMmJiJhdXRvRm9jdXMiIT09cyYmKHAuaGFzT3duUHJvcGVydHkocyk/bnVsbCE9bSYmIm9uU2Nyb2xsIj09PXMmJnJ0KCJzY3JvbGwiLGUpOm51bGwhPW0mJkMoZSxzLG0sYykpfXN3aXRjaCh0KXtjYXNlImlucHV0IjpZKGUpLGV0KGUsciwhMSk7YnJlYWs7Y2FzZSJ0ZXh0YXJlYSI6WShlKSxlcyhlKTticmVhaztjYXNlIm9wdGlvbiI6bnVsbCE9ci52YWx1ZSYmZS5zZXRBdHRyaWJ1dGUoInZhbHVlIiwiIitxKHIudmFsdWUpKTticmVhaztjYXNlInNlbGVjdCI6ZS5tdWx0aXBsZT0hIXIubXVsdGlwbGUsbnVsbCE9KHM9ci52YWx1ZSk/ZWEoZSwhIXIubXVsdGlwbGUscywhMSk6bnVsbCE9ci5kZWZhdWx0VmFsdWUmJmVhKGUsISFyLm11bHRpcGxlLHIuZGVmYXVsdFZhbHVlLCEwKTticmVhaztkZWZhdWx0OiJmdW5jdGlvbiI9PXR5cGVvZiBpLm9uQ2xpY2smJihlLm9uY2xpY2s9cmcpfXN3aXRjaCh0KXtjYXNlImJ1dHRvbiI6Y2FzZSJpbnB1dCI6Y2FzZSJzZWxlY3QiOmNhc2UidGV4dGFyZWEiOnI9ISFyLmF1dG9Gb2N1czticmVhayBlO2Nhc2UiaW1nIjpyPSEwO2JyZWFrIGU7ZGVmYXVsdDpyPSExfX1yJiYobi5mbGFnc3w9NCl9bnVsbCE9PW4ucmVmJiYobi5mbGFnc3w9NTEyLG4uZmxhZ3N8PTIwOTcxNTIpfXJldHVybiB1TihuKSxudWxsO2Nhc2UgNjppZihlJiZudWxsIT1uLnN0YXRlTm9kZSlvKGUsbixlLm1lbW9pemVkUHJvcHMscik7ZWxzZXtpZigic3RyaW5nIiE9dHlwZW9mIHImJm51bGw9PT1uLnN0YXRlTm9kZSl0aHJvdyBFcnJvcihmKDE2NikpO2lmKHQ9bDkobDUuY3VycmVudCksbDkobDguY3VycmVudCksbHYobikpe2lmKHI9bi5zdGF0ZU5vZGUsdD1uLm1lbW9pemVkUHJvcHMscltyel09biwocz1yLm5vZGVWYWx1ZSE9PXQpJiZudWxsIT09KGU9bGkpKXN3aXRjaChlLnRhZyl7Y2FzZSAzOnJoKHIubm9kZVZhbHVlLHQsMCE9KDEmZS5tb2RlKSk7YnJlYWs7Y2FzZSA1OiEwIT09ZS5tZW1vaXplZFByb3BzLnN1cHByZXNzSHlkcmF0aW9uV2FybmluZyYmcmgoci5ub2RlVmFsdWUsdCwwIT0oMSZlLm1vZGUpKX1zJiYobi5mbGFnc3w9NCl9ZWxzZShyPSg5PT09dC5ub2RlVHlwZT90OnQub3duZXJEb2N1bWVudCkuY3JlYXRlVGV4dE5vZGUocikpW3J6XT1uLG4uc3RhdGVOb2RlPXJ9cmV0dXJuIHVOKG4pLG51bGw7Y2FzZSAxMzppZihyaihhcikscj1uLm1lbW9pemVkU3RhdGUsbnVsbD09PWV8fG51bGwhPT1lLm1lbW9pemVkU3RhdGUmJm51bGwhPT1lLm1lbW9pemVkU3RhdGUuZGVoeWRyYXRlZCl7aWYobGMmJm51bGwhPT1scyYmMCE9KDEmbi5tb2RlKSYmMD09KDEyOCZuLmZsYWdzKSlseSgpLGxiKCksbi5mbGFnc3w9OTg1NjAscz0hMTtlbHNlIGlmKHM9bHYobiksbnVsbCE9PXImJm51bGwhPT1yLmRlaHlkcmF0ZWQpe2lmKG51bGw9PT1lKXtpZighcyl0aHJvdyBFcnJvcihmKDMxOCkpO2lmKCEocz1udWxsIT09KHM9bi5tZW1vaXplZFN0YXRlKT9zLmRlaHlkcmF0ZWQ6bnVsbCkpdGhyb3cgRXJyb3IoZigzMTcpKTtzW3J6XT1ufWVsc2UgbGIoKSwwPT0oMTI4Jm4uZmxhZ3MpJiYobi5tZW1vaXplZFN0YXRlPW51bGwpLG4uZmxhZ3N8PTQ7dU4obikscz0hMX1lbHNlIG51bGwhPT1sZiYmKG9FKGxmKSxsZj1udWxsKSxzPSEwO2lmKCFzKXJldHVybiA2NTUzNiZuLmZsYWdzP246bnVsbH1pZigwIT0oMTI4Jm4uZmxhZ3MpKXJldHVybiBuLmxhbmVzPXQsbjtyZXR1cm4ocj1udWxsIT09cikhPShudWxsIT09ZSYmbnVsbCE9PWUubWVtb2l6ZWRTdGF0ZSkmJnImJihuLmNoaWxkLmZsYWdzfD04MTkyLDAhPSgxJm4ubW9kZSkmJihudWxsPT09ZXx8MCE9KDEmYXIuY3VycmVudCk/MD09PXU5JiYodTk9Myk6b00oKSkpLG51bGwhPT1uLnVwZGF0ZVF1ZXVlJiYobi5mbGFnc3w9NCksdU4obiksbnVsbDtjYXNlIDQ6cmV0dXJuIGFlKCksYShlLG4pLG51bGw9PT1lJiZyYShuLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSx1TihuKSxudWxsO2Nhc2UgMTA6cmV0dXJuIGxOKG4udHlwZS5fY29udGV4dCksdU4obiksbnVsbDtjYXNlIDE5OmlmKHJqKGFyKSxudWxsPT09KHM9bi5tZW1vaXplZFN0YXRlKSlyZXR1cm4gdU4obiksbnVsbDtpZihyPTAhPSgxMjgmbi5mbGFncyksbnVsbD09PShjPXMucmVuZGVyaW5nKSl7aWYocil1UChzLCExKTtlbHNle2lmKDAhPT11OXx8bnVsbCE9PWUmJjAhPSgxMjgmZS5mbGFncykpZm9yKGU9bi5jaGlsZDtudWxsIT09ZTspe2lmKG51bGwhPT0oYz1hbChlKSkpe2ZvcihuLmZsYWdzfD0xMjgsdVAocywhMSksbnVsbCE9PShyPWMudXBkYXRlUXVldWUpJiYobi51cGRhdGVRdWV1ZT1yLG4uZmxhZ3N8PTQpLG4uc3VidHJlZUZsYWdzPTAscj10LHQ9bi5jaGlsZDtudWxsIT09dDspcz10LGU9cixzLmZsYWdzJj0xNDY4MDA2NixudWxsPT09KGM9cy5hbHRlcm5hdGUpPyhzLmNoaWxkTGFuZXM9MCxzLmxhbmVzPWUscy5jaGlsZD1udWxsLHMuc3VidHJlZUZsYWdzPTAscy5tZW1vaXplZFByb3BzPW51bGwscy5tZW1vaXplZFN0YXRlPW51bGwscy51cGRhdGVRdWV1ZT1udWxsLHMuZGVwZW5kZW5jaWVzPW51bGwscy5zdGF0ZU5vZGU9bnVsbCk6KHMuY2hpbGRMYW5lcz1jLmNoaWxkTGFuZXMscy5sYW5lcz1jLmxhbmVzLHMuY2hpbGQ9Yy5jaGlsZCxzLnN1YnRyZWVGbGFncz0wLHMuZGVsZXRpb25zPW51bGwscy5tZW1vaXplZFByb3BzPWMubWVtb2l6ZWRQcm9wcyxzLm1lbW9pemVkU3RhdGU9Yy5tZW1vaXplZFN0YXRlLHMudXBkYXRlUXVldWU9Yy51cGRhdGVRdWV1ZSxzLnR5cGU9Yy50eXBlLGU9Yy5kZXBlbmRlbmNpZXMscy5kZXBlbmRlbmNpZXM9bnVsbD09PWU/bnVsbDp7bGFuZXM6ZS5sYW5lcyxmaXJzdENvbnRleHQ6ZS5maXJzdENvbnRleHR9KSx0PXQuc2libGluZztyZXR1cm4gckIoYXIsMSZhci5jdXJyZW50fDIpLG4uY2hpbGR9ZT1lLnNpYmxpbmd9bnVsbCE9PXMudGFpbCYmZUooKT5vdSYmKG4uZmxhZ3N8PTEyOCxyPSEwLHVQKHMsITEpLG4ubGFuZXM9NDE5NDMwNCl9fWVsc2V7aWYoIXIpe2lmKG51bGwhPT0oZT1hbChjKSkpe2lmKG4uZmxhZ3N8PTEyOCxyPSEwLG51bGwhPT0odD1lLnVwZGF0ZVF1ZXVlKSYmKG4udXBkYXRlUXVldWU9dCxuLmZsYWdzfD00KSx1UChzLCEwKSxudWxsPT09cy50YWlsJiYiaGlkZGVuIj09PXMudGFpbE1vZGUmJiFjLmFsdGVybmF0ZSYmIWxjKXJldHVybiB1TihuKSxudWxsfWVsc2UgMiplSigpLXMucmVuZGVyaW5nU3RhcnRUaW1lPm91JiYxMDczNzQxODI0IT09dCYmKG4uZmxhZ3N8PTEyOCxyPSEwLHVQKHMsITEpLG4ubGFuZXM9NDE5NDMwNCl9cy5pc0JhY2t3YXJkcz8oYy5zaWJsaW5nPW4uY2hpbGQsbi5jaGlsZD1jKToobnVsbCE9PSh0PXMubGFzdCk/dC5zaWJsaW5nPWM6bi5jaGlsZD1jLHMubGFzdD1jKX1pZihudWxsIT09cy50YWlsKXJldHVybiBuPXMudGFpbCxzLnJlbmRlcmluZz1uLHMudGFpbD1uLnNpYmxpbmcscy5yZW5kZXJpbmdTdGFydFRpbWU9ZUooKSxuLnNpYmxpbmc9bnVsbCx0PWFyLmN1cnJlbnQsckIoYXIscj8xJnR8MjoxJnQpLG47cmV0dXJuIHVOKG4pLG51bGw7Y2FzZSAyMjpjYXNlIDIzOnJldHVybiBveigpLHI9bnVsbCE9PW4ubWVtb2l6ZWRTdGF0ZSxudWxsIT09ZSYmbnVsbCE9PWUubWVtb2l6ZWRTdGF0ZSE9PXImJihuLmZsYWdzfD04MTkyKSxyJiYwIT0oMSZuLm1vZGUpPzAhPSgxMDczNzQxODI0JnU2KSYmKHVOKG4pLDYmbi5zdWJ0cmVlRmxhZ3MmJihuLmZsYWdzfD04MTkyKSk6dU4obiksbnVsbDtjYXNlIDI0OmNhc2UgMjU6cmV0dXJuIG51bGx9dGhyb3cgRXJyb3IoZigxNTYsbi50YWcpKX0odCxuLHU2KSkpe3U0PXQ7cmV0dXJufX1lbHNle2lmKG51bGwhPT0odD1mdW5jdGlvbihlLG4pe3N3aXRjaChsbyhuKSxuLnRhZyl7Y2FzZSAxOnJldHVybiByWShuLnR5cGUpJiZyWCgpLDY1NTM2JihlPW4uZmxhZ3MpPyhuLmZsYWdzPS02NTUzNyZlfDEyOCxuKTpudWxsO2Nhc2UgMzpyZXR1cm4gYWUoKSxyaihyUSkscmooclcpLGF1KCksMCE9KDY1NTM2JihlPW4uZmxhZ3MpKSYmMD09KDEyOCZlKT8obi5mbGFncz0tNjU1MzcmZXwxMjgsbik6bnVsbDtjYXNlIDU6cmV0dXJuIGF0KG4pLG51bGw7Y2FzZSAxMzppZihyaihhciksbnVsbCE9PShlPW4ubWVtb2l6ZWRTdGF0ZSkmJm51bGwhPT1lLmRlaHlkcmF0ZWQpe2lmKG51bGw9PT1uLmFsdGVybmF0ZSl0aHJvdyBFcnJvcihmKDM0MCkpO2xiKCl9cmV0dXJuIDY1NTM2JihlPW4uZmxhZ3MpPyhuLmZsYWdzPS02NTUzNyZlfDEyOCxuKTpudWxsO2Nhc2UgMTk6cmV0dXJuIHJqKGFyKSxudWxsO2Nhc2UgNDpyZXR1cm4gYWUoKSxudWxsO2Nhc2UgMTA6cmV0dXJuIGxOKG4udHlwZS5fY29udGV4dCksbnVsbDtjYXNlIDIyOmNhc2UgMjM6cmV0dXJuIG96KCksbnVsbDtkZWZhdWx0OnJldHVybiBudWxsfX0odCxuKSkpe3QuZmxhZ3MmPTMyNzY3LHU0PXQ7cmV0dXJufWlmKG51bGwhPT1lKWUuZmxhZ3N8PTMyNzY4LGUuc3VidHJlZUZsYWdzPTAsZS5kZWxldGlvbnM9bnVsbDtlbHNle3U5PTYsdTQ9bnVsbDtyZXR1cm59fWlmKG51bGwhPT0obj1uLnNpYmxpbmcpKXt1ND1uO3JldHVybn11ND1uPWV9d2hpbGUobnVsbCE9PW4pOzA9PT11OSYmKHU5PTUpfWZ1bmN0aW9uIG9JKGUsbix0KXt2YXIgcj1uYyxsPXUxLnRyYW5zaXRpb247dHJ5e3UxLnRyYW5zaXRpb249bnVsbCxuYz0xLGZ1bmN0aW9uKGUsbix0LHIpe2RvIG9VKCk7d2hpbGUobnVsbCE9PW9kKTtpZigwIT0oNiZ1MikpdGhyb3cgRXJyb3IoZigzMjcpKTt0PWUuZmluaXNoZWRXb3JrO3ZhciBsPWUuZmluaXNoZWRMYW5lcztpZihudWxsIT09dCl7aWYoZS5maW5pc2hlZFdvcms9bnVsbCxlLmZpbmlzaGVkTGFuZXM9MCx0PT09ZS5jdXJyZW50KXRocm93IEVycm9yKGYoMTc3KSk7ZS5jYWxsYmFja05vZGU9bnVsbCxlLmNhbGxiYWNrUHJpb3JpdHk9MDt2YXIgYT10LmxhbmVzfHQuY2hpbGRMYW5lcztpZihmdW5jdGlvbihlLG4pe3ZhciB0PWUucGVuZGluZ0xhbmVzJn5uO2UucGVuZGluZ0xhbmVzPW4sZS5zdXNwZW5kZWRMYW5lcz0wLGUucGluZ2VkTGFuZXM9MCxlLmV4cGlyZWRMYW5lcyY9bixlLm11dGFibGVSZWFkTGFuZXMmPW4sZS5lbnRhbmdsZWRMYW5lcyY9bixuPWUuZW50YW5nbGVtZW50czt2YXIgcj1lLmV2ZW50VGltZXM7Zm9yKGU9ZS5leHBpcmF0aW9uVGltZXM7MDx0Oyl7dmFyIGw9MzEtZTkodCksYT0xPDxsO25bbF09MCxyW2xdPS0xLGVbbF09LTEsdCY9fmF9fShlLGEpLGU9PT11MyYmKHU0PXUzPW51bGwsdTg9MCksMD09KDIwNjQmdC5zdWJ0cmVlRmxhZ3MpJiYwPT0oMjA2NCZ0LmZsYWdzKXx8b2Z8fChvZj0hMCx1PWUzLG89ZnVuY3Rpb24oKXtyZXR1cm4gb1UoKSxudWxsfSxlWSh1LG8pKSxhPTAhPSgxNTk5MCZ0LmZsYWdzKSwwIT0oMTU5OTAmdC5zdWJ0cmVlRmxhZ3MpfHxhKXthPXUxLnRyYW5zaXRpb24sdTEudHJhbnNpdGlvbj1udWxsO3ZhciB1LG8saSxzLGMsZD1uYztuYz0xO3ZhciBwPXUyO3UyfD00LHUwLmN1cnJlbnQ9bnVsbCxmdW5jdGlvbihlLG4pe2lmKHJ2PW5PLHQkKGU9dEEoKSkpe2lmKCJzZWxlY3Rpb25TdGFydCJpbiBlKXZhciB0PXtzdGFydDplLnNlbGVjdGlvblN0YXJ0LGVuZDplLnNlbGVjdGlvbkVuZH07ZWxzZSBlOnt2YXIgcj0odD0odD1lLm93bmVyRG9jdW1lbnQpJiZ0LmRlZmF1bHRWaWV3fHx3aW5kb3cpLmdldFNlbGVjdGlvbiYmdC5nZXRTZWxlY3Rpb24oKTtpZihyJiYwIT09ci5yYW5nZUNvdW50KXt0PXIuYW5jaG9yTm9kZTt2YXIgbCxhPXIuYW5jaG9yT2Zmc2V0LHU9ci5mb2N1c05vZGU7cj1yLmZvY3VzT2Zmc2V0O3RyeXt0Lm5vZGVUeXBlLHUubm9kZVR5cGV9Y2F0Y2goZSl7dD1udWxsO2JyZWFrIGV9dmFyIG89MCxpPS0xLHM9LTEsYz0wLGQ9MCxwPWUsbT1udWxsO246Zm9yKDs7KXtmb3IoO3AhPT10fHwwIT09YSYmMyE9PXAubm9kZVR5cGV8fChpPW8rYSkscCE9PXV8fDAhPT1yJiYzIT09cC5ub2RlVHlwZXx8KHM9bytyKSwzPT09cC5ub2RlVHlwZSYmKG8rPXAubm9kZVZhbHVlLmxlbmd0aCksbnVsbCE9PShsPXAuZmlyc3RDaGlsZCk7KW09cCxwPWw7Zm9yKDs7KXtpZihwPT09ZSlicmVhayBuO2lmKG09PT10JiYrK2M9PT1hJiYoaT1vKSxtPT09dSYmKytkPT09ciYmKHM9byksbnVsbCE9PShsPXAubmV4dFNpYmxpbmcpKWJyZWFrO209KHA9bSkucGFyZW50Tm9kZX1wPWx9dD0tMT09PWl8fC0xPT09cz9udWxsOntzdGFydDppLGVuZDpzfX1lbHNlIHQ9bnVsbH10PXR8fHtzdGFydDowLGVuZDowfX1lbHNlIHQ9bnVsbDtmb3Iocnk9e2ZvY3VzZWRFbGVtOmUsc2VsZWN0aW9uUmFuZ2U6dH0sbk89ITEsdVI9bjtudWxsIT09dVI7KWlmKGU9KG49dVIpLmNoaWxkLDAhPSgxMDI4Jm4uc3VidHJlZUZsYWdzKSYmbnVsbCE9PWUpZS5yZXR1cm49bix1Uj1lO2Vsc2UgZm9yKDtudWxsIT09dVI7KXtuPXVSO3RyeXt2YXIgaD1uLmFsdGVybmF0ZTtpZigwIT0oMTAyNCZuLmZsYWdzKSlzd2l0Y2gobi50YWcpe2Nhc2UgMDpjYXNlIDExOmNhc2UgMTU6Y2FzZSA1OmNhc2UgNjpjYXNlIDQ6Y2FzZSAxNzpicmVhaztjYXNlIDE6aWYobnVsbCE9PWgpe3ZhciBnPWgubWVtb2l6ZWRQcm9wcyx2PWgubWVtb2l6ZWRTdGF0ZSx5PW4uc3RhdGVOb2RlLGI9eS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShuLmVsZW1lbnRUeXBlPT09bi50eXBlP2c6bFMobi50eXBlLGcpLHYpO3kuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGU9Yn1icmVhaztjYXNlIDM6dmFyIGs9bi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbzsxPT09ay5ub2RlVHlwZT9rLnRleHRDb250ZW50PSIiOjk9PT1rLm5vZGVUeXBlJiZrLmRvY3VtZW50RWxlbWVudCYmay5yZW1vdmVDaGlsZChrLmRvY3VtZW50RWxlbWVudCk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihmKDE2MykpfX1jYXRjaChlKXtvQShuLG4ucmV0dXJuLGUpfWlmKG51bGwhPT0oZT1uLnNpYmxpbmcpKXtlLnJldHVybj1uLnJldHVybix1Uj1lO2JyZWFrfXVSPW4ucmV0dXJufWg9dU8sdU89ITF9KGUsdCksdXEodCxlKSxmdW5jdGlvbihlKXt2YXIgbj10QSgpLHQ9ZS5mb2N1c2VkRWxlbSxyPWUuc2VsZWN0aW9uUmFuZ2U7aWYobiE9PXQmJnQmJnQub3duZXJEb2N1bWVudCYmZnVuY3Rpb24gZShuLHQpe3JldHVybiEhbiYmISF0JiYobj09PXR8fCghbnx8MyE9PW4ubm9kZVR5cGUpJiYodCYmMz09PXQubm9kZVR5cGU/ZShuLHQucGFyZW50Tm9kZSk6ImNvbnRhaW5zImluIG4/bi5jb250YWlucyh0KTohIW4uY29tcGFyZURvY3VtZW50UG9zaXRpb24mJiEhKDE2Jm4uY29tcGFyZURvY3VtZW50UG9zaXRpb24odCkpKSl9KHQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsdCkpe2lmKG51bGwhPT1yJiZ0JCh0KSl7aWYobj1yLnN0YXJ0LHZvaWQgMD09PShlPXIuZW5kKSYmKGU9biksInNlbGVjdGlvblN0YXJ0ImluIHQpdC5zZWxlY3Rpb25TdGFydD1uLHQuc2VsZWN0aW9uRW5kPU1hdGgubWluKGUsdC52YWx1ZS5sZW5ndGgpO2Vsc2UgaWYoKGU9KG49dC5vd25lckRvY3VtZW50fHxkb2N1bWVudCkmJm4uZGVmYXVsdFZpZXd8fHdpbmRvdykuZ2V0U2VsZWN0aW9uKXtlPWUuZ2V0U2VsZWN0aW9uKCk7dmFyIGw9dC50ZXh0Q29udGVudC5sZW5ndGgsYT1NYXRoLm1pbihyLnN0YXJ0LGwpO3I9dm9pZCAwPT09ci5lbmQ/YTpNYXRoLm1pbihyLmVuZCxsKSwhZS5leHRlbmQmJmE+ciYmKGw9cixyPWEsYT1sKSxsPXRWKHQsYSk7dmFyIHU9dFYodCxyKTtsJiZ1JiYoMSE9PWUucmFuZ2VDb3VudHx8ZS5hbmNob3JOb2RlIT09bC5ub2RlfHxlLmFuY2hvck9mZnNldCE9PWwub2Zmc2V0fHxlLmZvY3VzTm9kZSE9PXUubm9kZXx8ZS5mb2N1c09mZnNldCE9PXUub2Zmc2V0KSYmKChuPW4uY3JlYXRlUmFuZ2UoKSkuc2V0U3RhcnQobC5ub2RlLGwub2Zmc2V0KSxlLnJlbW92ZUFsbFJhbmdlcygpLGE+cj8oZS5hZGRSYW5nZShuKSxlLmV4dGVuZCh1Lm5vZGUsdS5vZmZzZXQpKToobi5zZXRFbmQodS5ub2RlLHUub2Zmc2V0KSxlLmFkZFJhbmdlKG4pKSl9fWZvcihuPVtdLGU9dDtlPWUucGFyZW50Tm9kZTspMT09PWUubm9kZVR5cGUmJm4ucHVzaCh7ZWxlbWVudDplLGxlZnQ6ZS5zY3JvbGxMZWZ0LHRvcDplLnNjcm9sbFRvcH0pO2ZvcigiZnVuY3Rpb24iPT10eXBlb2YgdC5mb2N1cyYmdC5mb2N1cygpLHQ9MDt0PG4ubGVuZ3RoO3QrKykoZT1uW3RdKS5lbGVtZW50LnNjcm9sbExlZnQ9ZS5sZWZ0LGUuZWxlbWVudC5zY3JvbGxUb3A9ZS50b3B9fShyeSksbk89ISFydixyeT1ydj1udWxsLGUuY3VycmVudD10LGk9dCxzPWUsYz1sLHVSPWksZnVuY3Rpb24gZShuLHQscil7Zm9yKHZhciBsPTAhPSgxJm4ubW9kZSk7bnVsbCE9PXVSOyl7dmFyIGE9dVIsdT1hLmNoaWxkO2lmKDIyPT09YS50YWcmJmwpe3ZhciBvPW51bGwhPT1hLm1lbW9pemVkU3RhdGV8fHV6O2lmKCFvKXt2YXIgaT1hLmFsdGVybmF0ZSxzPW51bGwhPT1pJiZudWxsIT09aS5tZW1vaXplZFN0YXRlfHx1VDtpPXV6O3ZhciBjPXVUO2lmKHV6PW8sKHVUPXMpJiYhYylmb3IodVI9YTtudWxsIT09dVI7KXM9KG89dVIpLmNoaWxkLDIyPT09by50YWcmJm51bGwhPT1vLm1lbW9pemVkU3RhdGU/dUcoYSk6bnVsbCE9PXM/KHMucmV0dXJuPW8sdVI9cyk6dUcoYSk7Zm9yKDtudWxsIT09dTspdVI9dSxlKHUsdCxyKSx1PXUuc2libGluZzt1Uj1hLHV6PWksdVQ9Y311WShuLHQscil9ZWxzZSAwIT0oODc3MiZhLnN1YnRyZWVGbGFncykmJm51bGwhPT11Pyh1LnJldHVybj1hLHVSPXUpOnVZKG4sdCxyKX19KGkscyxjKSxlWigpLHUyPXAsbmM9ZCx1MS50cmFuc2l0aW9uPWF9ZWxzZSBlLmN1cnJlbnQ9dDtpZihvZiYmKG9mPSExLG9kPWUsb3A9bCksMD09PShhPWUucGVuZGluZ0xhbmVzKSYmKG9jPW51bGwpLGZ1bmN0aW9uKGUpe2lmKGU1JiYiZnVuY3Rpb24iPT10eXBlb2YgZTUub25Db21taXRGaWJlclJvb3QpdHJ5e2U1Lm9uQ29tbWl0RmliZXJSb290KGU2LGUsdm9pZCAwLDEyOD09KDEyOCZlLmN1cnJlbnQuZmxhZ3MpKX1jYXRjaChlKXt9fSh0LnN0YXRlTm9kZSxyKSxvdyhlLGVKKCkpLG51bGwhPT1uKWZvcihyPWUub25SZWNvdmVyYWJsZUVycm9yLHQ9MDt0PG4ubGVuZ3RoO3QrKylyKChsPW5bdF0pLnZhbHVlLHtjb21wb25lbnRTdGFjazpsLnN0YWNrLGRpZ2VzdDpsLmRpZ2VzdH0pO2lmKG9pKXRocm93IG9pPSExLGU9b3Msb3M9bnVsbCxlOzAhPSgxJm9wKSYmMCE9PWUudGFnJiZvVSgpLDAhPSgxJihhPWUucGVuZGluZ0xhbmVzKSk/ZT09PW9oP29tKys6KG9tPTAsb2g9ZSk6b209MCxyNCgpfX0oZSxuLHQscil9ZmluYWxseXt1MS50cmFuc2l0aW9uPWwsbmM9cn1yZXR1cm4gbnVsbH1mdW5jdGlvbiBvVSgpe2lmKG51bGwhPT1vZCl7dmFyIGU9bmYob3ApLG49dTEudHJhbnNpdGlvbix0PW5jO3RyeXtpZih1MS50cmFuc2l0aW9uPW51bGwsbmM9MTY+ZT8xNjplLG51bGw9PT1vZCl2YXIgcj0hMTtlbHNle2lmKGU9b2Qsb2Q9bnVsbCxvcD0wLDAhPSg2JnUyKSl0aHJvdyBFcnJvcihmKDMzMSkpO3ZhciBsPXUyO2Zvcih1Mnw9NCx1Uj1lLmN1cnJlbnQ7bnVsbCE9PXVSOyl7dmFyIGE9dVIsdT1hLmNoaWxkO2lmKDAhPSgxNiZ1Ui5mbGFncykpe3ZhciBvPWEuZGVsZXRpb25zO2lmKG51bGwhPT1vKXtmb3IodmFyIGk9MDtpPG8ubGVuZ3RoO2krKyl7dmFyIHM9b1tpXTtmb3IodVI9cztudWxsIT09dVI7KXt2YXIgYz11Ujtzd2l0Y2goYy50YWcpe2Nhc2UgMDpjYXNlIDExOmNhc2UgMTU6dUQoOCxjLGEpfXZhciBkPWMuY2hpbGQ7aWYobnVsbCE9PWQpZC5yZXR1cm49Yyx1Uj1kO2Vsc2UgZm9yKDtudWxsIT09dVI7KXt2YXIgcD0oYz11Uikuc2libGluZyxtPWMucmV0dXJuO2lmKCFmdW5jdGlvbiBlKG4pe3ZhciB0PW4uYWx0ZXJuYXRlO251bGwhPT10JiYobi5hbHRlcm5hdGU9bnVsbCxlKHQpKSxuLmNoaWxkPW51bGwsbi5kZWxldGlvbnM9bnVsbCxuLnNpYmxpbmc9bnVsbCw1PT09bi50YWcmJm51bGwhPT0odD1uLnN0YXRlTm9kZSkmJihkZWxldGUgdFtyel0sZGVsZXRlIHRbclRdLGRlbGV0ZSB0W3JSXSxkZWxldGUgdFtyTV0sZGVsZXRlIHRbckZdKSxuLnN0YXRlTm9kZT1udWxsLG4ucmV0dXJuPW51bGwsbi5kZXBlbmRlbmNpZXM9bnVsbCxuLm1lbW9pemVkUHJvcHM9bnVsbCxuLm1lbW9pemVkU3RhdGU9bnVsbCxuLnBlbmRpbmdQcm9wcz1udWxsLG4uc3RhdGVOb2RlPW51bGwsbi51cGRhdGVRdWV1ZT1udWxsfShjKSxjPT09cyl7dVI9bnVsbDticmVha31pZihudWxsIT09cCl7cC5yZXR1cm49bSx1Uj1wO2JyZWFrfXVSPW19fX12YXIgaD1hLmFsdGVybmF0ZTtpZihudWxsIT09aCl7dmFyIGc9aC5jaGlsZDtpZihudWxsIT09Zyl7aC5jaGlsZD1udWxsO2Rve3ZhciB2PWcuc2libGluZztnLnNpYmxpbmc9bnVsbCxnPXZ9d2hpbGUobnVsbCE9PWcpfX11Uj1hfX1pZigwIT0oMjA2NCZhLnN1YnRyZWVGbGFncykmJm51bGwhPT11KXUucmV0dXJuPWEsdVI9dTtlbHNlIGZvcig7bnVsbCE9PXVSOyl7aWYoYT11UiwwIT0oMjA0OCZhLmZsYWdzKSlzd2l0Y2goYS50YWcpe2Nhc2UgMDpjYXNlIDExOmNhc2UgMTU6dUQoOSxhLGEucmV0dXJuKX12YXIgeT1hLnNpYmxpbmc7aWYobnVsbCE9PXkpe3kucmV0dXJuPWEucmV0dXJuLHVSPXk7YnJlYWt9dVI9YS5yZXR1cm59fXZhciBiPWUuY3VycmVudDtmb3IodVI9YjtudWxsIT09dVI7KXt2YXIgaz0odT11UikuY2hpbGQ7aWYoMCE9KDIwNjQmdS5zdWJ0cmVlRmxhZ3MpJiZudWxsIT09aylrLnJldHVybj11LHVSPWs7ZWxzZSBmb3IodT1iO251bGwhPT11Ujspe2lmKG89dVIsMCE9KDIwNDgmby5mbGFncykpdHJ5e3N3aXRjaChvLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNTp1SSg5LG8pfX1jYXRjaChlKXtvQShvLG8ucmV0dXJuLGUpfWlmKG89PT11KXt1Uj1udWxsO2JyZWFrfXZhciB3PW8uc2libGluZztpZihudWxsIT09dyl7dy5yZXR1cm49by5yZXR1cm4sdVI9dzticmVha311Uj1vLnJldHVybn19aWYodTI9bCxyNCgpLGU1JiYiZnVuY3Rpb24iPT10eXBlb2YgZTUub25Qb3N0Q29tbWl0RmliZXJSb290KXRyeXtlNS5vblBvc3RDb21taXRGaWJlclJvb3QoZTYsZSl9Y2F0Y2goZSl7fXI9ITB9cmV0dXJuIHJ9ZmluYWxseXtuYz10LHUxLnRyYW5zaXRpb249bn19cmV0dXJuITF9ZnVuY3Rpb24gb1YoZSxuLHQpe249YTgodCxuKSxuPWE3KGUsbiwxKSxlPWxBKGUsbiwxKSxuPW95KCksbnVsbCE9PWUmJihuaShlLDEsbiksb3coZSxuKSl9ZnVuY3Rpb24gb0EoZSxuLHQpe2lmKDM9PT1lLnRhZylvVihlLGUsdCk7ZWxzZSBmb3IoO251bGwhPT1uOyl7aWYoMz09PW4udGFnKXtvVihuLGUsdCk7YnJlYWt9aWYoMT09PW4udGFnKXt2YXIgcj1uLnN0YXRlTm9kZTtpZigiZnVuY3Rpb24iPT10eXBlb2Ygbi50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcnx8ImZ1bmN0aW9uIj09dHlwZW9mIHIuY29tcG9uZW50RGlkQ2F0Y2gmJihudWxsPT09b2N8fCFvYy5oYXMocikpKXtlPWE4KHQsZSksZT11ZShuLGUsMSksbj1sQShuLGUsMSksZT1veSgpLG51bGwhPT1uJiYobmkobiwxLGUpLG93KG4sZSkpO2JyZWFrfX1uPW4ucmV0dXJufX1mdW5jdGlvbiBvJChlLG4sdCl7dmFyIHI9ZS5waW5nQ2FjaGU7bnVsbCE9PXImJnIuZGVsZXRlKG4pLG49b3koKSxlLnBpbmdlZExhbmVzfD1lLnN1c3BlbmRlZExhbmVzJnQsdTM9PT1lJiYodTgmdCk9PT10JiYoND09PXU5fHwzPT09dTkmJigxMzAwMjM0MjQmdTgpPT09dTgmJjUwMD5lSigpLW9hP29UKGUsMCk6b3R8PXQpLG93KGUsbil9ZnVuY3Rpb24gb2ooZSxuKXswPT09biYmKDA9PSgxJmUubW9kZSk/bj0xOihuPW50LDA9PSgxMzAwMjM0MjQmKG50PDw9MSkpJiYobnQ9NDE5NDMwNCkpKTt2YXIgdD1veSgpO251bGwhPT0oZT1sTyhlLG4pKSYmKG5pKGUsbix0KSxvdyhlLHQpKX1mdW5jdGlvbiBvQihlKXt2YXIgbj1lLm1lbW9pemVkU3RhdGUsdD0wO251bGwhPT1uJiYodD1uLnJldHJ5TGFuZSksb2ooZSx0KX1mdW5jdGlvbiBvSChlLG4pe3ZhciB0PTA7c3dpdGNoKGUudGFnKXtjYXNlIDEzOnZhciByPWUuc3RhdGVOb2RlLGw9ZS5tZW1vaXplZFN0YXRlO251bGwhPT1sJiYodD1sLnJldHJ5TGFuZSk7YnJlYWs7Y2FzZSAxOTpyPWUuc3RhdGVOb2RlO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoZigzMTQpKX1udWxsIT09ciYmci5kZWxldGUobiksb2ooZSx0KX1mdW5jdGlvbiBvVyhlLG4sdCxyKXt0aGlzLnRhZz1lLHRoaXMua2V5PXQsdGhpcy5zaWJsaW5nPXRoaXMuY2hpbGQ9dGhpcy5yZXR1cm49dGhpcy5zdGF0ZU5vZGU9dGhpcy50eXBlPXRoaXMuZWxlbWVudFR5cGU9bnVsbCx0aGlzLmluZGV4PTAsdGhpcy5yZWY9bnVsbCx0aGlzLnBlbmRpbmdQcm9wcz1uLHRoaXMuZGVwZW5kZW5jaWVzPXRoaXMubWVtb2l6ZWRTdGF0ZT10aGlzLnVwZGF0ZVF1ZXVlPXRoaXMubWVtb2l6ZWRQcm9wcz1udWxsLHRoaXMubW9kZT1yLHRoaXMuc3VidHJlZUZsYWdzPXRoaXMuZmxhZ3M9MCx0aGlzLmRlbGV0aW9ucz1udWxsLHRoaXMuY2hpbGRMYW5lcz10aGlzLmxhbmVzPTAsdGhpcy5hbHRlcm5hdGU9bnVsbH1mdW5jdGlvbiBvUShlLG4sdCxyKXtyZXR1cm4gbmV3IG9XKGUsbix0LHIpfWZ1bmN0aW9uIG9xKGUpe3JldHVybiEoIShlPWUucHJvdG90eXBlKXx8IWUuaXNSZWFjdENvbXBvbmVudCl9ZnVuY3Rpb24gb0soZSxuKXt2YXIgdD1lLmFsdGVybmF0ZTtyZXR1cm4gbnVsbD09PXQ/KCh0PW9RKGUudGFnLG4sZS5rZXksZS5tb2RlKSkuZWxlbWVudFR5cGU9ZS5lbGVtZW50VHlwZSx0LnR5cGU9ZS50eXBlLHQuc3RhdGVOb2RlPWUuc3RhdGVOb2RlLHQuYWx0ZXJuYXRlPWUsZS5hbHRlcm5hdGU9dCk6KHQucGVuZGluZ1Byb3BzPW4sdC50eXBlPWUudHlwZSx0LmZsYWdzPTAsdC5zdWJ0cmVlRmxhZ3M9MCx0LmRlbGV0aW9ucz1udWxsKSx0LmZsYWdzPTE0NjgwMDY0JmUuZmxhZ3MsdC5jaGlsZExhbmVzPWUuY2hpbGRMYW5lcyx0LmxhbmVzPWUubGFuZXMsdC5jaGlsZD1lLmNoaWxkLHQubWVtb2l6ZWRQcm9wcz1lLm1lbW9pemVkUHJvcHMsdC5tZW1vaXplZFN0YXRlPWUubWVtb2l6ZWRTdGF0ZSx0LnVwZGF0ZVF1ZXVlPWUudXBkYXRlUXVldWUsbj1lLmRlcGVuZGVuY2llcyx0LmRlcGVuZGVuY2llcz1udWxsPT09bj9udWxsOntsYW5lczpuLmxhbmVzLGZpcnN0Q29udGV4dDpuLmZpcnN0Q29udGV4dH0sdC5zaWJsaW5nPWUuc2libGluZyx0LmluZGV4PWUuaW5kZXgsdC5yZWY9ZS5yZWYsdH1mdW5jdGlvbiBvWShlLG4sdCxyLGwsYSl7dmFyIHU9MjtpZihyPWUsImZ1bmN0aW9uIj09dHlwZW9mIGUpb3EoZSkmJih1PTEpO2Vsc2UgaWYoInN0cmluZyI9PXR5cGVvZiBlKXU9NTtlbHNlIGU6c3dpdGNoKGUpe2Nhc2UgejpyZXR1cm4gb1godC5jaGlsZHJlbixsLGEsbik7Y2FzZSBUOnU9OCxsfD04O2JyZWFrO2Nhc2UgTDpyZXR1cm4oZT1vUSgxMix0LG4sMnxsKSkuZWxlbWVudFR5cGU9TCxlLmxhbmVzPWEsZTtjYXNlIE86cmV0dXJuKGU9b1EoMTMsdCxuLGwpKS5lbGVtZW50VHlwZT1PLGUubGFuZXM9YSxlO2Nhc2UgRDpyZXR1cm4oZT1vUSgxOSx0LG4sbCkpLmVsZW1lbnRUeXBlPUQsZS5sYW5lcz1hLGU7Y2FzZSBWOnJldHVybiBvRyh0LGwsYSxuKTtkZWZhdWx0OmlmKCJvYmplY3QiPT10eXBlb2YgZSYmbnVsbCE9PWUpc3dpdGNoKGUuJCR0eXBlb2Ype2Nhc2UgUjp1PTEwO2JyZWFrIGU7Y2FzZSBNOnU9OTticmVhayBlO2Nhc2UgRjp1PTExO2JyZWFrIGU7Y2FzZSBJOnU9MTQ7YnJlYWsgZTtjYXNlIFU6dT0xNixyPW51bGw7YnJlYWsgZX10aHJvdyBFcnJvcihmKDEzMCxudWxsPT1lP2U6dHlwZW9mIGUsIiIpKX1yZXR1cm4obj1vUSh1LHQsbixsKSkuZWxlbWVudFR5cGU9ZSxuLnR5cGU9cixuLmxhbmVzPWEsbn1mdW5jdGlvbiBvWChlLG4sdCxyKXtyZXR1cm4oZT1vUSg3LGUscixuKSkubGFuZXM9dCxlfWZ1bmN0aW9uIG9HKGUsbix0LHIpe3JldHVybihlPW9RKDIyLGUscixuKSkuZWxlbWVudFR5cGU9VixlLmxhbmVzPXQsZS5zdGF0ZU5vZGU9e2lzSGlkZGVuOiExfSxlfWZ1bmN0aW9uIG9aKGUsbix0KXtyZXR1cm4oZT1vUSg2LGUsbnVsbCxuKSkubGFuZXM9dCxlfWZ1bmN0aW9uIG9KKGUsbix0KXtyZXR1cm4obj1vUSg0LG51bGwhPT1lLmNoaWxkcmVuP2UuY2hpbGRyZW46W10sZS5rZXksbikpLmxhbmVzPXQsbi5zdGF0ZU5vZGU9e2NvbnRhaW5lckluZm86ZS5jb250YWluZXJJbmZvLHBlbmRpbmdDaGlsZHJlbjpudWxsLGltcGxlbWVudGF0aW9uOmUuaW1wbGVtZW50YXRpb259LG59ZnVuY3Rpb24gbzAoZSxuLHQscixsKXt0aGlzLnRhZz1uLHRoaXMuY29udGFpbmVySW5mbz1lLHRoaXMuZmluaXNoZWRXb3JrPXRoaXMucGluZ0NhY2hlPXRoaXMuY3VycmVudD10aGlzLnBlbmRpbmdDaGlsZHJlbj1udWxsLHRoaXMudGltZW91dEhhbmRsZT0tMSx0aGlzLmNhbGxiYWNrTm9kZT10aGlzLnBlbmRpbmdDb250ZXh0PXRoaXMuY29udGV4dD1udWxsLHRoaXMuY2FsbGJhY2tQcmlvcml0eT0wLHRoaXMuZXZlbnRUaW1lcz1ubygwKSx0aGlzLmV4cGlyYXRpb25UaW1lcz1ubygtMSksdGhpcy5lbnRhbmdsZWRMYW5lcz10aGlzLmZpbmlzaGVkTGFuZXM9dGhpcy5tdXRhYmxlUmVhZExhbmVzPXRoaXMuZXhwaXJlZExhbmVzPXRoaXMucGluZ2VkTGFuZXM9dGhpcy5zdXNwZW5kZWRMYW5lcz10aGlzLnBlbmRpbmdMYW5lcz0wLHRoaXMuZW50YW5nbGVtZW50cz1ubygwKSx0aGlzLmlkZW50aWZpZXJQcmVmaXg9cix0aGlzLm9uUmVjb3ZlcmFibGVFcnJvcj1sLHRoaXMubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YT1udWxsfWZ1bmN0aW9uIG8xKGUsbix0LHIsbCxhLHUsbyxpKXtyZXR1cm4gZT1uZXcgbzAoZSxuLHQsbyxpKSwxPT09bj8obj0xLCEwPT09YSYmKG58PTgpKTpuPTAsYT1vUSgzLG51bGwsbnVsbCxuKSxlLmN1cnJlbnQ9YSxhLnN0YXRlTm9kZT1lLGEubWVtb2l6ZWRTdGF0ZT17ZWxlbWVudDpyLGlzRGVoeWRyYXRlZDp0LGNhY2hlOm51bGwsdHJhbnNpdGlvbnM6bnVsbCxwZW5kaW5nU3VzcGVuc2VCb3VuZGFyaWVzOm51bGx9LGxJKGEpLGV9ZnVuY3Rpb24gbzIoZSl7aWYoIWUpcmV0dXJuIHJIO2U9ZS5fcmVhY3RJbnRlcm5hbHM7ZTp7aWYoZVcoZSkhPT1lfHwxIT09ZS50YWcpdGhyb3cgRXJyb3IoZigxNzApKTt2YXIgbj1lO2Rve3N3aXRjaChuLnRhZyl7Y2FzZSAzOm49bi5zdGF0ZU5vZGUuY29udGV4dDticmVhayBlO2Nhc2UgMTppZihyWShuLnR5cGUpKXtuPW4uc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O2JyZWFrIGV9fW49bi5yZXR1cm59d2hpbGUobnVsbCE9PW4pO3Rocm93IEVycm9yKGYoMTcxKSl9aWYoMT09PWUudGFnKXt2YXIgdD1lLnR5cGU7aWYoclkodCkpcmV0dXJuIHJaKGUsdCxuKX1yZXR1cm4gbn1mdW5jdGlvbiBvMyhlLG4sdCxyLGwsYSx1LG8saSl7cmV0dXJuKGU9bzEodCxyLCEwLGUsbCxhLHUsbyxpKSkuY29udGV4dD1vMihudWxsKSx0PWUuY3VycmVudCwoYT1sVihyPW95KCksbD1vYih0KSkpLmNhbGxiYWNrPW51bGwhPW4/bjpudWxsLGxBKHQsYSxsKSxlLmN1cnJlbnQubGFuZXM9bCxuaShlLGwsciksb3coZSxyKSxlfWZ1bmN0aW9uIG80KGUsbix0LHIpe3ZhciBsPW4uY3VycmVudCxhPW95KCksdT1vYihsKTtyZXR1cm4gdD1vMih0KSxudWxsPT09bi5jb250ZXh0P24uY29udGV4dD10Om4ucGVuZGluZ0NvbnRleHQ9dCwobj1sVihhLHUpKS5wYXlsb2FkPXtlbGVtZW50OmV9LG51bGwhPT0ocj12b2lkIDA9PT1yP251bGw6cikmJihuLmNhbGxiYWNrPXIpLG51bGwhPT0oZT1sQShsLG4sdSkpJiYob2soZSxsLHUsYSksbCQoZSxsLHUpKSx1fWZ1bmN0aW9uIG84KGUpe3JldHVybihlPWUuY3VycmVudCkuY2hpbGQ/KGUuY2hpbGQudGFnLGUuY2hpbGQuc3RhdGVOb2RlKTpudWxsfWZ1bmN0aW9uIG82KGUsbil7aWYobnVsbCE9PShlPWUubWVtb2l6ZWRTdGF0ZSkmJm51bGwhPT1lLmRlaHlkcmF0ZWQpe3ZhciB0PWUucmV0cnlMYW5lO2UucmV0cnlMYW5lPTAhPT10JiZ0PG4/dDpufX1mdW5jdGlvbiBvNShlLG4pe282KGUsbiksKGU9ZS5hbHRlcm5hdGUpJiZvNihlLG4pfWk9ZnVuY3Rpb24oZSxuLHQpe2lmKG51bGwhPT1lKXtpZihlLm1lbW9pemVkUHJvcHMhPT1uLnBlbmRpbmdQcm9wc3x8clEuY3VycmVudCl1YT0hMDtlbHNle2lmKDA9PShlLmxhbmVzJnQpJiYwPT0oMTI4Jm4uZmxhZ3MpKXJldHVybiB1YT0hMSxmdW5jdGlvbihlLG4sdCl7c3dpdGNoKG4udGFnKXtjYXNlIDM6dWgobiksbGIoKTticmVhaztjYXNlIDU6YW4obik7YnJlYWs7Y2FzZSAxOnJZKG4udHlwZSkmJnJKKG4pO2JyZWFrO2Nhc2UgNDpsNyhuLG4uc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO2JyZWFrO2Nhc2UgMTA6dmFyIHI9bi50eXBlLl9jb250ZXh0LGw9bi5tZW1vaXplZFByb3BzLnZhbHVlO3JCKGx4LHIuX2N1cnJlbnRWYWx1ZSksci5fY3VycmVudFZhbHVlPWw7YnJlYWs7Y2FzZSAxMzppZihudWxsIT09KHI9bi5tZW1vaXplZFN0YXRlKSl7aWYobnVsbCE9PXIuZGVoeWRyYXRlZClyZXR1cm4gckIoYXIsMSZhci5jdXJyZW50KSxuLmZsYWdzfD0xMjgsbnVsbDtpZigwIT0odCZuLmNoaWxkLmNoaWxkTGFuZXMpKXJldHVybiB1YihlLG4sdCk7cmV0dXJuIHJCKGFyLDEmYXIuY3VycmVudCksbnVsbCE9PShlPXVfKGUsbix0KSk/ZS5zaWJsaW5nOm51bGx9ckIoYXIsMSZhci5jdXJyZW50KTticmVhaztjYXNlIDE5OmlmKHI9MCE9KHQmbi5jaGlsZExhbmVzKSwwIT0oMTI4JmUuZmxhZ3MpKXtpZihyKXJldHVybiB1RShlLG4sdCk7bi5mbGFnc3w9MTI4fWlmKG51bGwhPT0obD1uLm1lbW9pemVkU3RhdGUpJiYobC5yZW5kZXJpbmc9bnVsbCxsLnRhaWw9bnVsbCxsLmxhc3RFZmZlY3Q9bnVsbCksckIoYXIsYXIuY3VycmVudCksIXIpcmV0dXJuIG51bGw7YnJlYWs7Y2FzZSAyMjpjYXNlIDIzOnJldHVybiBuLmxhbmVzPTAsdWMoZSxuLHQpfXJldHVybiB1XyhlLG4sdCl9KGUsbix0KTt1YT0wIT0oMTMxMDcyJmUuZmxhZ3MpfX1lbHNlIHVhPSExLGxjJiYwIT0oMTA0ODU3NiZuLmZsYWdzKSYmbGEobixyOSxuLmluZGV4KTtzd2l0Y2gobi5sYW5lcz0wLG4udGFnKXtjYXNlIDI6dmFyIHI9bi50eXBlO3VDKGUsbiksZT1uLnBlbmRpbmdQcm9wczt2YXIgbD1ySyhuLHJXLmN1cnJlbnQpO2xUKG4sdCksbD1hYihudWxsLG4scixlLGwsdCk7dmFyIGE9YWsoKTtyZXR1cm4gbi5mbGFnc3w9MSwib2JqZWN0Ij09dHlwZW9mIGwmJm51bGwhPT1sJiYiZnVuY3Rpb24iPT10eXBlb2YgbC5yZW5kZXImJnZvaWQgMD09PWwuJCR0eXBlb2Y/KG4udGFnPTEsbi5tZW1vaXplZFN0YXRlPW51bGwsbi51cGRhdGVRdWV1ZT1udWxsLHJZKHIpPyhhPSEwLHJKKG4pKTphPSExLG4ubWVtb2l6ZWRTdGF0ZT1udWxsIT09bC5zdGF0ZSYmdm9pZCAwIT09bC5zdGF0ZT9sLnN0YXRlOm51bGwsbEkobiksbC51cGRhdGVyPWxxLG4uc3RhdGVOb2RlPWwsbC5fcmVhY3RJbnRlcm5hbHM9bixsRyhuLHIsZSx0KSxuPXVtKG51bGwsbixyLCEwLGEsdCkpOihuLnRhZz0wLGxjJiZhJiZsdShuKSx1dShudWxsLG4sbCx0KSxuPW4uY2hpbGQpLG47Y2FzZSAxNjpyPW4uZWxlbWVudFR5cGU7ZTp7c3dpdGNoKHVDKGUsbiksZT1uLnBlbmRpbmdQcm9wcyxyPShsPXIuX2luaXQpKHIuX3BheWxvYWQpLG4udHlwZT1yLGw9bi50YWc9ZnVuY3Rpb24oZSl7aWYoImZ1bmN0aW9uIj09dHlwZW9mIGUpcmV0dXJuIG9xKGUpPzE6MDtpZihudWxsIT1lKXtpZigoZT1lLiQkdHlwZW9mKT09PUYpcmV0dXJuIDExO2lmKGU9PT1JKXJldHVybiAxNH1yZXR1cm4gMn0ociksZT1sUyhyLGUpLGwpe2Nhc2UgMDpuPXVkKG51bGwsbixyLGUsdCk7YnJlYWsgZTtjYXNlIDE6bj11cChudWxsLG4scixlLHQpO2JyZWFrIGU7Y2FzZSAxMTpuPXVvKG51bGwsbixyLGUsdCk7YnJlYWsgZTtjYXNlIDE0Om49dWkobnVsbCxuLHIsbFMoci50eXBlLGUpLHQpO2JyZWFrIGV9dGhyb3cgRXJyb3IoZigzMDYsciwiIikpfXJldHVybiBuO2Nhc2UgMDpyZXR1cm4gcj1uLnR5cGUsbD1uLnBlbmRpbmdQcm9wcyxsPW4uZWxlbWVudFR5cGU9PT1yP2w6bFMocixsKSx1ZChlLG4scixsLHQpO2Nhc2UgMTpyZXR1cm4gcj1uLnR5cGUsbD1uLnBlbmRpbmdQcm9wcyxsPW4uZWxlbWVudFR5cGU9PT1yP2w6bFMocixsKSx1cChlLG4scixsLHQpO2Nhc2UgMzplOntpZih1aChuKSxudWxsPT09ZSl0aHJvdyBFcnJvcihmKDM4NykpO3I9bi5wZW5kaW5nUHJvcHMsbD0oYT1uLm1lbW9pemVkU3RhdGUpLmVsZW1lbnQsbFUoZSxuKSxsQihuLHIsbnVsbCx0KTt2YXIgdT1uLm1lbW9pemVkU3RhdGU7aWYocj11LmVsZW1lbnQsYS5pc0RlaHlkcmF0ZWQpe2lmKGE9e2VsZW1lbnQ6cixpc0RlaHlkcmF0ZWQ6ITEsY2FjaGU6dS5jYWNoZSxwZW5kaW5nU3VzcGVuc2VCb3VuZGFyaWVzOnUucGVuZGluZ1N1c3BlbnNlQm91bmRhcmllcyx0cmFuc2l0aW9uczp1LnRyYW5zaXRpb25zfSxuLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZT1hLG4ubWVtb2l6ZWRTdGF0ZT1hLDI1NiZuLmZsYWdzKXtsPWE4KEVycm9yKGYoNDIzKSksbiksbj11ZyhlLG4scix0LGwpO2JyZWFrIGV9aWYociE9PWwpe2w9YTgoRXJyb3IoZig0MjQpKSxuKSxuPXVnKGUsbixyLHQsbCk7YnJlYWsgZX1mb3IobHM9cl8obi5zdGF0ZU5vZGUuY29udGFpbmVySW5mby5maXJzdENoaWxkKSxsaT1uLGxjPSEwLGxmPW51bGwsdD1sMyhuLG51bGwscix0KSxuLmNoaWxkPXQ7dDspdC5mbGFncz0tMyZ0LmZsYWdzfDQwOTYsdD10LnNpYmxpbmd9ZWxzZXtpZihsYigpLHI9PT1sKXtuPXVfKGUsbix0KTticmVhayBlfXV1KGUsbixyLHQpfW49bi5jaGlsZH1yZXR1cm4gbjtjYXNlIDU6cmV0dXJuIGFuKG4pLG51bGw9PT1lJiZsaChuKSxyPW4udHlwZSxsPW4ucGVuZGluZ1Byb3BzLGE9bnVsbCE9PWU/ZS5tZW1vaXplZFByb3BzOm51bGwsdT1sLmNoaWxkcmVuLHJiKHIsbCk/dT1udWxsOm51bGwhPT1hJiZyYihyLGEpJiYobi5mbGFnc3w9MzIpLHVmKGUsbiksdXUoZSxuLHUsdCksbi5jaGlsZDtjYXNlIDY6cmV0dXJuIG51bGw9PT1lJiZsaChuKSxudWxsO2Nhc2UgMTM6cmV0dXJuIHViKGUsbix0KTtjYXNlIDQ6cmV0dXJuIGw3KG4sbi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbykscj1uLnBlbmRpbmdQcm9wcyxudWxsPT09ZT9uLmNoaWxkPWwyKG4sbnVsbCxyLHQpOnV1KGUsbixyLHQpLG4uY2hpbGQ7Y2FzZSAxMTpyZXR1cm4gcj1uLnR5cGUsbD1uLnBlbmRpbmdQcm9wcyxsPW4uZWxlbWVudFR5cGU9PT1yP2w6bFMocixsKSx1byhlLG4scixsLHQpO2Nhc2UgNzpyZXR1cm4gdXUoZSxuLG4ucGVuZGluZ1Byb3BzLHQpLG4uY2hpbGQ7Y2FzZSA4OmNhc2UgMTI6cmV0dXJuIHV1KGUsbixuLnBlbmRpbmdQcm9wcy5jaGlsZHJlbix0KSxuLmNoaWxkO2Nhc2UgMTA6ZTp7aWYocj1uLnR5cGUuX2NvbnRleHQsbD1uLnBlbmRpbmdQcm9wcyxhPW4ubWVtb2l6ZWRQcm9wcyx1PWwudmFsdWUsckIobHgsci5fY3VycmVudFZhbHVlKSxyLl9jdXJyZW50VmFsdWU9dSxudWxsIT09YSl7aWYodEQoYS52YWx1ZSx1KSl7aWYoYS5jaGlsZHJlbj09PWwuY2hpbGRyZW4mJiFyUS5jdXJyZW50KXtuPXVfKGUsbix0KTticmVhayBlfX1lbHNlIGZvcihudWxsIT09KGE9bi5jaGlsZCkmJihhLnJldHVybj1uKTtudWxsIT09YTspe3ZhciBvPWEuZGVwZW5kZW5jaWVzO2lmKG51bGwhPT1vKXt1PWEuY2hpbGQ7Zm9yKHZhciBpPW8uZmlyc3RDb250ZXh0O251bGwhPT1pOyl7aWYoaS5jb250ZXh0PT09cil7aWYoMT09PWEudGFnKXsoaT1sVigtMSx0Ji10KSkudGFnPTI7dmFyIHM9YS51cGRhdGVRdWV1ZTtpZihudWxsIT09cyl7dmFyIGM9KHM9cy5zaGFyZWQpLnBlbmRpbmc7bnVsbD09PWM/aS5uZXh0PWk6KGkubmV4dD1jLm5leHQsYy5uZXh0PWkpLHMucGVuZGluZz1pfX1hLmxhbmVzfD10LG51bGwhPT0oaT1hLmFsdGVybmF0ZSkmJihpLmxhbmVzfD10KSxseihhLnJldHVybix0LG4pLG8ubGFuZXN8PXQ7YnJlYWt9aT1pLm5leHR9fWVsc2UgaWYoMTA9PT1hLnRhZyl1PWEudHlwZT09PW4udHlwZT9udWxsOmEuY2hpbGQ7ZWxzZSBpZigxOD09PWEudGFnKXtpZihudWxsPT09KHU9YS5yZXR1cm4pKXRocm93IEVycm9yKGYoMzQxKSk7dS5sYW5lc3w9dCxudWxsIT09KG89dS5hbHRlcm5hdGUpJiYoby5sYW5lc3w9dCksbHoodSx0LG4pLHU9YS5zaWJsaW5nfWVsc2UgdT1hLmNoaWxkO2lmKG51bGwhPT11KXUucmV0dXJuPWE7ZWxzZSBmb3IodT1hO251bGwhPT11Oyl7aWYodT09PW4pe3U9bnVsbDticmVha31pZihudWxsIT09KGE9dS5zaWJsaW5nKSl7YS5yZXR1cm49dS5yZXR1cm4sdT1hO2JyZWFrfXU9dS5yZXR1cm59YT11fX11dShlLG4sbC5jaGlsZHJlbix0KSxuPW4uY2hpbGR9cmV0dXJuIG47Y2FzZSA5OnJldHVybiBsPW4udHlwZSxyPW4ucGVuZGluZ1Byb3BzLmNoaWxkcmVuLGxUKG4sdCksbD1sTChsKSxyPXIobCksbi5mbGFnc3w9MSx1dShlLG4scix0KSxuLmNoaWxkO2Nhc2UgMTQ6cmV0dXJuIGw9bFMocj1uLnR5cGUsbi5wZW5kaW5nUHJvcHMpLGw9bFMoci50eXBlLGwpLHVpKGUsbixyLGwsdCk7Y2FzZSAxNTpyZXR1cm4gdXMoZSxuLG4udHlwZSxuLnBlbmRpbmdQcm9wcyx0KTtjYXNlIDE3OnJldHVybiByPW4udHlwZSxsPW4ucGVuZGluZ1Byb3BzLGw9bi5lbGVtZW50VHlwZT09PXI/bDpsUyhyLGwpLHVDKGUsbiksbi50YWc9MSxyWShyKT8oZT0hMCxySihuKSk6ZT0hMSxsVChuLHQpLGxZKG4scixsKSxsRyhuLHIsbCx0KSx1bShudWxsLG4sciwhMCxlLHQpO2Nhc2UgMTk6cmV0dXJuIHVFKGUsbix0KTtjYXNlIDIyOnJldHVybiB1YyhlLG4sdCl9dGhyb3cgRXJyb3IoZigxNTYsbi50YWcpKX07dmFyIG85PSJmdW5jdGlvbiI9PXR5cGVvZiByZXBvcnRFcnJvcj9yZXBvcnRFcnJvcjpmdW5jdGlvbihlKXtjb25zb2xlLmVycm9yKGUpfTtmdW5jdGlvbiBvNyhlKXt0aGlzLl9pbnRlcm5hbFJvb3Q9ZX1mdW5jdGlvbiBpZShlKXt0aGlzLl9pbnRlcm5hbFJvb3Q9ZX1mdW5jdGlvbiBpdChlKXtyZXR1cm4hKCFlfHwxIT09ZS5ub2RlVHlwZSYmOSE9PWUubm9kZVR5cGUmJjExIT09ZS5ub2RlVHlwZSl9ZnVuY3Rpb24gaXIoZSl7cmV0dXJuISghZXx8MSE9PWUubm9kZVR5cGUmJjkhPT1lLm5vZGVUeXBlJiYxMSE9PWUubm9kZVR5cGUmJig4IT09ZS5ub2RlVHlwZXx8IiByZWFjdC1tb3VudC1wb2ludC11bnN0YWJsZSAiIT09ZS5ub2RlVmFsdWUpKX1mdW5jdGlvbiBpbCgpe31mdW5jdGlvbiBpYShlLG4sdCxyLGwpe3ZhciBhPXQuX3JlYWN0Um9vdENvbnRhaW5lcjtpZihhKXt2YXIgdT1hO2lmKCJmdW5jdGlvbiI9PXR5cGVvZiBsKXt2YXIgbz1sO2w9ZnVuY3Rpb24oKXt2YXIgZT1vOCh1KTtvLmNhbGwoZSl9fW80KG4sdSxlLGwpfWVsc2UgdT1mdW5jdGlvbihlLG4sdCxyLGwpe2lmKGwpe2lmKCJmdW5jdGlvbiI9PXR5cGVvZiByKXt2YXIgYT1yO3I9ZnVuY3Rpb24oKXt2YXIgZT1vOCh1KTthLmNhbGwoZSl9fXZhciB1PW8zKG4scixlLDAsbnVsbCwhMSwhMSwiIixpbCk7cmV0dXJuIGUuX3JlYWN0Um9vdENvbnRhaW5lcj11LGVbckxdPXUuY3VycmVudCxyYSg4PT09ZS5ub2RlVHlwZT9lLnBhcmVudE5vZGU6ZSksb04oKSx1fWZvcig7bD1lLmxhc3RDaGlsZDspZS5yZW1vdmVDaGlsZChsKTtpZigiZnVuY3Rpb24iPT10eXBlb2Ygcil7dmFyIG89cjtyPWZ1bmN0aW9uKCl7dmFyIGU9bzgoaSk7by5jYWxsKGUpfX12YXIgaT1vMShlLDAsITEsbnVsbCxudWxsLCExLCExLCIiLGlsKTtyZXR1cm4gZS5fcmVhY3RSb290Q29udGFpbmVyPWksZVtyTF09aS5jdXJyZW50LHJhKDg9PT1lLm5vZGVUeXBlP2UucGFyZW50Tm9kZTplKSxvTihmdW5jdGlvbigpe280KG4saSx0LHIpfSksaX0odCxuLGUsbCxyKTtyZXR1cm4gbzgodSl9aWUucHJvdG90eXBlLnJlbmRlcj1vNy5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKGUpe3ZhciBuPXRoaXMuX2ludGVybmFsUm9vdDtpZihudWxsPT09bil0aHJvdyBFcnJvcihmKDQwOSkpO280KGUsbixudWxsLG51bGwpfSxpZS5wcm90b3R5cGUudW5tb3VudD1vNy5wcm90b3R5cGUudW5tb3VudD1mdW5jdGlvbigpe3ZhciBlPXRoaXMuX2ludGVybmFsUm9vdDtpZihudWxsIT09ZSl7dGhpcy5faW50ZXJuYWxSb290PW51bGw7dmFyIG49ZS5jb250YWluZXJJbmZvO29OKGZ1bmN0aW9uKCl7bzQobnVsbCxlLG51bGwsbnVsbCl9KSxuW3JMXT1udWxsfX0saWUucHJvdG90eXBlLnVuc3RhYmxlX3NjaGVkdWxlSHlkcmF0aW9uPWZ1bmN0aW9uKGUpe2lmKGUpe3ZhciBuPW5oKCk7ZT17YmxvY2tlZE9uOm51bGwsdGFyZ2V0OmUscHJpb3JpdHk6bn07Zm9yKHZhciB0PTA7dDxuRS5sZW5ndGgmJjAhPT1uJiZuPG5FW3RdLnByaW9yaXR5O3QrKyk7bkUuc3BsaWNlKHQsMCxlKSwwPT09dCYmbk4oZSl9fSxuZD1mdW5jdGlvbihlKXtzd2l0Y2goZS50YWcpe2Nhc2UgMzp2YXIgbj1lLnN0YXRlTm9kZTtpZihuLmN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQpe3ZhciB0PW5yKG4ucGVuZGluZ0xhbmVzKTswIT09dCYmKG5zKG4sMXx0KSxvdyhuLGVKKCkpLDA9PSg2JnUyKSYmKG91PWVKKCkrNTAwLHI0KCkpKX1icmVhaztjYXNlIDEzOm9OKGZ1bmN0aW9uKCl7dmFyIG49bE8oZSwxKTtudWxsIT09biYmb2sobixlLDEsb3koKSl9KSxvNShlLDEpfX0sbnA9ZnVuY3Rpb24oZSl7aWYoMTM9PT1lLnRhZyl7dmFyIG49bE8oZSwxMzQyMTc3MjgpO251bGwhPT1uJiZvayhuLGUsMTM0MjE3NzI4LG95KCkpLG81KGUsMTM0MjE3NzI4KX19LG5tPWZ1bmN0aW9uKGUpe2lmKDEzPT09ZS50YWcpe3ZhciBuPW9iKGUpLHQ9bE8oZSxuKTtudWxsIT09dCYmb2sodCxlLG4sb3koKSksbzUoZSxuKX19LG5oPWZ1bmN0aW9uKCl7cmV0dXJuIG5jfSxuZz1mdW5jdGlvbihlLG4pe3ZhciB0PW5jO3RyeXtyZXR1cm4gbmM9ZSxuKCl9ZmluYWxseXtuYz10fX0sZUM9ZnVuY3Rpb24oZSxuLHQpe3N3aXRjaChuKXtjYXNlImlucHV0IjppZihlbihlLHQpLG49dC5uYW1lLCJyYWRpbyI9PT10LnR5cGUmJm51bGwhPW4pe2Zvcih0PWU7dC5wYXJlbnROb2RlOyl0PXQucGFyZW50Tm9kZTtmb3IodD10LnF1ZXJ5U2VsZWN0b3JBbGwoImlucHV0W25hbWU9IitKU09OLnN0cmluZ2lmeSgiIituKSsnXVt0eXBlPSJyYWRpbyJdJyksbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO2lmKHIhPT1lJiZyLmZvcm09PT1lLmZvcm0pe3ZhciBsPXJVKHIpO2lmKCFsKXRocm93IEVycm9yKGYoOTApKTtYKHIpLGVuKHIsbCl9fX1icmVhaztjYXNlInRleHRhcmVhIjplaShlLHQpO2JyZWFrO2Nhc2Uic2VsZWN0IjpudWxsIT0obj10LnZhbHVlKSYmZWEoZSwhIXQubXVsdGlwbGUsbiwhMSl9fSxlTD1vUCxlUj1vTjt2YXIgaXU9e2ZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOnJPLGJ1bmRsZVR5cGU6MCx2ZXJzaW9uOiIxOC4yLjAiLHJlbmRlcmVyUGFja2FnZU5hbWU6InJlYWN0LWRvbSJ9LGlvPXtidW5kbGVUeXBlOml1LmJ1bmRsZVR5cGUsdmVyc2lvbjppdS52ZXJzaW9uLHJlbmRlcmVyUGFja2FnZU5hbWU6aXUucmVuZGVyZXJQYWNrYWdlTmFtZSxyZW5kZXJlckNvbmZpZzppdS5yZW5kZXJlckNvbmZpZyxvdmVycmlkZUhvb2tTdGF0ZTpudWxsLG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aDpudWxsLG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aDpudWxsLG92ZXJyaWRlUHJvcHM6bnVsbCxvdmVycmlkZVByb3BzRGVsZXRlUGF0aDpudWxsLG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoOm51bGwsc2V0RXJyb3JIYW5kbGVyOm51bGwsc2V0U3VzcGVuc2VIYW5kbGVyOm51bGwsc2NoZWR1bGVVcGRhdGU6bnVsbCxjdXJyZW50RGlzcGF0Y2hlclJlZjpfLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PT0oZT1lSyhlKSk/bnVsbDplLnN0YXRlTm9kZX0sZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6aXUuZmluZEZpYmVyQnlIb3N0SW5zdGFuY2V8fGZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LGZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaDpudWxsLHNjaGVkdWxlUmVmcmVzaDpudWxsLHNjaGVkdWxlUm9vdDpudWxsLHNldFJlZnJlc2hIYW5kbGVyOm51bGwsZ2V0Q3VycmVudEZpYmVyOm51bGwscmVjb25jaWxlclZlcnNpb246IjE4LjIuMC1uZXh0LTllM2I3NzJiOC0yMDIyMDYwOCJ9O2lmKCJ1bmRlZmluZWQiIT10eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fKXt2YXIgaWk9X19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO2lmKCFpaS5pc0Rpc2FibGVkJiZpaS5zdXBwb3J0c0ZpYmVyKXRyeXtlNj1paS5pbmplY3QoaW8pLGU1PWlpfWNhdGNoKGUpe319bi5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRD17dXNpbmdDbGllbnRFbnRyeVBvaW50OiExLEV2ZW50czpbckQsckksclUsZXosZVQsb1BdfSxuLmNyZWF0ZVBvcnRhbD1mdW5jdGlvbihlLG4pe3ZhciB0PTI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpudWxsO2lmKCFpdChuKSl0aHJvdyBFcnJvcihmKDIwMCkpO3JldHVybiBmdW5jdGlvbihlLG4sdCl7dmFyIHI9Mzxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOm51bGw7cmV0dXJueyQkdHlwZW9mOk4sa2V5Om51bGw9PXI/bnVsbDoiIityLGNoaWxkcmVuOmUsY29udGFpbmVySW5mbzpuLGltcGxlbWVudGF0aW9uOm51bGx9fShlLG4sbnVsbCx0KX0sbi5jcmVhdGVSb290PWZ1bmN0aW9uKGUsbil7aWYoIWl0KGUpKXRocm93IEVycm9yKGYoMjk5KSk7dmFyIHQ9ITEscj0iIixsPW85O3JldHVybiBudWxsIT1uJiYoITA9PT1uLnVuc3RhYmxlX3N0cmljdE1vZGUmJih0PSEwKSx2b2lkIDAhPT1uLmlkZW50aWZpZXJQcmVmaXgmJihyPW4uaWRlbnRpZmllclByZWZpeCksdm9pZCAwIT09bi5vblJlY292ZXJhYmxlRXJyb3ImJihsPW4ub25SZWNvdmVyYWJsZUVycm9yKSksbj1vMShlLDEsITEsbnVsbCxudWxsLHQsITEscixsKSxlW3JMXT1uLmN1cnJlbnQscmEoOD09PWUubm9kZVR5cGU/ZS5wYXJlbnROb2RlOmUpLG5ldyBvNyhuKX0sbi5maW5kRE9NTm9kZT1mdW5jdGlvbihlKXtpZihudWxsPT1lKXJldHVybiBudWxsO2lmKDE9PT1lLm5vZGVUeXBlKXJldHVybiBlO3ZhciBuPWUuX3JlYWN0SW50ZXJuYWxzO2lmKHZvaWQgMD09PW4pe2lmKCJmdW5jdGlvbiI9PXR5cGVvZiBlLnJlbmRlcil0aHJvdyBFcnJvcihmKDE4OCkpO3Rocm93IEVycm9yKGYoMjY4LGU9T2JqZWN0LmtleXMoZSkuam9pbigiLCIpKSl9cmV0dXJuIGU9bnVsbD09PShlPWVLKG4pKT9udWxsOmUuc3RhdGVOb2RlfSxuLmZsdXNoU3luYz1mdW5jdGlvbihlKXtyZXR1cm4gb04oZSl9LG4uaHlkcmF0ZT1mdW5jdGlvbihlLG4sdCl7aWYoIWlyKG4pKXRocm93IEVycm9yKGYoMjAwKSk7cmV0dXJuIGlhKG51bGwsZSxuLCEwLHQpfSxuLmh5ZHJhdGVSb290PWZ1bmN0aW9uKGUsbix0KXtpZighaXQoZSkpdGhyb3cgRXJyb3IoZig0MDUpKTt2YXIgcj1udWxsIT10JiZ0Lmh5ZHJhdGVkU291cmNlc3x8bnVsbCxsPSExLGE9IiIsdT1vOTtpZihudWxsIT10JiYoITA9PT10LnVuc3RhYmxlX3N0cmljdE1vZGUmJihsPSEwKSx2b2lkIDAhPT10LmlkZW50aWZpZXJQcmVmaXgmJihhPXQuaWRlbnRpZmllclByZWZpeCksdm9pZCAwIT09dC5vblJlY292ZXJhYmxlRXJyb3ImJih1PXQub25SZWNvdmVyYWJsZUVycm9yKSksbj1vMyhuLG51bGwsZSwxLG51bGwhPXQ/dDpudWxsLGwsITEsYSx1KSxlW3JMXT1uLmN1cnJlbnQscmEoZSkscilmb3IoZT0wO2U8ci5sZW5ndGg7ZSsrKWw9KGw9KHQ9cltlXSkuX2dldFZlcnNpb24pKHQuX3NvdXJjZSksbnVsbD09bi5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhP24ubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YT1bdCxsXTpuLm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGEucHVzaCh0LGwpO3JldHVybiBuZXcgaWUobil9LG4ucmVuZGVyPWZ1bmN0aW9uKGUsbix0KXtpZighaXIobikpdGhyb3cgRXJyb3IoZigyMDApKTtyZXR1cm4gaWEobnVsbCxlLG4sITEsdCl9LG4udW5tb3VudENvbXBvbmVudEF0Tm9kZT1mdW5jdGlvbihlKXtpZighaXIoZSkpdGhyb3cgRXJyb3IoZig0MCkpO3JldHVybiEhZS5fcmVhY3RSb290Q29udGFpbmVyJiYob04oZnVuY3Rpb24oKXtpYShudWxsLG51bGwsZSwhMSxmdW5jdGlvbigpe2UuX3JlYWN0Um9vdENvbnRhaW5lcj1udWxsLGVbckxdPW51bGx9KX0pLCEwKX0sbi51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcz1vUCxuLnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyPWZ1bmN0aW9uKGUsbix0LHIpe2lmKCFpcih0KSl0aHJvdyBFcnJvcihmKDIwMCkpO2lmKG51bGw9PWV8fHZvaWQgMD09PWUuX3JlYWN0SW50ZXJuYWxzKXRocm93IEVycm9yKGYoMzgpKTtyZXR1cm4gaWEoZSxuLHQsITEscil9LG4udmVyc2lvbj0iMTguMi4wLW5leHQtOWUzYjc3MmI4LTIwMjIwNjA4In0sNzQ1OmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10KDM5MzUpO24uY3JlYXRlUm9vdD1yLmNyZWF0ZVJvb3Qsbi5oeWRyYXRlUm9vdD1yLmh5ZHJhdGVSb290fSwzOTM1OmZ1bmN0aW9uKGUsbix0KXshZnVuY3Rpb24gZSgpe2lmKCJ1bmRlZmluZWQiIT10eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fJiYiZnVuY3Rpb24iPT10eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFKXRyeXtfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UoZSl9Y2F0Y2goZSl7Y29uc29sZS5lcnJvcihlKX19KCksZS5leHBvcnRzPXQoNDQ0OCl9LDI0MDg6ZnVuY3Rpb24oZSxuKXsvKioKICogQGxpY2Vuc2UgUmVhY3QKICogcmVhY3QucHJvZHVjdGlvbi5taW4uanMKICoKICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuCiAqCiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZQogKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuCiAqL3ZhciB0PVN5bWJvbC5mb3IoInJlYWN0LmVsZW1lbnQiKSxyPVN5bWJvbC5mb3IoInJlYWN0LnBvcnRhbCIpLGw9U3ltYm9sLmZvcigicmVhY3QuZnJhZ21lbnQiKSxhPVN5bWJvbC5mb3IoInJlYWN0LnN0cmljdF9tb2RlIiksdT1TeW1ib2wuZm9yKCJyZWFjdC5wcm9maWxlciIpLG89U3ltYm9sLmZvcigicmVhY3QucHJvdmlkZXIiKSxpPVN5bWJvbC5mb3IoInJlYWN0LmNvbnRleHQiKSxzPVN5bWJvbC5mb3IoInJlYWN0LmZvcndhcmRfcmVmIiksYz1TeW1ib2wuZm9yKCJyZWFjdC5zdXNwZW5zZSIpLGY9U3ltYm9sLmZvcigicmVhY3QubWVtbyIpLGQ9U3ltYm9sLmZvcigicmVhY3QubGF6eSIpLHA9U3ltYm9sLml0ZXJhdG9yLG09e2lzTW91bnRlZDpmdW5jdGlvbigpe3JldHVybiExfSxlbnF1ZXVlRm9yY2VVcGRhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVSZXBsYWNlU3RhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbigpe319LGg9T2JqZWN0LmFzc2lnbixnPXt9O2Z1bmN0aW9uIHYoZSxuLHQpe3RoaXMucHJvcHM9ZSx0aGlzLmNvbnRleHQ9bix0aGlzLnJlZnM9Zyx0aGlzLnVwZGF0ZXI9dHx8bX1mdW5jdGlvbiB5KCl7fWZ1bmN0aW9uIGIoZSxuLHQpe3RoaXMucHJvcHM9ZSx0aGlzLmNvbnRleHQ9bix0aGlzLnJlZnM9Zyx0aGlzLnVwZGF0ZXI9dHx8bX12LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50PXt9LHYucHJvdG90eXBlLnNldFN0YXRlPWZ1bmN0aW9uKGUsbil7aWYoIm9iamVjdCIhPXR5cGVvZiBlJiYiZnVuY3Rpb24iIT10eXBlb2YgZSYmbnVsbCE9ZSl0aHJvdyBFcnJvcigic2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuIik7dGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLGUsbiwic2V0U3RhdGUiKX0sdi5wcm90b3R5cGUuZm9yY2VVcGRhdGU9ZnVuY3Rpb24oZSl7dGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLGUsImZvcmNlVXBkYXRlIil9LHkucHJvdG90eXBlPXYucHJvdG90eXBlO3ZhciBrPWIucHJvdG90eXBlPW5ldyB5O2suY29uc3RydWN0b3I9YixoKGssdi5wcm90b3R5cGUpLGsuaXNQdXJlUmVhY3RDb21wb25lbnQ9ITA7dmFyIHc9QXJyYXkuaXNBcnJheSxTPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkseD17Y3VycmVudDpudWxsfSxFPXtrZXk6ITAscmVmOiEwLF9fc2VsZjohMCxfX3NvdXJjZTohMH07ZnVuY3Rpb24gQyhlLG4scil7dmFyIGwsYT17fSx1PW51bGwsbz1udWxsO2lmKG51bGwhPW4pZm9yKGwgaW4gdm9pZCAwIT09bi5yZWYmJihvPW4ucmVmKSx2b2lkIDAhPT1uLmtleSYmKHU9IiIrbi5rZXkpLG4pUy5jYWxsKG4sbCkmJiFFLmhhc093blByb3BlcnR5KGwpJiYoYVtsXT1uW2xdKTt2YXIgaT1hcmd1bWVudHMubGVuZ3RoLTI7aWYoMT09PWkpYS5jaGlsZHJlbj1yO2Vsc2UgaWYoMTxpKXtmb3IodmFyIHM9QXJyYXkoaSksYz0wO2M8aTtjKyspc1tjXT1hcmd1bWVudHNbYysyXTthLmNoaWxkcmVuPXN9aWYoZSYmZS5kZWZhdWx0UHJvcHMpZm9yKGwgaW4gaT1lLmRlZmF1bHRQcm9wcyl2b2lkIDA9PT1hW2xdJiYoYVtsXT1pW2xdKTtyZXR1cm57JCR0eXBlb2Y6dCx0eXBlOmUsa2V5OnUscmVmOm8scHJvcHM6YSxfb3duZXI6eC5jdXJyZW50fX1mdW5jdGlvbiBfKGUpe3JldHVybiJvYmplY3QiPT10eXBlb2YgZSYmbnVsbCE9PWUmJmUuJCR0eXBlb2Y9PT10fXZhciBQPS9cLysvZztmdW5jdGlvbiBOKGUsbil7dmFyIHQscjtyZXR1cm4ib2JqZWN0Ij09dHlwZW9mIGUmJm51bGwhPT1lJiZudWxsIT1lLmtleT8odD0iIitlLmtleSxyPXsiPSI6Ij0wIiwiOiI6Ij0yIn0sIiQiK3QucmVwbGFjZSgvWz06XS9nLGZ1bmN0aW9uKGUpe3JldHVybiByW2VdfSkpOm4udG9TdHJpbmcoMzYpfWZ1bmN0aW9uIHooZSxuLGwpe2lmKG51bGw9PWUpcmV0dXJuIGU7dmFyIGE9W10sdT0wO3JldHVybiFmdW5jdGlvbiBlKG4sbCxhLHUsbyl7dmFyIGkscyxjLGY9dHlwZW9mIG47KCJ1bmRlZmluZWQiPT09Znx8ImJvb2xlYW4iPT09ZikmJihuPW51bGwpO3ZhciBkPSExO2lmKG51bGw9PT1uKWQ9ITA7ZWxzZSBzd2l0Y2goZil7Y2FzZSJzdHJpbmciOmNhc2UibnVtYmVyIjpkPSEwO2JyZWFrO2Nhc2Uib2JqZWN0Ijpzd2l0Y2gobi4kJHR5cGVvZil7Y2FzZSB0OmNhc2UgcjpkPSEwfX1pZihkKXJldHVybiBvPW8oZD1uKSxuPSIiPT09dT8iLiIrTihkLDApOnUsdyhvKT8oYT0iIixudWxsIT1uJiYoYT1uLnJlcGxhY2UoUCwiJCYvIikrIi8iKSxlKG8sbCxhLCIiLGZ1bmN0aW9uKGUpe3JldHVybiBlfSkpOm51bGwhPW8mJihfKG8pJiYoaT1vLHM9YSsoIW8ua2V5fHxkJiZkLmtleT09PW8ua2V5PyIiOigiIitvLmtleSkucmVwbGFjZShQLCIkJi8iKSsiLyIpK24sbz17JCR0eXBlb2Y6dCx0eXBlOmkudHlwZSxrZXk6cyxyZWY6aS5yZWYscHJvcHM6aS5wcm9wcyxfb3duZXI6aS5fb3duZXJ9KSxsLnB1c2gobykpLDE7aWYoZD0wLHU9IiI9PT11PyIuIjp1KyI6Iix3KG4pKWZvcih2YXIgbT0wO208bi5sZW5ndGg7bSsrKXtmPW5bbV07dmFyIGg9dStOKGYsbSk7ZCs9ZShmLGwsYSxoLG8pfWVsc2UgaWYoImZ1bmN0aW9uIj09dHlwZW9mKGg9bnVsbD09PShjPW4pfHwib2JqZWN0IiE9dHlwZW9mIGM/bnVsbDoiZnVuY3Rpb24iPT10eXBlb2YoYz1wJiZjW3BdfHxjWyJAQGl0ZXJhdG9yIl0pP2M6bnVsbCkpZm9yKG49aC5jYWxsKG4pLG09MDshKGY9bi5uZXh0KCkpLmRvbmU7KWg9dStOKGY9Zi52YWx1ZSxtKyspLGQrPWUoZixsLGEsaCxvKTtlbHNlIGlmKCJvYmplY3QiPT09Zil0aHJvdyBFcnJvcigiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAiKygiW29iamVjdCBPYmplY3RdIj09PShsPVN0cmluZyhuKSk/Im9iamVjdCB3aXRoIGtleXMgeyIrT2JqZWN0LmtleXMobikuam9pbigiLCAiKSsifSI6bCkrIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC4iKTtyZXR1cm4gZH0oZSxhLCIiLCIiLGZ1bmN0aW9uKGUpe3JldHVybiBuLmNhbGwobCxlLHUrKyl9KSxhfWZ1bmN0aW9uIFQoZSl7aWYoLTE9PT1lLl9zdGF0dXMpe3ZhciBuPWUuX3Jlc3VsdDsobj1uKCkpLnRoZW4oZnVuY3Rpb24obil7KDA9PT1lLl9zdGF0dXN8fC0xPT09ZS5fc3RhdHVzKSYmKGUuX3N0YXR1cz0xLGUuX3Jlc3VsdD1uKX0sZnVuY3Rpb24obil7KDA9PT1lLl9zdGF0dXN8fC0xPT09ZS5fc3RhdHVzKSYmKGUuX3N0YXR1cz0yLGUuX3Jlc3VsdD1uKX0pLC0xPT09ZS5fc3RhdHVzJiYoZS5fc3RhdHVzPTAsZS5fcmVzdWx0PW4pfWlmKDE9PT1lLl9zdGF0dXMpcmV0dXJuIGUuX3Jlc3VsdC5kZWZhdWx0O3Rocm93IGUuX3Jlc3VsdH12YXIgTD17Y3VycmVudDpudWxsfSxSPXt0cmFuc2l0aW9uOm51bGx9O24uQ2hpbGRyZW49e21hcDp6LGZvckVhY2g6ZnVuY3Rpb24oZSxuLHQpe3ooZSxmdW5jdGlvbigpe24uYXBwbHkodGhpcyxhcmd1bWVudHMpfSx0KX0sY291bnQ6ZnVuY3Rpb24oZSl7dmFyIG49MDtyZXR1cm4geihlLGZ1bmN0aW9uKCl7bisrfSksbn0sdG9BcnJheTpmdW5jdGlvbihlKXtyZXR1cm4geihlLGZ1bmN0aW9uKGUpe3JldHVybiBlfSl8fFtdfSxvbmx5OmZ1bmN0aW9uKGUpe2lmKCFfKGUpKXRocm93IEVycm9yKCJSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC4iKTtyZXR1cm4gZX19LG4uQ29tcG9uZW50PXYsbi5GcmFnbWVudD1sLG4uUHJvZmlsZXI9dSxuLlB1cmVDb21wb25lbnQ9YixuLlN0cmljdE1vZGU9YSxuLlN1c3BlbnNlPWMsbi5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRD17UmVhY3RDdXJyZW50RGlzcGF0Y2hlcjpMLFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOlIsUmVhY3RDdXJyZW50T3duZXI6eH0sbi5jbG9uZUVsZW1lbnQ9ZnVuY3Rpb24oZSxuLHIpe2lmKG51bGw9PWUpdGhyb3cgRXJyb3IoIlJlYWN0LmNsb25lRWxlbWVudCguLi4pOiBUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkICIrZSsiLiIpO3ZhciBsPWgoe30sZS5wcm9wcyksYT1lLmtleSx1PWUucmVmLG89ZS5fb3duZXI7aWYobnVsbCE9bil7aWYodm9pZCAwIT09bi5yZWYmJih1PW4ucmVmLG89eC5jdXJyZW50KSx2b2lkIDAhPT1uLmtleSYmKGE9IiIrbi5rZXkpLGUudHlwZSYmZS50eXBlLmRlZmF1bHRQcm9wcyl2YXIgaT1lLnR5cGUuZGVmYXVsdFByb3BzO2ZvcihzIGluIG4pUy5jYWxsKG4scykmJiFFLmhhc093blByb3BlcnR5KHMpJiYobFtzXT12b2lkIDA9PT1uW3NdJiZ2b2lkIDAhPT1pP2lbc106bltzXSl9dmFyIHM9YXJndW1lbnRzLmxlbmd0aC0yO2lmKDE9PT1zKWwuY2hpbGRyZW49cjtlbHNlIGlmKDE8cyl7aT1BcnJheShzKTtmb3IodmFyIGM9MDtjPHM7YysrKWlbY109YXJndW1lbnRzW2MrMl07bC5jaGlsZHJlbj1pfXJldHVybnskJHR5cGVvZjp0LHR5cGU6ZS50eXBlLGtleTphLHJlZjp1LHByb3BzOmwsX293bmVyOm99fSxuLmNyZWF0ZUNvbnRleHQ9ZnVuY3Rpb24oZSl7cmV0dXJuKGU9eyQkdHlwZW9mOmksX2N1cnJlbnRWYWx1ZTplLF9jdXJyZW50VmFsdWUyOmUsX3RocmVhZENvdW50OjAsUHJvdmlkZXI6bnVsbCxDb25zdW1lcjpudWxsLF9kZWZhdWx0VmFsdWU6bnVsbCxfZ2xvYmFsTmFtZTpudWxsfSkuUHJvdmlkZXI9eyQkdHlwZW9mOm8sX2NvbnRleHQ6ZX0sZS5Db25zdW1lcj1lfSxuLmNyZWF0ZUVsZW1lbnQ9QyxuLmNyZWF0ZUZhY3Rvcnk9ZnVuY3Rpb24oZSl7dmFyIG49Qy5iaW5kKG51bGwsZSk7cmV0dXJuIG4udHlwZT1lLG59LG4uY3JlYXRlUmVmPWZ1bmN0aW9uKCl7cmV0dXJue2N1cnJlbnQ6bnVsbH19LG4uZm9yd2FyZFJlZj1mdW5jdGlvbihlKXtyZXR1cm57JCR0eXBlb2Y6cyxyZW5kZXI6ZX19LG4uaXNWYWxpZEVsZW1lbnQ9XyxuLmxhenk9ZnVuY3Rpb24oZSl7cmV0dXJueyQkdHlwZW9mOmQsX3BheWxvYWQ6e19zdGF0dXM6LTEsX3Jlc3VsdDplfSxfaW5pdDpUfX0sbi5tZW1vPWZ1bmN0aW9uKGUsbil7cmV0dXJueyQkdHlwZW9mOmYsdHlwZTplLGNvbXBhcmU6dm9pZCAwPT09bj9udWxsOm59fSxuLnN0YXJ0VHJhbnNpdGlvbj1mdW5jdGlvbihlKXt2YXIgbj1SLnRyYW5zaXRpb247Ui50cmFuc2l0aW9uPXt9O3RyeXtlKCl9ZmluYWxseXtSLnRyYW5zaXRpb249bn19LG4udW5zdGFibGVfYWN0PWZ1bmN0aW9uKCl7dGhyb3cgRXJyb3IoImFjdCguLi4pIGlzIG5vdCBzdXBwb3J0ZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMgb2YgUmVhY3QuIil9LG4udXNlQ2FsbGJhY2s9ZnVuY3Rpb24oZSxuKXtyZXR1cm4gTC5jdXJyZW50LnVzZUNhbGxiYWNrKGUsbil9LG4udXNlQ29udGV4dD1mdW5jdGlvbihlKXtyZXR1cm4gTC5jdXJyZW50LnVzZUNvbnRleHQoZSl9LG4udXNlRGVidWdWYWx1ZT1mdW5jdGlvbigpe30sbi51c2VEZWZlcnJlZFZhbHVlPWZ1bmN0aW9uKGUpe3JldHVybiBMLmN1cnJlbnQudXNlRGVmZXJyZWRWYWx1ZShlKX0sbi51c2VFZmZlY3Q9ZnVuY3Rpb24oZSxuKXtyZXR1cm4gTC5jdXJyZW50LnVzZUVmZmVjdChlLG4pfSxuLnVzZUlkPWZ1bmN0aW9uKCl7cmV0dXJuIEwuY3VycmVudC51c2VJZCgpfSxuLnVzZUltcGVyYXRpdmVIYW5kbGU9ZnVuY3Rpb24oZSxuLHQpe3JldHVybiBMLmN1cnJlbnQudXNlSW1wZXJhdGl2ZUhhbmRsZShlLG4sdCl9LG4udXNlSW5zZXJ0aW9uRWZmZWN0PWZ1bmN0aW9uKGUsbil7cmV0dXJuIEwuY3VycmVudC51c2VJbnNlcnRpb25FZmZlY3QoZSxuKX0sbi51c2VMYXlvdXRFZmZlY3Q9ZnVuY3Rpb24oZSxuKXtyZXR1cm4gTC5jdXJyZW50LnVzZUxheW91dEVmZmVjdChlLG4pfSxuLnVzZU1lbW89ZnVuY3Rpb24oZSxuKXtyZXR1cm4gTC5jdXJyZW50LnVzZU1lbW8oZSxuKX0sbi51c2VSZWR1Y2VyPWZ1bmN0aW9uKGUsbix0KXtyZXR1cm4gTC5jdXJyZW50LnVzZVJlZHVjZXIoZSxuLHQpfSxuLnVzZVJlZj1mdW5jdGlvbihlKXtyZXR1cm4gTC5jdXJyZW50LnVzZVJlZihlKX0sbi51c2VTdGF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gTC5jdXJyZW50LnVzZVN0YXRlKGUpfSxuLnVzZVN5bmNFeHRlcm5hbFN0b3JlPWZ1bmN0aW9uKGUsbix0KXtyZXR1cm4gTC5jdXJyZW50LnVzZVN5bmNFeHRlcm5hbFN0b3JlKGUsbix0KX0sbi51c2VUcmFuc2l0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIEwuY3VycmVudC51c2VUcmFuc2l0aW9uKCl9LG4udmVyc2lvbj0iMTguMi4wIn0sNzI5NDpmdW5jdGlvbihlLG4sdCl7ZS5leHBvcnRzPXQoMjQwOCl9LDUzOmZ1bmN0aW9uKGUsbil7LyoqCiAqIEBsaWNlbnNlIFJlYWN0CiAqIHNjaGVkdWxlci5wcm9kdWN0aW9uLm1pbi5qcwogKgogKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy4KICoKICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlCiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4KICovZnVuY3Rpb24gdChlLG4pe3ZhciB0PWUubGVuZ3RoO2ZvcihlLnB1c2gobik7MDx0Oyl7dmFyIHI9dC0xPj4+MSxsPWVbcl07aWYoMDxhKGwsbikpZVtyXT1uLGVbdF09bCx0PXI7ZWxzZSBicmVha319ZnVuY3Rpb24gcihlKXtyZXR1cm4gMD09PWUubGVuZ3RoP251bGw6ZVswXX1mdW5jdGlvbiBsKGUpe2lmKDA9PT1lLmxlbmd0aClyZXR1cm4gbnVsbDt2YXIgbj1lWzBdLHQ9ZS5wb3AoKTtpZih0IT09bil7ZVswXT10O2Zvcih2YXIgcj0wLGw9ZS5sZW5ndGgsdT1sPj4+MTtyPHU7KXt2YXIgbz0yKihyKzEpLTEsaT1lW29dLHM9bysxLGM9ZVtzXTtpZigwPmEoaSx0KSlzPGwmJjA+YShjLGkpPyhlW3JdPWMsZVtzXT10LHI9cyk6KGVbcl09aSxlW29dPXQscj1vKTtlbHNlIGlmKHM8bCYmMD5hKGMsdCkpZVtyXT1jLGVbc109dCxyPXM7ZWxzZSBicmVha319cmV0dXJuIG59ZnVuY3Rpb24gYShlLG4pe3ZhciB0PWUuc29ydEluZGV4LW4uc29ydEluZGV4O3JldHVybiAwIT09dD90OmUuaWQtbi5pZH1pZigib2JqZWN0Ij09dHlwZW9mIHBlcmZvcm1hbmNlJiYiZnVuY3Rpb24iPT10eXBlb2YgcGVyZm9ybWFuY2Uubm93KXt2YXIgdSxvPXBlcmZvcm1hbmNlO24udW5zdGFibGVfbm93PWZ1bmN0aW9uKCl7cmV0dXJuIG8ubm93KCl9fWVsc2V7dmFyIGk9RGF0ZSxzPWkubm93KCk7bi51bnN0YWJsZV9ub3c9ZnVuY3Rpb24oKXtyZXR1cm4gaS5ub3coKS1zfX12YXIgYz1bXSxmPVtdLGQ9MSxwPW51bGwsbT0zLGg9ITEsZz0hMSx2PSExLHk9ImZ1bmN0aW9uIj09dHlwZW9mIHNldFRpbWVvdXQ/c2V0VGltZW91dDpudWxsLGI9ImZ1bmN0aW9uIj09dHlwZW9mIGNsZWFyVGltZW91dD9jbGVhclRpbWVvdXQ6bnVsbCxrPSJ1bmRlZmluZWQiIT10eXBlb2Ygc2V0SW1tZWRpYXRlP3NldEltbWVkaWF0ZTpudWxsO2Z1bmN0aW9uIHcoZSl7Zm9yKHZhciBuPXIoZik7bnVsbCE9PW47KXtpZihudWxsPT09bi5jYWxsYmFjaylsKGYpO2Vsc2UgaWYobi5zdGFydFRpbWU8PWUpbChmKSxuLnNvcnRJbmRleD1uLmV4cGlyYXRpb25UaW1lLHQoYyxuKTtlbHNlIGJyZWFrO249cihmKX19ZnVuY3Rpb24gUyhlKXtpZih2PSExLHcoZSksIWcpe2lmKG51bGwhPT1yKGMpKWc9ITAsTSh4KTtlbHNle3ZhciBuPXIoZik7bnVsbCE9PW4mJkYoUyxuLnN0YXJ0VGltZS1lKX19fWZ1bmN0aW9uIHgoZSx0KXtnPSExLHYmJih2PSExLGIoXyksXz0tMSksaD0hMDt2YXIgYT1tO3RyeXtmb3Iodyh0KSxwPXIoYyk7bnVsbCE9PXAmJighKHAuZXhwaXJhdGlvblRpbWU+dCl8fGUmJiF6KCkpOyl7dmFyIHU9cC5jYWxsYmFjaztpZigiZnVuY3Rpb24iPT10eXBlb2YgdSl7cC5jYWxsYmFjaz1udWxsLG09cC5wcmlvcml0eUxldmVsO3ZhciBvPXUocC5leHBpcmF0aW9uVGltZTw9dCk7dD1uLnVuc3RhYmxlX25vdygpLCJmdW5jdGlvbiI9PXR5cGVvZiBvP3AuY2FsbGJhY2s9bzpwPT09cihjKSYmbChjKSx3KHQpfWVsc2UgbChjKTtwPXIoYyl9aWYobnVsbCE9PXApdmFyIGk9ITA7ZWxzZXt2YXIgcz1yKGYpO251bGwhPT1zJiZGKFMscy5zdGFydFRpbWUtdCksaT0hMX1yZXR1cm4gaX1maW5hbGx5e3A9bnVsbCxtPWEsaD0hMX19InVuZGVmaW5lZCIhPXR5cGVvZiBuYXZpZ2F0b3ImJnZvaWQgMCE9PW5hdmlnYXRvci5zY2hlZHVsaW5nJiZ2b2lkIDAhPT1uYXZpZ2F0b3Iuc2NoZWR1bGluZy5pc0lucHV0UGVuZGluZyYmbmF2aWdhdG9yLnNjaGVkdWxpbmcuaXNJbnB1dFBlbmRpbmcuYmluZChuYXZpZ2F0b3Iuc2NoZWR1bGluZyk7dmFyIEU9ITEsQz1udWxsLF89LTEsUD01LE49LTE7ZnVuY3Rpb24geigpe3JldHVybiEobi51bnN0YWJsZV9ub3coKS1OPFApfWZ1bmN0aW9uIFQoKXtpZihudWxsIT09Qyl7dmFyIGU9bi51bnN0YWJsZV9ub3coKTtOPWU7dmFyIHQ9ITA7dHJ5e3Q9QyghMCxlKX1maW5hbGx5e3Q/dSgpOihFPSExLEM9bnVsbCl9fWVsc2UgRT0hMX1pZigiZnVuY3Rpb24iPT10eXBlb2Ygayl1PWZ1bmN0aW9uKCl7ayhUKX07ZWxzZSBpZigidW5kZWZpbmVkIiE9dHlwZW9mIE1lc3NhZ2VDaGFubmVsKXt2YXIgTD1uZXcgTWVzc2FnZUNoYW5uZWwsUj1MLnBvcnQyO0wucG9ydDEub25tZXNzYWdlPVQsdT1mdW5jdGlvbigpe1IucG9zdE1lc3NhZ2UobnVsbCl9fWVsc2UgdT1mdW5jdGlvbigpe3koVCwwKX07ZnVuY3Rpb24gTShlKXtDPWUsRXx8KEU9ITAsdSgpKX1mdW5jdGlvbiBGKGUsdCl7Xz15KGZ1bmN0aW9uKCl7ZShuLnVuc3RhYmxlX25vdygpKX0sdCl9bi51bnN0YWJsZV9JZGxlUHJpb3JpdHk9NSxuLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5PTEsbi51bnN0YWJsZV9Mb3dQcmlvcml0eT00LG4udW5zdGFibGVfTm9ybWFsUHJpb3JpdHk9MyxuLnVuc3RhYmxlX1Byb2ZpbGluZz1udWxsLG4udW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHk9MixuLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrPWZ1bmN0aW9uKGUpe2UuY2FsbGJhY2s9bnVsbH0sbi51bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbj1mdW5jdGlvbigpe2d8fGh8fChnPSEwLE0oeCkpfSxuLnVuc3RhYmxlX2ZvcmNlRnJhbWVSYXRlPWZ1bmN0aW9uKGUpezA+ZXx8MTI1PGU/Y29uc29sZS5lcnJvcigiZm9yY2VGcmFtZVJhdGUgdGFrZXMgYSBwb3NpdGl2ZSBpbnQgYmV0d2VlbiAwIGFuZCAxMjUsIGZvcmNpbmcgZnJhbWUgcmF0ZXMgaGlnaGVyIHRoYW4gMTI1IGZwcyBpcyBub3Qgc3VwcG9ydGVkIik6UD0wPGU/TWF0aC5mbG9vcigxZTMvZSk6NX0sbi51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbD1mdW5jdGlvbigpe3JldHVybiBtfSxuLnVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIHIoYyl9LG4udW5zdGFibGVfbmV4dD1mdW5jdGlvbihlKXtzd2l0Y2gobSl7Y2FzZSAxOmNhc2UgMjpjYXNlIDM6dmFyIG49MzticmVhaztkZWZhdWx0Om49bX12YXIgdD1tO209bjt0cnl7cmV0dXJuIGUoKX1maW5hbGx5e209dH19LG4udW5zdGFibGVfcGF1c2VFeGVjdXRpb249ZnVuY3Rpb24oKXt9LG4udW5zdGFibGVfcmVxdWVzdFBhaW50PWZ1bmN0aW9uKCl7fSxuLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eT1mdW5jdGlvbihlLG4pe3N3aXRjaChlKXtjYXNlIDE6Y2FzZSAyOmNhc2UgMzpjYXNlIDQ6Y2FzZSA1OmJyZWFrO2RlZmF1bHQ6ZT0zfXZhciB0PW07bT1lO3RyeXtyZXR1cm4gbigpfWZpbmFsbHl7bT10fX0sbi51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrPWZ1bmN0aW9uKGUsbCxhKXt2YXIgdT1uLnVuc3RhYmxlX25vdygpO3N3aXRjaChhPSJvYmplY3QiPT10eXBlb2YgYSYmbnVsbCE9PWEmJiJudW1iZXIiPT10eXBlb2YoYT1hLmRlbGF5KSYmMDxhP3UrYTp1LGUpe2Nhc2UgMTp2YXIgbz0tMTticmVhaztjYXNlIDI6bz0yNTA7YnJlYWs7Y2FzZSA1Om89MTA3Mzc0MTgyMzticmVhaztjYXNlIDQ6bz0xZTQ7YnJlYWs7ZGVmYXVsdDpvPTVlM31yZXR1cm4gbz1hK28sZT17aWQ6ZCsrLGNhbGxiYWNrOmwscHJpb3JpdHlMZXZlbDplLHN0YXJ0VGltZTphLGV4cGlyYXRpb25UaW1lOm8sc29ydEluZGV4Oi0xfSxhPnU/KGUuc29ydEluZGV4PWEsdChmLGUpLG51bGw9PT1yKGMpJiZlPT09cihmKSYmKHY/KGIoXyksXz0tMSk6dj0hMCxGKFMsYS11KSkpOihlLnNvcnRJbmRleD1vLHQoYyxlKSxnfHxofHwoZz0hMCxNKHgpKSksZX0sbi51bnN0YWJsZV9zaG91bGRZaWVsZD16LG4udW5zdGFibGVfd3JhcENhbGxiYWNrPWZ1bmN0aW9uKGUpe3ZhciBuPW07cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHQ9bTttPW47dHJ5e3JldHVybiBlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maW5hbGx5e209dH19fX0sMzg0MDpmdW5jdGlvbihlLG4sdCl7ZS5leHBvcnRzPXQoNTMpfX1dKTs=\")\nassets.set(\"/_next/static/chunks/main-a19712a603cff01e.js\", \"data:application/javascript;base64,KHNlbGYud2VicGFja0NodW5rX05fRT1zZWxmLndlYnBhY2tDaHVua19OX0V8fFtdKS5wdXNoKFtbMTc5XSx7Mzc6ZnVuY3Rpb24oKXsidHJpbVN0YXJ0ImluIFN0cmluZy5wcm90b3R5cGV8fChTdHJpbmcucHJvdG90eXBlLnRyaW1TdGFydD1TdHJpbmcucHJvdG90eXBlLnRyaW1MZWZ0KSwidHJpbUVuZCJpbiBTdHJpbmcucHJvdG90eXBlfHwoU3RyaW5nLnByb3RvdHlwZS50cmltRW5kPVN0cmluZy5wcm90b3R5cGUudHJpbVJpZ2h0KSwiZGVzY3JpcHRpb24iaW4gU3ltYm9sLnByb3RvdHlwZXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KFN5bWJvbC5wcm90b3R5cGUsImRlc2NyaXB0aW9uIix7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3ZhciBlPS9cKCguKilcKS8uZXhlYyh0aGlzLnRvU3RyaW5nKCkpO3JldHVybiBlP2VbMV06dm9pZCAwfX0pLEFycmF5LnByb3RvdHlwZS5mbGF0fHwoQXJyYXkucHJvdG90eXBlLmZsYXQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdD10aGlzLmNvbmNhdC5hcHBseShbXSx0aGlzKSxlPjEmJnQuc29tZShBcnJheS5pc0FycmF5KT90LmZsYXQoZS0xKTp0fSxBcnJheS5wcm90b3R5cGUuZmxhdE1hcD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLm1hcChlLHQpLmZsYXQoKX0pLFByb21pc2UucHJvdG90eXBlLmZpbmFsbHl8fChQcm9taXNlLnByb3RvdHlwZS5maW5hbGx5PWZ1bmN0aW9uKGUpe2lmKCJmdW5jdGlvbiIhPXR5cGVvZiBlKXJldHVybiB0aGlzLnRoZW4oZSxlKTt2YXIgdD10aGlzLmNvbnN0cnVjdG9yfHxQcm9taXNlO3JldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24ocil7cmV0dXJuIHQucmVzb2x2ZShlKCkpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gcn0pfSxmdW5jdGlvbihyKXtyZXR1cm4gdC5yZXNvbHZlKGUoKSkudGhlbihmdW5jdGlvbigpe3Rocm93IHJ9KX0pfSksT2JqZWN0LmZyb21FbnRyaWVzfHwoT2JqZWN0LmZyb21FbnRyaWVzPWZ1bmN0aW9uKGUpe3JldHVybiBBcnJheS5mcm9tKGUpLnJlZHVjZShmdW5jdGlvbihlLHQpe3JldHVybiBlW3RbMF1dPXRbMV0sZX0se30pfSl9LDM0NzU6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImFkZEJhc2VQYXRoIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gb319KTtsZXQgbj1yKDE0ODQpLGE9cigzNzg1KTtmdW5jdGlvbiBvKGUsdCl7cmV0dXJuKDAsYS5ub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCkoKDAsbi5hZGRQYXRoUHJlZml4KShlLCIiKSl9KCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sMjk5OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJhZGRMb2NhbGUiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBufX0pLHIoMzc4NSk7bGV0IG49ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgscj1BcnJheSh0PjE/dC0xOjApLG49MTtuPHQ7bisrKXJbbi0xXT1hcmd1bWVudHNbbl07cmV0dXJuIGV9OygiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDI2ODpmdW5jdGlvbihlLHQpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImRldGVjdERvbWFpbkxvY2FsZSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHJ9fSk7bGV0IHI9ZnVuY3Rpb24oKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCx0PUFycmF5KGUpLHI9MDtyPGU7cisrKXRbcl09YXJndW1lbnRzW3JdfTsoImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSwxMTczOmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJoYXNCYXNlUGF0aCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGF9fSk7bGV0IG49cig5NjIzKTtmdW5jdGlvbiBhKGUpe3JldHVybigwLG4ucGF0aEhhc1ByZWZpeCkoZSwiIil9KCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sMzEyOmZ1bmN0aW9uKGUsdCl7InVzZSBzdHJpY3QiO2xldCByO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ITAsZ2V0OnRbcl19KX0odCx7RE9NQXR0cmlidXRlTmFtZXM6ZnVuY3Rpb24oKXtyZXR1cm4gbn0saXNFcXVhbE5vZGU6ZnVuY3Rpb24oKXtyZXR1cm4gb30sZGVmYXVsdDpmdW5jdGlvbigpe3JldHVybiBpfX0pO2xldCBuPXthY2NlcHRDaGFyc2V0OiJhY2NlcHQtY2hhcnNldCIsY2xhc3NOYW1lOiJjbGFzcyIsaHRtbEZvcjoiZm9yIixodHRwRXF1aXY6Imh0dHAtZXF1aXYiLG5vTW9kdWxlOiJub01vZHVsZSJ9O2Z1bmN0aW9uIGEoZSl7bGV0e3R5cGU6dCxwcm9wczpyfT1lLGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0KTtmb3IobGV0IGUgaW4gcil7aWYoIXIuaGFzT3duUHJvcGVydHkoZSl8fCJjaGlsZHJlbiI9PT1lfHwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiPT09ZXx8dm9pZCAwPT09cltlXSljb250aW51ZTtsZXQgbz1uW2VdfHxlLnRvTG93ZXJDYXNlKCk7InNjcmlwdCI9PT10JiYoImFzeW5jIj09PW98fCJkZWZlciI9PT1vfHwibm9Nb2R1bGUiPT09byk/YVtvXT0hIXJbZV06YS5zZXRBdHRyaWJ1dGUobyxyW2VdKX1sZXR7Y2hpbGRyZW46byxkYW5nZXJvdXNseVNldElubmVySFRNTDppfT1yO3JldHVybiBpP2EuaW5uZXJIVE1MPWkuX19odG1sfHwiIjpvJiYoYS50ZXh0Q29udGVudD0ic3RyaW5nIj09dHlwZW9mIG8/bzpBcnJheS5pc0FycmF5KG8pP28uam9pbigiIik6IiIpLGF9ZnVuY3Rpb24gbyhlLHQpe2lmKGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCYmdCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KXtsZXQgcj10LmdldEF0dHJpYnV0ZSgibm9uY2UiKTtpZihyJiYhZS5nZXRBdHRyaWJ1dGUoIm5vbmNlIikpe2xldCBuPXQuY2xvbmVOb2RlKCEwKTtyZXR1cm4gbi5zZXRBdHRyaWJ1dGUoIm5vbmNlIiwiIiksbi5ub25jZT1yLHI9PT1lLm5vbmNlJiZlLmlzRXF1YWxOb2RlKG4pfX1yZXR1cm4gZS5pc0VxdWFsTm9kZSh0KX1mdW5jdGlvbiBpKCl7cmV0dXJue21vdW50ZWRJbnN0YW5jZXM6bmV3IFNldCx1cGRhdGVIZWFkOmU9PntsZXQgdD17fTtlLmZvckVhY2goZT0+e2lmKCJsaW5rIj09PWUudHlwZSYmZS5wcm9wc1siZGF0YS1vcHRpbWl6ZWQtZm9udHMiXSl7aWYoZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS1ocmVmPSInK2UucHJvcHNbImRhdGEtaHJlZiJdKyciXScpKXJldHVybjtlLnByb3BzLmhyZWY9ZS5wcm9wc1siZGF0YS1ocmVmIl0sZS5wcm9wc1siZGF0YS1ocmVmIl09dm9pZCAwfWxldCByPXRbZS50eXBlXXx8W107ci5wdXNoKGUpLHRbZS50eXBlXT1yfSk7bGV0IG49dC50aXRsZT90LnRpdGxlWzBdOm51bGwsYT0iIjtpZihuKXtsZXR7Y2hpbGRyZW46ZX09bi5wcm9wczthPSJzdHJpbmciPT10eXBlb2YgZT9lOkFycmF5LmlzQXJyYXkoZSk/ZS5qb2luKCIiKToiIn1hIT09ZG9jdW1lbnQudGl0bGUmJihkb2N1bWVudC50aXRsZT1hKSxbIm1ldGEiLCJiYXNlIiwibGluayIsInN0eWxlIiwic2NyaXB0Il0uZm9yRWFjaChlPT57cihlLHRbZV18fFtdKX0pfX19cj0oZSx0KT0+e2xldCByPWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJoZWFkIilbMF0sbj1yLnF1ZXJ5U2VsZWN0b3IoIm1ldGFbbmFtZT1uZXh0LWhlYWQtY291bnRdIiksaT1OdW1iZXIobi5jb250ZW50KSxsPVtdO2ZvcihsZXQgdD0wLHI9bi5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO3Q8aTt0Kysscj0obnVsbD09cj92b2lkIDA6ci5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKXx8bnVsbCl7dmFyIHU7KG51bGw9PXI/dm9pZCAwOm51bGw9PSh1PXIudGFnTmFtZSk/dm9pZCAwOnUudG9Mb3dlckNhc2UoKSk9PT1lJiZsLnB1c2gocil9bGV0IHM9dC5tYXAoYSkuZmlsdGVyKGU9Pntmb3IobGV0IHQ9MCxyPWwubGVuZ3RoO3Q8cjt0Kyspe2xldCByPWxbdF07aWYobyhyLGUpKXJldHVybiBsLnNwbGljZSh0LDEpLCExfXJldHVybiEwfSk7bC5mb3JFYWNoKGU9Pnt2YXIgdDtyZXR1cm4gbnVsbD09KHQ9ZS5wYXJlbnROb2RlKT92b2lkIDA6dC5yZW1vdmVDaGlsZChlKX0pLHMuZm9yRWFjaChlPT5yLmluc2VydEJlZm9yZShlLG4pKSxuLmNvbnRlbnQ9KGktbC5sZW5ndGgrcy5sZW5ndGgpLnRvU3RyaW5nKCl9LCgiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDk0OTQ6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtsZXQgbixhLG8saSxsLHUscyxjLGYsZCxoLHA7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO2xldCBtPXIoMTc1Nyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIHQpT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscix7ZW51bWVyYWJsZTohMCxnZXQ6dFtyXX0pfSh0LHt2ZXJzaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIEd9LHJvdXRlcjpmdW5jdGlvbigpe3JldHVybiBufSxlbWl0dGVyOmZ1bmN0aW9uKCl7cmV0dXJuIFZ9LGluaXRpYWxpemU6ZnVuY3Rpb24oKXtyZXR1cm4gS30saHlkcmF0ZTpmdW5jdGlvbigpe3JldHVybiBlY319KTtsZXQgZz1yKDg3NTQpO3IoMzcpO2xldCB5PWcuXyhyKDcyOTQpKSxfPWcuXyhyKDc0NSkpLGI9cig2MTE3KSx2PWcuXyhyKDY3MTIpKSxQPXIoMjI1MCksdz1yKDEyNTcpLFM9cigzNzAyKSxqPXIoMTM1NCksTz1yKDE4NTgpLEU9cig3MzIxKSxSPXIoNzA4OSkseD1nLl8ocigzMTIpKSxDPWcuXyhyKDI2OTcpKSxNPWcuXyhyKDcyNjYpKSxBPXIoODgxMyksTD1yKDEyNDcpLEk9cig2NzYpLFQ9cigyNDkzKSxOPXIoNjM2Nyksaz1yKDExNzMpLEQ9cig2NDUxKSxCPXIoNDEyOCksSD1yKDQ4NTgpLFU9Zy5fKHIoNDQxMykpLEY9ZT0+dD0+ZSh0KSsiIixXPXIudTtyLnU9RihXKTtsZXQgcT1yLms7ci5rPUYocSk7bGV0IHo9ci5taW5pQ3NzRjtyLm1pbmlDc3NGPUYoeik7bGV0IEc9IjEzLjQuMTAiLFY9KDAsdi5kZWZhdWx0KSgpLFg9ZT0+W10uc2xpY2UuY2FsbChlKSwkPSExO3NlbGYuX19uZXh0X3JlcXVpcmVfXz1yO2NsYXNzIFkgZXh0ZW5kcyB5LmRlZmF1bHQuQ29tcG9uZW50e2NvbXBvbmVudERpZENhdGNoKGUsdCl7dGhpcy5wcm9wcy5mbihlLHQpfWNvbXBvbmVudERpZE1vdW50KCl7dGhpcy5zY3JvbGxUb0hhc2goKSxuLmlzU3NyJiYoYS5pc0ZhbGxiYWNrfHxhLm5leHRFeHBvcnQmJigoMCxTLmlzRHluYW1pY1JvdXRlKShuLnBhdGhuYW1lKXx8bG9jYXRpb24uc2VhcmNofHwkKXx8YS5wcm9wcyYmYS5wcm9wcy5fX05fU1NHJiYobG9jYXRpb24uc2VhcmNofHwkKSkmJm4ucmVwbGFjZShuLnBhdGhuYW1lKyI/IitTdHJpbmcoKDAsai5hc3NpZ24pKCgwLGoudXJsUXVlcnlUb1NlYXJjaFBhcmFtcykobi5xdWVyeSksbmV3IFVSTFNlYXJjaFBhcmFtcyhsb2NhdGlvbi5zZWFyY2gpKSksbyx7X2g6MSxzaGFsbG93OiFhLmlzRmFsbGJhY2smJiEkfSkuY2F0Y2goZT0+e2lmKCFlLmNhbmNlbGxlZCl0aHJvdyBlfSl9Y29tcG9uZW50RGlkVXBkYXRlKCl7dGhpcy5zY3JvbGxUb0hhc2goKX1zY3JvbGxUb0hhc2goKXtsZXR7aGFzaDplfT1sb2NhdGlvbjtpZighKGU9ZSYmZS5zdWJzdHJpbmcoMSkpKXJldHVybjtsZXQgdD1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChlKTt0JiZzZXRUaW1lb3V0KCgpPT50LnNjcm9sbEludG9WaWV3KCksMCl9cmVuZGVyKCl7cmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW59fWFzeW5jIGZ1bmN0aW9uIEsoZSl7dm9pZCAwPT09ZSYmKGU9e30pLGE9SlNPTi5wYXJzZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiX19ORVhUX0RBVEFfXyIpLnRleHRDb250ZW50KSx3aW5kb3cuX19ORVhUX0RBVEFfXz1hLHA9YS5kZWZhdWx0TG9jYWxlO2xldCB0PWEuYXNzZXRQcmVmaXh8fCIiO2lmKHIucD0iIit0KyIvX25leHQvIiwoMCxPLnNldENvbmZpZykoe3NlcnZlclJ1bnRpbWVDb25maWc6e30scHVibGljUnVudGltZUNvbmZpZzphLnJ1bnRpbWVDb25maWd8fHt9fSksbz0oMCxFLmdldFVSTCkoKSwoMCxrLmhhc0Jhc2VQYXRoKShvKSYmKG89KDAsTi5yZW1vdmVCYXNlUGF0aCkobykpLGEuc2NyaXB0TG9hZGVyKXtsZXR7aW5pdFNjcmlwdExvYWRlcjplfT1yKDQyOTQpO2UoYS5zY3JpcHRMb2FkZXIpfWk9bmV3IEMuZGVmYXVsdChhLmJ1aWxkSWQsdCk7bGV0IHM9ZT0+e2xldFt0LHJdPWU7cmV0dXJuIGkucm91dGVMb2FkZXIub25FbnRyeXBvaW50KHQscil9O3JldHVybiB3aW5kb3cuX19ORVhUX1AmJndpbmRvdy5fX05FWFRfUC5tYXAoZT0+c2V0VGltZW91dCgoKT0+cyhlKSwwKSksd2luZG93Ll9fTkVYVF9QPVtdLHdpbmRvdy5fX05FWFRfUC5wdXNoPXMsKHU9KDAseC5kZWZhdWx0KSgpKS5nZXRJc1Nzcj0oKT0+bi5pc1NzcixsPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCJfX25leHQiKSx7YXNzZXRQcmVmaXg6dH19ZnVuY3Rpb24gSihlLHQpe3JldHVybiB5LmRlZmF1bHQuY3JlYXRlRWxlbWVudChlLHQpfWZ1bmN0aW9uIFEoZSl7dmFyIHQ7bGV0e2NoaWxkcmVuOnJ9PWUsYT15LmRlZmF1bHQudXNlTWVtbygoKT0+KDAsQi5hZGFwdEZvckFwcFJvdXRlckluc3RhbmNlKShuKSxbXSk7cmV0dXJuIHkuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFkse2ZuOmU9PmVlKHtBcHA6ZixlcnI6ZX0pLmNhdGNoKGU9PmNvbnNvbGUuZXJyb3IoIkVycm9yIHJlbmRlcmluZyBwYWdlOiAiLGUpKX0seS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRC5BcHBSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLHt2YWx1ZTphfSx5LmRlZmF1bHQuY3JlYXRlRWxlbWVudChILlNlYXJjaFBhcmFtc0NvbnRleHQuUHJvdmlkZXIse3ZhbHVlOigwLEIuYWRhcHRGb3JTZWFyY2hQYXJhbXMpKG4pfSx5LmRlZmF1bHQuY3JlYXRlRWxlbWVudChCLlBhdGhuYW1lQ29udGV4dFByb3ZpZGVyQWRhcHRlcix7cm91dGVyOm4saXNBdXRvRXhwb3J0Om51bGwhPSh0PXNlbGYuX19ORVhUX0RBVEFfXy5hdXRvRXhwb3J0KSYmdH0seS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUC5Sb3V0ZXJDb250ZXh0LlByb3ZpZGVyLHt2YWx1ZTooMCxMLm1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZSkobil9LHkuZGVmYXVsdC5jcmVhdGVFbGVtZW50KGIuSGVhZE1hbmFnZXJDb250ZXh0LlByb3ZpZGVyLHt2YWx1ZTp1fSx5LmRlZmF1bHQuY3JlYXRlRWxlbWVudChULkltYWdlQ29uZmlnQ29udGV4dC5Qcm92aWRlcix7dmFsdWU6e2RldmljZVNpemVzOls2NDAsNzUwLDgyOCwxMDgwLDEyMDAsMTkyMCwyMDQ4LDM4NDBdLGltYWdlU2l6ZXM6WzE2LDMyLDQ4LDY0LDk2LDEyOCwyNTYsMzg0XSxwYXRoOiIvX25leHQvaW1hZ2UiLGxvYWRlcjoiZGVmYXVsdCIsZGFuZ2Vyb3VzbHlBbGxvd1NWRzohMSx1bm9wdGltaXplZDohMH19LHIpKSkpKSkpfWxldCBaPWU9PnQ9PntsZXQgcj17Li4udCxDb21wb25lbnQ6aCxlcnI6YS5lcnIscm91dGVyOm59O3JldHVybiB5LmRlZmF1bHQuY3JlYXRlRWxlbWVudChRLG51bGwsSihlLHIpKX07ZnVuY3Rpb24gZWUoZSl7bGV0e0FwcDp0LGVycjpsfT1lO3JldHVybiBjb25zb2xlLmVycm9yKGwpLGNvbnNvbGUuZXJyb3IoIkEgY2xpZW50LXNpZGUgZXhjZXB0aW9uIGhhcyBvY2N1cnJlZCwgc2VlIGhlcmUgZm9yIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvY2xpZW50LXNpZGUtZXhjZXB0aW9uLW9jY3VycmVkIiksaS5sb2FkUGFnZSgiL19lcnJvciIpLnRoZW4obj0+e2xldHtwYWdlOmEsc3R5bGVTaGVldHM6b309bjtyZXR1cm4obnVsbD09cz92b2lkIDA6cy5Db21wb25lbnQpPT09YT9Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT5tLl8ocigzNDQxKSkpLnRoZW4obj0+UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+bS5fKHIoNjUzMCkpKS50aGVuKHI9Pih0PXIuZGVmYXVsdCxlLkFwcD10LG4pKSkudGhlbihlPT4oe0Vycm9yQ29tcG9uZW50OmUuZGVmYXVsdCxzdHlsZVNoZWV0czpbXX0pKTp7RXJyb3JDb21wb25lbnQ6YSxzdHlsZVNoZWV0czpvfX0pLnRoZW4ocj0+e3ZhciBpO2xldHtFcnJvckNvbXBvbmVudDp1LHN0eWxlU2hlZXRzOnN9PXIsYz1aKHQpLGY9e0NvbXBvbmVudDp1LEFwcFRyZWU6Yyxyb3V0ZXI6bixjdHg6e2VycjpsLHBhdGhuYW1lOmEucGFnZSxxdWVyeTphLnF1ZXJ5LGFzUGF0aDpvLEFwcFRyZWU6Y319O3JldHVybiBQcm9taXNlLnJlc29sdmUoKG51bGw9PShpPWUucHJvcHMpP3ZvaWQgMDppLmVycik/ZS5wcm9wczooMCxFLmxvYWRHZXRJbml0aWFsUHJvcHMpKHQsZikpLnRoZW4odD0+ZXUoey4uLmUsZXJyOmwsQ29tcG9uZW50OnUsc3R5bGVTaGVldHM6cyxwcm9wczp0fSkpfSl9ZnVuY3Rpb24gZXQoZSl7bGV0e2NhbGxiYWNrOnR9PWU7cmV0dXJuIHkuZGVmYXVsdC51c2VMYXlvdXRFZmZlY3QoKCk9PnQoKSxbdF0pLG51bGx9bGV0IGVyPW51bGwsZW49ITA7ZnVuY3Rpb24gZWEoKXtbImJlZm9yZVJlbmRlciIsImFmdGVySHlkcmF0ZSIsImFmdGVyUmVuZGVyIiwicm91dGVDaGFuZ2UiXS5mb3JFYWNoKGU9PnBlcmZvcm1hbmNlLmNsZWFyTWFya3MoZSkpfWZ1bmN0aW9uIGVvKCl7RS5TVCYmKHBlcmZvcm1hbmNlLm1hcmsoImFmdGVySHlkcmF0ZSIpLHBlcmZvcm1hbmNlLm1lYXN1cmUoIk5leHQuanMtYmVmb3JlLWh5ZHJhdGlvbiIsIm5hdmlnYXRpb25TdGFydCIsImJlZm9yZVJlbmRlciIpLHBlcmZvcm1hbmNlLm1lYXN1cmUoIk5leHQuanMtaHlkcmF0aW9uIiwiYmVmb3JlUmVuZGVyIiwiYWZ0ZXJIeWRyYXRlIiksZCYmcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgiTmV4dC5qcy1oeWRyYXRpb24iKS5mb3JFYWNoKGQpLGVhKCkpfWZ1bmN0aW9uIGVpKCl7aWYoIUUuU1QpcmV0dXJuO3BlcmZvcm1hbmNlLm1hcmsoImFmdGVyUmVuZGVyIik7bGV0IGU9cGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgicm91dGVDaGFuZ2UiLCJtYXJrIik7ZS5sZW5ndGgmJihwZXJmb3JtYW5jZS5tZWFzdXJlKCJOZXh0LmpzLXJvdXRlLWNoYW5nZS10by1yZW5kZXIiLGVbMF0ubmFtZSwiYmVmb3JlUmVuZGVyIikscGVyZm9ybWFuY2UubWVhc3VyZSgiTmV4dC5qcy1yZW5kZXIiLCJiZWZvcmVSZW5kZXIiLCJhZnRlclJlbmRlciIpLGQmJihwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKCJOZXh0LmpzLXJlbmRlciIpLmZvckVhY2goZCkscGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgiTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyIikuZm9yRWFjaChkKSksZWEoKSxbIk5leHQuanMtcm91dGUtY2hhbmdlLXRvLXJlbmRlciIsIk5leHQuanMtcmVuZGVyIl0uZm9yRWFjaChlPT5wZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKGUpKSl9ZnVuY3Rpb24gZWwoZSl7bGV0e2NhbGxiYWNrczp0LGNoaWxkcmVuOnJ9PWU7cmV0dXJuIHkuZGVmYXVsdC51c2VMYXlvdXRFZmZlY3QoKCk9PnQuZm9yRWFjaChlPT5lKCkpLFt0XSkseS5kZWZhdWx0LnVzZUVmZmVjdCgoKT0+eygwLE0uZGVmYXVsdCkoZCl9LFtdKSxyfWZ1bmN0aW9uIGV1KGUpe2xldCB0LHtBcHA6cixDb21wb25lbnQ6YSxwcm9wczpvLGVycjppfT1lLHU9ImluaXRpYWwiaW4gZT92b2lkIDA6ZS5zdHlsZVNoZWV0czthPWF8fHMuQ29tcG9uZW50LG89b3x8cy5wcm9wcztsZXQgZj17Li4ubyxDb21wb25lbnQ6YSxlcnI6aSxyb3V0ZXI6bn07cz1mO2xldCBkPSExLGg9bmV3IFByb21pc2UoKGUscik9PntjJiZjKCksdD0oKT0+e2M9bnVsbCxlKCl9LGM9KCk9PntkPSEwLGM9bnVsbDtsZXQgZT1FcnJvcigiQ2FuY2VsIHJlbmRlcmluZyByb3V0ZSIpO2UuY2FuY2VsbGVkPSEwLHIoZSl9fSk7ZnVuY3Rpb24gcCgpe3QoKX0hZnVuY3Rpb24oKXtpZighdSlyZXR1cm47bGV0IGU9WChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCJzdHlsZVtkYXRhLW4taHJlZl0iKSksdD1uZXcgU2V0KGUubWFwKGU9PmUuZ2V0QXR0cmlidXRlKCJkYXRhLW4taHJlZiIpKSkscj1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCJub3NjcmlwdFtkYXRhLW4tY3NzXSIpLG49bnVsbD09cj92b2lkIDA6ci5nZXRBdHRyaWJ1dGUoImRhdGEtbi1jc3MiKTt1LmZvckVhY2goZT0+e2xldHtocmVmOnIsdGV4dDphfT1lO2lmKCF0LmhhcyhyKSl7bGV0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic3R5bGUiKTtlLnNldEF0dHJpYnV0ZSgiZGF0YS1uLWhyZWYiLHIpLGUuc2V0QXR0cmlidXRlKCJtZWRpYSIsIngiKSxuJiZlLnNldEF0dHJpYnV0ZSgibm9uY2UiLG4pLGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZSksZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhKSl9fSl9KCk7bGV0IG09eS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoeS5kZWZhdWx0LkZyYWdtZW50LG51bGwseS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoZXQse2NhbGxiYWNrOmZ1bmN0aW9uKCl7aWYodSYmIWQpe2xldCBlPW5ldyBTZXQodS5tYXAoZT0+ZS5ocmVmKSksdD1YKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoInN0eWxlW2RhdGEtbi1ocmVmXSIpKSxyPXQubWFwKGU9PmUuZ2V0QXR0cmlidXRlKCJkYXRhLW4taHJlZiIpKTtmb3IobGV0IG49MDtuPHIubGVuZ3RoOysrbillLmhhcyhyW25dKT90W25dLnJlbW92ZUF0dHJpYnV0ZSgibWVkaWEiKTp0W25dLnNldEF0dHJpYnV0ZSgibWVkaWEiLCJ4Iik7bGV0IG49ZG9jdW1lbnQucXVlcnlTZWxlY3Rvcigibm9zY3JpcHRbZGF0YS1uLWNzc10iKTtuJiZ1LmZvckVhY2goZT0+e2xldHtocmVmOnR9PWUscj1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdHlsZVtkYXRhLW4taHJlZj0iJyt0KyciXScpO3ImJihuLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHIsbi5uZXh0U2libGluZyksbj1yKX0pLFgoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgibGlua1tkYXRhLW4tcF0iKSkuZm9yRWFjaChlPT57ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSl9aWYoZS5zY3JvbGwpe2xldHt4OnQseTpyfT1lLnNjcm9sbDsoMCx3LmhhbmRsZVNtb290aFNjcm9sbCkoKCk9Pnt3aW5kb3cuc2Nyb2xsVG8odCxyKX0pfX19KSx5LmRlZmF1bHQuY3JlYXRlRWxlbWVudChRLG51bGwsSihyLGYpLHkuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFIuUG9ydGFsLHt0eXBlOiJuZXh0LXJvdXRlLWFubm91bmNlciJ9LHkuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEEuUm91dGVBbm5vdW5jZXIsbnVsbCkpKSk7cmV0dXJuIWZ1bmN0aW9uKGUsdCl7RS5TVCYmcGVyZm9ybWFuY2UubWFyaygiYmVmb3JlUmVuZGVyIik7bGV0IHI9dChlbj9lbzplaSk7aWYoZXIpe2xldCBlPXkuZGVmYXVsdC5zdGFydFRyYW5zaXRpb247ZSgoKT0+e2VyLnJlbmRlcihyKX0pfWVsc2UgZXI9Xy5kZWZhdWx0Lmh5ZHJhdGVSb290KGUscix7b25SZWNvdmVyYWJsZUVycm9yOlUuZGVmYXVsdH0pLGVuPSExfShsLGU9PnkuZGVmYXVsdC5jcmVhdGVFbGVtZW50KGVsLHtjYWxsYmFja3M6W2UscF19LG0pKSxofWFzeW5jIGZ1bmN0aW9uIGVzKGUpe2lmKGUuZXJyKXthd2FpdCBlZShlKTtyZXR1cm59dHJ5e2F3YWl0IGV1KGUpfWNhdGNoKHIpe2xldCB0PSgwLEkuZ2V0UHJvcGVyRXJyb3IpKHIpO2lmKHQuY2FuY2VsbGVkKXRocm93IHQ7YXdhaXQgZWUoey4uLmUsZXJyOnR9KX19YXN5bmMgZnVuY3Rpb24gZWMoZSl7bGV0IHQ9YS5lcnI7dHJ5e2xldCBlPWF3YWl0IGkucm91dGVMb2FkZXIud2hlbkVudHJ5cG9pbnQoIi9fYXBwIik7aWYoImVycm9yImluIGUpdGhyb3cgZS5lcnJvcjtsZXR7Y29tcG9uZW50OnQsZXhwb3J0czpyfT1lO2Y9dCxyJiZyLnJlcG9ydFdlYlZpdGFscyYmKGQ9ZT0+e2xldCB0LHtpZDpuLG5hbWU6YSxzdGFydFRpbWU6byx2YWx1ZTppLGR1cmF0aW9uOmwsZW50cnlUeXBlOnUsZW50cmllczpzLGF0dHJpYnV0aW9uOmN9PWUsZj1EYXRlLm5vdygpKyItIisoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKig5ZTEyLTEpKSsxZTEyKTtzJiZzLmxlbmd0aCYmKHQ9c1swXS5zdGFydFRpbWUpO2xldCBkPXtpZDpufHxmLG5hbWU6YSxzdGFydFRpbWU6b3x8dCx2YWx1ZTpudWxsPT1pP2w6aSxsYWJlbDoibWFyayI9PT11fHwibWVhc3VyZSI9PT11PyJjdXN0b20iOiJ3ZWItdml0YWwifTtjJiYoZC5hdHRyaWJ1dGlvbj1jKSxyLnJlcG9ydFdlYlZpdGFscyhkKX0pO2xldCBuPWF3YWl0IGkucm91dGVMb2FkZXIud2hlbkVudHJ5cG9pbnQoYS5wYWdlKTtpZigiZXJyb3IiaW4gbil0aHJvdyBuLmVycm9yO2g9bi5jb21wb25lbnR9Y2F0Y2goZSl7dD0oMCxJLmdldFByb3BlckVycm9yKShlKX13aW5kb3cuX19ORVhUX1BSRUxPQURSRUFEWSYmYXdhaXQgd2luZG93Ll9fTkVYVF9QUkVMT0FEUkVBRFkoYS5keW5hbWljSWRzKSxuPSgwLEwuY3JlYXRlUm91dGVyKShhLnBhZ2UsYS5xdWVyeSxvLHtpbml0aWFsUHJvcHM6YS5wcm9wcyxwYWdlTG9hZGVyOmksQXBwOmYsQ29tcG9uZW50Omgsd3JhcEFwcDpaLGVycjp0LGlzRmFsbGJhY2s6ISFhLmlzRmFsbGJhY2ssc3Vic2NyaXB0aW9uOihlLHQscik9PmVzKE9iamVjdC5hc3NpZ24oe30sZSx7QXBwOnQsc2Nyb2xsOnJ9KSksbG9jYWxlOmEubG9jYWxlLGxvY2FsZXM6YS5sb2NhbGVzLGRlZmF1bHRMb2NhbGU6cCxkb21haW5Mb2NhbGVzOmEuZG9tYWluTG9jYWxlcyxpc1ByZXZpZXc6YS5pc1ByZXZpZXd9KSwkPWF3YWl0IG4uX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2U7bGV0IHI9e0FwcDpmLGluaXRpYWw6ITAsQ29tcG9uZW50OmgscHJvcHM6YS5wcm9wcyxlcnI6dH07KG51bGw9PWU/dm9pZCAwOmUuYmVmb3JlUmVuZGVyKSYmYXdhaXQgZS5iZWZvcmVSZW5kZXIoKSxlcyhyKX0oImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSwxMDE5OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO2xldCBuPXIoOTQ5NCk7d2luZG93Lm5leHQ9e3ZlcnNpb246bi52ZXJzaW9uLGdldCByb3V0ZXIoKXtyZXR1cm4gbi5yb3V0ZXJ9LGVtaXR0ZXI6bi5lbWl0dGVyfSwoMCxuLmluaXRpYWxpemUpKHt9KS50aGVuKCgpPT4oMCxuLmh5ZHJhdGUpKCkpLmNhdGNoKGNvbnNvbGUuZXJyb3IpLCgiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDM3ODU6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gb319KTtsZXQgbj1yKDUxMjkpLGE9cig3NjM3KSxvPWU9PntpZighZS5zdGFydHNXaXRoKCIvIikpcmV0dXJuIGU7bGV0e3BhdGhuYW1lOnQscXVlcnk6cixoYXNoOm99PSgwLGEucGFyc2VQYXRoKShlKTtyZXR1cm4iIisoMCxuLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHQpK3Irb307KCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sNDQxMzpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiZGVmYXVsdCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGF9fSk7bGV0IG49cig2MjY2KTtmdW5jdGlvbiBhKGUpe2xldCB0PSJmdW5jdGlvbiI9PXR5cGVvZiByZXBvcnRFcnJvcj9yZXBvcnRFcnJvcjplPT57d2luZG93LmNvbnNvbGUuZXJyb3IoZSl9O2UuZGlnZXN0IT09bi5ORVhUX0RZTkFNSUNfTk9fU1NSX0NPREUmJnQoZSl9KCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sMjY5NzpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiZGVmYXVsdCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGR9fSk7bGV0IG49cig4NzU0KSxhPXIoMzQ3NSksbz1yKDE2OTApLGk9bi5fKHIoNTg1NCkpLGw9cigyOTkpLHU9cigzNzAyKSxzPXIoMTM3KSxjPXIoNTEyOSksZj1yKDgyNjkpO2NsYXNzIGR7Z2V0UGFnZUxpc3QoKXtyZXR1cm4oMCxmLmdldENsaWVudEJ1aWxkTWFuaWZlc3QpKCkudGhlbihlPT5lLnNvcnRlZFBhZ2VzKX1nZXRNaWRkbGV3YXJlKCl7cmV0dXJuIHdpbmRvdy5fX01JRERMRVdBUkVfTUFUQ0hFUlM9W10sd2luZG93Ll9fTUlERExFV0FSRV9NQVRDSEVSU31nZXREYXRhSHJlZihlKXtsZXR7YXNQYXRoOnQsaHJlZjpyLGxvY2FsZTpufT1lLHtwYXRobmFtZTpmLHF1ZXJ5OmQsc2VhcmNoOmh9PSgwLHMucGFyc2VSZWxhdGl2ZVVybCkocikse3BhdGhuYW1lOnB9PSgwLHMucGFyc2VSZWxhdGl2ZVVybCkodCksbT0oMCxjLnJlbW92ZVRyYWlsaW5nU2xhc2gpKGYpO2lmKCIvIiE9PW1bMF0pdGhyb3cgRXJyb3IoJ1JvdXRlIG5hbWUgc2hvdWxkIHN0YXJ0IHdpdGggYSAiLyIsIGdvdCAiJyttKyciJyk7cmV0dXJuKGU9PntsZXQgdD0oMCxpLmRlZmF1bHQpKCgwLGMucmVtb3ZlVHJhaWxpbmdTbGFzaCkoKDAsbC5hZGRMb2NhbGUpKGUsbikpLCIuanNvbiIpO3JldHVybigwLGEuYWRkQmFzZVBhdGgpKCIvX25leHQvZGF0YS8iK3RoaXMuYnVpbGRJZCt0K2gsITApfSkoZS5za2lwSW50ZXJwb2xhdGlvbj9wOigwLHUuaXNEeW5hbWljUm91dGUpKG0pPygwLG8uaW50ZXJwb2xhdGVBcykoZixwLGQpLnJlc3VsdDptKX1faXNTc2coZSl7cmV0dXJuIHRoaXMucHJvbWlzZWRTc2dNYW5pZmVzdC50aGVuKHQ9PnQuaGFzKGUpKX1sb2FkUGFnZShlKXtyZXR1cm4gdGhpcy5yb3V0ZUxvYWRlci5sb2FkUm91dGUoZSkudGhlbihlPT57aWYoImNvbXBvbmVudCJpbiBlKXJldHVybntwYWdlOmUuY29tcG9uZW50LG1vZDplLmV4cG9ydHMsc3R5bGVTaGVldHM6ZS5zdHlsZXMubWFwKGU9Pih7aHJlZjplLmhyZWYsdGV4dDplLmNvbnRlbnR9KSl9O3Rocm93IGUuZXJyb3J9KX1wcmVmZXRjaChlKXtyZXR1cm4gdGhpcy5yb3V0ZUxvYWRlci5wcmVmZXRjaChlKX1jb25zdHJ1Y3RvcihlLHQpe3RoaXMucm91dGVMb2FkZXI9KDAsZi5jcmVhdGVSb3V0ZUxvYWRlcikodCksdGhpcy5idWlsZElkPWUsdGhpcy5hc3NldFByZWZpeD10LHRoaXMucHJvbWlzZWRTc2dNYW5pZmVzdD1uZXcgUHJvbWlzZShlPT57d2luZG93Ll9fU1NHX01BTklGRVNUP2Uod2luZG93Ll9fU1NHX01BTklGRVNUKTp3aW5kb3cuX19TU0dfTUFOSUZFU1RfQ0I9KCk9PntlKHdpbmRvdy5fX1NTR19NQU5JRkVTVCl9fSl9fSgiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDcyNjY6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtsZXQgbjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImRlZmF1bHQiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBsfX0pO2xldCBhPVsiQ0xTIiwiRkNQIiwiRklEIiwiSU5QIiwiTENQIiwiVFRGQiJdO2xvY2F0aW9uLmhyZWY7bGV0IG89ITE7ZnVuY3Rpb24gaShlKXtuJiZuKGUpfWxldCBsPWU9PntpZihuPWUsIW8pZm9yKGxldCBlIG9mKG89ITAsYSkpdHJ5e2xldCB0O3R8fCh0PXIoODAxOCkpLHRbIm9uIitlXShpKX1jYXRjaCh0KXtjb25zb2xlLndhcm4oIkZhaWxlZCB0byB0cmFjayAiK2UrIiB3ZWItdml0YWwiLHQpfX07KCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sNzA4OTpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiUG9ydGFsIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gb319KTtsZXQgbj1yKDcyOTQpLGE9cigzOTM1KSxvPWU9PntsZXR7Y2hpbGRyZW46dCx0eXBlOnJ9PWUsW28saV09KDAsbi51c2VTdGF0ZSkobnVsbCk7cmV0dXJuKDAsbi51c2VFZmZlY3QpKCgpPT57bGV0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChyKTtyZXR1cm4gZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlKSxpKGUpLCgpPT57ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlKX19LFtyXSksbz8oMCxhLmNyZWF0ZVBvcnRhbCkodCxvKTpudWxsfTsoImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSw2MzY3OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gbihlKXtyZXR1cm4oZT1lLnNsaWNlKDApKS5zdGFydHNXaXRoKCIvIil8fChlPSIvIitlKSxlfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwicmVtb3ZlQmFzZVBhdGgiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBufX0pLHIoMTE3MyksKCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sNjExOTpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIG4oZSx0KXtyZXR1cm4gZX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsInJlbW92ZUxvY2FsZSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG59fSkscig3NjM3KSwoImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSw0NDgyOmZ1bmN0aW9uKGUsdCl7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ITAsZ2V0OnRbcl19KX0odCx7cmVxdWVzdElkbGVDYWxsYmFjazpmdW5jdGlvbigpe3JldHVybiByfSxjYW5jZWxJZGxlQ2FsbGJhY2s6ZnVuY3Rpb24oKXtyZXR1cm4gbn19KTtsZXQgcj0idW5kZWZpbmVkIiE9dHlwZW9mIHNlbGYmJnNlbGYucmVxdWVzdElkbGVDYWxsYmFjayYmc2VsZi5yZXF1ZXN0SWRsZUNhbGxiYWNrLmJpbmQod2luZG93KXx8ZnVuY3Rpb24oZSl7bGV0IHQ9RGF0ZS5ub3coKTtyZXR1cm4gc2VsZi5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZSh7ZGlkVGltZW91dDohMSx0aW1lUmVtYWluaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIE1hdGgubWF4KDAsNTAtKERhdGUubm93KCktdCkpfX0pfSwxKX0sbj0idW5kZWZpbmVkIiE9dHlwZW9mIHNlbGYmJnNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrJiZzZWxmLmNhbmNlbElkbGVDYWxsYmFjay5iaW5kKHdpbmRvdyl8fGZ1bmN0aW9uKGUpe3JldHVybiBjbGVhclRpbWVvdXQoZSl9OygiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDg4MTM6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gdClPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLHtlbnVtZXJhYmxlOiEwLGdldDp0W3JdfSl9KHQse1JvdXRlQW5ub3VuY2VyOmZ1bmN0aW9uKCl7cmV0dXJuIGx9LGRlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdX19KTtsZXQgbj1yKDg3NTQpLGE9bi5fKHIoNzI5NCkpLG89cigxMjQ3KSxpPXtib3JkZXI6MCxjbGlwOiJyZWN0KDAgMCAwIDApIixoZWlnaHQ6IjFweCIsbWFyZ2luOiItMXB4IixvdmVyZmxvdzoiaGlkZGVuIixwYWRkaW5nOjAscG9zaXRpb246ImFic29sdXRlIix0b3A6MCx3aWR0aDoiMXB4Iix3aGl0ZVNwYWNlOiJub3dyYXAiLHdvcmRXcmFwOiJub3JtYWwifSxsPSgpPT57bGV0e2FzUGF0aDplfT0oMCxvLnVzZVJvdXRlcikoKSxbdCxyXT1hLmRlZmF1bHQudXNlU3RhdGUoIiIpLG49YS5kZWZhdWx0LnVzZVJlZihlKTtyZXR1cm4gYS5kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e2lmKG4uY3VycmVudCE9PWUpe2lmKG4uY3VycmVudD1lLGRvY3VtZW50LnRpdGxlKXIoZG9jdW1lbnQudGl0bGUpO2Vsc2V7dmFyIHQ7bGV0IG49ZG9jdW1lbnQucXVlcnlTZWxlY3RvcigiaDEiKSxhPW51bGwhPSh0PW51bGw9PW4/dm9pZCAwOm4uaW5uZXJUZXh0KT90Om51bGw9PW4/dm9pZCAwOm4udGV4dENvbnRlbnQ7cihhfHxlKX19fSxbZV0pLGEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCJwIix7ImFyaWEtbGl2ZSI6ImFzc2VydGl2ZSIsaWQ6Il9fbmV4dC1yb3V0ZS1hbm5vdW5jZXJfXyIscm9sZToiYWxlcnQiLHN0eWxlOml9LHQpfSx1PWw7KCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sODI2OTpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ITAsZ2V0OnRbcl19KX0odCx7bWFya0Fzc2V0RXJyb3I6ZnVuY3Rpb24oKXtyZXR1cm4gbH0saXNBc3NldEVycm9yOmZ1bmN0aW9uKCl7cmV0dXJuIHV9LGdldENsaWVudEJ1aWxkTWFuaWZlc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gZH0sY3JlYXRlUm91dGVMb2FkZXI6ZnVuY3Rpb24oKXtyZXR1cm4gcH19KSxyKDg3NTQpLHIoNTg1NCk7bGV0IG49cig4OTkpLGE9cig0NDgyKTtmdW5jdGlvbiBvKGUsdCxyKXtsZXQgbixhPXQuZ2V0KGUpO2lmKGEpcmV0dXJuImZ1dHVyZSJpbiBhP2EuZnV0dXJlOlByb21pc2UucmVzb2x2ZShhKTtsZXQgbz1uZXcgUHJvbWlzZShlPT57bj1lfSk7cmV0dXJuIHQuc2V0KGUsYT17cmVzb2x2ZTpuLGZ1dHVyZTpvfSkscj9yKCkudGhlbihlPT4obihlKSxlKSkuY2F0Y2gocj0+e3Rocm93IHQuZGVsZXRlKGUpLHJ9KTpvfWxldCBpPVN5bWJvbCgiQVNTRVRfTE9BRF9FUlJPUiIpO2Z1bmN0aW9uIGwoZSl7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGkse30pfWZ1bmN0aW9uIHUoZSl7cmV0dXJuIGUmJmkgaW4gZX1sZXQgcz1mdW5jdGlvbihlKXt0cnl7cmV0dXJuIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgibGluayIpLCEhd2luZG93Lk1TSW5wdXRNZXRob2RDb250ZXh0JiYhIWRvY3VtZW50LmRvY3VtZW50TW9kZXx8ZS5yZWxMaXN0LnN1cHBvcnRzKCJwcmVmZXRjaCIpfWNhdGNoKGUpe3JldHVybiExfX0oKSxjPSgpPT4iIjtmdW5jdGlvbiBmKGUsdCxyKXtyZXR1cm4gbmV3IFByb21pc2UoKG4sbyk9PntsZXQgaT0hMTtlLnRoZW4oZT0+e2k9ITAsbihlKX0pLmNhdGNoKG8pLCgwLGEucmVxdWVzdElkbGVDYWxsYmFjaykoKCk9PnNldFRpbWVvdXQoKCk9PntpfHxvKHIpfSx0KSl9KX1mdW5jdGlvbiBkKCl7aWYoc2VsZi5fX0JVSUxEX01BTklGRVNUKXJldHVybiBQcm9taXNlLnJlc29sdmUoc2VsZi5fX0JVSUxEX01BTklGRVNUKTtsZXQgZT1uZXcgUHJvbWlzZShlPT57bGV0IHQ9c2VsZi5fX0JVSUxEX01BTklGRVNUX0NCO3NlbGYuX19CVUlMRF9NQU5JRkVTVF9DQj0oKT0+e2Uoc2VsZi5fX0JVSUxEX01BTklGRVNUKSx0JiZ0KCl9fSk7cmV0dXJuIGYoZSwzODAwLGwoRXJyb3IoIkZhaWxlZCB0byBsb2FkIGNsaWVudCBidWlsZCBtYW5pZmVzdCIpKSl9ZnVuY3Rpb24gaChlLHQpe3JldHVybiBkKCkudGhlbihyPT57aWYoISh0IGluIHIpKXRocm93IGwoRXJyb3IoIkZhaWxlZCB0byBsb29rdXAgcm91dGU6ICIrdCkpO2xldCBhPXJbdF0ubWFwKHQ9PmUrIi9fbmV4dC8iK2VuY29kZVVSSSh0KSk7cmV0dXJue3NjcmlwdHM6YS5maWx0ZXIoZT0+ZS5lbmRzV2l0aCgiLmpzIikpLm1hcChlPT4oMCxuLl9fdW5zYWZlQ3JlYXRlVHJ1c3RlZFNjcmlwdFVSTCkoZSkrYygpKSxjc3M6YS5maWx0ZXIoZT0+ZS5lbmRzV2l0aCgiLmNzcyIpKS5tYXAoZT0+ZStjKCkpfX0pfWZ1bmN0aW9uIHAoZSl7bGV0IHQ9bmV3IE1hcCxyPW5ldyBNYXAsbj1uZXcgTWFwLGk9bmV3IE1hcDtmdW5jdGlvbiB1KGUpe3t2YXIgdDtsZXQgbj1yLmdldChlLnRvU3RyaW5nKCkpO3JldHVybiBufHwoZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc2NyaXB0W3NyY149IicrZSsnIl0nKT9Qcm9taXNlLnJlc29sdmUoKTooci5zZXQoZS50b1N0cmluZygpLG49bmV3IFByb21pc2UoKHIsbik9PnsodD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzY3JpcHQiKSkub25sb2FkPXIsdC5vbmVycm9yPSgpPT5uKGwoRXJyb3IoIkZhaWxlZCB0byBsb2FkIHNjcmlwdDogIitlKSkpLHQuY3Jvc3NPcmlnaW49dm9pZCAwLHQuc3JjPWUsZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0KX0pKSxuKSl9fWZ1bmN0aW9uIGMoZSl7bGV0IHQ9bi5nZXQoZSk7cmV0dXJuIHR8fG4uc2V0KGUsdD1mZXRjaChlKS50aGVuKHQ9PntpZighdC5vayl0aHJvdyBFcnJvcigiRmFpbGVkIHRvIGxvYWQgc3R5bGVzaGVldDogIitlKTtyZXR1cm4gdC50ZXh0KCkudGhlbih0PT4oe2hyZWY6ZSxjb250ZW50OnR9KSl9KS5jYXRjaChlPT57dGhyb3cgbChlKX0pKSx0fXJldHVybnt3aGVuRW50cnlwb2ludDplPT5vKGUsdCksb25FbnRyeXBvaW50KGUscil7KHI/UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+cigpKS50aGVuKGU9Pih7Y29tcG9uZW50OmUmJmUuZGVmYXVsdHx8ZSxleHBvcnRzOmV9KSxlPT4oe2Vycm9yOmV9KSk6UHJvbWlzZS5yZXNvbHZlKHZvaWQgMCkpLnRoZW4ocj0+e2xldCBuPXQuZ2V0KGUpO24mJiJyZXNvbHZlImluIG4/ciYmKHQuc2V0KGUsciksbi5yZXNvbHZlKHIpKToocj90LnNldChlLHIpOnQuZGVsZXRlKGUpLGkuZGVsZXRlKGUpKX0pfSxsb2FkUm91dGUocixuKXtyZXR1cm4gbyhyLGksKCk9PntsZXQgYTtyZXR1cm4gZihoKGUscikudGhlbihlPT57bGV0e3NjcmlwdHM6bixjc3M6YX09ZTtyZXR1cm4gUHJvbWlzZS5hbGwoW3QuaGFzKHIpP1tdOlByb21pc2UuYWxsKG4ubWFwKHUpKSxQcm9taXNlLmFsbChhLm1hcChjKSldKX0pLnRoZW4oZT0+dGhpcy53aGVuRW50cnlwb2ludChyKS50aGVuKHQ9Pih7ZW50cnlwb2ludDp0LHN0eWxlczplWzFdfSkpKSwzODAwLGwoRXJyb3IoIlJvdXRlIGRpZCBub3QgY29tcGxldGUgbG9hZGluZzogIityKSkpLnRoZW4oZT0+e2xldHtlbnRyeXBvaW50OnQsc3R5bGVzOnJ9PWUsbj1PYmplY3QuYXNzaWduKHtzdHlsZXM6cn0sdCk7cmV0dXJuImVycm9yImluIHQ/dDpufSkuY2F0Y2goZT0+e2lmKG4pdGhyb3cgZTtyZXR1cm57ZXJyb3I6ZX19KS5maW5hbGx5KCgpPT5udWxsPT1hP3ZvaWQgMDphKCkpfSl9LHByZWZldGNoKHQpe2xldCByO3JldHVybihyPW5hdmlnYXRvci5jb25uZWN0aW9uKSYmKHIuc2F2ZURhdGF8fC8yZy8udGVzdChyLmVmZmVjdGl2ZVR5cGUpKT9Qcm9taXNlLnJlc29sdmUoKTpoKGUsdCkudGhlbihlPT5Qcm9taXNlLmFsbChzP2Uuc2NyaXB0cy5tYXAoZT0+e3ZhciB0LHIsbjtyZXR1cm4gdD1lLnRvU3RyaW5nKCkscj0ic2NyaXB0IixuZXcgUHJvbWlzZSgoZSxhKT0+e2xldCBvPSdcbiAgICAgIGxpbmtbcmVsPSJwcmVmZXRjaCJdW2hyZWZePSInK3QrJyJdLFxuICAgICAgbGlua1tyZWw9InByZWxvYWQiXVtocmVmXj0iJyt0KyciXSxcbiAgICAgIHNjcmlwdFtzcmNePSInK3QrJyJdJztpZihkb2N1bWVudC5xdWVyeVNlbGVjdG9yKG8pKXJldHVybiBlKCk7bj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJsaW5rIiksciYmKG4uYXM9ciksbi5yZWw9InByZWZldGNoIixuLmNyb3NzT3JpZ2luPXZvaWQgMCxuLm9ubG9hZD1lLG4ub25lcnJvcj0oKT0+YShsKEVycm9yKCJGYWlsZWQgdG8gcHJlZmV0Y2g6ICIrdCkpKSxuLmhyZWY9dCxkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKG4pfSl9KTpbXSkpLnRoZW4oKCk9PnsoMCxhLnJlcXVlc3RJZGxlQ2FsbGJhY2spKCgpPT50aGlzLmxvYWRSb3V0ZSh0LCEwKS5jYXRjaCgoKT0+e30pKX0pLmNhdGNoKCgpPT57fSl9fX0oImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSwxMjQ3OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIHQpT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscix7ZW51bWVyYWJsZTohMCxnZXQ6dFtyXX0pfSh0LHtSb3V0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gby5kZWZhdWx0fSxkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJuIGh9LHdpdGhSb3V0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdS5kZWZhdWx0fSx1c2VSb3V0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gcH0sY3JlYXRlUm91dGVyOmZ1bmN0aW9uKCl7cmV0dXJuIG19LG1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZTpmdW5jdGlvbigpe3JldHVybiBnfX0pO2xldCBuPXIoODc1NCksYT1uLl8ocig3Mjk0KSksbz1uLl8ocig2MjUzKSksaT1yKDIyNTApLGw9bi5fKHIoNjc2KSksdT1uLl8ocig1MDk0KSkscz17cm91dGVyOm51bGwscmVhZHlDYWxsYmFja3M6W10scmVhZHkoZSl7aWYodGhpcy5yb3V0ZXIpcmV0dXJuIGUoKTt0aGlzLnJlYWR5Q2FsbGJhY2tzLnB1c2goZSl9fSxjPVsicGF0aG5hbWUiLCJyb3V0ZSIsInF1ZXJ5IiwiYXNQYXRoIiwiY29tcG9uZW50cyIsImlzRmFsbGJhY2siLCJiYXNlUGF0aCIsImxvY2FsZSIsImxvY2FsZXMiLCJkZWZhdWx0TG9jYWxlIiwiaXNSZWFkeSIsImlzUHJldmlldyIsImlzTG9jYWxlRG9tYWluIiwiZG9tYWluTG9jYWxlcyJdLGY9WyJwdXNoIiwicmVwbGFjZSIsInJlbG9hZCIsImJhY2siLCJwcmVmZXRjaCIsImJlZm9yZVBvcFN0YXRlIl07ZnVuY3Rpb24gZCgpe2lmKCFzLnJvdXRlcil0aHJvdyBFcnJvcignTm8gcm91dGVyIGluc3RhbmNlIGZvdW5kLlxuWW91IHNob3VsZCBvbmx5IHVzZSAibmV4dC9yb3V0ZXIiIG9uIHRoZSBjbGllbnQgc2lkZSBvZiB5b3VyIGFwcC5cbicpO3JldHVybiBzLnJvdXRlcn1PYmplY3QuZGVmaW5lUHJvcGVydHkocywiZXZlbnRzIix7Z2V0OigpPT5vLmRlZmF1bHQuZXZlbnRzfSksYy5mb3JFYWNoKGU9PntPYmplY3QuZGVmaW5lUHJvcGVydHkocyxlLHtnZXQoKXtsZXQgdD1kKCk7cmV0dXJuIHRbZV19fSl9KSxmLmZvckVhY2goZT0+e3NbZV09ZnVuY3Rpb24oKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxyPUFycmF5KHQpLG49MDtuPHQ7bisrKXJbbl09YXJndW1lbnRzW25dO2xldCBhPWQoKTtyZXR1cm4gYVtlXSguLi5yKX19KSxbInJvdXRlQ2hhbmdlU3RhcnQiLCJiZWZvcmVIaXN0b3J5Q2hhbmdlIiwicm91dGVDaGFuZ2VDb21wbGV0ZSIsInJvdXRlQ2hhbmdlRXJyb3IiLCJoYXNoQ2hhbmdlU3RhcnQiLCJoYXNoQ2hhbmdlQ29tcGxldGUiXS5mb3JFYWNoKGU9PntzLnJlYWR5KCgpPT57by5kZWZhdWx0LmV2ZW50cy5vbihlLGZ1bmN0aW9uKCl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgscj1BcnJheSh0KSxuPTA7bjx0O24rKylyW25dPWFyZ3VtZW50c1tuXTtsZXQgYT0ib24iK2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zdWJzdHJpbmcoMSk7aWYoc1thXSl0cnl7c1thXSguLi5yKX1jYXRjaChlKXtjb25zb2xlLmVycm9yKCJFcnJvciB3aGVuIHJ1bm5pbmcgdGhlIFJvdXRlciBldmVudDogIithKSxjb25zb2xlLmVycm9yKCgwLGwuZGVmYXVsdCkoZSk/ZS5tZXNzYWdlKyJcbiIrZS5zdGFjazplKyIiKX19KX0pfSk7bGV0IGg9cztmdW5jdGlvbiBwKCl7bGV0IGU9YS5kZWZhdWx0LnVzZUNvbnRleHQoaS5Sb3V0ZXJDb250ZXh0KTtpZighZSl0aHJvdyBFcnJvcigiTmV4dFJvdXRlciB3YXMgbm90IG1vdW50ZWQuIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtcm91dGVyLW5vdC1tb3VudGVkIik7cmV0dXJuIGV9ZnVuY3Rpb24gbSgpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoLHQ9QXJyYXkoZSkscj0wO3I8ZTtyKyspdFtyXT1hcmd1bWVudHNbcl07cmV0dXJuIHMucm91dGVyPW5ldyBvLmRlZmF1bHQoLi4udCkscy5yZWFkeUNhbGxiYWNrcy5mb3JFYWNoKGU9PmUoKSkscy5yZWFkeUNhbGxiYWNrcz1bXSxzLnJvdXRlcn1mdW5jdGlvbiBnKGUpe2xldCB0PXt9O2ZvcihsZXQgciBvZiBjKXtpZigib2JqZWN0Ij09dHlwZW9mIGVbcl0pe3Rbcl09T2JqZWN0LmFzc2lnbihBcnJheS5pc0FycmF5KGVbcl0pP1tdOnt9LGVbcl0pO2NvbnRpbnVlfXRbcl09ZVtyXX1yZXR1cm4gdC5ldmVudHM9by5kZWZhdWx0LmV2ZW50cyxmLmZvckVhY2gocj0+e3Rbcl09ZnVuY3Rpb24oKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxuPUFycmF5KHQpLGE9MDthPHQ7YSsrKW5bYV09YXJndW1lbnRzW2FdO3JldHVybiBlW3JdKC4uLm4pfX0pLHR9KCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sNDI5NDpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ITAsZ2V0OnRbcl19KX0odCx7aGFuZGxlQ2xpZW50U2NyaXB0TG9hZDpmdW5jdGlvbigpe3JldHVybiBwfSxpbml0U2NyaXB0TG9hZGVyOmZ1bmN0aW9uKCl7cmV0dXJuIG19LGRlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm4geX19KTtsZXQgbj1yKDg3NTQpLGE9cigxNzU3KSxvPW4uXyhyKDM5MzUpKSxpPWEuXyhyKDcyOTQpKSxsPXIoNjExNyksdT1yKDMxMikscz1yKDQ0ODIpLGM9bmV3IE1hcCxmPW5ldyBTZXQsZD1bIm9uTG9hZCIsIm9uUmVhZHkiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsImNoaWxkcmVuIiwib25FcnJvciIsInN0cmF0ZWd5Il0saD1lPT57bGV0e3NyYzp0LGlkOnIsb25Mb2FkOm49KCk9Pnt9LG9uUmVhZHk6YT1udWxsLGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOm8sY2hpbGRyZW46aT0iIixzdHJhdGVneTpsPSJhZnRlckludGVyYWN0aXZlIixvbkVycm9yOnN9PWUsaD1yfHx0O2lmKGgmJmYuaGFzKGgpKXJldHVybjtpZihjLmhhcyh0KSl7Zi5hZGQoaCksYy5nZXQodCkudGhlbihuLHMpO3JldHVybn1sZXQgcD0oKT0+e2EmJmEoKSxmLmFkZChoKX0sbT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzY3JpcHQiKSxnPW5ldyBQcm9taXNlKChlLHQpPT57bS5hZGRFdmVudExpc3RlbmVyKCJsb2FkIixmdW5jdGlvbih0KXtlKCksbiYmbi5jYWxsKHRoaXMsdCkscCgpfSksbS5hZGRFdmVudExpc3RlbmVyKCJlcnJvciIsZnVuY3Rpb24oZSl7dChlKX0pfSkuY2F0Y2goZnVuY3Rpb24oZSl7cyYmcyhlKX0pO2ZvcihsZXRbcixuXW9mKG8/KG0uaW5uZXJIVE1MPW8uX19odG1sfHwiIixwKCkpOmk/KG0udGV4dENvbnRlbnQ9InN0cmluZyI9PXR5cGVvZiBpP2k6QXJyYXkuaXNBcnJheShpKT9pLmpvaW4oIiIpOiIiLHAoKSk6dCYmKG0uc3JjPXQsYy5zZXQodCxnKSksT2JqZWN0LmVudHJpZXMoZSkpKXtpZih2b2lkIDA9PT1ufHxkLmluY2x1ZGVzKHIpKWNvbnRpbnVlO2xldCBlPXUuRE9NQXR0cmlidXRlTmFtZXNbcl18fHIudG9Mb3dlckNhc2UoKTttLnNldEF0dHJpYnV0ZShlLG4pfSJ3b3JrZXIiPT09bCYmbS5zZXRBdHRyaWJ1dGUoInR5cGUiLCJ0ZXh0L3BhcnR5dG93biIpLG0uc2V0QXR0cmlidXRlKCJkYXRhLW5zY3JpcHQiLGwpLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobSl9O2Z1bmN0aW9uIHAoZSl7bGV0e3N0cmF0ZWd5OnQ9ImFmdGVySW50ZXJhY3RpdmUifT1lOyJsYXp5T25sb2FkIj09PXQ/d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoImxvYWQiLCgpPT57KDAscy5yZXF1ZXN0SWRsZUNhbGxiYWNrKSgoKT0+aChlKSl9KTpoKGUpfWZ1bmN0aW9uIG0oZSl7ZS5mb3JFYWNoKHApLGZ1bmN0aW9uKCl7bGV0IGU9Wy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLW5zY3JpcHQ9ImJlZm9yZUludGVyYWN0aXZlIl0nKSwuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1uc2NyaXB0PSJiZWZvcmVQYWdlUmVuZGVyIl0nKV07ZS5mb3JFYWNoKGU9PntsZXQgdD1lLmlkfHxlLmdldEF0dHJpYnV0ZSgic3JjIik7Zi5hZGQodCl9KX0oKX1mdW5jdGlvbiBnKGUpe2xldHtpZDp0LHNyYzpyPSIiLG9uTG9hZDpuPSgpPT57fSxvblJlYWR5OmE9bnVsbCxzdHJhdGVneTp1PSJhZnRlckludGVyYWN0aXZlIixvbkVycm9yOmMsLi4uZH09ZSx7dXBkYXRlU2NyaXB0czpwLHNjcmlwdHM6bSxnZXRJc1NzcjpnLGFwcERpcjp5LG5vbmNlOl99PSgwLGkudXNlQ29udGV4dCkobC5IZWFkTWFuYWdlckNvbnRleHQpLGI9KDAsaS51c2VSZWYpKCExKTsoMCxpLnVzZUVmZmVjdCkoKCk9PntsZXQgZT10fHxyO2IuY3VycmVudHx8KGEmJmUmJmYuaGFzKGUpJiZhKCksYi5jdXJyZW50PSEwKX0sW2EsdCxyXSk7bGV0IHY9KDAsaS51c2VSZWYpKCExKTtpZigoMCxpLnVzZUVmZmVjdCkoKCk9Pnshdi5jdXJyZW50JiYoImFmdGVySW50ZXJhY3RpdmUiPT09dT9oKGUpOiJsYXp5T25sb2FkIj09PXUmJigiY29tcGxldGUiPT09ZG9jdW1lbnQucmVhZHlTdGF0ZT8oMCxzLnJlcXVlc3RJZGxlQ2FsbGJhY2spKCgpPT5oKGUpKTp3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigibG9hZCIsKCk9PnsoMCxzLnJlcXVlc3RJZGxlQ2FsbGJhY2spKCgpPT5oKGUpKX0pKSx2LmN1cnJlbnQ9ITApfSxbZSx1XSksKCJiZWZvcmVJbnRlcmFjdGl2ZSI9PT11fHwid29ya2VyIj09PXUpJiYocD8obVt1XT0obVt1XXx8W10pLmNvbmNhdChbe2lkOnQsc3JjOnIsb25Mb2FkOm4sb25SZWFkeTphLG9uRXJyb3I6YywuLi5kfV0pLHAobSkpOmcmJmcoKT9mLmFkZCh0fHxyKTpnJiYhZygpJiZoKGUpKSx5KXtpZigiYmVmb3JlSW50ZXJhY3RpdmUiPT09dSlyZXR1cm4gcj8oby5kZWZhdWx0LnByZWxvYWQocixkLmludGVncml0eT97YXM6InNjcmlwdCIsaW50ZWdyaXR5OmQuaW50ZWdyaXR5fTp7YXM6InNjcmlwdCJ9KSxpLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgic2NyaXB0Iix7bm9uY2U6XyxkYW5nZXJvdXNseVNldElubmVySFRNTDp7X19odG1sOiIoc2VsZi5fX25leHRfcz1zZWxmLl9fbmV4dF9zfHxbXSkucHVzaCgiK0pTT04uc3RyaW5naWZ5KFtyXSkrIikifX0pKTooZC5kYW5nZXJvdXNseVNldElubmVySFRNTCYmKGQuY2hpbGRyZW49ZC5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWwsZGVsZXRlIGQuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpLGkuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCJzY3JpcHQiLHtub25jZTpfLGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOntfX2h0bWw6IihzZWxmLl9fbmV4dF9zPXNlbGYuX19uZXh0X3N8fFtdKS5wdXNoKCIrSlNPTi5zdHJpbmdpZnkoWzAsey4uLmR9XSkrIikifX0pKTsiYWZ0ZXJJbnRlcmFjdGl2ZSI9PT11JiZyJiZvLmRlZmF1bHQucHJlbG9hZChyLGQuaW50ZWdyaXR5P3thczoic2NyaXB0IixpbnRlZ3JpdHk6ZC5pbnRlZ3JpdHl9Onthczoic2NyaXB0In0pfXJldHVybiBudWxsfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShnLCJfX25leHRTY3JpcHQiLHt2YWx1ZTohMH0pO2xldCB5PWc7KCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sODk5OmZ1bmN0aW9uKGUsdCl7InVzZSBzdHJpY3QiO2xldCByO2Z1bmN0aW9uIG4oZSl7dmFyIHQ7cmV0dXJuKG51bGw9PSh0PWZ1bmN0aW9uKCl7aWYodm9pZCAwPT09cil7dmFyIGU7cj0obnVsbD09KGU9d2luZG93LnRydXN0ZWRUeXBlcyk/dm9pZCAwOmUuY3JlYXRlUG9saWN5KCJuZXh0anMiLHtjcmVhdGVIVE1MOmU9PmUsY3JlYXRlU2NyaXB0OmU9PmUsY3JlYXRlU2NyaXB0VVJMOmU9PmV9KSl8fG51bGx9cmV0dXJuIHJ9KCkpP3ZvaWQgMDp0LmNyZWF0ZVNjcmlwdFVSTChlKSl8fGV9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX3Vuc2FmZUNyZWF0ZVRydXN0ZWRTY3JpcHRVUkwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBufX0pLCgiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDUwOTQ6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImRlZmF1bHQiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBpfX0pO2xldCBuPXIoODc1NCksYT1uLl8ocig3Mjk0KSksbz1yKDEyNDcpO2Z1bmN0aW9uIGkoZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoZSx7cm91dGVyOigwLG8udXNlUm91dGVyKSgpLC4uLnR9KX1yZXR1cm4gdC5nZXRJbml0aWFsUHJvcHM9ZS5nZXRJbml0aWFsUHJvcHMsdC5vcmlnR2V0SW5pdGlhbFByb3BzPWUub3JpZ0dldEluaXRpYWxQcm9wcyx0fSgiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDY1MzA6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImRlZmF1bHQiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBsfX0pO2xldCBuPXIoODc1NCksYT1uLl8ocig3Mjk0KSksbz1yKDczMjEpO2FzeW5jIGZ1bmN0aW9uIGkoZSl7bGV0e0NvbXBvbmVudDp0LGN0eDpyfT1lLG49YXdhaXQgKDAsby5sb2FkR2V0SW5pdGlhbFByb3BzKSh0LHIpO3JldHVybntwYWdlUHJvcHM6bn19Y2xhc3MgbCBleHRlbmRzIGEuZGVmYXVsdC5Db21wb25lbnR7cmVuZGVyKCl7bGV0e0NvbXBvbmVudDplLHBhZ2VQcm9wczp0fT10aGlzLnByb3BzO3JldHVybiBhLmRlZmF1bHQuY3JlYXRlRWxlbWVudChlLHQpfX1sLm9yaWdHZXRJbml0aWFsUHJvcHM9aSxsLmdldEluaXRpYWxQcm9wcz1pLCgiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDM0NDE6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImRlZmF1bHQiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBzfX0pO2xldCBuPXIoODc1NCksYT1uLl8ocig3Mjk0KSksbz1uLl8ocigzOTAyKSksaT17NDAwOiJCYWQgUmVxdWVzdCIsNDA0OiJUaGlzIHBhZ2UgY291bGQgbm90IGJlIGZvdW5kIiw0MDU6Ik1ldGhvZCBOb3QgQWxsb3dlZCIsNTAwOiJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3IifTtmdW5jdGlvbiBsKGUpe2xldHtyZXM6dCxlcnI6cn09ZSxuPXQmJnQuc3RhdHVzQ29kZT90LnN0YXR1c0NvZGU6cj9yLnN0YXR1c0NvZGU6NDA0O3JldHVybntzdGF0dXNDb2RlOm59fWxldCB1PXtlcnJvcjp7Zm9udEZhbWlseTonc3lzdGVtLXVpLCJTZWdvZSBVSSIsUm9ib3RvLEhlbHZldGljYSxBcmlhbCxzYW5zLXNlcmlmLCJBcHBsZSBDb2xvciBFbW9qaSIsIlNlZ29lIFVJIEVtb2ppIicsaGVpZ2h0OiIxMDB2aCIsdGV4dEFsaWduOiJjZW50ZXIiLGRpc3BsYXk6ImZsZXgiLGZsZXhEaXJlY3Rpb246ImNvbHVtbiIsYWxpZ25JdGVtczoiY2VudGVyIixqdXN0aWZ5Q29udGVudDoiY2VudGVyIn0sZGVzYzp7bGluZUhlaWdodDoiNDhweCJ9LGgxOntkaXNwbGF5OiJpbmxpbmUtYmxvY2siLG1hcmdpbjoiMCAyMHB4IDAgMCIscGFkZGluZ1JpZ2h0OjIzLGZvbnRTaXplOjI0LGZvbnRXZWlnaHQ6NTAwLHZlcnRpY2FsQWxpZ246InRvcCJ9LGgyOntmb250U2l6ZToxNCxmb250V2VpZ2h0OjQwMCxsaW5lSGVpZ2h0OiIyOHB4In0sd3JhcDp7ZGlzcGxheToiaW5saW5lLWJsb2NrIn19O2NsYXNzIHMgZXh0ZW5kcyBhLmRlZmF1bHQuQ29tcG9uZW50e3JlbmRlcigpe2xldHtzdGF0dXNDb2RlOmUsd2l0aERhcmtNb2RlOnQ9ITB9PXRoaXMucHJvcHMscj10aGlzLnByb3BzLnRpdGxlfHxpW2VdfHwiQW4gdW5leHBlY3RlZCBlcnJvciBoYXMgb2NjdXJyZWQiO3JldHVybiBhLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgiZGl2Iix7c3R5bGU6dS5lcnJvcn0sYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoby5kZWZhdWx0LG51bGwsYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoInRpdGxlIixudWxsLGU/ZSsiOiAiK3I6IkFwcGxpY2F0aW9uIGVycm9yOiBhIGNsaWVudC1zaWRlIGV4Y2VwdGlvbiBoYXMgb2NjdXJyZWQiKSksYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoImRpdiIse3N0eWxlOnUuZGVzY30sYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoInN0eWxlIix7ZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6e19faHRtbDoiYm9keXtjb2xvcjojMDAwO2JhY2tncm91bmQ6I2ZmZjttYXJnaW46MH0ubmV4dC1lcnJvci1oMXtib3JkZXItcmlnaHQ6MXB4IHNvbGlkIHJnYmEoMCwwLDAsLjMpfSIrKHQ/IkBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6ZGFyayl7Ym9keXtjb2xvcjojZmZmO2JhY2tncm91bmQ6IzAwMH0ubmV4dC1lcnJvci1oMXtib3JkZXItcmlnaHQ6MXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsLjMpfX0iOiIiKX19KSxlP2EuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCJoMSIse2NsYXNzTmFtZToibmV4dC1lcnJvci1oMSIsc3R5bGU6dS5oMX0sZSk6bnVsbCxhLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgiZGl2Iix7c3R5bGU6dS53cmFwfSxhLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgiaDIiLHtzdHlsZTp1LmgyfSx0aGlzLnByb3BzLnRpdGxlfHxlP3I6YS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoYS5kZWZhdWx0LkZyYWdtZW50LG51bGwsIkFwcGxpY2F0aW9uIGVycm9yOiBhIGNsaWVudC1zaWRlIGV4Y2VwdGlvbiBoYXMgb2NjdXJyZWQgKHNlZSB0aGUgYnJvd3NlciBjb25zb2xlIGZvciBtb3JlIGluZm9ybWF0aW9uKSIpLCIuIikpKSl9fXMuZGlzcGxheU5hbWU9IkVycm9yUGFnZSIscy5nZXRJbml0aWFsUHJvcHM9bCxzLm9yaWdHZXRJbml0aWFsUHJvcHM9bCwoImZ1bmN0aW9uIj09dHlwZW9mIHQuZGVmYXVsdHx8Im9iamVjdCI9PXR5cGVvZiB0LmRlZmF1bHQmJm51bGwhPT10LmRlZmF1bHQpJiZ2b2lkIDA9PT10LmRlZmF1bHQuX19lc01vZHVsZSYmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5hc3NpZ24odC5kZWZhdWx0LHQpLGUuZXhwb3J0cz10LmRlZmF1bHQpfSw0OTUwOmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJBbXBTdGF0ZUNvbnRleHQiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBvfX0pO2xldCBuPXIoODc1NCksYT1uLl8ocig3Mjk0KSksbz1hLmRlZmF1bHQuY3JlYXRlQ29udGV4dCh7fSl9LDIzNjM6ZnVuY3Rpb24oZSx0KXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcihlKXtsZXR7YW1wRmlyc3Q6dD0hMSxoeWJyaWQ6cj0hMSxoYXNRdWVyeTpuPSExfT12b2lkIDA9PT1lP3t9OmU7cmV0dXJuIHR8fHImJm59T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJpc0luQW1wTW9kZSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHJ9fSl9LDY0NTE6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0Ijt2YXIgbixhO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ITAsZ2V0OnRbcl19KX0odCx7Q2FjaGVTdGF0ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gbn0sQXBwUm91dGVyQ29udGV4dDpmdW5jdGlvbigpe3JldHVybiBsfSxMYXlvdXRSb3V0ZXJDb250ZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHV9LEdsb2JhbExheW91dFJvdXRlckNvbnRleHQ6ZnVuY3Rpb24oKXtyZXR1cm4gc30sVGVtcGxhdGVDb250ZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIGN9fSk7bGV0IG89cig4NzU0KSxpPW8uXyhyKDcyOTQpKTsoYT1ufHwobj17fSkpLkxBWllfSU5JVElBTElaRUQ9IkxBWllJTklUSUFMSVpFRCIsYS5EQVRBX0ZFVENIPSJEQVRBRkVUQ0giLGEuUkVBRFk9IlJFQURZIjtsZXQgbD1pLmRlZmF1bHQuY3JlYXRlQ29udGV4dChudWxsKSx1PWkuZGVmYXVsdC5jcmVhdGVDb250ZXh0KG51bGwpLHM9aS5kZWZhdWx0LmNyZWF0ZUNvbnRleHQobnVsbCksYz1pLmRlZmF1bHQuY3JlYXRlQ29udGV4dChudWxsKX0sMTkxODpmdW5jdGlvbihlLHQpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIkJsb29tRmlsdGVyIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcn19KTtjbGFzcyBye3N0YXRpYyBmcm9tKGUsdCl7dm9pZCAwPT09dCYmKHQ9LjAxKTtsZXQgbj1uZXcgcihlLmxlbmd0aCx0KTtmb3IobGV0IHQgb2YgZSluLmFkZCh0KTtyZXR1cm4gbn1leHBvcnQoKXtsZXQgZT17bnVtSXRlbXM6dGhpcy5udW1JdGVtcyxlcnJvclJhdGU6dGhpcy5lcnJvclJhdGUsbnVtQml0czp0aGlzLm51bUJpdHMsbnVtSGFzaGVzOnRoaXMubnVtSGFzaGVzLGJpdEFycmF5OnRoaXMuYml0QXJyYXl9O3JldHVybiBlfWltcG9ydChlKXt0aGlzLm51bUl0ZW1zPWUubnVtSXRlbXMsdGhpcy5lcnJvclJhdGU9ZS5lcnJvclJhdGUsdGhpcy5udW1CaXRzPWUubnVtQml0cyx0aGlzLm51bUhhc2hlcz1lLm51bUhhc2hlcyx0aGlzLmJpdEFycmF5PWUuYml0QXJyYXl9YWRkKGUpe2xldCB0PXRoaXMuZ2V0SGFzaFZhbHVlcyhlKTt0LmZvckVhY2goZT0+e3RoaXMuYml0QXJyYXlbZV09MX0pfWNvbnRhaW5zKGUpe2xldCB0PXRoaXMuZ2V0SGFzaFZhbHVlcyhlKTtyZXR1cm4gdC5ldmVyeShlPT50aGlzLmJpdEFycmF5W2VdKX1nZXRIYXNoVmFsdWVzKGUpe2xldCB0PVtdO2ZvcihsZXQgcj0xO3I8PXRoaXMubnVtSGFzaGVzO3IrKyl7bGV0IG49ZnVuY3Rpb24oZSl7bGV0IHQ9MDtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7bGV0IG49ZS5jaGFyQ29kZUF0KHIpO3Q9TWF0aC5pbXVsKHRebiwxNTQwNDgzNDc3KSx0Xj10Pj4+MTMsdD1NYXRoLmltdWwodCwxNTQwNDgzNDc3KX1yZXR1cm4gdD4+PjB9KCIiK2UrcikldGhpcy5udW1CaXRzO3QucHVzaChuKX1yZXR1cm4gdH1jb25zdHJ1Y3RvcihlLHQpe3RoaXMubnVtSXRlbXM9ZSx0aGlzLmVycm9yUmF0ZT10LHRoaXMubnVtQml0cz1NYXRoLmNlaWwoLShlKk1hdGgubG9nKHQpKS8oTWF0aC5sb2coMikqTWF0aC5sb2coMikpKSx0aGlzLm51bUhhc2hlcz1NYXRoLmNlaWwodGhpcy5udW1CaXRzL2UqTWF0aC5sb2coMikpLHRoaXMuYml0QXJyYXk9QXJyYXkodGhpcy5udW1CaXRzKS5maWxsKDApfX19LDk0MzQ6ZnVuY3Rpb24oZSx0KXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJlc2NhcGVTdHJpbmdSZWdleHAiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBhfX0pO2xldCByPS9bfFxce30oKVtcXV4kKyo/Li1dLyxuPS9bfFxce30oKVtcXV4kKyo/Li1dL2c7ZnVuY3Rpb24gYShlKXtyZXR1cm4gci50ZXN0KGUpP2UucmVwbGFjZShuLCJcXCQmIik6ZX19LDYxMTc6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIkhlYWRNYW5hZ2VyQ29udGV4dCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG99fSk7bGV0IG49cig4NzU0KSxhPW4uXyhyKDcyOTQpKSxvPWEuZGVmYXVsdC5jcmVhdGVDb250ZXh0KHt9KX0sMzkwMjpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ITAsZ2V0OnRbcl19KX0odCx7ZGVmYXVsdEhlYWQ6ZnVuY3Rpb24oKXtyZXR1cm4gY30sZGVmYXVsdDpmdW5jdGlvbigpe3JldHVybiBwfX0pO2xldCBuPXIoODc1NCksYT1yKDE3NTcpLG89YS5fKHIoNzI5NCkpLGk9bi5fKHIoNTEyNikpLGw9cig0OTUwKSx1PXIoNjExNykscz1yKDIzNjMpO2Z1bmN0aW9uIGMoZSl7dm9pZCAwPT09ZSYmKGU9ITEpO2xldCB0PVtvLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgibWV0YSIse2NoYXJTZXQ6InV0Zi04In0pXTtyZXR1cm4gZXx8dC5wdXNoKG8uZGVmYXVsdC5jcmVhdGVFbGVtZW50KCJtZXRhIix7bmFtZToidmlld3BvcnQiLGNvbnRlbnQ6IndpZHRoPWRldmljZS13aWR0aCJ9KSksdH1mdW5jdGlvbiBmKGUsdCl7cmV0dXJuInN0cmluZyI9PXR5cGVvZiB0fHwibnVtYmVyIj09dHlwZW9mIHQ/ZTp0LnR5cGU9PT1vLmRlZmF1bHQuRnJhZ21lbnQ/ZS5jb25jYXQoby5kZWZhdWx0LkNoaWxkcmVuLnRvQXJyYXkodC5wcm9wcy5jaGlsZHJlbikucmVkdWNlKChlLHQpPT4ic3RyaW5nIj09dHlwZW9mIHR8fCJudW1iZXIiPT10eXBlb2YgdD9lOmUuY29uY2F0KHQpLFtdKSk6ZS5jb25jYXQodCl9cigyMDc4KTtsZXQgZD1bIm5hbWUiLCJodHRwRXF1aXYiLCJjaGFyU2V0IiwiaXRlbVByb3AiXTtmdW5jdGlvbiBoKGUsdCl7bGV0e2luQW1wTW9kZTpyfT10O3JldHVybiBlLnJlZHVjZShmLFtdKS5yZXZlcnNlKCkuY29uY2F0KGMocikucmV2ZXJzZSgpKS5maWx0ZXIoZnVuY3Rpb24oKXtsZXQgZT1uZXcgU2V0LHQ9bmV3IFNldCxyPW5ldyBTZXQsbj17fTtyZXR1cm4gYT0+e2xldCBvPSEwLGk9ITE7aWYoYS5rZXkmJiJudW1iZXIiIT10eXBlb2YgYS5rZXkmJmEua2V5LmluZGV4T2YoIiQiKT4wKXtpPSEwO2xldCB0PWEua2V5LnNsaWNlKGEua2V5LmluZGV4T2YoIiQiKSsxKTtlLmhhcyh0KT9vPSExOmUuYWRkKHQpfXN3aXRjaChhLnR5cGUpe2Nhc2UidGl0bGUiOmNhc2UiYmFzZSI6dC5oYXMoYS50eXBlKT9vPSExOnQuYWRkKGEudHlwZSk7YnJlYWs7Y2FzZSJtZXRhIjpmb3IobGV0IGU9MCx0PWQubGVuZ3RoO2U8dDtlKyspe2xldCB0PWRbZV07aWYoYS5wcm9wcy5oYXNPd25Qcm9wZXJ0eSh0KSl7aWYoImNoYXJTZXQiPT09dClyLmhhcyh0KT9vPSExOnIuYWRkKHQpO2Vsc2V7bGV0IGU9YS5wcm9wc1t0XSxyPW5bdF18fG5ldyBTZXQ7KCJuYW1lIiE9PXR8fCFpKSYmci5oYXMoZSk/bz0hMTooci5hZGQoZSksblt0XT1yKX19fX1yZXR1cm4gb319KCkpLnJldmVyc2UoKS5tYXAoKGUsdCk9PntsZXQgbj1lLmtleXx8dDtpZighciYmImxpbmsiPT09ZS50eXBlJiZlLnByb3BzLmhyZWYmJlsiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MiLCJodHRwczovL3VzZS50eXBla2l0Lm5ldC8iXS5zb21lKHQ9PmUucHJvcHMuaHJlZi5zdGFydHNXaXRoKHQpKSl7bGV0IHQ9ey4uLmUucHJvcHN8fHt9fTtyZXR1cm4gdFsiZGF0YS1ocmVmIl09dC5ocmVmLHQuaHJlZj12b2lkIDAsdFsiZGF0YS1vcHRpbWl6ZWQtZm9udHMiXT0hMCxvLmRlZmF1bHQuY2xvbmVFbGVtZW50KGUsdCl9cmV0dXJuIG8uZGVmYXVsdC5jbG9uZUVsZW1lbnQoZSx7a2V5Om59KX0pfWxldCBwPWZ1bmN0aW9uKGUpe2xldHtjaGlsZHJlbjp0fT1lLHI9KDAsby51c2VDb250ZXh0KShsLkFtcFN0YXRlQ29udGV4dCksbj0oMCxvLnVzZUNvbnRleHQpKHUuSGVhZE1hbmFnZXJDb250ZXh0KTtyZXR1cm4gby5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoaS5kZWZhdWx0LHtyZWR1Y2VDb21wb25lbnRzVG9TdGF0ZTpoLGhlYWRNYW5hZ2VyOm4saW5BbXBNb2RlOigwLHMuaXNJbkFtcE1vZGUpKHIpfSx0KX07KCJmdW5jdGlvbiI9PXR5cGVvZiB0LmRlZmF1bHR8fCJvYmplY3QiPT10eXBlb2YgdC5kZWZhdWx0JiZudWxsIT09dC5kZWZhdWx0KSYmdm9pZCAwPT09dC5kZWZhdWx0Ll9fZXNNb2R1bGUmJihPYmplY3QuZGVmaW5lUHJvcGVydHkodC5kZWZhdWx0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KSxlLmV4cG9ydHM9dC5kZWZhdWx0KX0sNDg1ODpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ITAsZ2V0OnRbcl19KX0odCx7U2VhcmNoUGFyYW1zQ29udGV4dDpmdW5jdGlvbigpe3JldHVybiBhfSxQYXRobmFtZUNvbnRleHQ6ZnVuY3Rpb24oKXtyZXR1cm4gb319KTtsZXQgbj1yKDcyOTQpLGE9KDAsbi5jcmVhdGVDb250ZXh0KShudWxsKSxvPSgwLG4uY3JlYXRlQ29udGV4dCkobnVsbCl9LDQ5OTA6ZnVuY3Rpb24oZSx0KXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcihlLHQpe2xldCByO2xldCBuPWUuc3BsaXQoIi8iKTtyZXR1cm4odHx8W10pLnNvbWUodD0+ISFuWzFdJiZuWzFdLnRvTG93ZXJDYXNlKCk9PT10LnRvTG93ZXJDYXNlKCkmJihyPXQsbi5zcGxpY2UoMSwxKSxlPW4uam9pbigiLyIpfHwiLyIsITApKSx7cGF0aG5hbWU6ZSxkZXRlY3RlZExvY2FsZTpyfX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiByfX0pfSwyNDkzOmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJJbWFnZUNvbmZpZ0NvbnRleHQiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBpfX0pO2xldCBuPXIoODc1NCksYT1uLl8ocig3Mjk0KSksbz1yKDIwOTMpLGk9YS5kZWZhdWx0LmNyZWF0ZUNvbnRleHQoby5pbWFnZUNvbmZpZ0RlZmF1bHQpfSwyMDkzOmZ1bmN0aW9uKGUsdCl7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ITAsZ2V0OnRbcl19KX0odCx7VkFMSURfTE9BREVSUzpmdW5jdGlvbigpe3JldHVybiByfSxpbWFnZUNvbmZpZ0RlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm4gbn19KTtsZXQgcj1bImRlZmF1bHQiLCJpbWdpeCIsImNsb3VkaW5hcnkiLCJha2FtYWkiLCJjdXN0b20iXSxuPXtkZXZpY2VTaXplczpbNjQwLDc1MCw4MjgsMTA4MCwxMjAwLDE5MjAsMjA0OCwzODQwXSxpbWFnZVNpemVzOlsxNiwzMiw0OCw2NCw5NiwxMjgsMjU2LDM4NF0scGF0aDoiL19uZXh0L2ltYWdlIixsb2FkZXI6ImRlZmF1bHQiLGxvYWRlckZpbGU6IiIsZG9tYWluczpbXSxkaXNhYmxlU3RhdGljSW1hZ2VzOiExLG1pbmltdW1DYWNoZVRUTDo2MCxmb3JtYXRzOlsiaW1hZ2Uvd2VicCJdLGRhbmdlcm91c2x5QWxsb3dTVkc6ITEsY29udGVudFNlY3VyaXR5UG9saWN5OiJzY3JpcHQtc3JjICdub25lJzsgZnJhbWUtc3JjICdub25lJzsgc2FuZGJveDsiLGNvbnRlbnREaXNwb3NpdGlvblR5cGU6ImlubGluZSIscmVtb3RlUGF0dGVybnM6W10sdW5vcHRpbWl6ZWQ6ITF9fSw4MzI1OmZ1bmN0aW9uKGUsdCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKX1mdW5jdGlvbiBuKGUpe2lmKCJbb2JqZWN0IE9iamVjdF0iIT09cihlKSlyZXR1cm4hMTtsZXQgdD1PYmplY3QuZ2V0UHJvdG90eXBlT2YoZSk7cmV0dXJuIG51bGw9PT10fHx0Lmhhc093blByb3BlcnR5KCJpc1Byb3RvdHlwZU9mIil9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIHQpT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscix7ZW51bWVyYWJsZTohMCxnZXQ6dFtyXX0pfSh0LHtnZXRPYmplY3RDbGFzc0xhYmVsOmZ1bmN0aW9uKCl7cmV0dXJuIHJ9LGlzUGxhaW5PYmplY3Q6ZnVuY3Rpb24oKXtyZXR1cm4gbn19KX0sNjI2NjpmdW5jdGlvbihlLHQpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIk5FWFRfRFlOQU1JQ19OT19TU1JfQ09ERSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHJ9fSk7bGV0IHI9Ik5FWFRfRFlOQU1JQ19OT19TU1JfQ09ERSJ9LDY3MTI6ZnVuY3Rpb24oZSx0KXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcigpe2xldCBlPU9iamVjdC5jcmVhdGUobnVsbCk7cmV0dXJue29uKHQscil7KGVbdF18fChlW3RdPVtdKSkucHVzaChyKX0sb2ZmKHQscil7ZVt0XSYmZVt0XS5zcGxpY2UoZVt0XS5pbmRleE9mKHIpPj4+MCwxKX0sZW1pdCh0KXtmb3IodmFyIHI9YXJndW1lbnRzLmxlbmd0aCxuPUFycmF5KHI+MT9yLTE6MCksYT0xO2E8cjthKyspblthLTFdPWFyZ3VtZW50c1thXTsoZVt0XXx8W10pLnNsaWNlKCkubWFwKGU9PntlKC4uLm4pfSl9fX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImRlZmF1bHQiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiByfX0pfSwyNjI5OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJkZW5vcm1hbGl6ZVBhZ2VQYXRoIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gb319KTtsZXQgbj1yKDk0NDYpLGE9cig2NTM4KTtmdW5jdGlvbiBvKGUpe2xldCB0PSgwLGEubm9ybWFsaXplUGF0aFNlcCkoZSk7cmV0dXJuIHQuc3RhcnRzV2l0aCgiL2luZGV4LyIpJiYhKDAsbi5pc0R5bmFtaWNSb3V0ZSkodCk/dC5zbGljZSg2KToiL2luZGV4IiE9PXQ/dDoiLyJ9fSw0MTU3OmZ1bmN0aW9uKGUsdCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUuc3RhcnRzV2l0aCgiLyIpP2U6Ii8iK2V9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJlbnN1cmVMZWFkaW5nU2xhc2giLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiByfX0pfSw2NTM4OmZ1bmN0aW9uKGUsdCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUucmVwbGFjZSgvXFwvZywiLyIpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwibm9ybWFsaXplUGF0aFNlcCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHJ9fSl9LDIyNTA6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIlJvdXRlckNvbnRleHQiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBvfX0pO2xldCBuPXIoODc1NCksYT1uLl8ocig3Mjk0KSksbz1hLmRlZmF1bHQuY3JlYXRlQ29udGV4dChudWxsKX0sNDEyODpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ITAsZ2V0OnRbcl19KX0odCx7YWRhcHRGb3JBcHBSb3V0ZXJJbnN0YW5jZTpmdW5jdGlvbigpe3JldHVybiBsfSxhZGFwdEZvclNlYXJjaFBhcmFtczpmdW5jdGlvbigpe3JldHVybiB1fSxQYXRobmFtZUNvbnRleHRQcm92aWRlckFkYXB0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gc319KTtsZXQgbj1yKDE3NTcpLGE9bi5fKHIoNzI5NCkpLG89cig0ODU4KSxpPXIoOTQ0Nik7ZnVuY3Rpb24gbChlKXtyZXR1cm57YmFjaygpe2UuYmFjaygpfSxmb3J3YXJkKCl7ZS5mb3J3YXJkKCl9LHJlZnJlc2goKXtlLnJlbG9hZCgpfSxwdXNoKHQpe2UucHVzaCh0KX0scmVwbGFjZSh0KXtlLnJlcGxhY2UodCl9LHByZWZldGNoKHQpe2UucHJlZmV0Y2godCl9fX1mdW5jdGlvbiB1KGUpe3JldHVybiBlLmlzUmVhZHkmJmUucXVlcnk/ZnVuY3Rpb24oZSl7bGV0IHQ9bmV3IFVSTFNlYXJjaFBhcmFtcztmb3IobGV0W3Isbl1vZiBPYmplY3QuZW50cmllcyhlKSlpZihBcnJheS5pc0FycmF5KG4pKWZvcihsZXQgZSBvZiBuKXQuYXBwZW5kKHIsZSk7ZWxzZSB2b2lkIDAhPT1uJiZ0LmFwcGVuZChyLG4pO3JldHVybiB0fShlLnF1ZXJ5KTpuZXcgVVJMU2VhcmNoUGFyYW1zfWZ1bmN0aW9uIHMoZSl7bGV0e2NoaWxkcmVuOnQscm91dGVyOnIsLi4ubn09ZSxsPSgwLGEudXNlUmVmKShuLmlzQXV0b0V4cG9ydCksdT0oMCxhLnVzZU1lbW8pKCgpPT57bGV0IGU7bGV0IHQ9bC5jdXJyZW50O2lmKHQmJihsLmN1cnJlbnQ9ITEpLCgwLGkuaXNEeW5hbWljUm91dGUpKHIucGF0aG5hbWUpJiYoci5pc0ZhbGxiYWNrfHx0JiYhci5pc1JlYWR5KSlyZXR1cm4gbnVsbDt0cnl7ZT1uZXcgVVJMKHIuYXNQYXRoLCJodHRwOi8vZiIpfWNhdGNoKGUpe3JldHVybiIvIn1yZXR1cm4gZS5wYXRobmFtZX0sW3IuYXNQYXRoLHIuaXNGYWxsYmFjayxyLmlzUmVhZHksci5wYXRobmFtZV0pO3JldHVybiBhLmRlZmF1bHQuY3JlYXRlRWxlbWVudChvLlBhdGhuYW1lQ29udGV4dC5Qcm92aWRlcix7dmFsdWU6dX0sdCl9fSw2MjUzOmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIHQpT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscix7ZW51bWVyYWJsZTohMCxnZXQ6dFtyXX0pfSh0LHtkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJuIFZ9LG1hdGNoZXNNaWRkbGV3YXJlOmZ1bmN0aW9uKCl7cmV0dXJuIE59LGNyZWF0ZUtleTpmdW5jdGlvbigpe3JldHVybiBxfX0pO2xldCBuPXIoODc1NCksYT1yKDE3NTcpLG89cig1MTI5KSxpPXIoODI2OSksbD1yKDQyOTQpLHU9YS5fKHIoNjc2KSkscz1yKDI2MjkpLGM9cig0OTkwKSxmPW4uXyhyKDY3MTIpKSxkPXIoNzMyMSksaD1yKDM3MDIpLHA9cigxMzcpO3IoMjQzMSk7bGV0IG09cigzNjYwKSxnPXIoMjkzMikseT1yKDI5MDIpO3IoMjY4KTtsZXQgXz1yKDc2MzcpLGI9cigyOTkpLHY9cig2MTE5KSxQPXIoNjM2Nyksdz1yKDM0NzUpLFM9cigxMTczKSxqPXIoOTQyMyksTz1yKDU1NjQpLEU9cigxNzAzKSxSPXIoOTI0NSkseD1yKDI5NjgpLEM9cigyMzgpLE09cig4NDQ3KSxBPXIoMjg2MiksTD1yKDE2OTApLEk9cigxMjU3KTtmdW5jdGlvbiBUKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oRXJyb3IoIlJvdXRlIENhbmNlbGxlZCIpLHtjYW5jZWxsZWQ6ITB9KX1hc3luYyBmdW5jdGlvbiBOKGUpe2xldCB0PWF3YWl0IFByb21pc2UucmVzb2x2ZShlLnJvdXRlci5wYWdlTG9hZGVyLmdldE1pZGRsZXdhcmUoKSk7aWYoIXQpcmV0dXJuITE7bGV0e3BhdGhuYW1lOnJ9PSgwLF8ucGFyc2VQYXRoKShlLmFzUGF0aCksbj0oMCxTLmhhc0Jhc2VQYXRoKShyKT8oMCxQLnJlbW92ZUJhc2VQYXRoKShyKTpyLGE9KDAsdy5hZGRCYXNlUGF0aCkoKDAsYi5hZGRMb2NhbGUpKG4sZS5sb2NhbGUpKTtyZXR1cm4gdC5zb21lKGU9Pm5ldyBSZWdFeHAoZS5yZWdleHApLnRlc3QoYSkpfWZ1bmN0aW9uIGsoZSl7bGV0IHQ9KDAsZC5nZXRMb2NhdGlvbk9yaWdpbikoKTtyZXR1cm4gZS5zdGFydHNXaXRoKHQpP2Uuc3Vic3RyaW5nKHQubGVuZ3RoKTplfWZ1bmN0aW9uIEQoZSx0LHIpe2xldFtuLGFdPSgwLEEucmVzb2x2ZUhyZWYpKGUsdCwhMCksbz0oMCxkLmdldExvY2F0aW9uT3JpZ2luKSgpLGk9bi5zdGFydHNXaXRoKG8pLGw9YSYmYS5zdGFydHNXaXRoKG8pO249ayhuKSxhPWE/ayhhKTphO2xldCB1PWk/bjooMCx3LmFkZEJhc2VQYXRoKShuKSxzPXI/aygoMCxBLnJlc29sdmVIcmVmKShlLHIpKTphfHxuO3JldHVybnt1cmw6dSxhczpsP3M6KDAsdy5hZGRCYXNlUGF0aCkocyl9fWZ1bmN0aW9uIEIoZSx0KXtsZXQgcj0oMCxvLnJlbW92ZVRyYWlsaW5nU2xhc2gpKCgwLHMuZGVub3JtYWxpemVQYWdlUGF0aCkoZSkpO3JldHVybiIvNDA0Ij09PXJ8fCIvX2Vycm9yIj09PXI/ZToodC5pbmNsdWRlcyhyKXx8dC5zb21lKHQ9PntpZigoMCxoLmlzRHluYW1pY1JvdXRlKSh0KSYmKDAsZy5nZXRSb3V0ZVJlZ2V4KSh0KS5yZS50ZXN0KHIpKXJldHVybiBlPXQsITB9KSwoMCxvLnJlbW92ZVRyYWlsaW5nU2xhc2gpKGUpKX1hc3luYyBmdW5jdGlvbiBIKGUpe2xldCB0PWF3YWl0IE4oZSk7aWYoIXR8fCFlLmZldGNoRGF0YSlyZXR1cm4gbnVsbDt0cnl7bGV0IHQ9YXdhaXQgZS5mZXRjaERhdGEoKSxyPWF3YWl0IGZ1bmN0aW9uKGUsdCxyKXtsZXQgbj17YmFzZVBhdGg6ci5yb3V0ZXIuYmFzZVBhdGgsaTE4bjp7bG9jYWxlczpyLnJvdXRlci5sb2NhbGVzfSx0cmFpbGluZ1NsYXNoOiExfSxhPXQuaGVhZGVycy5nZXQoIngtbmV4dGpzLXJld3JpdGUiKSxsPWF8fHQuaGVhZGVycy5nZXQoIngtbmV4dGpzLW1hdGNoZWQtcGF0aCIpLHU9dC5oZWFkZXJzLmdldCgieC1tYXRjaGVkLXBhdGgiKTtpZighdXx8bHx8dS5pbmNsdWRlcygiX19uZXh0X2RhdGFfY2F0Y2hhbGwiKXx8dS5pbmNsdWRlcygiL19lcnJvciIpfHx1LmluY2x1ZGVzKCIvNDA0Iil8fChsPXUpLGwpe2lmKGwuc3RhcnRzV2l0aCgiLyIpKXtsZXQgdD0oMCxwLnBhcnNlUmVsYXRpdmVVcmwpKGwpLHU9KDAsTy5nZXROZXh0UGF0aG5hbWVJbmZvKSh0LnBhdGhuYW1lLHtuZXh0Q29uZmlnOm4scGFyc2VEYXRhOiEwfSkscz0oMCxvLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHUucGF0aG5hbWUpO3JldHVybiBQcm9taXNlLmFsbChbci5yb3V0ZXIucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpLCgwLGkuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCkoKV0pLnRoZW4obz0+e2xldFtpLHtfX3Jld3JpdGVzOmx9XT1vLGY9KDAsYi5hZGRMb2NhbGUpKHUucGF0aG5hbWUsdS5sb2NhbGUpO2lmKCgwLGguaXNEeW5hbWljUm91dGUpKGYpfHwhYSYmaS5pbmNsdWRlcygoMCxjLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKCgwLFAucmVtb3ZlQmFzZVBhdGgpKGYpLHIucm91dGVyLmxvY2FsZXMpLnBhdGhuYW1lKSl7bGV0IHI9KDAsTy5nZXROZXh0UGF0aG5hbWVJbmZvKSgoMCxwLnBhcnNlUmVsYXRpdmVVcmwpKGUpLnBhdGhuYW1lLHtuZXh0Q29uZmlnOm4scGFyc2VEYXRhOiEwfSk7Zj0oMCx3LmFkZEJhc2VQYXRoKShyLnBhdGhuYW1lKSx0LnBhdGhuYW1lPWZ9aWYoIWkuaW5jbHVkZXMocykpe2xldCBlPUIocyxpKTtlIT09cyYmKHM9ZSl9bGV0IGQ9aS5pbmNsdWRlcyhzKT9zOkIoKDAsYy5ub3JtYWxpemVMb2NhbGVQYXRoKSgoMCxQLnJlbW92ZUJhc2VQYXRoKSh0LnBhdGhuYW1lKSxyLnJvdXRlci5sb2NhbGVzKS5wYXRobmFtZSxpKTtpZigoMCxoLmlzRHluYW1pY1JvdXRlKShkKSl7bGV0IGU9KDAsbS5nZXRSb3V0ZU1hdGNoZXIpKCgwLGcuZ2V0Um91dGVSZWdleCkoZCkpKGYpO09iamVjdC5hc3NpZ24odC5xdWVyeSxlfHx7fSl9cmV0dXJue3R5cGU6InJld3JpdGUiLHBhcnNlZEFzOnQscmVzb2x2ZWRIcmVmOmR9fSl9bGV0IHQ9KDAsXy5wYXJzZVBhdGgpKGUpLHU9KDAsRS5mb3JtYXROZXh0UGF0aG5hbWVJbmZvKSh7Li4uKDAsTy5nZXROZXh0UGF0aG5hbWVJbmZvKSh0LnBhdGhuYW1lLHtuZXh0Q29uZmlnOm4scGFyc2VEYXRhOiEwfSksZGVmYXVsdExvY2FsZTpyLnJvdXRlci5kZWZhdWx0TG9jYWxlLGJ1aWxkSWQ6IiJ9KTtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt0eXBlOiJyZWRpcmVjdC1leHRlcm5hbCIsZGVzdGluYXRpb246IiIrdSt0LnF1ZXJ5K3QuaGFzaH0pfWxldCBzPXQuaGVhZGVycy5nZXQoIngtbmV4dGpzLXJlZGlyZWN0Iik7aWYocyl7aWYocy5zdGFydHNXaXRoKCIvIikpe2xldCBlPSgwLF8ucGFyc2VQYXRoKShzKSx0PSgwLEUuZm9ybWF0TmV4dFBhdGhuYW1lSW5mbykoey4uLigwLE8uZ2V0TmV4dFBhdGhuYW1lSW5mbykoZS5wYXRobmFtZSx7bmV4dENvbmZpZzpuLHBhcnNlRGF0YTohMH0pLGRlZmF1bHRMb2NhbGU6ci5yb3V0ZXIuZGVmYXVsdExvY2FsZSxidWlsZElkOiIifSk7cmV0dXJuIFByb21pc2UucmVzb2x2ZSh7dHlwZToicmVkaXJlY3QtaW50ZXJuYWwiLG5ld0FzOiIiK3QrZS5xdWVyeStlLmhhc2gsbmV3VXJsOiIiK3QrZS5xdWVyeStlLmhhc2h9KX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt0eXBlOiJyZWRpcmVjdC1leHRlcm5hbCIsZGVzdGluYXRpb246c30pfXJldHVybiBQcm9taXNlLnJlc29sdmUoe3R5cGU6Im5leHQifSl9KHQuZGF0YUhyZWYsdC5yZXNwb25zZSxlKTtyZXR1cm57ZGF0YUhyZWY6dC5kYXRhSHJlZixqc29uOnQuanNvbixyZXNwb25zZTp0LnJlc3BvbnNlLHRleHQ6dC50ZXh0LGNhY2hlS2V5OnQuY2FjaGVLZXksZWZmZWN0OnJ9fWNhdGNoKGUpe3JldHVybiBudWxsfX1sZXQgVT1TeW1ib2woIlNTR19EQVRBX05PVF9GT1VORCIpO2Z1bmN0aW9uIEYoZSl7dHJ5e3JldHVybiBKU09OLnBhcnNlKGUpfWNhdGNoKGUpe3JldHVybiBudWxsfX1mdW5jdGlvbiBXKGUpe3ZhciB0O2xldHtkYXRhSHJlZjpyLGluZmxpZ2h0Q2FjaGU6bixpc1ByZWZldGNoOmEsaGFzTWlkZGxld2FyZTpvLGlzU2VydmVyUmVuZGVyOmwscGFyc2VKU09OOnUscGVyc2lzdENhY2hlOnMsaXNCYWNrZ3JvdW5kOmMsdW5zdGFibGVfc2tpcENsaWVudENhY2hlOmZ9PWUse2hyZWY6ZH09bmV3IFVSTChyLHdpbmRvdy5sb2NhdGlvbi5ocmVmKSxoPWU9PihmdW5jdGlvbiBlKHQscixuKXtyZXR1cm4gZmV0Y2godCx7Y3JlZGVudGlhbHM6InNhbWUtb3JpZ2luIixtZXRob2Q6bi5tZXRob2R8fCJHRVQiLGhlYWRlcnM6T2JqZWN0LmFzc2lnbih7fSxuLmhlYWRlcnMseyJ4LW5leHRqcy1kYXRhIjoiMSJ9KX0pLnRoZW4oYT0+IWEub2smJnI+MSYmYS5zdGF0dXM+PTUwMD9lKHQsci0xLG4pOmEpfSkocixsPzM6MSx7aGVhZGVyczpPYmplY3QuYXNzaWduKHt9LGE/e3B1cnBvc2U6InByZWZldGNoIn06e30sYSYmbz97IngtbWlkZGxld2FyZS1wcmVmZXRjaCI6IjEifTp7fSksbWV0aG9kOm51bGwhPSh0PW51bGw9PWU/dm9pZCAwOmUubWV0aG9kKT90OiJHRVQifSkudGhlbih0PT50Lm9rJiYobnVsbD09ZT92b2lkIDA6ZS5tZXRob2QpPT09IkhFQUQiP3tkYXRhSHJlZjpyLHJlc3BvbnNlOnQsdGV4dDoiIixqc29uOnt9LGNhY2hlS2V5OmR9OnQudGV4dCgpLnRoZW4oZT0+e2lmKCF0Lm9rKXtpZihvJiZbMzAxLDMwMiwzMDcsMzA4XS5pbmNsdWRlcyh0LnN0YXR1cykpcmV0dXJue2RhdGFIcmVmOnIscmVzcG9uc2U6dCx0ZXh0OmUsanNvbjp7fSxjYWNoZUtleTpkfTtpZig0MDQ9PT10LnN0YXR1cyl7dmFyIG47aWYobnVsbD09KG49RihlKSk/dm9pZCAwOm4ubm90Rm91bmQpcmV0dXJue2RhdGFIcmVmOnIsanNvbjp7bm90Rm91bmQ6VX0scmVzcG9uc2U6dCx0ZXh0OmUsY2FjaGVLZXk6ZH19bGV0IGE9RXJyb3IoIkZhaWxlZCB0byBsb2FkIHN0YXRpYyBwcm9wcyIpO3Rocm93IGx8fCgwLGkubWFya0Fzc2V0RXJyb3IpKGEpLGF9cmV0dXJue2RhdGFIcmVmOnIsanNvbjp1P0YoZSk6bnVsbCxyZXNwb25zZTp0LHRleHQ6ZSxjYWNoZUtleTpkfX0pKS50aGVuKGU9PihzJiYibm8tY2FjaGUiIT09ZS5yZXNwb25zZS5oZWFkZXJzLmdldCgieC1taWRkbGV3YXJlLWNhY2hlIil8fGRlbGV0ZSBuW2RdLGUpKS5jYXRjaChlPT57dGhyb3cgZnx8ZGVsZXRlIG5bZF0sKCJGYWlsZWQgdG8gZmV0Y2giPT09ZS5tZXNzYWdlfHwiTmV0d29ya0Vycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBmZXRjaCByZXNvdXJjZS4iPT09ZS5tZXNzYWdlfHwiTG9hZCBmYWlsZWQiPT09ZS5tZXNzYWdlKSYmKDAsaS5tYXJrQXNzZXRFcnJvcikoZSksZX0pO3JldHVybiBmJiZzP2goe30pLnRoZW4oZT0+KG5bZF09UHJvbWlzZS5yZXNvbHZlKGUpLGUpKTp2b2lkIDAhPT1uW2RdP25bZF06bltkXT1oKGM/e21ldGhvZDoiSEVBRCJ9Ont9KX1mdW5jdGlvbiBxKCl7cmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsMTApfWZ1bmN0aW9uIHooZSl7bGV0e3VybDp0LHJvdXRlcjpyfT1lO2lmKHQ9PT0oMCx3LmFkZEJhc2VQYXRoKSgoMCxiLmFkZExvY2FsZSkoci5hc1BhdGgsci5sb2NhbGUpKSl0aHJvdyBFcnJvcigiSW52YXJpYW50OiBhdHRlbXB0ZWQgdG8gaGFyZCBuYXZpZ2F0ZSB0byB0aGUgc2FtZSBVUkwgIit0KyIgIitsb2NhdGlvbi5ocmVmKTt3aW5kb3cubG9jYXRpb24uaHJlZj10fWxldCBHPWU9PntsZXR7cm91dGU6dCxyb3V0ZXI6cn09ZSxuPSExLGE9ci5jbGM9KCk9PntuPSEwfTtyZXR1cm4oKT0+e2lmKG4pe2xldCBlPUVycm9yKCdBYm9ydCBmZXRjaGluZyBjb21wb25lbnQgZm9yIHJvdXRlOiAiJyt0KyciJyk7dGhyb3cgZS5jYW5jZWxsZWQ9ITAsZX1hPT09ci5jbGMmJihyLmNsYz1udWxsKX19O2NsYXNzIFZ7cmVsb2FkKCl7d2luZG93LmxvY2F0aW9uLnJlbG9hZCgpfWJhY2soKXt3aW5kb3cuaGlzdG9yeS5iYWNrKCl9Zm9yd2FyZCgpe3dpbmRvdy5oaXN0b3J5LmZvcndhcmQoKX1wdXNoKGUsdCxyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9e30pLHt1cmw6ZSxhczp0fT1EKHRoaXMsZSx0KSx0aGlzLmNoYW5nZSgicHVzaFN0YXRlIixlLHQscil9cmVwbGFjZShlLHQscil7cmV0dXJuIHZvaWQgMD09PXImJihyPXt9KSx7dXJsOmUsYXM6dH09RCh0aGlzLGUsdCksdGhpcy5jaGFuZ2UoInJlcGxhY2VTdGF0ZSIsZSx0LHIpfWFzeW5jIF9iZmwoZSx0LHIsbil7e2xldCB1PSExLHM9ITE7Zm9yKGxldCBjIG9mW2UsdF0paWYoYyl7bGV0IHQ9KDAsby5yZW1vdmVUcmFpbGluZ1NsYXNoKShuZXcgVVJMKGMsImh0dHA6Ly9uIikucGF0aG5hbWUpLGY9KDAsdy5hZGRCYXNlUGF0aCkoKDAsYi5hZGRMb2NhbGUpKHQscnx8dGhpcy5sb2NhbGUpKTtpZih0IT09KDAsby5yZW1vdmVUcmFpbGluZ1NsYXNoKShuZXcgVVJMKHRoaXMuYXNQYXRoLCJodHRwOi8vbiIpLnBhdGhuYW1lKSl7dmFyIGEsaSxsO2ZvcihsZXQgZSBvZih1PXV8fCEhKG51bGw9PShhPXRoaXMuX2JmbF9zKT92b2lkIDA6YS5jb250YWlucyh0KSl8fCEhKG51bGw9PShpPXRoaXMuX2JmbF9zKT92b2lkIDA6aS5jb250YWlucyhmKSksW3QsZl0pKXtsZXQgdD1lLnNwbGl0KCIvIik7Zm9yKGxldCBlPTA7IXMmJmU8dC5sZW5ndGgrMTtlKyspe2xldCByPXQuc2xpY2UoMCxlKS5qb2luKCIvIik7aWYociYmKG51bGw9PShsPXRoaXMuX2JmbF9kKT92b2lkIDA6bC5jb250YWlucyhyKSkpe3M9ITA7YnJlYWt9fX1pZih1fHxzKXtpZihuKXJldHVybiEwO3JldHVybiB6KHt1cmw6KDAsdy5hZGRCYXNlUGF0aCkoKDAsYi5hZGRMb2NhbGUpKGUscnx8dGhpcy5sb2NhbGUsdGhpcy5kZWZhdWx0TG9jYWxlKSkscm91dGVyOnRoaXN9KSxuZXcgUHJvbWlzZSgoKT0+e30pfX19fXJldHVybiExfWFzeW5jIGNoYW5nZShlLHQscixuLGEpe3ZhciBzLGMsZixqLE8sRSxDLEEsSTtsZXQgayxIO2lmKCEoMCx4LmlzTG9jYWxVUkwpKHQpKXJldHVybiB6KHt1cmw6dCxyb3V0ZXI6dGhpc30pLCExO2xldCBGPTE9PT1uLl9oO0Z8fG4uc2hhbGxvd3x8YXdhaXQgdGhpcy5fYmZsKHIsdm9pZCAwLG4ubG9jYWxlKTtsZXQgVz1GfHxuLl9zaG91bGRSZXNvbHZlSHJlZnx8KDAsXy5wYXJzZVBhdGgpKHQpLnBhdGhuYW1lPT09KDAsXy5wYXJzZVBhdGgpKHIpLnBhdGhuYW1lLHE9ey4uLnRoaXMuc3RhdGV9LEc9ITAhPT10aGlzLmlzUmVhZHk7dGhpcy5pc1JlYWR5PSEwO2xldCBYPXRoaXMuaXNTc3I7aWYoRnx8KHRoaXMuaXNTc3I9ITEpLEYmJnRoaXMuY2xjKXJldHVybiExO2xldCAkPXEubG9jYWxlO2QuU1QmJnBlcmZvcm1hbmNlLm1hcmsoInJvdXRlQ2hhbmdlIik7bGV0e3NoYWxsb3c6WT0hMSxzY3JvbGw6Sz0hMH09bixKPXtzaGFsbG93Oll9O3RoaXMuX2luRmxpZ2h0Um91dGUmJnRoaXMuY2xjJiYoWHx8Vi5ldmVudHMuZW1pdCgicm91dGVDaGFuZ2VFcnJvciIsVCgpLHRoaXMuX2luRmxpZ2h0Um91dGUsSiksdGhpcy5jbGMoKSx0aGlzLmNsYz1udWxsKSxyPSgwLHcuYWRkQmFzZVBhdGgpKCgwLGIuYWRkTG9jYWxlKSgoMCxTLmhhc0Jhc2VQYXRoKShyKT8oMCxQLnJlbW92ZUJhc2VQYXRoKShyKTpyLG4ubG9jYWxlLHRoaXMuZGVmYXVsdExvY2FsZSkpO2xldCBRPSgwLHYucmVtb3ZlTG9jYWxlKSgoMCxTLmhhc0Jhc2VQYXRoKShyKT8oMCxQLnJlbW92ZUJhc2VQYXRoKShyKTpyLHEubG9jYWxlKTt0aGlzLl9pbkZsaWdodFJvdXRlPXI7bGV0IFo9JCE9PXEubG9jYWxlO2lmKCFGJiZ0aGlzLm9ubHlBSGFzaENoYW5nZShRKSYmIVope3EuYXNQYXRoPVEsVi5ldmVudHMuZW1pdCgiaGFzaENoYW5nZVN0YXJ0IixyLEopLHRoaXMuY2hhbmdlU3RhdGUoZSx0LHIsey4uLm4sc2Nyb2xsOiExfSksSyYmdGhpcy5zY3JvbGxUb0hhc2goUSk7dHJ5e2F3YWl0IHRoaXMuc2V0KHEsdGhpcy5jb21wb25lbnRzW3Eucm91dGVdLG51bGwpfWNhdGNoKGUpe3Rocm93KDAsdS5kZWZhdWx0KShlKSYmZS5jYW5jZWxsZWQmJlYuZXZlbnRzLmVtaXQoInJvdXRlQ2hhbmdlRXJyb3IiLGUsUSxKKSxlfXJldHVybiBWLmV2ZW50cy5lbWl0KCJoYXNoQ2hhbmdlQ29tcGxldGUiLHIsSiksITB9bGV0IGVlPSgwLHAucGFyc2VSZWxhdGl2ZVVybCkodCkse3BhdGhuYW1lOmV0LHF1ZXJ5OmVyfT1lZTtpZihudWxsPT0ocz10aGlzLmNvbXBvbmVudHNbZXRdKT92b2lkIDA6cy5fX2FwcFJvdXRlcilyZXR1cm4geih7dXJsOnIscm91dGVyOnRoaXN9KSxuZXcgUHJvbWlzZSgoKT0+e30pO3RyeXtbayx7X19yZXdyaXRlczpIfV09YXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpLCgwLGkuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCkoKSx0aGlzLnBhZ2VMb2FkZXIuZ2V0TWlkZGxld2FyZSgpXSl9Y2F0Y2goZSl7cmV0dXJuIHooe3VybDpyLHJvdXRlcjp0aGlzfSksITF9dGhpcy51cmxJc05ldyhRKXx8Wnx8KGU9InJlcGxhY2VTdGF0ZSIpO2xldCBlbj1yO2V0PWV0PygwLG8ucmVtb3ZlVHJhaWxpbmdTbGFzaCkoKDAsUC5yZW1vdmVCYXNlUGF0aCkoZXQpKTpldDtsZXQgZWE9KDAsby5yZW1vdmVUcmFpbGluZ1NsYXNoKShldCksZW89ci5zdGFydHNXaXRoKCIvIikmJigwLHAucGFyc2VSZWxhdGl2ZVVybCkocikucGF0aG5hbWUsZWk9ISEoZW8mJmVhIT09ZW8mJighKDAsaC5pc0R5bmFtaWNSb3V0ZSkoZWEpfHwhKDAsbS5nZXRSb3V0ZU1hdGNoZXIpKCgwLGcuZ2V0Um91dGVSZWdleCkoZWEpKShlbykpKSxlbD0hbi5zaGFsbG93JiZhd2FpdCBOKHthc1BhdGg6cixsb2NhbGU6cS5sb2NhbGUscm91dGVyOnRoaXN9KTtpZihGJiZlbCYmKFc9ITEpLFcmJiIvX2Vycm9yIiE9PWV0JiYobi5fc2hvdWxkUmVzb2x2ZUhyZWY9ITAsZWUucGF0aG5hbWU9QihldCxrKSxlZS5wYXRobmFtZT09PWV0fHwoZXQ9ZWUucGF0aG5hbWUsZWUucGF0aG5hbWU9KDAsdy5hZGRCYXNlUGF0aCkoZXQpLGVsfHwodD0oMCx5LmZvcm1hdFdpdGhWYWxpZGF0aW9uKShlZSkpKSksISgwLHguaXNMb2NhbFVSTCkocikpcmV0dXJuIHooe3VybDpyLHJvdXRlcjp0aGlzfSksITE7ZW49KDAsdi5yZW1vdmVMb2NhbGUpKCgwLFAucmVtb3ZlQmFzZVBhdGgpKGVuKSxxLmxvY2FsZSksZWE9KDAsby5yZW1vdmVUcmFpbGluZ1NsYXNoKShldCk7bGV0IGV1PSExO2lmKCgwLGguaXNEeW5hbWljUm91dGUpKGVhKSl7bGV0IGU9KDAscC5wYXJzZVJlbGF0aXZlVXJsKShlbiksbj1lLnBhdGhuYW1lLGE9KDAsZy5nZXRSb3V0ZVJlZ2V4KShlYSk7ZXU9KDAsbS5nZXRSb3V0ZU1hdGNoZXIpKGEpKG4pO2xldCBvPWVhPT09bixpPW8/KDAsTC5pbnRlcnBvbGF0ZUFzKShlYSxuLGVyKTp7fTtpZihldSYmKCFvfHxpLnJlc3VsdCkpbz9yPSgwLHkuZm9ybWF0V2l0aFZhbGlkYXRpb24pKE9iamVjdC5hc3NpZ24oe30sZSx7cGF0aG5hbWU6aS5yZXN1bHQscXVlcnk6KDAsTS5vbWl0KShlcixpLnBhcmFtcyl9KSk6T2JqZWN0LmFzc2lnbihlcixldSk7ZWxzZXtsZXQgZT1PYmplY3Qua2V5cyhhLmdyb3VwcykuZmlsdGVyKGU9PiFlcltlXSYmIWEuZ3JvdXBzW2VdLm9wdGlvbmFsKTtpZihlLmxlbmd0aD4wJiYhZWwpdGhyb3cgRXJyb3IoKG8/IlRoZSBwcm92aWRlZCBgaHJlZmAgKCIrdCsiKSB2YWx1ZSBpcyBtaXNzaW5nIHF1ZXJ5IHZhbHVlcyAoIitlLmpvaW4oIiwgIikrIikgdG8gYmUgaW50ZXJwb2xhdGVkIHByb3Blcmx5LiAiOiJUaGUgcHJvdmlkZWQgYGFzYCB2YWx1ZSAoIituKyIpIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoZSBgaHJlZmAgdmFsdWUgKCIrZWErIikuICIpKyJSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzLyIrKG8/ImhyZWYtaW50ZXJwb2xhdGlvbi1mYWlsZWQiOiJpbmNvbXBhdGlibGUtaHJlZi1hcyIpKX19Rnx8Vi5ldmVudHMuZW1pdCgicm91dGVDaGFuZ2VTdGFydCIscixKKTtsZXQgZXM9Ii80MDQiPT09dGhpcy5wYXRobmFtZXx8Ii9fZXJyb3IiPT09dGhpcy5wYXRobmFtZTt0cnl7bGV0IG89YXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe3JvdXRlOmVhLHBhdGhuYW1lOmV0LHF1ZXJ5OmVyLGFzOnIscmVzb2x2ZWRBczplbixyb3V0ZVByb3BzOkosbG9jYWxlOnEubG9jYWxlLGlzUHJldmlldzpxLmlzUHJldmlldyxoYXNNaWRkbGV3YXJlOmVsLHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZTpuLnVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSxpc1F1ZXJ5VXBkYXRpbmc6RiYmIXRoaXMuaXNGYWxsYmFjayxpc01pZGRsZXdhcmVSZXdyaXRlOmVpfSk7aWYoRnx8bi5zaGFsbG93fHxhd2FpdCB0aGlzLl9iZmwociwicmVzb2x2ZWRBcyJpbiBvP28ucmVzb2x2ZWRBczp2b2lkIDAscS5sb2NhbGUpLCJyb3V0ZSJpbiBvJiZlbCl7ZWE9ZXQ9by5yb3V0ZXx8ZWEsSi5zaGFsbG93fHwoZXI9T2JqZWN0LmFzc2lnbih7fSxvLnF1ZXJ5fHx7fSxlcikpO2xldCBlPSgwLFMuaGFzQmFzZVBhdGgpKGVlLnBhdGhuYW1lKT8oMCxQLnJlbW92ZUJhc2VQYXRoKShlZS5wYXRobmFtZSk6ZWUucGF0aG5hbWU7aWYoZXUmJmV0IT09ZSYmT2JqZWN0LmtleXMoZXUpLmZvckVhY2goZT0+e2V1JiZlcltlXT09PWV1W2VdJiZkZWxldGUgZXJbZV19KSwoMCxoLmlzRHluYW1pY1JvdXRlKShldCkpe2xldCBlPSFKLnNoYWxsb3cmJm8ucmVzb2x2ZWRBcz9vLnJlc29sdmVkQXM6KDAsdy5hZGRCYXNlUGF0aCkoKDAsYi5hZGRMb2NhbGUpKG5ldyBVUkwocixsb2NhdGlvbi5ocmVmKS5wYXRobmFtZSxxLmxvY2FsZSksITApLHQ9ZTsoMCxTLmhhc0Jhc2VQYXRoKSh0KSYmKHQ9KDAsUC5yZW1vdmVCYXNlUGF0aCkodCkpO2xldCBuPSgwLGcuZ2V0Um91dGVSZWdleCkoZXQpLGE9KDAsbS5nZXRSb3V0ZU1hdGNoZXIpKG4pKG5ldyBVUkwodCxsb2NhdGlvbi5ocmVmKS5wYXRobmFtZSk7YSYmT2JqZWN0LmFzc2lnbihlcixhKX19aWYoInR5cGUiaW4gbyl7aWYoInJlZGlyZWN0LWludGVybmFsIj09PW8udHlwZSlyZXR1cm4gdGhpcy5jaGFuZ2UoZSxvLm5ld1VybCxvLm5ld0FzLG4pO3JldHVybiB6KHt1cmw6by5kZXN0aW5hdGlvbixyb3V0ZXI6dGhpc30pLG5ldyBQcm9taXNlKCgpPT57fSl9bGV0IGk9by5Db21wb25lbnQ7aWYoaSYmaS51bnN0YWJsZV9zY3JpcHRMb2FkZXIpe2xldCBlPVtdLmNvbmNhdChpLnVuc3RhYmxlX3NjcmlwdExvYWRlcigpKTtlLmZvckVhY2goZT0+eygwLGwuaGFuZGxlQ2xpZW50U2NyaXB0TG9hZCkoZS5wcm9wcyl9KX1pZigoby5fX05fU1NHfHxvLl9fTl9TU1ApJiZvLnByb3BzKXtpZihvLnByb3BzLnBhZ2VQcm9wcyYmby5wcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUKXtuLmxvY2FsZT0hMTtsZXQgdD1vLnByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1Q7aWYodC5zdGFydHNXaXRoKCIvIikmJiExIT09by5wcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUX0JBU0VfUEFUSCl7bGV0IHI9KDAscC5wYXJzZVJlbGF0aXZlVXJsKSh0KTtyLnBhdGhuYW1lPUIoci5wYXRobmFtZSxrKTtsZXR7dXJsOmEsYXM6b309RCh0aGlzLHQsdCk7cmV0dXJuIHRoaXMuY2hhbmdlKGUsYSxvLG4pfXJldHVybiB6KHt1cmw6dCxyb3V0ZXI6dGhpc30pLG5ldyBQcm9taXNlKCgpPT57fSl9aWYocS5pc1ByZXZpZXc9ISFvLnByb3BzLl9fTl9QUkVWSUVXLG8ucHJvcHMubm90Rm91bmQ9PT1VKXtsZXQgZTt0cnl7YXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudCgiLzQwNCIpLGU9Ii80MDQifWNhdGNoKHQpe2U9Ii9fZXJyb3IifWlmKG89YXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe3JvdXRlOmUscGF0aG5hbWU6ZSxxdWVyeTplcixhczpyLHJlc29sdmVkQXM6ZW4scm91dGVQcm9wczp7c2hhbGxvdzohMX0sbG9jYWxlOnEubG9jYWxlLGlzUHJldmlldzpxLmlzUHJldmlldyxpc05vdEZvdW5kOiEwfSksInR5cGUiaW4gbyl0aHJvdyBFcnJvcigiVW5leHBlY3RlZCBtaWRkbGV3YXJlIGVmZmVjdCBvbiAvNDA0Iil9fUYmJiIvX2Vycm9yIj09PXRoaXMucGF0aG5hbWUmJihudWxsPT0oYz1zZWxmLl9fTkVYVF9EQVRBX18ucHJvcHMpP3ZvaWQgMDpudWxsPT0oZj1jLnBhZ2VQcm9wcyk/dm9pZCAwOmYuc3RhdHVzQ29kZSk9PT01MDAmJihudWxsPT0oaj1vLnByb3BzKT92b2lkIDA6ai5wYWdlUHJvcHMpJiYoby5wcm9wcy5wYWdlUHJvcHMuc3RhdHVzQ29kZT01MDApO2xldCBzPW4uc2hhbGxvdyYmcS5yb3V0ZT09PShudWxsIT0oTz1vLnJvdXRlKT9POmVhKSxkPW51bGwhPShFPW4uc2Nyb2xsKT9FOiFGJiYhcyx5PW51bGwhPWE/YTpkP3t4OjAseTowfTpudWxsLF89ey4uLnEscm91dGU6ZWEscGF0aG5hbWU6ZXQscXVlcnk6ZXIsYXNQYXRoOlEsaXNGYWxsYmFjazohMX07aWYoRiYmZXMpe2lmKG89YXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe3JvdXRlOnRoaXMucGF0aG5hbWUscGF0aG5hbWU6dGhpcy5wYXRobmFtZSxxdWVyeTplcixhczpyLHJlc29sdmVkQXM6ZW4scm91dGVQcm9wczp7c2hhbGxvdzohMX0sbG9jYWxlOnEubG9jYWxlLGlzUHJldmlldzpxLmlzUHJldmlldyxpc1F1ZXJ5VXBkYXRpbmc6RiYmIXRoaXMuaXNGYWxsYmFja30pLCJ0eXBlImluIG8pdGhyb3cgRXJyb3IoIlVuZXhwZWN0ZWQgbWlkZGxld2FyZSBlZmZlY3Qgb24gIit0aGlzLnBhdGhuYW1lKTsiL19lcnJvciI9PT10aGlzLnBhdGhuYW1lJiYobnVsbD09KEM9c2VsZi5fX05FWFRfREFUQV9fLnByb3BzKT92b2lkIDA6bnVsbD09KEE9Qy5wYWdlUHJvcHMpP3ZvaWQgMDpBLnN0YXR1c0NvZGUpPT09NTAwJiYobnVsbD09KEk9by5wcm9wcyk/dm9pZCAwOkkucGFnZVByb3BzKSYmKG8ucHJvcHMucGFnZVByb3BzLnN0YXR1c0NvZGU9NTAwKTt0cnl7YXdhaXQgdGhpcy5zZXQoXyxvLHkpfWNhdGNoKGUpe3Rocm93KDAsdS5kZWZhdWx0KShlKSYmZS5jYW5jZWxsZWQmJlYuZXZlbnRzLmVtaXQoInJvdXRlQ2hhbmdlRXJyb3IiLGUsUSxKKSxlfXJldHVybiEwfVYuZXZlbnRzLmVtaXQoImJlZm9yZUhpc3RvcnlDaGFuZ2UiLHIsSiksdGhpcy5jaGFuZ2VTdGF0ZShlLHQscixuKTtsZXQgdj1GJiYheSYmIUcmJiFaJiYoMCxSLmNvbXBhcmVSb3V0ZXJTdGF0ZXMpKF8sdGhpcy5zdGF0ZSk7aWYoIXYpe3RyeXthd2FpdCB0aGlzLnNldChfLG8seSl9Y2F0Y2goZSl7aWYoZS5jYW5jZWxsZWQpby5lcnJvcj1vLmVycm9yfHxlO2Vsc2UgdGhyb3cgZX1pZihvLmVycm9yKXRocm93IEZ8fFYuZXZlbnRzLmVtaXQoInJvdXRlQ2hhbmdlRXJyb3IiLG8uZXJyb3IsUSxKKSxvLmVycm9yO0Z8fFYuZXZlbnRzLmVtaXQoInJvdXRlQ2hhbmdlQ29tcGxldGUiLHIsSiksZCYmLyMuKyQvLnRlc3QocikmJnRoaXMuc2Nyb2xsVG9IYXNoKHIpfXJldHVybiEwfWNhdGNoKGUpe2lmKCgwLHUuZGVmYXVsdCkoZSkmJmUuY2FuY2VsbGVkKXJldHVybiExO3Rocm93IGV9fWNoYW5nZVN0YXRlKGUsdCxyLG4pe3ZvaWQgMD09PW4mJihuPXt9KSwoInB1c2hTdGF0ZSIhPT1lfHwoMCxkLmdldFVSTCkoKSE9PXIpJiYodGhpcy5fc2hhbGxvdz1uLnNoYWxsb3csd2luZG93Lmhpc3RvcnlbZV0oe3VybDp0LGFzOnIsb3B0aW9uczpuLF9fTjohMCxrZXk6dGhpcy5fa2V5PSJwdXNoU3RhdGUiIT09ZT90aGlzLl9rZXk6cSgpfSwiIixyKSl9YXN5bmMgaGFuZGxlUm91dGVJbmZvRXJyb3IoZSx0LHIsbixhLG8pe2lmKGNvbnNvbGUuZXJyb3IoZSksZS5jYW5jZWxsZWQpdGhyb3cgZTtpZigoMCxpLmlzQXNzZXRFcnJvcikoZSl8fG8pdGhyb3cgVi5ldmVudHMuZW1pdCgicm91dGVDaGFuZ2VFcnJvciIsZSxuLGEpLHooe3VybDpuLHJvdXRlcjp0aGlzfSksVCgpO3RyeXtsZXQgbjtsZXR7cGFnZTphLHN0eWxlU2hlZXRzOm99PWF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoIi9fZXJyb3IiKSxpPXtwcm9wczpuLENvbXBvbmVudDphLHN0eWxlU2hlZXRzOm8sZXJyOmUsZXJyb3I6ZX07aWYoIWkucHJvcHMpdHJ5e2kucHJvcHM9YXdhaXQgdGhpcy5nZXRJbml0aWFsUHJvcHMoYSx7ZXJyOmUscGF0aG5hbWU6dCxxdWVyeTpyfSl9Y2F0Y2goZSl7Y29uc29sZS5lcnJvcigiRXJyb3IgaW4gZXJyb3IgcGFnZSBgZ2V0SW5pdGlhbFByb3BzYDogIixlKSxpLnByb3BzPXt9fXJldHVybiBpfWNhdGNoKGUpe3JldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKCgwLHUuZGVmYXVsdCkoZSk/ZTpFcnJvcihlKyIiKSx0LHIsbixhLCEwKX19YXN5bmMgZ2V0Um91dGVJbmZvKGUpe2xldHtyb3V0ZTp0LHBhdGhuYW1lOnIscXVlcnk6bixhczphLHJlc29sdmVkQXM6aSxyb3V0ZVByb3BzOmwsbG9jYWxlOnMsaGFzTWlkZGxld2FyZTpmLGlzUHJldmlldzpkLHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZTpoLGlzUXVlcnlVcGRhdGluZzpwLGlzTWlkZGxld2FyZVJld3JpdGU6bSxpc05vdEZvdW5kOmd9PWUsXz10O3RyeXt2YXIgYix2LHcsUztsZXQgZT1HKHtyb3V0ZTpfLHJvdXRlcjp0aGlzfSksdD10aGlzLmNvbXBvbmVudHNbX107aWYobC5zaGFsbG93JiZ0JiZ0aGlzLnJvdXRlPT09XylyZXR1cm4gdDtmJiYodD12b2lkIDApO2xldCB1PSF0fHwiaW5pdGlhbCJpbiB0P3ZvaWQgMDp0LE89e2RhdGFIcmVmOnRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7aHJlZjooMCx5LmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7cGF0aG5hbWU6cixxdWVyeTpufSksc2tpcEludGVycG9sYXRpb246ITAsYXNQYXRoOmc/Ii80MDQiOmksbG9jYWxlOnN9KSxoYXNNaWRkbGV3YXJlOiEwLGlzU2VydmVyUmVuZGVyOnRoaXMuaXNTc3IscGFyc2VKU09OOiEwLGluZmxpZ2h0Q2FjaGU6cD90aGlzLnNiYzp0aGlzLnNkYyxwZXJzaXN0Q2FjaGU6IWQsaXNQcmVmZXRjaDohMSx1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU6aCxpc0JhY2tncm91bmQ6cH0sRT1wJiYhbT9udWxsOmF3YWl0IEgoe2ZldGNoRGF0YTooKT0+VyhPKSxhc1BhdGg6Zz8iLzQwNCI6aSxsb2NhbGU6cyxyb3V0ZXI6dGhpc30pLmNhdGNoKGU9PntpZihwKXJldHVybiBudWxsO3Rocm93IGV9KTtpZihFJiYoIi9fZXJyb3IiPT09cnx8Ii80MDQiPT09cikmJihFLmVmZmVjdD12b2lkIDApLHAmJihFP0UuanNvbj1zZWxmLl9fTkVYVF9EQVRBX18ucHJvcHM6RT17anNvbjpzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHN9KSxlKCksKG51bGw9PUU/dm9pZCAwOm51bGw9PShiPUUuZWZmZWN0KT92b2lkIDA6Yi50eXBlKT09PSJyZWRpcmVjdC1pbnRlcm5hbCJ8fChudWxsPT1FP3ZvaWQgMDpudWxsPT0odj1FLmVmZmVjdCk/dm9pZCAwOnYudHlwZSk9PT0icmVkaXJlY3QtZXh0ZXJuYWwiKXJldHVybiBFLmVmZmVjdDtpZigobnVsbD09RT92b2lkIDA6bnVsbD09KHc9RS5lZmZlY3QpP3ZvaWQgMDp3LnR5cGUpPT09InJld3JpdGUiKXtsZXQgZT0oMCxvLnJlbW92ZVRyYWlsaW5nU2xhc2gpKEUuZWZmZWN0LnJlc29sdmVkSHJlZiksYT1hd2FpdCB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKTtpZigoIXB8fGEuaW5jbHVkZXMoZSkpJiYoXz1lLHI9RS5lZmZlY3QucmVzb2x2ZWRIcmVmLG49ey4uLm4sLi4uRS5lZmZlY3QucGFyc2VkQXMucXVlcnl9LGk9KDAsUC5yZW1vdmVCYXNlUGF0aCkoKDAsYy5ub3JtYWxpemVMb2NhbGVQYXRoKShFLmVmZmVjdC5wYXJzZWRBcy5wYXRobmFtZSx0aGlzLmxvY2FsZXMpLnBhdGhuYW1lKSx0PXRoaXMuY29tcG9uZW50c1tfXSxsLnNoYWxsb3cmJnQmJnRoaXMucm91dGU9PT1fJiYhZikpcmV0dXJuey4uLnQscm91dGU6X319aWYoKDAsai5pc0FQSVJvdXRlKShfKSlyZXR1cm4geih7dXJsOmEscm91dGVyOnRoaXN9KSxuZXcgUHJvbWlzZSgoKT0+e30pO2xldCBSPXV8fGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoXykudGhlbihlPT4oe0NvbXBvbmVudDplLnBhZ2Usc3R5bGVTaGVldHM6ZS5zdHlsZVNoZWV0cyxfX05fU1NHOmUubW9kLl9fTl9TU0csX19OX1NTUDplLm1vZC5fX05fU1NQfSkpLHg9bnVsbD09RT92b2lkIDA6bnVsbD09KFM9RS5yZXNwb25zZSk/dm9pZCAwOlMuaGVhZGVycy5nZXQoIngtbWlkZGxld2FyZS1za2lwIiksQz1SLl9fTl9TU0d8fFIuX19OX1NTUDt4JiYobnVsbD09RT92b2lkIDA6RS5kYXRhSHJlZikmJmRlbGV0ZSB0aGlzLnNkY1tFLmRhdGFIcmVmXTtsZXR7cHJvcHM6TSxjYWNoZUtleTpBfT1hd2FpdCB0aGlzLl9nZXREYXRhKGFzeW5jKCk9PntpZihDKXtpZigobnVsbD09RT92b2lkIDA6RS5qc29uKSYmIXgpcmV0dXJue2NhY2hlS2V5OkUuY2FjaGVLZXkscHJvcHM6RS5qc29ufTtsZXQgZT0obnVsbD09RT92b2lkIDA6RS5kYXRhSHJlZik/RS5kYXRhSHJlZjp0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe2hyZWY6KDAseS5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe3BhdGhuYW1lOnIscXVlcnk6bn0pLGFzUGF0aDppLGxvY2FsZTpzfSksdD1hd2FpdCBXKHtkYXRhSHJlZjplLGlzU2VydmVyUmVuZGVyOnRoaXMuaXNTc3IscGFyc2VKU09OOiEwLGluZmxpZ2h0Q2FjaGU6eD97fTp0aGlzLnNkYyxwZXJzaXN0Q2FjaGU6IWQsaXNQcmVmZXRjaDohMSx1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU6aH0pO3JldHVybntjYWNoZUtleTp0LmNhY2hlS2V5LHByb3BzOnQuanNvbnx8e319fXJldHVybntoZWFkZXJzOnt9LHByb3BzOmF3YWl0IHRoaXMuZ2V0SW5pdGlhbFByb3BzKFIuQ29tcG9uZW50LHtwYXRobmFtZTpyLHF1ZXJ5Om4sYXNQYXRoOmEsbG9jYWxlOnMsbG9jYWxlczp0aGlzLmxvY2FsZXMsZGVmYXVsdExvY2FsZTp0aGlzLmRlZmF1bHRMb2NhbGV9KX19KTtyZXR1cm4gUi5fX05fU1NQJiZPLmRhdGFIcmVmJiZBJiZkZWxldGUgdGhpcy5zZGNbQV0sdGhpcy5pc1ByZXZpZXd8fCFSLl9fTl9TU0d8fHB8fFcoT2JqZWN0LmFzc2lnbih7fSxPLHtpc0JhY2tncm91bmQ6ITAscGVyc2lzdENhY2hlOiExLGluZmxpZ2h0Q2FjaGU6dGhpcy5zYmN9KSkuY2F0Y2goKCk9Pnt9KSxNLnBhZ2VQcm9wcz1PYmplY3QuYXNzaWduKHt9LE0ucGFnZVByb3BzKSxSLnByb3BzPU0sUi5yb3V0ZT1fLFIucXVlcnk9bixSLnJlc29sdmVkQXM9aSx0aGlzLmNvbXBvbmVudHNbX109UixSfWNhdGNoKGUpe3JldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKCgwLHUuZ2V0UHJvcGVyRXJyb3IpKGUpLHIsbixhLGwpfX1zZXQoZSx0LHIpe3JldHVybiB0aGlzLnN0YXRlPWUsdGhpcy5zdWIodCx0aGlzLmNvbXBvbmVudHNbIi9fYXBwIl0uQ29tcG9uZW50LHIpfWJlZm9yZVBvcFN0YXRlKGUpe3RoaXMuX2Jwcz1lfW9ubHlBSGFzaENoYW5nZShlKXtpZighdGhpcy5hc1BhdGgpcmV0dXJuITE7bGV0W3Qscl09dGhpcy5hc1BhdGguc3BsaXQoIiMiKSxbbixhXT1lLnNwbGl0KCIjIik7cmV0dXJuISFhJiZ0PT09biYmcj09PWF8fHQ9PT1uJiZyIT09YX1zY3JvbGxUb0hhc2goZSl7bGV0Wyx0PSIiXT1lLnNwbGl0KCIjIik7aWYoIiI9PT10fHwidG9wIj09PXQpeygwLEkuaGFuZGxlU21vb3RoU2Nyb2xsKSgoKT0+d2luZG93LnNjcm9sbFRvKDAsMCkpO3JldHVybn1sZXQgcj1kZWNvZGVVUklDb21wb25lbnQodCksbj1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChyKTtpZihuKXsoMCxJLmhhbmRsZVNtb290aFNjcm9sbCkoKCk9Pm4uc2Nyb2xsSW50b1ZpZXcoKSk7cmV0dXJufWxldCBhPWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKHIpWzBdO2EmJigwLEkuaGFuZGxlU21vb3RoU2Nyb2xsKSgoKT0+YS5zY3JvbGxJbnRvVmlldygpKX11cmxJc05ldyhlKXtyZXR1cm4gdGhpcy5hc1BhdGghPT1lfWFzeW5jIHByZWZldGNoKGUsdCxyKXtpZih2b2lkIDA9PT10JiYodD1lKSx2b2lkIDA9PT1yJiYocj17fSksKDAsQy5pc0JvdCkod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpKXJldHVybjtsZXQgbj0oMCxwLnBhcnNlUmVsYXRpdmVVcmwpKGUpLGE9bi5wYXRobmFtZSx7cGF0aG5hbWU6aSxxdWVyeTpsfT1uLHU9aSxzPWF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpLGM9dCxmPXZvaWQgMCE9PXIubG9jYWxlP3IubG9jYWxlfHx2b2lkIDA6dGhpcy5sb2NhbGUsZD1hd2FpdCBOKHthc1BhdGg6dCxsb2NhbGU6Zixyb3V0ZXI6dGhpc30pO24ucGF0aG5hbWU9QihuLnBhdGhuYW1lLHMpLCgwLGguaXNEeW5hbWljUm91dGUpKG4ucGF0aG5hbWUpJiYoaT1uLnBhdGhuYW1lLG4ucGF0aG5hbWU9aSxPYmplY3QuYXNzaWduKGwsKDAsbS5nZXRSb3V0ZU1hdGNoZXIpKCgwLGcuZ2V0Um91dGVSZWdleCkobi5wYXRobmFtZSkpKCgwLF8ucGFyc2VQYXRoKSh0KS5wYXRobmFtZSl8fHt9KSxkfHwoZT0oMCx5LmZvcm1hdFdpdGhWYWxpZGF0aW9uKShuKSkpO2xldCBiPWF3YWl0IEgoe2ZldGNoRGF0YTooKT0+Vyh7ZGF0YUhyZWY6dGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtocmVmOigwLHkuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtwYXRobmFtZTp1LHF1ZXJ5Omx9KSxza2lwSW50ZXJwb2xhdGlvbjohMCxhc1BhdGg6Yyxsb2NhbGU6Zn0pLGhhc01pZGRsZXdhcmU6ITAsaXNTZXJ2ZXJSZW5kZXI6dGhpcy5pc1NzcixwYXJzZUpTT046ITAsaW5mbGlnaHRDYWNoZTp0aGlzLnNkYyxwZXJzaXN0Q2FjaGU6IXRoaXMuaXNQcmV2aWV3LGlzUHJlZmV0Y2g6ITB9KSxhc1BhdGg6dCxsb2NhbGU6Zixyb3V0ZXI6dGhpc30pO2lmKChudWxsPT1iP3ZvaWQgMDpiLmVmZmVjdC50eXBlKT09PSJyZXdyaXRlIiYmKG4ucGF0aG5hbWU9Yi5lZmZlY3QucmVzb2x2ZWRIcmVmLGk9Yi5lZmZlY3QucmVzb2x2ZWRIcmVmLGw9ey4uLmwsLi4uYi5lZmZlY3QucGFyc2VkQXMucXVlcnl9LGM9Yi5lZmZlY3QucGFyc2VkQXMucGF0aG5hbWUsZT0oMCx5LmZvcm1hdFdpdGhWYWxpZGF0aW9uKShuKSksKG51bGw9PWI/dm9pZCAwOmIuZWZmZWN0LnR5cGUpPT09InJlZGlyZWN0LWV4dGVybmFsIilyZXR1cm47bGV0IHY9KDAsby5yZW1vdmVUcmFpbGluZ1NsYXNoKShpKTthd2FpdCB0aGlzLl9iZmwodCxjLHIubG9jYWxlLCEwKSYmKHRoaXMuY29tcG9uZW50c1thXT17X19hcHBSb3V0ZXI6ITB9KSxhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5wYWdlTG9hZGVyLl9pc1NzZyh2KS50aGVuKHQ9PiEhdCYmVyh7ZGF0YUhyZWY6KG51bGw9PWI/dm9pZCAwOmIuanNvbik/bnVsbD09Yj92b2lkIDA6Yi5kYXRhSHJlZjp0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe2hyZWY6ZSxhc1BhdGg6Yyxsb2NhbGU6Zn0pLGlzU2VydmVyUmVuZGVyOiExLHBhcnNlSlNPTjohMCxpbmZsaWdodENhY2hlOnRoaXMuc2RjLHBlcnNpc3RDYWNoZTohdGhpcy5pc1ByZXZpZXcsaXNQcmVmZXRjaDohMCx1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU6ci51bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGV8fHIucHJpb3JpdHkmJiEwfSkudGhlbigoKT0+ITEpLmNhdGNoKCgpPT4hMSkpLHRoaXMucGFnZUxvYWRlcltyLnByaW9yaXR5PyJsb2FkUGFnZSI6InByZWZldGNoIl0odildKX1hc3luYyBmZXRjaENvbXBvbmVudChlKXtsZXQgdD1HKHtyb3V0ZTplLHJvdXRlcjp0aGlzfSk7dHJ5e2xldCByPWF3YWl0IHRoaXMucGFnZUxvYWRlci5sb2FkUGFnZShlKTtyZXR1cm4gdCgpLHJ9Y2F0Y2goZSl7dGhyb3cgdCgpLGV9fV9nZXREYXRhKGUpe2xldCB0PSExLHI9KCk9Pnt0PSEwfTtyZXR1cm4gdGhpcy5jbGM9cixlKCkudGhlbihlPT57aWYocj09PXRoaXMuY2xjJiYodGhpcy5jbGM9bnVsbCksdCl7bGV0IGU9RXJyb3IoIkxvYWRpbmcgaW5pdGlhbCBwcm9wcyBjYW5jZWxsZWQiKTt0aHJvdyBlLmNhbmNlbGxlZD0hMCxlfXJldHVybiBlfSl9X2dldEZsaWdodERhdGEoZSl7cmV0dXJuIFcoe2RhdGFIcmVmOmUsaXNTZXJ2ZXJSZW5kZXI6ITAscGFyc2VKU09OOiExLGluZmxpZ2h0Q2FjaGU6dGhpcy5zZGMscGVyc2lzdENhY2hlOiExLGlzUHJlZmV0Y2g6ITF9KS50aGVuKGU9PntsZXR7dGV4dDp0fT1lO3JldHVybntkYXRhOnR9fSl9Z2V0SW5pdGlhbFByb3BzKGUsdCl7bGV0e0NvbXBvbmVudDpyfT10aGlzLmNvbXBvbmVudHNbIi9fYXBwIl0sbj10aGlzLl93cmFwQXBwKHIpO3JldHVybiB0LkFwcFRyZWU9biwoMCxkLmxvYWRHZXRJbml0aWFsUHJvcHMpKHIse0FwcFRyZWU6bixDb21wb25lbnQ6ZSxyb3V0ZXI6dGhpcyxjdHg6dH0pfWdldCByb3V0ZSgpe3JldHVybiB0aGlzLnN0YXRlLnJvdXRlfWdldCBwYXRobmFtZSgpe3JldHVybiB0aGlzLnN0YXRlLnBhdGhuYW1lfWdldCBxdWVyeSgpe3JldHVybiB0aGlzLnN0YXRlLnF1ZXJ5fWdldCBhc1BhdGgoKXtyZXR1cm4gdGhpcy5zdGF0ZS5hc1BhdGh9Z2V0IGxvY2FsZSgpe3JldHVybiB0aGlzLnN0YXRlLmxvY2FsZX1nZXQgaXNGYWxsYmFjaygpe3JldHVybiB0aGlzLnN0YXRlLmlzRmFsbGJhY2t9Z2V0IGlzUHJldmlldygpe3JldHVybiB0aGlzLnN0YXRlLmlzUHJldmlld31jb25zdHJ1Y3RvcihlLHQsbix7aW5pdGlhbFByb3BzOmEscGFnZUxvYWRlcjppLEFwcDpsLHdyYXBBcHA6dSxDb21wb25lbnQ6cyxlcnI6YyxzdWJzY3JpcHRpb246Zixpc0ZhbGxiYWNrOm0sbG9jYWxlOmcsbG9jYWxlczpfLGRlZmF1bHRMb2NhbGU6Yixkb21haW5Mb2NhbGVzOnYsaXNQcmV2aWV3OlB9KXt0aGlzLnNkYz17fSx0aGlzLnNiYz17fSx0aGlzLmlzRmlyc3RQb3BTdGF0ZUV2ZW50PSEwLHRoaXMuX2tleT1xKCksdGhpcy5vblBvcFN0YXRlPWU9PntsZXQgdDtsZXR7aXNGaXJzdFBvcFN0YXRlRXZlbnQ6cn09dGhpczt0aGlzLmlzRmlyc3RQb3BTdGF0ZUV2ZW50PSExO2xldCBuPWUuc3RhdGU7aWYoIW4pe2xldHtwYXRobmFtZTplLHF1ZXJ5OnR9PXRoaXM7dGhpcy5jaGFuZ2VTdGF0ZSgicmVwbGFjZVN0YXRlIiwoMCx5LmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7cGF0aG5hbWU6KDAsdy5hZGRCYXNlUGF0aCkoZSkscXVlcnk6dH0pLCgwLGQuZ2V0VVJMKSgpKTtyZXR1cm59aWYobi5fX05BKXt3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7cmV0dXJufWlmKCFuLl9fTnx8ciYmdGhpcy5sb2NhbGU9PT1uLm9wdGlvbnMubG9jYWxlJiZuLmFzPT09dGhpcy5hc1BhdGgpcmV0dXJuO2xldHt1cmw6YSxhczpvLG9wdGlvbnM6aSxrZXk6bH09bjt0aGlzLl9rZXk9bDtsZXR7cGF0aG5hbWU6dX09KDAscC5wYXJzZVJlbGF0aXZlVXJsKShhKTsoIXRoaXMuaXNTc3J8fG8hPT0oMCx3LmFkZEJhc2VQYXRoKSh0aGlzLmFzUGF0aCl8fHUhPT0oMCx3LmFkZEJhc2VQYXRoKSh0aGlzLnBhdGhuYW1lKSkmJighdGhpcy5fYnBzfHx0aGlzLl9icHMobikpJiZ0aGlzLmNoYW5nZSgicmVwbGFjZVN0YXRlIixhLG8sT2JqZWN0LmFzc2lnbih7fSxpLHtzaGFsbG93Omkuc2hhbGxvdyYmdGhpcy5fc2hhbGxvdyxsb2NhbGU6aS5sb2NhbGV8fHRoaXMuZGVmYXVsdExvY2FsZSxfaDowfSksdCl9O2xldCBTPSgwLG8ucmVtb3ZlVHJhaWxpbmdTbGFzaCkoZSk7dGhpcy5jb21wb25lbnRzPXt9LCIvX2Vycm9yIiE9PWUmJih0aGlzLmNvbXBvbmVudHNbU109e0NvbXBvbmVudDpzLGluaXRpYWw6ITAscHJvcHM6YSxlcnI6YyxfX05fU1NHOmEmJmEuX19OX1NTRyxfX05fU1NQOmEmJmEuX19OX1NTUH0pLHRoaXMuY29tcG9uZW50c1siL19hcHAiXT17Q29tcG9uZW50Omwsc3R5bGVTaGVldHM6W119O3tsZXR7Qmxvb21GaWx0ZXI6ZX09cigxOTE4KSx0PXtudW1JdGVtczoyLGVycm9yUmF0ZTouMDEsbnVtQml0czoyMCxudW1IYXNoZXM6NyxiaXRBcnJheTpbMCwwLDAsMSwxLDAsMSwxLDAsMCwxLDEsMCwwLDAsMSwxLDAsMSwxXX0sbj17bnVtSXRlbXM6MCxlcnJvclJhdGU6LjAxLG51bUJpdHM6MCxudW1IYXNoZXM6bnVsbCxiaXRBcnJheTpbXX07KG51bGw9PXQ/dm9pZCAwOnQubnVtSGFzaGVzKSYmKHRoaXMuX2JmbF9zPW5ldyBlKHQubnVtSXRlbXMsdC5lcnJvclJhdGUpLHRoaXMuX2JmbF9zLmltcG9ydCh0KSksKG51bGw9PW4/dm9pZCAwOm4ubnVtSGFzaGVzKSYmKHRoaXMuX2JmbF9kPW5ldyBlKG4ubnVtSXRlbXMsbi5lcnJvclJhdGUpLHRoaXMuX2JmbF9kLmltcG9ydChuKSl9dGhpcy5ldmVudHM9Vi5ldmVudHMsdGhpcy5wYWdlTG9hZGVyPWk7bGV0IGo9KDAsaC5pc0R5bmFtaWNSb3V0ZSkoZSkmJnNlbGYuX19ORVhUX0RBVEFfXy5hdXRvRXhwb3J0O2lmKHRoaXMuYmFzZVBhdGg9IiIsdGhpcy5zdWI9Zix0aGlzLmNsYz1udWxsLHRoaXMuX3dyYXBBcHA9dSx0aGlzLmlzU3NyPSEwLHRoaXMuaXNMb2NhbGVEb21haW49ITEsdGhpcy5pc1JlYWR5PSEhKHNlbGYuX19ORVhUX0RBVEFfXy5nc3NwfHxzZWxmLl9fTkVYVF9EQVRBX18uZ2lwfHxzZWxmLl9fTkVYVF9EQVRBX18uYXBwR2lwJiYhc2VsZi5fX05FWFRfREFUQV9fLmdzcHx8IWomJiFzZWxmLmxvY2F0aW9uLnNlYXJjaCksdGhpcy5zdGF0ZT17cm91dGU6UyxwYXRobmFtZTplLHF1ZXJ5OnQsYXNQYXRoOmo/ZTpuLGlzUHJldmlldzohIVAsbG9jYWxlOnZvaWQgMCxpc0ZhbGxiYWNrOm19LHRoaXMuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2U9UHJvbWlzZS5yZXNvbHZlKCExKSwhbi5zdGFydHNXaXRoKCIvLyIpKXtsZXQgcj17bG9jYWxlOmd9LGE9KDAsZC5nZXRVUkwpKCk7dGhpcy5faW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZT1OKHtyb3V0ZXI6dGhpcyxsb2NhbGU6Zyxhc1BhdGg6YX0pLnRoZW4obz0+KHIuX3Nob3VsZFJlc29sdmVIcmVmPW4hPT1lLHRoaXMuY2hhbmdlU3RhdGUoInJlcGxhY2VTdGF0ZSIsbz9hOigwLHkuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtwYXRobmFtZTooMCx3LmFkZEJhc2VQYXRoKShlKSxxdWVyeTp0fSksYSxyKSxvKSl9d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoInBvcHN0YXRlIix0aGlzLm9uUG9wU3RhdGUpfX1WLmV2ZW50cz0oMCxmLmRlZmF1bHQpKCl9LDE5Njg6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImFkZExvY2FsZSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG99fSk7bGV0IG49cigxNDg0KSxhPXIoOTYyMyk7ZnVuY3Rpb24gbyhlLHQscixvKXtpZighdHx8dD09PXIpcmV0dXJuIGU7bGV0IGk9ZS50b0xvd2VyQ2FzZSgpO3JldHVybiFvJiYoKDAsYS5wYXRoSGFzUHJlZml4KShpLCIvYXBpIil8fCgwLGEucGF0aEhhc1ByZWZpeCkoaSwiLyIrdC50b0xvd2VyQ2FzZSgpKSk/ZTooMCxuLmFkZFBhdGhQcmVmaXgpKGUsIi8iK3QpfX0sMTQ4NDpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiYWRkUGF0aFByZWZpeCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGF9fSk7bGV0IG49cig3NjM3KTtmdW5jdGlvbiBhKGUsdCl7aWYoIWUuc3RhcnRzV2l0aCgiLyIpfHwhdClyZXR1cm4gZTtsZXR7cGF0aG5hbWU6cixxdWVyeTphLGhhc2g6b309KDAsbi5wYXJzZVBhdGgpKGUpO3JldHVybiIiK3QrcithK299fSw0OTE4OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJhZGRQYXRoU3VmZml4Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYX19KTtsZXQgbj1yKDc2MzcpO2Z1bmN0aW9uIGEoZSx0KXtpZighZS5zdGFydHNXaXRoKCIvIil8fCF0KXJldHVybiBlO2xldHtwYXRobmFtZTpyLHF1ZXJ5OmEsaGFzaDpvfT0oMCxuLnBhcnNlUGF0aCkoZSk7cmV0dXJuIiIrcit0K2Erb319LDc1ODQ6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gdClPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLHtlbnVtZXJhYmxlOiEwLGdldDp0W3JdfSl9KHQse25vcm1hbGl6ZUFwcFBhdGg6ZnVuY3Rpb24oKXtyZXR1cm4gYX0sbm9ybWFsaXplUnNjUGF0aDpmdW5jdGlvbigpe3JldHVybiBvfX0pO2xldCBuPXIoNDE1Nyk7ZnVuY3Rpb24gYShlKXtyZXR1cm4oMCxuLmVuc3VyZUxlYWRpbmdTbGFzaCkoZS5zcGxpdCgiLyIpLnJlZHVjZSgoZSx0LHIsbik9PiF0fHwiKCI9PT10WzBdJiZ0LmVuZHNXaXRoKCIpIil8fCJAIj09PXRbMF18fCgicGFnZSI9PT10fHwicm91dGUiPT09dCkmJnI9PT1uLmxlbmd0aC0xP2U6ZSsiLyIrdCwiIikpfWZ1bmN0aW9uIG8oZSx0KXtyZXR1cm4gdD9lLnJlcGxhY2UoL1wucnNjKCR8XD8pLywiJDEiKTplfX0sOTI0NTpmdW5jdGlvbihlLHQpeyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiByKGUsdCl7bGV0IHI9T2JqZWN0LmtleXMoZSk7aWYoci5sZW5ndGghPT1PYmplY3Qua2V5cyh0KS5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBuPXIubGVuZ3RoO24tLTspe2xldCBhPXJbbl07aWYoInF1ZXJ5Ij09PWEpe2xldCByPU9iamVjdC5rZXlzKGUucXVlcnkpO2lmKHIubGVuZ3RoIT09T2JqZWN0LmtleXModC5xdWVyeSkubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgbj1yLmxlbmd0aDtuLS07KXtsZXQgYT1yW25dO2lmKCF0LnF1ZXJ5Lmhhc093blByb3BlcnR5KGEpfHxlLnF1ZXJ5W2FdIT09dC5xdWVyeVthXSlyZXR1cm4hMX19ZWxzZSBpZighdC5oYXNPd25Qcm9wZXJ0eShhKXx8ZVthXSE9PXRbYV0pcmV0dXJuITF9cmV0dXJuITB9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJjb21wYXJlUm91dGVyU3RhdGVzIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcn19KX0sMTcwMzpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGx9fSk7bGV0IG49cig1MTI5KSxhPXIoMTQ4NCksbz1yKDQ5MTgpLGk9cigxOTY4KTtmdW5jdGlvbiBsKGUpe2xldCB0PSgwLGkuYWRkTG9jYWxlKShlLnBhdGhuYW1lLGUubG9jYWxlLGUuYnVpbGRJZD92b2lkIDA6ZS5kZWZhdWx0TG9jYWxlLGUuaWdub3JlUHJlZml4KTtyZXR1cm4oZS5idWlsZElkfHwhZS50cmFpbGluZ1NsYXNoKSYmKHQ9KDAsbi5yZW1vdmVUcmFpbGluZ1NsYXNoKSh0KSksZS5idWlsZElkJiYodD0oMCxvLmFkZFBhdGhTdWZmaXgpKCgwLGEuYWRkUGF0aFByZWZpeCkodCwiL19uZXh0L2RhdGEvIitlLmJ1aWxkSWQpLCIvIj09PWUucGF0aG5hbWU/ImluZGV4Lmpzb24iOiIuanNvbiIpKSx0PSgwLGEuYWRkUGF0aFByZWZpeCkodCxlLmJhc2VQYXRoKSwhZS5idWlsZElkJiZlLnRyYWlsaW5nU2xhc2g/dC5lbmRzV2l0aCgiLyIpP3Q6KDAsby5hZGRQYXRoU3VmZml4KSh0LCIvIik6KDAsbi5yZW1vdmVUcmFpbGluZ1NsYXNoKSh0KX19LDI5MDI6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gdClPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLHtlbnVtZXJhYmxlOiEwLGdldDp0W3JdfSl9KHQse2Zvcm1hdFVybDpmdW5jdGlvbigpe3JldHVybiBpfSx1cmxPYmplY3RLZXlzOmZ1bmN0aW9uKCl7cmV0dXJuIGx9LGZvcm1hdFdpdGhWYWxpZGF0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHV9fSk7bGV0IG49cigxNzU3KSxhPW4uXyhyKDEzNTQpKSxvPS9odHRwcz98ZnRwfGdvcGhlcnxmaWxlLztmdW5jdGlvbiBpKGUpe2xldHthdXRoOnQsaG9zdG5hbWU6cn09ZSxuPWUucHJvdG9jb2x8fCIiLGk9ZS5wYXRobmFtZXx8IiIsbD1lLmhhc2h8fCIiLHU9ZS5xdWVyeXx8IiIscz0hMTt0PXQ/ZW5jb2RlVVJJQ29tcG9uZW50KHQpLnJlcGxhY2UoLyUzQS9pLCI6IikrIkAiOiIiLGUuaG9zdD9zPXQrZS5ob3N0OnImJihzPXQrKH5yLmluZGV4T2YoIjoiKT8iWyIrcisiXSI6ciksZS5wb3J0JiYocys9IjoiK2UucG9ydCkpLHUmJiJvYmplY3QiPT10eXBlb2YgdSYmKHU9U3RyaW5nKGEudXJsUXVlcnlUb1NlYXJjaFBhcmFtcyh1KSkpO2xldCBjPWUuc2VhcmNofHx1JiYiPyIrdXx8IiI7cmV0dXJuIG4mJiFuLmVuZHNXaXRoKCI6IikmJihuKz0iOiIpLGUuc2xhc2hlc3x8KCFufHxvLnRlc3QobikpJiYhMSE9PXM/KHM9Ii8vIisoc3x8IiIpLGkmJiIvIiE9PWlbMF0mJihpPSIvIitpKSk6c3x8KHM9IiIpLGwmJiIjIiE9PWxbMF0mJihsPSIjIitsKSxjJiYiPyIhPT1jWzBdJiYoYz0iPyIrYyksIiIrbitzKyhpPWkucmVwbGFjZSgvWz8jXS9nLGVuY29kZVVSSUNvbXBvbmVudCkpKyhjPWMucmVwbGFjZSgiIyIsIiUyMyIpKStsfWxldCBsPVsiYXV0aCIsImhhc2giLCJob3N0IiwiaG9zdG5hbWUiLCJocmVmIiwicGF0aCIsInBhdGhuYW1lIiwicG9ydCIsInByb3RvY29sIiwicXVlcnkiLCJzZWFyY2giLCJzbGFzaGVzIl07ZnVuY3Rpb24gdShlKXtyZXR1cm4gaShlKX19LDU4NTQ6ZnVuY3Rpb24oZSx0KXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcihlLHQpe3ZvaWQgMD09PXQmJih0PSIiKTtsZXQgcj0iLyI9PT1lPyIvaW5kZXgiOi9eXC9pbmRleChcL3wkKS8udGVzdChlKT8iL2luZGV4IitlOiIiK2U7cmV0dXJuIHIrdH1PYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImRlZmF1bHQiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiByfX0pfSw1NTY0OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJnZXROZXh0UGF0aG5hbWVJbmZvIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaX19KTtsZXQgbj1yKDQ5OTApLGE9cig4NTkwKSxvPXIoOTYyMyk7ZnVuY3Rpb24gaShlLHQpe3ZhciByLGksbDtsZXR7YmFzZVBhdGg6dSxpMThuOnMsdHJhaWxpbmdTbGFzaDpjfT1udWxsIT0ocj10Lm5leHRDb25maWcpP3I6e30sZj17cGF0aG5hbWU6ZSx0cmFpbGluZ1NsYXNoOiIvIiE9PWU/ZS5lbmRzV2l0aCgiLyIpOmN9O2lmKHUmJigwLG8ucGF0aEhhc1ByZWZpeCkoZi5wYXRobmFtZSx1KSYmKGYucGF0aG5hbWU9KDAsYS5yZW1vdmVQYXRoUHJlZml4KShmLnBhdGhuYW1lLHUpLGYuYmFzZVBhdGg9dSksITA9PT10LnBhcnNlRGF0YSYmZi5wYXRobmFtZS5zdGFydHNXaXRoKCIvX25leHQvZGF0YS8iKSYmZi5wYXRobmFtZS5lbmRzV2l0aCgiLmpzb24iKSl7bGV0IGU9Zi5wYXRobmFtZS5yZXBsYWNlKC9eXC9fbmV4dFwvZGF0YVwvLywiIikucmVwbGFjZSgvXC5qc29uJC8sIiIpLnNwbGl0KCIvIiksdD1lWzBdO2YucGF0aG5hbWU9ImluZGV4IiE9PWVbMV0/Ii8iK2Uuc2xpY2UoMSkuam9pbigiLyIpOiIvIixmLmJ1aWxkSWQ9dH1pZih0LmkxOG5Qcm92aWRlcil7bGV0IGU9dC5pMThuUHJvdmlkZXIuYW5hbHl6ZShmLnBhdGhuYW1lKTtmLmxvY2FsZT1lLmRldGVjdGVkTG9jYWxlLGYucGF0aG5hbWU9bnVsbCE9KGk9ZS5wYXRobmFtZSk/aTpmLnBhdGhuYW1lfWVsc2UgaWYocyl7bGV0IGU9KDAsbi5ub3JtYWxpemVMb2NhbGVQYXRoKShmLnBhdGhuYW1lLHMubG9jYWxlcyk7Zi5sb2NhbGU9ZS5kZXRlY3RlZExvY2FsZSxmLnBhdGhuYW1lPW51bGwhPShsPWUucGF0aG5hbWUpP2w6Zi5wYXRobmFtZX1yZXR1cm4gZn19LDEyNTc6ZnVuY3Rpb24oZSx0KXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcihlLHQpe3ZvaWQgMD09PXQmJih0PXt9KTtsZXQgcj1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsbj1yLnN0eWxlLnNjcm9sbEJlaGF2aW9yO3Iuc3R5bGUuc2Nyb2xsQmVoYXZpb3I9ImF1dG8iLHQuZG9udEZvcmNlTGF5b3V0fHxyLmdldENsaWVudFJlY3RzKCksZSgpLHIuc3R5bGUuc2Nyb2xsQmVoYXZpb3I9bn1PYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImhhbmRsZVNtb290aFNjcm9sbCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHJ9fSl9LDk0NDY6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gdClPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLHtlbnVtZXJhYmxlOiEwLGdldDp0W3JdfSl9KHQse2dldFNvcnRlZFJvdXRlczpmdW5jdGlvbigpe3JldHVybiBuLmdldFNvcnRlZFJvdXRlc30saXNEeW5hbWljUm91dGU6ZnVuY3Rpb24oKXtyZXR1cm4gYS5pc0R5bmFtaWNSb3V0ZX19KTtsZXQgbj1yKDkyNDEpLGE9cigzNzAyKX0sMTY5MDpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiaW50ZXJwb2xhdGVBcyIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG99fSk7bGV0IG49cigzNjYwKSxhPXIoMjkzMik7ZnVuY3Rpb24gbyhlLHQscil7bGV0IG89IiIsaT0oMCxhLmdldFJvdXRlUmVnZXgpKGUpLGw9aS5ncm91cHMsdT0odCE9PWU/KDAsbi5nZXRSb3V0ZU1hdGNoZXIpKGkpKHQpOiIiKXx8cjtvPWU7bGV0IHM9T2JqZWN0LmtleXMobCk7cmV0dXJuIHMuZXZlcnkoZT0+e2xldCB0PXVbZV18fCIiLHtyZXBlYXQ6cixvcHRpb25hbDpufT1sW2VdLGE9IlsiKyhyPyIuLi4iOiIiKStlKyJdIjtyZXR1cm4gbiYmKGE9KHQ/IiI6Ii8iKSsiWyIrYSsiXSIpLHImJiFBcnJheS5pc0FycmF5KHQpJiYodD1bdF0pLChufHxlIGluIHUpJiYobz1vLnJlcGxhY2UoYSxyP3QubWFwKGU9PmVuY29kZVVSSUNvbXBvbmVudChlKSkuam9pbigiLyIpOmVuY29kZVVSSUNvbXBvbmVudCh0KSl8fCIvIil9KXx8KG89IiIpLHtwYXJhbXM6cyxyZXN1bHQ6b319fSwyMzg6ZnVuY3Rpb24oZSx0KXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4vR29vZ2xlYm90fE1lZGlhcGFydG5lcnMtR29vZ2xlfEFkc0JvdC1Hb29nbGV8Z29vZ2xld2VibGlnaHR8U3RvcmVib3QtR29vZ2xlfEdvb2dsZS1QYWdlUmVuZGVyZXJ8QmluZ2JvdHxCaW5nUHJldmlld3xTbHVycHxEdWNrRHVja0JvdHxiYWlkdXNwaWRlcnx5YW5kZXh8c29nb3V8TGlua2VkSW5Cb3R8Yml0bHlib3R8dHVtYmxyfHZrU2hhcmV8cXVvcmEgbGluayBwcmV2aWV3fGZhY2Vib29rZXh0ZXJuYWxoaXR8ZmFjZWJvb2tjYXRhbG9nfFR3aXR0ZXJib3R8YXBwbGVib3R8cmVkZGl0Ym90fFNsYWNrYm90fERpc2NvcmRib3R8V2hhdHNBcHB8U2t5cGVVcmlQcmV2aWV3fGlhX2FyY2hpdmVyL2kudGVzdChlKX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImlzQm90Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcn19KX0sMzcwMjpmdW5jdGlvbihlLHQpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImlzRHluYW1pY1JvdXRlIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbn19KTtsZXQgcj0vXC9cW1teL10rP1xdKD89XC98JCkvO2Z1bmN0aW9uIG4oZSl7cmV0dXJuIHIudGVzdChlKX19LDI5Njg6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImlzTG9jYWxVUkwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBvfX0pO2xldCBuPXIoNzMyMSksYT1yKDExNzMpO2Z1bmN0aW9uIG8oZSl7aWYoISgwLG4uaXNBYnNvbHV0ZVVybCkoZSkpcmV0dXJuITA7dHJ5e2xldCB0PSgwLG4uZ2V0TG9jYXRpb25PcmlnaW4pKCkscj1uZXcgVVJMKGUsdCk7cmV0dXJuIHIub3JpZ2luPT09dCYmKDAsYS5oYXNCYXNlUGF0aCkoci5wYXRobmFtZSl9Y2F0Y2goZSl7cmV0dXJuITF9fX0sODQ0NzpmdW5jdGlvbihlLHQpeyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiByKGUsdCl7bGV0IHI9e307cmV0dXJuIE9iamVjdC5rZXlzKGUpLmZvckVhY2gobj0+e3QuaW5jbHVkZXMobil8fChyW25dPWVbbl0pfSkscn1PYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIm9taXQiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiByfX0pfSw3NjM3OmZ1bmN0aW9uKGUsdCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHIoZSl7bGV0IHQ9ZS5pbmRleE9mKCIjIikscj1lLmluZGV4T2YoIj8iKSxuPXI+LTEmJih0PDB8fHI8dCk7cmV0dXJuIG58fHQ+LTE/e3BhdGhuYW1lOmUuc3Vic3RyaW5nKDAsbj9yOnQpLHF1ZXJ5Om4/ZS5zdWJzdHJpbmcocix0Pi0xP3Q6dm9pZCAwKToiIixoYXNoOnQ+LTE/ZS5zbGljZSh0KToiIn06e3BhdGhuYW1lOmUscXVlcnk6IiIsaGFzaDoiIn19T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJwYXJzZVBhdGgiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiByfX0pfSwxMzc6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsInBhcnNlUmVsYXRpdmVVcmwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBvfX0pO2xldCBuPXIoNzMyMSksYT1yKDEzNTQpO2Z1bmN0aW9uIG8oZSx0KXtsZXQgcj1uZXcgVVJMKCgwLG4uZ2V0TG9jYXRpb25PcmlnaW4pKCkpLG89dD9uZXcgVVJMKHQscik6ZS5zdGFydHNXaXRoKCIuIik/bmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik6cix7cGF0aG5hbWU6aSxzZWFyY2hQYXJhbXM6bCxzZWFyY2g6dSxoYXNoOnMsaHJlZjpjLG9yaWdpbjpmfT1uZXcgVVJMKGUsbyk7aWYoZiE9PXIub3JpZ2luKXRocm93IEVycm9yKCJpbnZhcmlhbnQ6IGludmFsaWQgcmVsYXRpdmUgVVJMLCByb3V0ZXIgcmVjZWl2ZWQgIitlKTtyZXR1cm57cGF0aG5hbWU6aSxxdWVyeTooMCxhLnNlYXJjaFBhcmFtc1RvVXJsUXVlcnkpKGwpLHNlYXJjaDp1LGhhc2g6cyxocmVmOmMuc2xpY2Uoci5vcmlnaW4ubGVuZ3RoKX19fSw5NjIzOmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJwYXRoSGFzUHJlZml4Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYX19KTtsZXQgbj1yKDc2MzcpO2Z1bmN0aW9uIGEoZSx0KXtpZigic3RyaW5nIiE9dHlwZW9mIGUpcmV0dXJuITE7bGV0e3BhdGhuYW1lOnJ9PSgwLG4ucGFyc2VQYXRoKShlKTtyZXR1cm4gcj09PXR8fHIuc3RhcnRzV2l0aCh0KyIvIil9fSwxMzU0OmZ1bmN0aW9uKGUsdCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHIoZSl7bGV0IHQ9e307cmV0dXJuIGUuZm9yRWFjaCgoZSxyKT0+e3ZvaWQgMD09PXRbcl0/dFtyXT1lOkFycmF5LmlzQXJyYXkodFtyXSk/dFtyXS5wdXNoKGUpOnRbcl09W3Rbcl0sZV19KSx0fWZ1bmN0aW9uIG4oZSl7cmV0dXJuInN0cmluZyIhPXR5cGVvZiBlJiYoIm51bWJlciIhPXR5cGVvZiBlfHxpc05hTihlKSkmJiJib29sZWFuIiE9dHlwZW9mIGU/IiI6U3RyaW5nKGUpfWZ1bmN0aW9uIGEoZSl7bGV0IHQ9bmV3IFVSTFNlYXJjaFBhcmFtcztyZXR1cm4gT2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaChlPT57bGV0W3IsYV09ZTtBcnJheS5pc0FycmF5KGEpP2EuZm9yRWFjaChlPT50LmFwcGVuZChyLG4oZSkpKTp0LnNldChyLG4oYSkpfSksdH1mdW5jdGlvbiBvKGUpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLHI9QXJyYXkodD4xP3QtMTowKSxuPTE7bjx0O24rKylyW24tMV09YXJndW1lbnRzW25dO3JldHVybiByLmZvckVhY2godD0+e0FycmF5LmZyb20odC5rZXlzKCkpLmZvckVhY2godD0+ZS5kZWxldGUodCkpLHQuZm9yRWFjaCgodCxyKT0+ZS5hcHBlbmQocix0KSl9KSxlfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ITAsZ2V0OnRbcl19KX0odCx7c2VhcmNoUGFyYW1zVG9VcmxRdWVyeTpmdW5jdGlvbigpe3JldHVybiByfSx1cmxRdWVyeVRvU2VhcmNoUGFyYW1zOmZ1bmN0aW9uKCl7cmV0dXJuIGF9LGFzc2lnbjpmdW5jdGlvbigpe3JldHVybiBvfX0pfSw4NTkwOmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJyZW1vdmVQYXRoUHJlZml4Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYX19KTtsZXQgbj1yKDk2MjMpO2Z1bmN0aW9uIGEoZSx0KXtpZighKDAsbi5wYXRoSGFzUHJlZml4KShlLHQpKXJldHVybiBlO2xldCByPWUuc2xpY2UodC5sZW5ndGgpO3JldHVybiByLnN0YXJ0c1dpdGgoIi8iKT9yOiIvIityfX0sNTEyOTpmdW5jdGlvbihlLHQpeyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiByKGUpe3JldHVybiBlLnJlcGxhY2UoL1wvJC8sIiIpfHwiLyJ9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJyZW1vdmVUcmFpbGluZ1NsYXNoIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcn19KX0sMjg2MjpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwicmVzb2x2ZUhyZWYiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBmfX0pO2xldCBuPXIoMTM1NCksYT1yKDI5MDIpLG89cig4NDQ3KSxpPXIoNzMyMSksbD1yKDM3ODUpLHU9cigyOTY4KSxzPXIoMzcwMiksYz1yKDE2OTApO2Z1bmN0aW9uIGYoZSx0LHIpe2xldCBmO2xldCBkPSJzdHJpbmciPT10eXBlb2YgdD90OigwLGEuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHQpLGg9ZC5tYXRjaCgvXlthLXpBLVpdezEsfTpcL1wvLykscD1oP2Quc2xpY2UoaFswXS5sZW5ndGgpOmQ7aWYoKHAuc3BsaXQoIj8iKVswXXx8IiIpLm1hdGNoKC8oXC9cL3xcXCkvKSl7Y29uc29sZS5lcnJvcigiSW52YWxpZCBocmVmICciK2QrIicgcGFzc2VkIHRvIG5leHQvcm91dGVyIGluIHBhZ2U6ICciK2UucGF0aG5hbWUrIicuIFJlcGVhdGVkIGZvcndhcmQtc2xhc2hlcyAoLy8pIG9yIGJhY2tzbGFzaGVzIFxcIGFyZSBub3QgdmFsaWQgaW4gdGhlIGhyZWYuIik7bGV0IHQ9KDAsaS5ub3JtYWxpemVSZXBlYXRlZFNsYXNoZXMpKHApO2Q9KGg/aFswXToiIikrdH1pZighKDAsdS5pc0xvY2FsVVJMKShkKSlyZXR1cm4gcj9bZF06ZDt0cnl7Zj1uZXcgVVJMKGQuc3RhcnRzV2l0aCgiIyIpP2UuYXNQYXRoOmUucGF0aG5hbWUsImh0dHA6Ly9uIil9Y2F0Y2goZSl7Zj1uZXcgVVJMKCIvIiwiaHR0cDovL24iKX10cnl7bGV0IGU9bmV3IFVSTChkLGYpO2UucGF0aG5hbWU9KDAsbC5ub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCkoZS5wYXRobmFtZSk7bGV0IHQ9IiI7aWYoKDAscy5pc0R5bmFtaWNSb3V0ZSkoZS5wYXRobmFtZSkmJmUuc2VhcmNoUGFyYW1zJiZyKXtsZXQgcj0oMCxuLnNlYXJjaFBhcmFtc1RvVXJsUXVlcnkpKGUuc2VhcmNoUGFyYW1zKSx7cmVzdWx0OmkscGFyYW1zOmx9PSgwLGMuaW50ZXJwb2xhdGVBcykoZS5wYXRobmFtZSxlLnBhdGhuYW1lLHIpO2kmJih0PSgwLGEuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtwYXRobmFtZTppLGhhc2g6ZS5oYXNoLHF1ZXJ5OigwLG8ub21pdCkocixsKX0pKX1sZXQgaT1lLm9yaWdpbj09PWYub3JpZ2luP2UuaHJlZi5zbGljZShlLm9yaWdpbi5sZW5ndGgpOmUuaHJlZjtyZXR1cm4gcj9baSx0fHxpXTppfWNhdGNoKGUpe3JldHVybiByP1tkXTpkfX19LDM2NjA6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImdldFJvdXRlTWF0Y2hlciIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGF9fSk7bGV0IG49cig3MzIxKTtmdW5jdGlvbiBhKGUpe2xldHtyZTp0LGdyb3VwczpyfT1lO3JldHVybiBlPT57bGV0IGE9dC5leGVjKGUpO2lmKCFhKXJldHVybiExO2xldCBvPWU9Pnt0cnl7cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlKX1jYXRjaChlKXt0aHJvdyBuZXcgbi5EZWNvZGVFcnJvcigiZmFpbGVkIHRvIGRlY29kZSBwYXJhbSIpfX0saT17fTtyZXR1cm4gT2JqZWN0LmtleXMocikuZm9yRWFjaChlPT57bGV0IHQ9cltlXSxuPWFbdC5wb3NdO3ZvaWQgMCE9PW4mJihpW2VdPX5uLmluZGV4T2YoIi8iKT9uLnNwbGl0KCIvIikubWFwKGU9Pm8oZSkpOnQucmVwZWF0P1tvKG4pXTpvKG4pKX0pLGl9fX0sMjkzMjpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ITAsZ2V0OnRbcl19KX0odCx7Z2V0Um91dGVSZWdleDpmdW5jdGlvbigpe3JldHVybiB1fSxnZXROYW1lZFJvdXRlUmVnZXg6ZnVuY3Rpb24oKXtyZXR1cm4gZn0sZ2V0TmFtZWRNaWRkbGV3YXJlUmVnZXg6ZnVuY3Rpb24oKXtyZXR1cm4gZH19KTtsZXQgbj1yKDI0MDcpLGE9cig5NDM0KSxvPXIoNTEyOSk7ZnVuY3Rpb24gaShlKXtsZXQgdD1lLnN0YXJ0c1dpdGgoIlsiKSYmZS5lbmRzV2l0aCgiXSIpO3QmJihlPWUuc2xpY2UoMSwtMSkpO2xldCByPWUuc3RhcnRzV2l0aCgiLi4uIik7cmV0dXJuIHImJihlPWUuc2xpY2UoMykpLHtrZXk6ZSxyZXBlYXQ6cixvcHRpb25hbDp0fX1mdW5jdGlvbiBsKGUpe2xldCB0PSgwLG8ucmVtb3ZlVHJhaWxpbmdTbGFzaCkoZSkuc2xpY2UoMSkuc3BsaXQoIi8iKSxyPXt9LGw9MTtyZXR1cm57cGFyYW1ldGVyaXplZFJvdXRlOnQubWFwKGU9PntsZXQgdD1uLklOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTLmZpbmQodD0+ZS5zdGFydHNXaXRoKHQpKSxvPWUubWF0Y2goL1xbKCg/OlxbLipcXSl8LispXF0vKTtpZih0JiZvKXtsZXR7a2V5OmUsb3B0aW9uYWw6bixyZXBlYXQ6dX09aShvWzFdKTtyZXR1cm4gcltlXT17cG9zOmwrKyxyZXBlYXQ6dSxvcHRpb25hbDpufSwiLyIrKDAsYS5lc2NhcGVTdHJpbmdSZWdleHApKHQpKyIoW14vXSs/KSJ9aWYoIW8pcmV0dXJuIi8iKygwLGEuZXNjYXBlU3RyaW5nUmVnZXhwKShlKTt7bGV0e2tleTplLHJlcGVhdDp0LG9wdGlvbmFsOm59PWkob1sxXSk7cmV0dXJuIHJbZV09e3BvczpsKysscmVwZWF0OnQsb3B0aW9uYWw6bn0sdD9uPyIoPzovKC4rPykpPyI6Ii8oLis/KSI6Ii8oW14vXSs/KSJ9fSkuam9pbigiIiksZ3JvdXBzOnJ9fWZ1bmN0aW9uIHUoZSl7bGV0e3BhcmFtZXRlcml6ZWRSb3V0ZTp0LGdyb3VwczpyfT1sKGUpO3JldHVybntyZTpSZWdFeHAoIl4iK3QrIig/Oi8pPyQiKSxncm91cHM6cn19ZnVuY3Rpb24gcyhlKXtsZXQgdCxyLHtzZWdtZW50Om4scm91dGVLZXlzOmEsa2V5UHJlZml4Om99PWUsbD0odD05NyxyPTEsKCk9PntsZXQgZT0iIjtmb3IobGV0IG49MDtuPHI7bisrKWUrPVN0cmluZy5mcm9tQ2hhckNvZGUodCksKyt0PjEyMiYmKHIrKyx0PTk3KTtyZXR1cm4gZX0pLHtrZXk6dSxvcHRpb25hbDpzLHJlcGVhdDpjfT1pKG4pLGY9dS5yZXBsYWNlKC9cVy9nLCIiKTtvJiYoZj0iIitvK2YpO2xldCBkPSExO3JldHVybigwPT09Zi5sZW5ndGh8fGYubGVuZ3RoPjMwKSYmKGQ9ITApLGlzTmFOKHBhcnNlSW50KGYuc2xpY2UoMCwxKSkpfHwoZD0hMCksZCYmKGY9bCgpKSxvP2FbZl09IiIrbyt1OmFbZl09IiIrdSxjP3M/Iig/Oi8oPzwiK2YrIj4uKz8pKT8iOiIvKD88IitmKyI+Lis/KSI6Ii8oPzwiK2YrIj5bXi9dKz8pIn1mdW5jdGlvbiBjKGUsdCl7bGV0IHI9KDAsby5yZW1vdmVUcmFpbGluZ1NsYXNoKShlKS5zbGljZSgxKS5zcGxpdCgiLyIpLGk9e307cmV0dXJue25hbWVkUGFyYW1ldGVyaXplZFJvdXRlOnIubWFwKGU9PntsZXQgcj1uLklOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTLnNvbWUodD0+ZS5zdGFydHNXaXRoKHQpKSxvPWUubWF0Y2goL1xbKCg/OlxbLipcXSl8LispXF0vKTtyZXR1cm4gciYmbz9zKHtzZWdtZW50Om9bMV0scm91dGVLZXlzOmksa2V5UHJlZml4OnQ/Im54dEkiOnZvaWQgMH0pOm8/cyh7c2VnbWVudDpvWzFdLHJvdXRlS2V5czppLGtleVByZWZpeDp0PyJueHRQIjp2b2lkIDB9KToiLyIrKDAsYS5lc2NhcGVTdHJpbmdSZWdleHApKGUpfSkuam9pbigiIikscm91dGVLZXlzOml9fWZ1bmN0aW9uIGYoZSx0KXtsZXQgcj1jKGUsdCk7cmV0dXJuey4uLnUoZSksbmFtZWRSZWdleDoiXiIrci5uYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSsiKD86Lyk/JCIscm91dGVLZXlzOnIucm91dGVLZXlzfX1mdW5jdGlvbiBkKGUsdCl7bGV0e3BhcmFtZXRlcml6ZWRSb3V0ZTpyfT1sKGUpLHtjYXRjaEFsbDpuPSEwfT10O2lmKCIvIj09PXIpcmV0dXJue25hbWVkUmVnZXg6Il4vIisobj8iLioiOiIiKSsiJCJ9O2xldHtuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZTphfT1jKGUsITEpO3JldHVybntuYW1lZFJlZ2V4OiJeIithKyhuPyIoPzooLy4qKT8pIjoiIikrIiQifX19LDkyNDE6ZnVuY3Rpb24oZSx0KXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJnZXRTb3J0ZWRSb3V0ZXMiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBufX0pO2NsYXNzIHJ7aW5zZXJ0KGUpe3RoaXMuX2luc2VydChlLnNwbGl0KCIvIikuZmlsdGVyKEJvb2xlYW4pLFtdLCExKX1zbW9vc2goKXtyZXR1cm4gdGhpcy5fc21vb3NoKCl9X3Ntb29zaChlKXt2b2lkIDA9PT1lJiYoZT0iLyIpO2xldCB0PVsuLi50aGlzLmNoaWxkcmVuLmtleXMoKV0uc29ydCgpO251bGwhPT10aGlzLnNsdWdOYW1lJiZ0LnNwbGljZSh0LmluZGV4T2YoIltdIiksMSksbnVsbCE9PXRoaXMucmVzdFNsdWdOYW1lJiZ0LnNwbGljZSh0LmluZGV4T2YoIlsuLi5dIiksMSksbnVsbCE9PXRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUmJnQuc3BsaWNlKHQuaW5kZXhPZigiW1suLi5dXSIpLDEpO2xldCByPXQubWFwKHQ9PnRoaXMuY2hpbGRyZW4uZ2V0KHQpLl9zbW9vc2goIiIrZSt0KyIvIikpLnJlZHVjZSgoZSx0KT0+Wy4uLmUsLi4udF0sW10pO2lmKG51bGwhPT10aGlzLnNsdWdOYW1lJiZyLnB1c2goLi4udGhpcy5jaGlsZHJlbi5nZXQoIltdIikuX3Ntb29zaChlKyJbIit0aGlzLnNsdWdOYW1lKyJdLyIpKSwhdGhpcy5wbGFjZWhvbGRlcil7bGV0IHQ9Ii8iPT09ZT8iLyI6ZS5zbGljZSgwLC0xKTtpZihudWxsIT10aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lKXRocm93IEVycm9yKCdZb3UgY2Fubm90IGRlZmluZSBhIHJvdXRlIHdpdGggdGhlIHNhbWUgc3BlY2lmaWNpdHkgYXMgYSBvcHRpb25hbCBjYXRjaC1hbGwgcm91dGUgKCInK3QrJyIgYW5kICInK3QrIltbLi4uIit0aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lKyddXSIpLicpO3IudW5zaGlmdCh0KX1yZXR1cm4gbnVsbCE9PXRoaXMucmVzdFNsdWdOYW1lJiZyLnB1c2goLi4udGhpcy5jaGlsZHJlbi5nZXQoIlsuLi5dIikuX3Ntb29zaChlKyJbLi4uIit0aGlzLnJlc3RTbHVnTmFtZSsiXS8iKSksbnVsbCE9PXRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUmJnIucHVzaCguLi50aGlzLmNoaWxkcmVuLmdldCgiW1suLi5dXSIpLl9zbW9vc2goZSsiW1suLi4iK3RoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUrIl1dLyIpKSxyfV9pbnNlcnQoZSx0LG4pe2lmKDA9PT1lLmxlbmd0aCl7dGhpcy5wbGFjZWhvbGRlcj0hMTtyZXR1cm59aWYobil0aHJvdyBFcnJvcigiQ2F0Y2gtYWxsIG11c3QgYmUgdGhlIGxhc3QgcGFydCBvZiB0aGUgVVJMLiIpO2xldCBhPWVbMF07aWYoYS5zdGFydHNXaXRoKCJbIikmJmEuZW5kc1dpdGgoIl0iKSl7bGV0IHI9YS5zbGljZSgxLC0xKSxpPSExO2lmKHIuc3RhcnRzV2l0aCgiWyIpJiZyLmVuZHNXaXRoKCJdIikmJihyPXIuc2xpY2UoMSwtMSksaT0hMCksci5zdGFydHNXaXRoKCIuLi4iKSYmKHI9ci5zdWJzdHJpbmcoMyksbj0hMCksci5zdGFydHNXaXRoKCJbIil8fHIuZW5kc1dpdGgoIl0iKSl0aHJvdyBFcnJvcigiU2VnbWVudCBuYW1lcyBtYXkgbm90IHN0YXJ0IG9yIGVuZCB3aXRoIGV4dHJhIGJyYWNrZXRzICgnIityKyInKS4iKTtpZihyLnN0YXJ0c1dpdGgoIi4iKSl0aHJvdyBFcnJvcigiU2VnbWVudCBuYW1lcyBtYXkgbm90IHN0YXJ0IHdpdGggZXJyb25lb3VzIHBlcmlvZHMgKCciK3IrIicpLiIpO2Z1bmN0aW9uIG8oZSxyKXtpZihudWxsIT09ZSYmZSE9PXIpdGhyb3cgRXJyb3IoIllvdSBjYW5ub3QgdXNlIGRpZmZlcmVudCBzbHVnIG5hbWVzIGZvciB0aGUgc2FtZSBkeW5hbWljIHBhdGggKCciK2UrIicgIT09ICciK3IrIicpLiIpO3QuZm9yRWFjaChlPT57aWYoZT09PXIpdGhyb3cgRXJyb3IoJ1lvdSBjYW5ub3QgaGF2ZSB0aGUgc2FtZSBzbHVnIG5hbWUgIicrcisnIiByZXBlYXQgd2l0aGluIGEgc2luZ2xlIGR5bmFtaWMgcGF0aCcpO2lmKGUucmVwbGFjZSgvXFcvZywiIik9PT1hLnJlcGxhY2UoL1xXL2csIiIpKXRocm93IEVycm9yKCdZb3UgY2Fubm90IGhhdmUgdGhlIHNsdWcgbmFtZXMgIicrZSsnIiBhbmQgIicrcisnIiBkaWZmZXIgb25seSBieSBub24td29yZCBzeW1ib2xzIHdpdGhpbiBhIHNpbmdsZSBkeW5hbWljIHBhdGgnKX0pLHQucHVzaChyKX1pZihuKXtpZihpKXtpZihudWxsIT10aGlzLnJlc3RTbHVnTmFtZSl0aHJvdyBFcnJvcignWW91IGNhbm5vdCB1c2UgYm90aCBhbiByZXF1aXJlZCBhbmQgb3B0aW9uYWwgY2F0Y2gtYWxsIHJvdXRlIGF0IHRoZSBzYW1lIGxldmVsICgiWy4uLicrdGhpcy5yZXN0U2x1Z05hbWUrJ10iIGFuZCAiJytlWzBdKyciICkuJyk7byh0aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lLHIpLHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWU9cixhPSJbWy4uLl1dIn1lbHNle2lmKG51bGwhPXRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUpdGhyb3cgRXJyb3IoJ1lvdSBjYW5ub3QgdXNlIGJvdGggYW4gb3B0aW9uYWwgYW5kIHJlcXVpcmVkIGNhdGNoLWFsbCByb3V0ZSBhdCB0aGUgc2FtZSBsZXZlbCAoIltbLi4uJyt0aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lKyddXSIgYW5kICInK2VbMF0rJyIpLicpO28odGhpcy5yZXN0U2x1Z05hbWUsciksdGhpcy5yZXN0U2x1Z05hbWU9cixhPSJbLi4uXSJ9fWVsc2V7aWYoaSl0aHJvdyBFcnJvcignT3B0aW9uYWwgcm91dGUgcGFyYW1ldGVycyBhcmUgbm90IHlldCBzdXBwb3J0ZWQgKCInK2VbMF0rJyIpLicpO28odGhpcy5zbHVnTmFtZSxyKSx0aGlzLnNsdWdOYW1lPXIsYT0iW10ifX10aGlzLmNoaWxkcmVuLmhhcyhhKXx8dGhpcy5jaGlsZHJlbi5zZXQoYSxuZXcgciksdGhpcy5jaGlsZHJlbi5nZXQoYSkuX2luc2VydChlLnNsaWNlKDEpLHQsbil9Y29uc3RydWN0b3IoKXt0aGlzLnBsYWNlaG9sZGVyPSEwLHRoaXMuY2hpbGRyZW49bmV3IE1hcCx0aGlzLnNsdWdOYW1lPW51bGwsdGhpcy5yZXN0U2x1Z05hbWU9bnVsbCx0aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lPW51bGx9fWZ1bmN0aW9uIG4oZSl7bGV0IHQ9bmV3IHI7cmV0dXJuIGUuZm9yRWFjaChlPT50Lmluc2VydChlKSksdC5zbW9vc2goKX19LDE4NTg6ZnVuY3Rpb24oZSx0KXsidXNlIHN0cmljdCI7bGV0IHI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIHQpT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscix7ZW51bWVyYWJsZTohMCxnZXQ6dFtyXX0pfSh0LHtkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJuIG59LHNldENvbmZpZzpmdW5jdGlvbigpe3JldHVybiBhfX0pO2xldCBuPSgpPT5yO2Z1bmN0aW9uIGEoZSl7cj1lfSgiZnVuY3Rpb24iPT10eXBlb2YgdC5kZWZhdWx0fHwib2JqZWN0Ij09dHlwZW9mIHQuZGVmYXVsdCYmbnVsbCE9PXQuZGVmYXVsdCkmJnZvaWQgMD09PXQuZGVmYXVsdC5fX2VzTW9kdWxlJiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuZGVmYXVsdCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmFzc2lnbih0LmRlZmF1bHQsdCksZS5leHBvcnRzPXQuZGVmYXVsdCl9LDUxMjY6ZnVuY3Rpb24oZSx0LHIpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImRlZmF1bHQiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBsfX0pO2xldCBuPXIoMTc1NyksYT1uLl8ocig3Mjk0KSksbz1hLnVzZUxheW91dEVmZmVjdCxpPWEudXNlRWZmZWN0O2Z1bmN0aW9uIGwoZSl7bGV0e2hlYWRNYW5hZ2VyOnQscmVkdWNlQ29tcG9uZW50c1RvU3RhdGU6cn09ZTtmdW5jdGlvbiBuKCl7aWYodCYmdC5tb3VudGVkSW5zdGFuY2VzKXtsZXQgbj1hLkNoaWxkcmVuLnRvQXJyYXkoQXJyYXkuZnJvbSh0Lm1vdW50ZWRJbnN0YW5jZXMpLmZpbHRlcihCb29sZWFuKSk7dC51cGRhdGVIZWFkKHIobixlKSl9fXJldHVybiBvKCgpPT57dmFyIHI7cmV0dXJuIG51bGw9PXR8fG51bGw9PShyPXQubW91bnRlZEluc3RhbmNlcyl8fHIuYWRkKGUuY2hpbGRyZW4pLCgpPT57dmFyIHI7bnVsbD09dHx8bnVsbD09KHI9dC5tb3VudGVkSW5zdGFuY2VzKXx8ci5kZWxldGUoZS5jaGlsZHJlbil9fSksbygoKT0+KHQmJih0Ll9wZW5kaW5nVXBkYXRlPW4pLCgpPT57dCYmKHQuX3BlbmRpbmdVcGRhdGU9bil9KSksaSgoKT0+KHQmJnQuX3BlbmRpbmdVcGRhdGUmJih0Ll9wZW5kaW5nVXBkYXRlKCksdC5fcGVuZGluZ1VwZGF0ZT1udWxsKSwoKT0+e3QmJnQuX3BlbmRpbmdVcGRhdGUmJih0Ll9wZW5kaW5nVXBkYXRlKCksdC5fcGVuZGluZ1VwZGF0ZT1udWxsKX0pKSxudWxsfX0sNzMyMTpmdW5jdGlvbihlLHQpeyJ1c2Ugc3RyaWN0IjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gdClPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLHtlbnVtZXJhYmxlOiEwLGdldDp0W3JdfSl9KHQse1dFQl9WSVRBTFM6ZnVuY3Rpb24oKXtyZXR1cm4gcn0sZXhlY09uY2U6ZnVuY3Rpb24oKXtyZXR1cm4gbn0saXNBYnNvbHV0ZVVybDpmdW5jdGlvbigpe3JldHVybiBvfSxnZXRMb2NhdGlvbk9yaWdpbjpmdW5jdGlvbigpe3JldHVybiBpfSxnZXRVUkw6ZnVuY3Rpb24oKXtyZXR1cm4gbH0sZ2V0RGlzcGxheU5hbWU6ZnVuY3Rpb24oKXtyZXR1cm4gdX0saXNSZXNTZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHN9LG5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlczpmdW5jdGlvbigpe3JldHVybiBjfSxsb2FkR2V0SW5pdGlhbFByb3BzOmZ1bmN0aW9uKCl7cmV0dXJuIGZ9LFNQOmZ1bmN0aW9uKCl7cmV0dXJuIGR9LFNUOmZ1bmN0aW9uKCl7cmV0dXJuIGh9LERlY29kZUVycm9yOmZ1bmN0aW9uKCl7cmV0dXJuIHB9LE5vcm1hbGl6ZUVycm9yOmZ1bmN0aW9uKCl7cmV0dXJuIG19LFBhZ2VOb3RGb3VuZEVycm9yOmZ1bmN0aW9uKCl7cmV0dXJuIGd9LE1pc3NpbmdTdGF0aWNQYWdlOmZ1bmN0aW9uKCl7cmV0dXJuIHl9LE1pZGRsZXdhcmVOb3RGb3VuZEVycm9yOmZ1bmN0aW9uKCl7cmV0dXJuIF99LHN0cmluZ2lmeUVycm9yOmZ1bmN0aW9uKCl7cmV0dXJuIGJ9fSk7bGV0IHI9WyJDTFMiLCJGQ1AiLCJGSUQiLCJJTlAiLCJMQ1AiLCJUVEZCIl07ZnVuY3Rpb24gbihlKXtsZXQgdCxyPSExO3JldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgbj1hcmd1bWVudHMubGVuZ3RoLGE9QXJyYXkobiksbz0wO288bjtvKyspYVtvXT1hcmd1bWVudHNbb107cmV0dXJuIHJ8fChyPSEwLHQ9ZSguLi5hKSksdH19bGV0IGE9L15bYS16QS1aXVthLXpBLVpcZCtcLS5dKj86LyxvPWU9PmEudGVzdChlKTtmdW5jdGlvbiBpKCl7bGV0e3Byb3RvY29sOmUsaG9zdG5hbWU6dCxwb3J0OnJ9PXdpbmRvdy5sb2NhdGlvbjtyZXR1cm4gZSsiLy8iK3QrKHI/IjoiK3I6IiIpfWZ1bmN0aW9uIGwoKXtsZXR7aHJlZjplfT13aW5kb3cubG9jYXRpb24sdD1pKCk7cmV0dXJuIGUuc3Vic3RyaW5nKHQubGVuZ3RoKX1mdW5jdGlvbiB1KGUpe3JldHVybiJzdHJpbmciPT10eXBlb2YgZT9lOmUuZGlzcGxheU5hbWV8fGUubmFtZXx8IlVua25vd24ifWZ1bmN0aW9uIHMoZSl7cmV0dXJuIGUuZmluaXNoZWR8fGUuaGVhZGVyc1NlbnR9ZnVuY3Rpb24gYyhlKXtsZXQgdD1lLnNwbGl0KCI/Iikscj10WzBdO3JldHVybiByLnJlcGxhY2UoL1xcL2csIi8iKS5yZXBsYWNlKC9cL1wvKy9nLCIvIikrKHRbMV0/Ij8iK3Quc2xpY2UoMSkuam9pbigiPyIpOiIiKX1hc3luYyBmdW5jdGlvbiBmKGUsdCl7bGV0IHI9dC5yZXN8fHQuY3R4JiZ0LmN0eC5yZXM7aWYoIWUuZ2V0SW5pdGlhbFByb3BzKXJldHVybiB0LmN0eCYmdC5Db21wb25lbnQ/e3BhZ2VQcm9wczphd2FpdCBmKHQuQ29tcG9uZW50LHQuY3R4KX06e307bGV0IG49YXdhaXQgZS5nZXRJbml0aWFsUHJvcHModCk7aWYociYmcyhyKSlyZXR1cm4gbjtpZighbil7bGV0IHQ9JyInK3UoZSkrJy5nZXRJbml0aWFsUHJvcHMoKSIgc2hvdWxkIHJlc29sdmUgdG8gYW4gb2JqZWN0LiBCdXQgZm91bmQgIicrbisnIiBpbnN0ZWFkLic7dGhyb3cgRXJyb3IodCl9cmV0dXJuIG59bGV0IGQ9InVuZGVmaW5lZCIhPXR5cGVvZiBwZXJmb3JtYW5jZSxoPWQmJlsibWFyayIsIm1lYXN1cmUiLCJnZXRFbnRyaWVzQnlOYW1lIl0uZXZlcnkoZT0+ImZ1bmN0aW9uIj09dHlwZW9mIHBlcmZvcm1hbmNlW2VdKTtjbGFzcyBwIGV4dGVuZHMgRXJyb3J7fWNsYXNzIG0gZXh0ZW5kcyBFcnJvcnt9Y2xhc3MgZyBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKGUpe3N1cGVyKCksdGhpcy5jb2RlPSJFTk9FTlQiLHRoaXMubmFtZT0iUGFnZU5vdEZvdW5kRXJyb3IiLHRoaXMubWVzc2FnZT0iQ2Fubm90IGZpbmQgbW9kdWxlIGZvciBwYWdlOiAiK2V9fWNsYXNzIHkgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKCksdGhpcy5tZXNzYWdlPSJGYWlsZWQgdG8gbG9hZCBzdGF0aWMgZmlsZSBmb3IgcGFnZTogIitlKyIgIit0fX1jbGFzcyBfIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuY29kZT0iRU5PRU5UIix0aGlzLm1lc3NhZ2U9IkNhbm5vdCBmaW5kIHRoZSBtaWRkbGV3YXJlIG1vZHVsZSJ9fWZ1bmN0aW9uIGIoZSl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHttZXNzYWdlOmUubWVzc2FnZSxzdGFjazplLnN0YWNrfSl9fSwyMDc4OmZ1bmN0aW9uKGUsdCl7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwid2Fybk9uY2UiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiByfX0pO2xldCByPWU9Pnt9fSw4MDE4OmZ1bmN0aW9uKGUpe3ZhciB0LHIsbixhLG8saSxsLHUscyxjLGYsZCxoLHAsbSxnLHksXyxiLHYsUCx3LFMsaixPLEUsUix4LEMsTSxBLEwsSSxULE4sayxELEIsSCxVLEYsVyxxLHosRyxWOyh0PXt9KS5kPWZ1bmN0aW9uKGUscil7Zm9yKHZhciBuIGluIHIpdC5vKHIsbikmJiF0Lm8oZSxuKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbix7ZW51bWVyYWJsZTohMCxnZXQ6cltuXX0pfSx0Lm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LHQucj1mdW5jdGlvbihlKXsidW5kZWZpbmVkIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOiJNb2R1bGUifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pfSx2b2lkIDAhPT10JiYodC5hYj0iLy8iKSxyPXt9LHQucihyKSx0LmQocix7Z2V0Q0xTOmZ1bmN0aW9uKCl7cmV0dXJuIFN9LGdldEZDUDpmdW5jdGlvbigpe3JldHVybiB2fSxnZXRGSUQ6ZnVuY3Rpb24oKXtyZXR1cm4gTX0sZ2V0SU5QOmZ1bmN0aW9uKCl7cmV0dXJuIFd9LGdldExDUDpmdW5jdGlvbigpe3JldHVybiB6fSxnZXRUVEZCOmZ1bmN0aW9uKCl7cmV0dXJuIFZ9LG9uQ0xTOmZ1bmN0aW9uKCl7cmV0dXJuIFN9LG9uRkNQOmZ1bmN0aW9uKCl7cmV0dXJuIHZ9LG9uRklEOmZ1bmN0aW9uKCl7cmV0dXJuIE19LG9uSU5QOmZ1bmN0aW9uKCl7cmV0dXJuIFd9LG9uTENQOmZ1bmN0aW9uKCl7cmV0dXJuIHp9LG9uVFRGQjpmdW5jdGlvbigpe3JldHVybiBWfX0pLHU9LTEscz1mdW5jdGlvbihlKXthZGRFdmVudExpc3RlbmVyKCJwYWdlc2hvdyIsZnVuY3Rpb24odCl7dC5wZXJzaXN0ZWQmJih1PXQudGltZVN0YW1wLGUodCkpfSwhMCl9LGM9ZnVuY3Rpb24oKXtyZXR1cm4gd2luZG93LnBlcmZvcm1hbmNlJiZwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlUeXBlJiZwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlUeXBlKCJuYXZpZ2F0aW9uIilbMF19LGY9ZnVuY3Rpb24oKXt2YXIgZT1jKCk7cmV0dXJuIGUmJmUuYWN0aXZhdGlvblN0YXJ0fHwwfSxkPWZ1bmN0aW9uKGUsdCl7dmFyIHI9YygpLG49Im5hdmlnYXRlIjtyZXR1cm4gdT49MD9uPSJiYWNrLWZvcndhcmQtY2FjaGUiOnImJihuPWRvY3VtZW50LnByZXJlbmRlcmluZ3x8ZigpPjA/InByZXJlbmRlciI6ci50eXBlLnJlcGxhY2UoL18vZywiLSIpKSx7bmFtZTplLHZhbHVlOnZvaWQgMD09PXQ/LTE6dCxyYXRpbmc6Imdvb2QiLGRlbHRhOjAsZW50cmllczpbXSxpZDoidjMtIi5jb25jYXQoRGF0ZS5ub3coKSwiLSIpLmNvbmNhdChNYXRoLmZsb29yKDg5OTk5OTk5OTk5OTkqTWF0aC5yYW5kb20oKSkrMWUxMiksbmF2aWdhdGlvblR5cGU6bn19LGg9ZnVuY3Rpb24oZSx0LHIpe3RyeXtpZihQZXJmb3JtYW5jZU9ic2VydmVyLnN1cHBvcnRlZEVudHJ5VHlwZXMuaW5jbHVkZXMoZSkpe3ZhciBuPW5ldyBQZXJmb3JtYW5jZU9ic2VydmVyKGZ1bmN0aW9uKGUpe3QoZS5nZXRFbnRyaWVzKCkpfSk7cmV0dXJuIG4ub2JzZXJ2ZShPYmplY3QuYXNzaWduKHt0eXBlOmUsYnVmZmVyZWQ6ITB9LHJ8fHt9KSksbn19Y2F0Y2goZSl7fX0scD1mdW5jdGlvbihlLHQpe3ZhciByPWZ1bmN0aW9uIHIobil7InBhZ2VoaWRlIiE9PW4udHlwZSYmImhpZGRlbiIhPT1kb2N1bWVudC52aXNpYmlsaXR5U3RhdGV8fChlKG4pLHQmJihyZW1vdmVFdmVudExpc3RlbmVyKCJ2aXNpYmlsaXR5Y2hhbmdlIixyLCEwKSxyZW1vdmVFdmVudExpc3RlbmVyKCJwYWdlaGlkZSIsciwhMCkpKX07YWRkRXZlbnRMaXN0ZW5lcigidmlzaWJpbGl0eWNoYW5nZSIsciwhMCksYWRkRXZlbnRMaXN0ZW5lcigicGFnZWhpZGUiLHIsITApfSxtPWZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBhLG87cmV0dXJuIGZ1bmN0aW9uKGkpe3ZhciBsO3QudmFsdWU+PTAmJihpfHxuKSYmKChvPXQudmFsdWUtKGF8fDApKXx8dm9pZCAwPT09YSkmJihhPXQudmFsdWUsdC5kZWx0YT1vLHQucmF0aW5nPShsPXQudmFsdWUpPnJbMV0/InBvb3IiOmw+clswXT8ibmVlZHMtaW1wcm92ZW1lbnQiOiJnb29kIixlKHQpKX19LGc9LTEseT1mdW5jdGlvbigpe3JldHVybiJoaWRkZW4iIT09ZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlfHxkb2N1bWVudC5wcmVyZW5kZXJpbmc/MS8wOjB9LF89ZnVuY3Rpb24oKXtwKGZ1bmN0aW9uKGUpe2c9ZS50aW1lU3RhbXB9LCEwKX0sYj1mdW5jdGlvbigpe3JldHVybiBnPDAmJihnPXkoKSxfKCkscyhmdW5jdGlvbigpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXtnPXkoKSxfKCl9LDApfSkpLHtnZXQgZmlyc3RIaWRkZW5UaW1lKCl7cmV0dXJuIGd9fX0sdj1mdW5jdGlvbihlLHQpe3Q9dHx8e307dmFyIHIsbj1bMTgwMCwzZTNdLGE9YigpLG89ZCgiRkNQIiksaT1mdW5jdGlvbihlKXtlLmZvckVhY2goZnVuY3Rpb24oZSl7ImZpcnN0LWNvbnRlbnRmdWwtcGFpbnQiPT09ZS5uYW1lJiYodSYmdS5kaXNjb25uZWN0KCksZS5zdGFydFRpbWU8YS5maXJzdEhpZGRlblRpbWUmJihvLnZhbHVlPWUuc3RhcnRUaW1lLWYoKSxvLmVudHJpZXMucHVzaChlKSxyKCEwKSkpfSl9LGw9d2luZG93LnBlcmZvcm1hbmNlJiZ3aW5kb3cucGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSYmd2luZG93LnBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoImZpcnN0LWNvbnRlbnRmdWwtcGFpbnQiKVswXSx1PWw/bnVsbDpoKCJwYWludCIsaSk7KGx8fHUpJiYocj1tKGUsbyxuLHQucmVwb3J0QWxsQ2hhbmdlcyksbCYmaShbbF0pLHMoZnVuY3Rpb24oYSl7cj1tKGUsbz1kKCJGQ1AiKSxuLHQucmVwb3J0QWxsQ2hhbmdlcykscmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7by52YWx1ZT1wZXJmb3JtYW5jZS5ub3coKS1hLnRpbWVTdGFtcCxyKCEwKX0pfSl9KSl9LFA9ITEsdz0tMSxTPWZ1bmN0aW9uKGUsdCl7dD10fHx7fTt2YXIgcj1bLjEsLjI1XTtQfHwodihmdW5jdGlvbihlKXt3PWUudmFsdWV9KSxQPSEwKTt2YXIgbixhPWZ1bmN0aW9uKHQpe3c+LTEmJmUodCl9LG89ZCgiQ0xTIiwwKSxpPTAsbD1bXSx1PWZ1bmN0aW9uKGUpe2UuZm9yRWFjaChmdW5jdGlvbihlKXtpZighZS5oYWRSZWNlbnRJbnB1dCl7dmFyIHQ9bFswXSxyPWxbbC5sZW5ndGgtMV07aSYmZS5zdGFydFRpbWUtci5zdGFydFRpbWU8MWUzJiZlLnN0YXJ0VGltZS10LnN0YXJ0VGltZTw1ZTM/KGkrPWUudmFsdWUsbC5wdXNoKGUpKTooaT1lLnZhbHVlLGw9W2VdKSxpPm8udmFsdWUmJihvLnZhbHVlPWksby5lbnRyaWVzPWwsbigpKX19KX0sYz1oKCJsYXlvdXQtc2hpZnQiLHUpO2MmJihuPW0oYSxvLHIsdC5yZXBvcnRBbGxDaGFuZ2VzKSxwKGZ1bmN0aW9uKCl7dShjLnRha2VSZWNvcmRzKCkpLG4oITApfSkscyhmdW5jdGlvbigpe2k9MCx3PS0xLG49bShhLG89ZCgiQ0xTIiwwKSxyLHQucmVwb3J0QWxsQ2hhbmdlcyl9KSl9LGo9e3Bhc3NpdmU6ITAsY2FwdHVyZTohMH0sTz1uZXcgRGF0ZSxFPWZ1bmN0aW9uKGUsdCl7bnx8KG49dCxhPWUsbz1uZXcgRGF0ZSxDKHJlbW92ZUV2ZW50TGlzdGVuZXIpLFIoKSl9LFI9ZnVuY3Rpb24oKXtpZihhPj0wJiZhPG8tTyl7dmFyIGU9e2VudHJ5VHlwZToiZmlyc3QtaW5wdXQiLG5hbWU6bi50eXBlLHRhcmdldDpuLnRhcmdldCxjYW5jZWxhYmxlOm4uY2FuY2VsYWJsZSxzdGFydFRpbWU6bi50aW1lU3RhbXAscHJvY2Vzc2luZ1N0YXJ0Om4udGltZVN0YW1wK2F9O2kuZm9yRWFjaChmdW5jdGlvbih0KXt0KGUpfSksaT1bXX19LHg9ZnVuY3Rpb24oZSl7aWYoZS5jYW5jZWxhYmxlKXt2YXIgdCxyLG4sYT0oZS50aW1lU3RhbXA+MWUxMj9uZXcgRGF0ZTpwZXJmb3JtYW5jZS5ub3coKSktZS50aW1lU3RhbXA7InBvaW50ZXJkb3duIj09ZS50eXBlPyh0PWZ1bmN0aW9uKCl7RShhLGUpLG4oKX0scj1mdW5jdGlvbigpe24oKX0sbj1mdW5jdGlvbigpe3JlbW92ZUV2ZW50TGlzdGVuZXIoInBvaW50ZXJ1cCIsdCxqKSxyZW1vdmVFdmVudExpc3RlbmVyKCJwb2ludGVyY2FuY2VsIixyLGopfSxhZGRFdmVudExpc3RlbmVyKCJwb2ludGVydXAiLHQsaiksYWRkRXZlbnRMaXN0ZW5lcigicG9pbnRlcmNhbmNlbCIscixqKSk6RShhLGUpfX0sQz1mdW5jdGlvbihlKXtbIm1vdXNlZG93biIsImtleWRvd24iLCJ0b3VjaHN0YXJ0IiwicG9pbnRlcmRvd24iXS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiBlKHQseCxqKX0pfSxNPWZ1bmN0aW9uKGUsdCl7dD10fHx7fTt2YXIgcixvPVsxMDAsMzAwXSxsPWIoKSx1PWQoIkZJRCIpLGM9ZnVuY3Rpb24oZSl7ZS5zdGFydFRpbWU8bC5maXJzdEhpZGRlblRpbWUmJih1LnZhbHVlPWUucHJvY2Vzc2luZ1N0YXJ0LWUuc3RhcnRUaW1lLHUuZW50cmllcy5wdXNoKGUpLHIoITApKX0sZj1mdW5jdGlvbihlKXtlLmZvckVhY2goYyl9LGc9aCgiZmlyc3QtaW5wdXQiLGYpO3I9bShlLHUsbyx0LnJlcG9ydEFsbENoYW5nZXMpLGcmJnAoZnVuY3Rpb24oKXtmKGcudGFrZVJlY29yZHMoKSksZy5kaXNjb25uZWN0KCl9LCEwKSxnJiZzKGZ1bmN0aW9uKCl7cj1tKGUsdT1kKCJGSUQiKSxvLHQucmVwb3J0QWxsQ2hhbmdlcyksaT1bXSxhPS0xLG49bnVsbCxDKGFkZEV2ZW50TGlzdGVuZXIpLGkucHVzaChjKSxSKCl9KX0sQT0wLEw9MS8wLEk9MCxUPWZ1bmN0aW9uKGUpe2UuZm9yRWFjaChmdW5jdGlvbihlKXtlLmludGVyYWN0aW9uSWQmJihMPU1hdGgubWluKEwsZS5pbnRlcmFjdGlvbklkKSxBPShJPU1hdGgubWF4KEksZS5pbnRlcmFjdGlvbklkKSk/KEktTCkvNysxOjApfSl9LE49ZnVuY3Rpb24oKXtyZXR1cm4gbD9BOnBlcmZvcm1hbmNlLmludGVyYWN0aW9uQ291bnR8fDB9LGs9ZnVuY3Rpb24oKXsiaW50ZXJhY3Rpb25Db3VudCJpbiBwZXJmb3JtYW5jZXx8bHx8KGw9aCgiZXZlbnQiLFQse3R5cGU6ImV2ZW50IixidWZmZXJlZDohMCxkdXJhdGlvblRocmVzaG9sZDowfSkpfSxEPTAsQj1mdW5jdGlvbigpe3JldHVybiBOKCktRH0sSD1bXSxVPXt9LEY9ZnVuY3Rpb24oZSl7dmFyIHQ9SFtILmxlbmd0aC0xXSxyPVVbZS5pbnRlcmFjdGlvbklkXTtpZihyfHxILmxlbmd0aDwxMHx8ZS5kdXJhdGlvbj50LmxhdGVuY3kpe2lmKHIpci5lbnRyaWVzLnB1c2goZSksci5sYXRlbmN5PU1hdGgubWF4KHIubGF0ZW5jeSxlLmR1cmF0aW9uKTtlbHNle3ZhciBuPXtpZDplLmludGVyYWN0aW9uSWQsbGF0ZW5jeTplLmR1cmF0aW9uLGVudHJpZXM6W2VdfTtVW24uaWRdPW4sSC5wdXNoKG4pfUguc29ydChmdW5jdGlvbihlLHQpe3JldHVybiB0LmxhdGVuY3ktZS5sYXRlbmN5fSksSC5zcGxpY2UoMTApLmZvckVhY2goZnVuY3Rpb24oZSl7ZGVsZXRlIFVbZS5pZF19KX19LFc9ZnVuY3Rpb24oZSx0KXt0PXR8fHt9O3ZhciByPVsyMDAsNTAwXTtrKCk7dmFyIG4sYT1kKCJJTlAiKSxvPWZ1bmN0aW9uKGUpe2UuZm9yRWFjaChmdW5jdGlvbihlKXtlLmludGVyYWN0aW9uSWQmJkYoZSksImZpcnN0LWlucHV0IiE9PWUuZW50cnlUeXBlfHxILnNvbWUoZnVuY3Rpb24odCl7cmV0dXJuIHQuZW50cmllcy5zb21lKGZ1bmN0aW9uKHQpe3JldHVybiBlLmR1cmF0aW9uPT09dC5kdXJhdGlvbiYmZS5zdGFydFRpbWU9PT10LnN0YXJ0VGltZX0pfSl8fEYoZSl9KTt2YXIgdCxyPSh0PU1hdGgubWluKEgubGVuZ3RoLTEsTWF0aC5mbG9vcihCKCkvNTApKSxIW3RdKTtyJiZyLmxhdGVuY3khPT1hLnZhbHVlJiYoYS52YWx1ZT1yLmxhdGVuY3ksYS5lbnRyaWVzPXIuZW50cmllcyxuKCkpfSxpPWgoImV2ZW50IixvLHtkdXJhdGlvblRocmVzaG9sZDp0LmR1cmF0aW9uVGhyZXNob2xkfHw0MH0pO249bShlLGEscix0LnJlcG9ydEFsbENoYW5nZXMpLGkmJihpLm9ic2VydmUoe3R5cGU6ImZpcnN0LWlucHV0IixidWZmZXJlZDohMH0pLHAoZnVuY3Rpb24oKXtvKGkudGFrZVJlY29yZHMoKSksYS52YWx1ZTwwJiZCKCk+MCYmKGEudmFsdWU9MCxhLmVudHJpZXM9W10pLG4oITApfSkscyhmdW5jdGlvbigpe0g9W10sRD1OKCksbj1tKGUsYT1kKCJJTlAiKSxyLHQucmVwb3J0QWxsQ2hhbmdlcyl9KSl9LHE9e30sej1mdW5jdGlvbihlLHQpe3Q9dHx8e307dmFyIHIsbj1bMjUwMCw0ZTNdLGE9YigpLG89ZCgiTENQIiksaT1mdW5jdGlvbihlKXt2YXIgdD1lW2UubGVuZ3RoLTFdO2lmKHQpe3ZhciBuPXQuc3RhcnRUaW1lLWYoKTtuPGEuZmlyc3RIaWRkZW5UaW1lJiYoby52YWx1ZT1uLG8uZW50cmllcz1bdF0scigpKX19LGw9aCgibGFyZ2VzdC1jb250ZW50ZnVsLXBhaW50IixpKTtpZihsKXtyPW0oZSxvLG4sdC5yZXBvcnRBbGxDaGFuZ2VzKTt2YXIgdT1mdW5jdGlvbigpe3Fbby5pZF18fChpKGwudGFrZVJlY29yZHMoKSksbC5kaXNjb25uZWN0KCkscVtvLmlkXT0hMCxyKCEwKSl9O1sia2V5ZG93biIsImNsaWNrIl0uZm9yRWFjaChmdW5jdGlvbihlKXthZGRFdmVudExpc3RlbmVyKGUsdSx7b25jZTohMCxjYXB0dXJlOiEwfSl9KSxwKHUsITApLHMoZnVuY3Rpb24oYSl7cj1tKGUsbz1kKCJMQ1AiKSxuLHQucmVwb3J0QWxsQ2hhbmdlcykscmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7by52YWx1ZT1wZXJmb3JtYW5jZS5ub3coKS1hLnRpbWVTdGFtcCxxW28uaWRdPSEwLHIoITApfSl9KX0pfX0sRz1mdW5jdGlvbiBlKHQpe2RvY3VtZW50LnByZXJlbmRlcmluZz9hZGRFdmVudExpc3RlbmVyKCJwcmVyZW5kZXJpbmdjaGFuZ2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGUodCl9LCEwKToiY29tcGxldGUiIT09ZG9jdW1lbnQucmVhZHlTdGF0ZT9hZGRFdmVudExpc3RlbmVyKCJsb2FkIixmdW5jdGlvbigpe3JldHVybiBlKHQpfSwhMCk6c2V0VGltZW91dCh0LDApfSxWPWZ1bmN0aW9uKGUsdCl7dD10fHx7fTt2YXIgcj1bODAwLDE4MDBdLG49ZCgiVFRGQiIpLGE9bShlLG4scix0LnJlcG9ydEFsbENoYW5nZXMpO0coZnVuY3Rpb24oKXt2YXIgbz1jKCk7aWYobyl7aWYobi52YWx1ZT1NYXRoLm1heChvLnJlc3BvbnNlU3RhcnQtZigpLDApLG4udmFsdWU8MHx8bi52YWx1ZT5wZXJmb3JtYW5jZS5ub3coKSlyZXR1cm47bi5lbnRyaWVzPVtvXSxhKCEwKSxzKGZ1bmN0aW9uKCl7KGE9bShlLG49ZCgiVFRGQiIsMCkscix0LnJlcG9ydEFsbENoYW5nZXMpKSghMCl9KX19KX0sZS5leHBvcnRzPXJ9LDk0MjM6ZnVuY3Rpb24oZSx0KXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4iL2FwaSI9PT1lfHwhIShudWxsPT1lP3ZvaWQgMDplLnN0YXJ0c1dpdGgoIi9hcGkvIikpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiaXNBUElSb3V0ZSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHJ9fSl9LDY3NjpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ITAsZ2V0OnRbcl19KX0odCx7ZGVmYXVsdDpmdW5jdGlvbigpe3JldHVybiBhfSxnZXRQcm9wZXJFcnJvcjpmdW5jdGlvbigpe3JldHVybiBvfX0pO2xldCBuPXIoODMyNSk7ZnVuY3Rpb24gYShlKXtyZXR1cm4ib2JqZWN0Ij09dHlwZW9mIGUmJm51bGwhPT1lJiYibmFtZSJpbiBlJiYibWVzc2FnZSJpbiBlfWZ1bmN0aW9uIG8oZSl7cmV0dXJuIGEoZSk/ZTpFcnJvcigoMCxuLmlzUGxhaW5PYmplY3QpKGUpP0pTT04uc3RyaW5naWZ5KGUpOmUrIiIpfX0sMjQwNzpmdW5jdGlvbihlLHQscil7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ITAsZ2V0OnRbcl19KX0odCx7SU5URVJDRVBUSU9OX1JPVVRFX01BUktFUlM6ZnVuY3Rpb24oKXtyZXR1cm4gYX0saXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGg6ZnVuY3Rpb24oKXtyZXR1cm4gb30sZXh0cmFjdEludGVyY2VwdGlvblJvdXRlSW5mb3JtYXRpb246ZnVuY3Rpb24oKXtyZXR1cm4gaX19KTtsZXQgbj1yKDc1ODQpLGE9WyIoLi4pKC4uKSIsIiguKSIsIiguLikiLCIoLi4uKSJdO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIHZvaWQgMCE9PWUuc3BsaXQoIi8iKS5maW5kKGU9PmEuZmluZCh0PT5lLnN0YXJ0c1dpdGgodCkpKX1mdW5jdGlvbiBpKGUpe2xldCB0LHIsbztmb3IobGV0IG4gb2YgZS5zcGxpdCgiLyIpKWlmKHI9YS5maW5kKGU9Pm4uc3RhcnRzV2l0aChlKSkpe1t0LG9dPWUuc3BsaXQociwyKTticmVha31pZighdHx8IXJ8fCFvKXRocm93IEVycm9yKGBJbnZhbGlkIGludGVyY2VwdGlvbiByb3V0ZTogJHtlfS4gTXVzdCBiZSBpbiB0aGUgZm9ybWF0IC88aW50ZXJjZXB0aW5nIHJvdXRlPi8oLi58Li4ufC4uKSguLikvPGludGVyY2VwdGVkIHJvdXRlPmApO3N3aXRjaCh0PSgwLG4ubm9ybWFsaXplQXBwUGF0aCkodCkscil7Y2FzZSIoLikiOm89Ii8iPT09dD9gLyR7b31gOnQrIi8iK287YnJlYWs7Y2FzZSIoLi4pIjppZigiLyI9PT10KXRocm93IEVycm9yKGBJbnZhbGlkIGludGVyY2VwdGlvbiByb3V0ZTogJHtlfS4gQ2Fubm90IHVzZSAoLi4pIG1hcmtlciBhdCB0aGUgcm9vdCBsZXZlbCwgdXNlICguKSBpbnN0ZWFkLmApO289dC5zcGxpdCgiLyIpLnNsaWNlKDAsLTEpLmNvbmNhdChvKS5qb2luKCIvIik7YnJlYWs7Y2FzZSIoLi4uKSI6bz0iLyIrbzticmVhaztjYXNlIiguLikoLi4pIjpsZXQgaT10LnNwbGl0KCIvIik7aWYoaS5sZW5ndGg8PTIpdGhyb3cgRXJyb3IoYEludmFsaWQgaW50ZXJjZXB0aW9uIHJvdXRlOiAke2V9LiBDYW5ub3QgdXNlICguLikoLi4pIG1hcmtlciBhdCB0aGUgcm9vdCBsZXZlbCBvciBvbmUgbGV2ZWwgdXAuYCk7bz1pLnNsaWNlKDAsLTIpLmNvbmNhdChvKS5qb2luKCIvIik7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcigiSW52YXJpYW50OiB1bmV4cGVjdGVkIG1hcmtlciIpfXJldHVybntpbnRlcmNlcHRpbmdSb3V0ZTp0LGludGVyY2VwdGVkUm91dGU6b319fSwyNDMxOmZ1bmN0aW9uKCl7fSw4NzU0OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ci5yKHQpLHIuZCh0LHtfOmZ1bmN0aW9uKCl7cmV0dXJuIG59LF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdDpmdW5jdGlvbigpe3JldHVybiBufX0pfSwxNzU3OmZ1bmN0aW9uKGUsdCxyKXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gbihlKXtpZigiZnVuY3Rpb24iIT10eXBlb2YgV2Vha01hcClyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcCxyPW5ldyBXZWFrTWFwO3JldHVybihuPWZ1bmN0aW9uKGUpe3JldHVybiBlP3I6dH0pKGUpfWZ1bmN0aW9uIGEoZSx0KXtpZighdCYmZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO2lmKG51bGw9PT1lfHwib2JqZWN0IiE9dHlwZW9mIGUmJiJmdW5jdGlvbiIhPXR5cGVvZiBlKXJldHVybntkZWZhdWx0OmV9O3ZhciByPW4odCk7aWYociYmci5oYXMoZSkpcmV0dXJuIHIuZ2V0KGUpO3ZhciBhPXt9LG89T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgaSBpbiBlKWlmKCJkZWZhdWx0IiE9PWkmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLGkpKXt2YXIgbD1vP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxpKTpudWxsO2wmJihsLmdldHx8bC5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGksbCk6YVtpXT1lW2ldfXJldHVybiBhLmRlZmF1bHQ9ZSxyJiZyLnNldChlLGEpLGF9ci5yKHQpLHIuZCh0LHtfOmZ1bmN0aW9uKCl7cmV0dXJuIGF9LF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQ6ZnVuY3Rpb24oKXtyZXR1cm4gYX19KX19LGZ1bmN0aW9uKGUpe2UuTygwLFs3NzRdLGZ1bmN0aW9uKCl7cmV0dXJuIGUoZS5zPTEwMTkpfSksX05fRT1lLk8oKX1dKTs=\")\nassets.set(\"/_next/static/chunks/main-app-9511d88d94004a7a.js\", \"data:application/javascript;base64,KHNlbGYud2VicGFja0NodW5rX05fRT1zZWxmLndlYnBhY2tDaHVua19OX0V8fFtdKS5wdXNoKFtbNzQ0XSx7OTUxNDpmdW5jdGlvbihlLG4sdCl7UHJvbWlzZS5yZXNvbHZlKCkudGhlbih0LnQuYmluZCh0LDEyMjMsMjMpKSxQcm9taXNlLnJlc29sdmUoKS50aGVuKHQudC5iaW5kKHQsMzQ2NiwyMykpLFByb21pc2UucmVzb2x2ZSgpLnRoZW4odC50LmJpbmQodCw4MDk1LDIzKSksUHJvbWlzZS5yZXNvbHZlKCkudGhlbih0LnQuYmluZCh0LDM3MiwyMykpLFByb21pc2UucmVzb2x2ZSgpLnRoZW4odC50LmJpbmQodCw1NzIxLDIzKSl9fSxmdW5jdGlvbihlKXt2YXIgbj1mdW5jdGlvbihuKXtyZXR1cm4gZShlLnM9bil9O2UuTygwLFsyNTMsOTYxXSxmdW5jdGlvbigpe3JldHVybiBuKDIxNzQpLG4oOTUxNCl9KSxfTl9FPWUuTygpfV0pOw==\")\nassets.set(\"/_next/static/chunks/pages/_app-52924524f99094ab.js\", \"data:application/javascript;base64,KHNlbGYud2VicGFja0NodW5rX05fRT1zZWxmLndlYnBhY2tDaHVua19OX0V8fFtdKS5wdXNoKFtbODg4XSx7MTU5NzpmdW5jdGlvbihuLF8sdSl7KHdpbmRvdy5fX05FWFRfUD13aW5kb3cuX19ORVhUX1B8fFtdKS5wdXNoKFsiL19hcHAiLGZ1bmN0aW9uKCl7cmV0dXJuIHUoNjUzMCl9XSl9fSxmdW5jdGlvbihuKXt2YXIgXz1mdW5jdGlvbihfKXtyZXR1cm4gbihuLnM9Xyl9O24uTygwLFs3NzQsMTc5XSxmdW5jdGlvbigpe3JldHVybiBfKDE1OTcpLF8oMTI0Nyl9KSxfTl9FPW4uTygpfV0pOw==\")\nassets.set(\"/_next/static/chunks/pages/_error-c92d5c4bb2b49926.js\", \"data:application/javascript;base64,KHNlbGYud2VicGFja0NodW5rX05fRT1zZWxmLndlYnBhY2tDaHVua19OX0V8fFtdKS5wdXNoKFtbODIwXSx7MTk4MTpmdW5jdGlvbihuLF8sdSl7KHdpbmRvdy5fX05FWFRfUD13aW5kb3cuX19ORVhUX1B8fFtdKS5wdXNoKFsiL19lcnJvciIsZnVuY3Rpb24oKXtyZXR1cm4gdSgzNDQxKX1dKX19LGZ1bmN0aW9uKG4pe24uTygwLFs4ODgsNzc0LDE3OV0sZnVuY3Rpb24oKXtyZXR1cm4gbihuLnM9MTk4MSl9KSxfTl9FPW4uTygpfV0pOw==\")\nassets.set(\"/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js\", \"data:application/javascript;base64,IWZ1bmN0aW9uKCl7dmFyIHQ9InVuZGVmaW5lZCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6InVuZGVmaW5lZCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OiJ1bmRlZmluZWQiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDoidW5kZWZpbmVkIiE9dHlwZW9mIHNlbGY/c2VsZjp7fTtmdW5jdGlvbiBlKHQpe3ZhciBlPXtleHBvcnRzOnt9fTtyZXR1cm4gdChlLGUuZXhwb3J0cyksZS5leHBvcnRzfXZhciByPWZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0Lk1hdGg9PU1hdGgmJnR9LG49cigib2JqZWN0Ij09dHlwZW9mIGdsb2JhbFRoaXMmJmdsb2JhbFRoaXMpfHxyKCJvYmplY3QiPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cpfHxyKCJvYmplY3QiPT10eXBlb2Ygc2VsZiYmc2VsZil8fHIoIm9iamVjdCI9PXR5cGVvZiB0JiZ0KXx8RnVuY3Rpb24oInJldHVybiB0aGlzIikoKSxvPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4hIXQoKX1jYXRjaCh0KXtyZXR1cm4hMH19LGk9IW8oZnVuY3Rpb24oKXtyZXR1cm4gNyE9T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LDEse2dldDpmdW5jdGlvbigpe3JldHVybiA3fX0pWzFdfSksYT17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSx1PU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iscz11JiYhYS5jYWxsKHsxOjJ9LDEpP2Z1bmN0aW9uKHQpe3ZhciBlPXUodGhpcyx0KTtyZXR1cm4hIWUmJmUuZW51bWVyYWJsZX06YSxjPXtmOnN9LGY9ZnVuY3Rpb24odCxlKXtyZXR1cm57ZW51bWVyYWJsZTohKDEmdCksY29uZmlndXJhYmxlOiEoMiZ0KSx3cml0YWJsZTohKDQmdCksdmFsdWU6ZX19LGw9e30udG9TdHJpbmcsaD1mdW5jdGlvbih0KXtyZXR1cm4gbC5jYWxsKHQpLnNsaWNlKDgsLTEpfSxwPSIiLnNwbGl0LGQ9byhmdW5jdGlvbigpe3JldHVybiFPYmplY3QoInoiKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKX0pP2Z1bmN0aW9uKHQpe3JldHVybiJTdHJpbmciPT1oKHQpP3AuY2FsbCh0LCIiKTpPYmplY3QodCl9Ok9iamVjdCx2PWZ1bmN0aW9uKHQpe2lmKG51bGw9PXQpdGhyb3cgVHlwZUVycm9yKCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAiK3QpO3JldHVybiB0fSxnPWZ1bmN0aW9uKHQpe3JldHVybiBkKHYodCkpfSx5PWZ1bmN0aW9uKHQpe3JldHVybiJvYmplY3QiPT10eXBlb2YgdD9udWxsIT09dDoiZnVuY3Rpb24iPT10eXBlb2YgdH0sbT1mdW5jdGlvbih0LGUpe2lmKCF5KHQpKXJldHVybiB0O3ZhciByLG47aWYoZSYmImZ1bmN0aW9uIj09dHlwZW9mKHI9dC50b1N0cmluZykmJiF5KG49ci5jYWxsKHQpKSlyZXR1cm4gbjtpZigiZnVuY3Rpb24iPT10eXBlb2Yocj10LnZhbHVlT2YpJiYheShuPXIuY2FsbCh0KSkpcmV0dXJuIG47aWYoIWUmJiJmdW5jdGlvbiI9PXR5cGVvZihyPXQudG9TdHJpbmcpJiYheShuPXIuY2FsbCh0KSkpcmV0dXJuIG47dGhyb3cgVHlwZUVycm9yKCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWUiKX0sYj17fS5oYXNPd25Qcm9wZXJ0eSx3PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGIuY2FsbCh0LGUpfSxTPW4uZG9jdW1lbnQsRT15KFMpJiZ5KFMuY3JlYXRlRWxlbWVudCkseD1mdW5jdGlvbih0KXtyZXR1cm4gRT9TLmNyZWF0ZUVsZW1lbnQodCk6e319LEE9IWkmJiFvKGZ1bmN0aW9uKCl7cmV0dXJuIDchPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh4KCJkaXYiKSwiYSIse2dldDpmdW5jdGlvbigpe3JldHVybiA3fX0pLmF9KSxPPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsUj17ZjppP086ZnVuY3Rpb24odCxlKXtpZih0PWcodCksZT1tKGUsITApLEEpdHJ5e3JldHVybiBPKHQsZSl9Y2F0Y2godCl7fWlmKHcodCxlKSlyZXR1cm4gZighYy5mLmNhbGwodCxlKSx0W2VdKX19LGo9ZnVuY3Rpb24odCl7aWYoIXkodCkpdGhyb3cgVHlwZUVycm9yKFN0cmluZyh0KSsiIGlzIG5vdCBhbiBvYmplY3QiKTtyZXR1cm4gdH0sUD1PYmplY3QuZGVmaW5lUHJvcGVydHksST17ZjppP1A6ZnVuY3Rpb24odCxlLHIpe2lmKGoodCksZT1tKGUsITApLGoociksQSl0cnl7cmV0dXJuIFAodCxlLHIpfWNhdGNoKHQpe31pZigiZ2V0ImluIHJ8fCJzZXQiaW4gcil0aHJvdyBUeXBlRXJyb3IoIkFjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIik7cmV0dXJuInZhbHVlImluIHImJih0W2VdPXIudmFsdWUpLHR9fSxUPWk/ZnVuY3Rpb24odCxlLHIpe3JldHVybiBJLmYodCxlLGYoMSxyKSl9OmZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdFtlXT1yLHR9LGs9ZnVuY3Rpb24odCxlKXt0cnl7VChuLHQsZSl9Y2F0Y2gocil7blt0XT1lfXJldHVybiBlfSxMPSJfX2NvcmUtanNfc2hhcmVkX18iLFU9bltMXXx8ayhMLHt9KSxNPUZ1bmN0aW9uLnRvU3RyaW5nOyJmdW5jdGlvbiIhPXR5cGVvZiBVLmluc3BlY3RTb3VyY2UmJihVLmluc3BlY3RTb3VyY2U9ZnVuY3Rpb24odCl7cmV0dXJuIE0uY2FsbCh0KX0pO3ZhciBfLE4sQyxGPVUuaW5zcGVjdFNvdXJjZSxCPW4uV2Vha01hcCxEPSJmdW5jdGlvbiI9PXR5cGVvZiBCJiYvbmF0aXZlIGNvZGUvLnRlc3QoRihCKSkscT0hMSx6PWUoZnVuY3Rpb24odCl7KHQuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3JldHVybiBVW3RdfHwoVVt0XT12b2lkIDAhPT1lP2U6e30pfSkoInZlcnNpb25zIixbXSkucHVzaCh7dmVyc2lvbjoiMy42LjUiLG1vZGU6Imdsb2JhbCIsY29weXJpZ2h0OiLCqSAyMDIwIERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpIn0pfSksVz0wLEs9TWF0aC5yYW5kb20oKSxHPWZ1bmN0aW9uKHQpe3JldHVybiJTeW1ib2woIitTdHJpbmcodm9pZCAwPT09dD8iIjp0KSsiKV8iKygrK1crSykudG9TdHJpbmcoMzYpfSwkPXooImtleXMiKSxWPWZ1bmN0aW9uKHQpe3JldHVybiAkW3RdfHwoJFt0XT1HKHQpKX0sSD17fTtpZihEKXt2YXIgWD1uZXcoMCxuLldlYWtNYXApLFk9WC5nZXQsSj1YLmhhcyxRPVguc2V0O189ZnVuY3Rpb24odCxlKXtyZXR1cm4gUS5jYWxsKFgsdCxlKSxlfSxOPWZ1bmN0aW9uKHQpe3JldHVybiBZLmNhbGwoWCx0KXx8e319LEM9ZnVuY3Rpb24odCl7cmV0dXJuIEouY2FsbChYLHQpfX1lbHNle3ZhciBaPVYoInN0YXRlIik7SFtaXT0hMCxfPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIFQodCxaLGUpLGV9LE49ZnVuY3Rpb24odCl7cmV0dXJuIHcodCxaKT90W1pdOnt9fSxDPWZ1bmN0aW9uKHQpe3JldHVybiB3KHQsWil9fXZhciB0dCxldD17c2V0Ol8sZ2V0Ok4saGFzOkMsZW5mb3JjZTpmdW5jdGlvbih0KXtyZXR1cm4gQyh0KT9OKHQpOl8odCx7fSl9LGdldHRlckZvcjpmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHI7aWYoIXkoZSl8fChyPU4oZSkpLnR5cGUhPT10KXRocm93IFR5cGVFcnJvcigiSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAiK3QrIiByZXF1aXJlZCIpO3JldHVybiByfX19LHJ0PWUoZnVuY3Rpb24odCl7dmFyIGU9ZXQuZ2V0LHI9ZXQuZW5mb3JjZSxvPVN0cmluZyhTdHJpbmcpLnNwbGl0KCJTdHJpbmciKTsodC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxpLGEpe3ZhciB1PSEhYSYmISFhLnVuc2FmZSxzPSEhYSYmISFhLmVudW1lcmFibGUsYz0hIWEmJiEhYS5ub1RhcmdldEdldDsiZnVuY3Rpb24iPT10eXBlb2YgaSYmKCJzdHJpbmciIT10eXBlb2YgZXx8dyhpLCJuYW1lIil8fFQoaSwibmFtZSIsZSkscihpKS5zb3VyY2U9by5qb2luKCJzdHJpbmciPT10eXBlb2YgZT9lOiIiKSksdCE9PW4/KHU/IWMmJnRbZV0mJihzPSEwKTpkZWxldGUgdFtlXSxzP3RbZV09aTpUKHQsZSxpKSk6cz90W2VdPWk6ayhlLGkpfSkoRnVuY3Rpb24ucHJvdG90eXBlLCJ0b1N0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4iZnVuY3Rpb24iPT10eXBlb2YgdGhpcyYmZSh0aGlzKS5zb3VyY2V8fEYodGhpcyl9KX0pLG50PW4sb3Q9ZnVuY3Rpb24odCl7cmV0dXJuImZ1bmN0aW9uIj09dHlwZW9mIHQ/dDp2b2lkIDB9LGl0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg8Mj9vdChudFt0XSl8fG90KG5bdF0pOm50W3RdJiZudFt0XVtlXXx8blt0XSYmblt0XVtlXX0sYXQ9TWF0aC5jZWlsLHV0PU1hdGguZmxvb3Isc3Q9ZnVuY3Rpb24odCl7cmV0dXJuIGlzTmFOKHQ9K3QpPzA6KHQ+MD91dDphdCkodCl9LGN0PU1hdGgubWluLGZ0PWZ1bmN0aW9uKHQpe3JldHVybiB0PjA/Y3Qoc3QodCksOTAwNzE5OTI1NDc0MDk5MSk6MH0sbHQ9TWF0aC5tYXgsaHQ9TWF0aC5taW4scHQ9ZnVuY3Rpb24odCxlKXt2YXIgcj1zdCh0KTtyZXR1cm4gcjwwP2x0KHIrZSwwKTpodChyLGUpfSxkdD1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxyLG4pe3ZhciBvLGk9ZyhlKSxhPWZ0KGkubGVuZ3RoKSx1PXB0KG4sYSk7aWYodCYmciE9cil7Zm9yKDthPnU7KWlmKChvPWlbdSsrXSkhPW8pcmV0dXJuITB9ZWxzZSBmb3IoO2E+dTt1KyspaWYoKHR8fHUgaW4gaSkmJmlbdV09PT1yKXJldHVybiB0fHx1fHwwO3JldHVybiF0JiYtMX19LHZ0PXtpbmNsdWRlczpkdCghMCksaW5kZXhPZjpkdCghMSl9LGd0PXZ0LmluZGV4T2YseXQ9ZnVuY3Rpb24odCxlKXt2YXIgcixuPWcodCksbz0wLGk9W107Zm9yKHIgaW4gbikhdyhILHIpJiZ3KG4scikmJmkucHVzaChyKTtmb3IoO2UubGVuZ3RoPm87KXcobixyPWVbbysrXSkmJih+Z3QoaSxyKXx8aS5wdXNoKHIpKTtyZXR1cm4gaX0sbXQ9WyJjb25zdHJ1Y3RvciIsImhhc093blByb3BlcnR5IiwiaXNQcm90b3R5cGVPZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwidG9Mb2NhbGVTdHJpbmciLCJ0b1N0cmluZyIsInZhbHVlT2YiXSxidD1tdC5jb25jYXQoImxlbmd0aCIsInByb3RvdHlwZSIpLHd0PXtmOk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzfHxmdW5jdGlvbih0KXtyZXR1cm4geXQodCxidCl9fSxTdD17ZjpPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzfSxFdD1pdCgiUmVmbGVjdCIsIm93bktleXMiKXx8ZnVuY3Rpb24odCl7dmFyIGU9d3QuZihqKHQpKSxyPVN0LmY7cmV0dXJuIHI/ZS5jb25jYXQocih0KSk6ZX0seHQ9ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9RXQoZSksbj1JLmYsbz1SLmYsaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgYT1yW2ldO3codCxhKXx8bih0LGEsbyhlLGEpKX19LEF0PS8jfFwucHJvdG90eXBlXC4vLE90PWZ1bmN0aW9uKHQsZSl7dmFyIHI9anRbUnQodCldO3JldHVybiByPT1JdHx8ciE9UHQmJigiZnVuY3Rpb24iPT10eXBlb2YgZT9vKGUpOiEhZSl9LFJ0PU90Lm5vcm1hbGl6ZT1mdW5jdGlvbih0KXtyZXR1cm4gU3RyaW5nKHQpLnJlcGxhY2UoQXQsIi4iKS50b0xvd2VyQ2FzZSgpfSxqdD1PdC5kYXRhPXt9LFB0PU90Lk5BVElWRT0iTiIsSXQ9T3QuUE9MWUZJTEw9IlAiLFR0PU90LGt0PVIuZixMdD1mdW5jdGlvbih0LGUpe3ZhciByLG8saSxhLHUscz10LnRhcmdldCxjPXQuZ2xvYmFsLGY9dC5zdGF0O2lmKHI9Yz9uOmY/bltzXXx8ayhzLHt9KToobltzXXx8e30pLnByb3RvdHlwZSlmb3IobyBpbiBlKXtpZihhPWVbb10saT10Lm5vVGFyZ2V0R2V0Pyh1PWt0KHIsbykpJiZ1LnZhbHVlOnJbb10sIVR0KGM/bzpzKyhmPyIuIjoiIyIpK28sdC5mb3JjZWQpJiZ2b2lkIDAhPT1pKXtpZih0eXBlb2YgYT09dHlwZW9mIGkpY29udGludWU7eHQoYSxpKX0odC5zaGFtfHxpJiZpLnNoYW0pJiZUKGEsInNoYW0iLCEwKSxydChyLG8sYSx0KX19LFV0PWZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3Qodih0KSl9LE10PU1hdGgubWluLF90PVtdLmNvcHlXaXRoaW58fGZ1bmN0aW9uKHQsZSl7dmFyIHI9VXQodGhpcyksbj1mdChyLmxlbmd0aCksbz1wdCh0LG4pLGk9cHQoZSxuKSxhPWFyZ3VtZW50cy5sZW5ndGg+Mj9hcmd1bWVudHNbMl06dm9pZCAwLHU9TXQoKHZvaWQgMD09PWE/bjpwdChhLG4pKS1pLG4tbykscz0xO2ZvcihpPG8mJm88aSt1JiYocz0tMSxpKz11LTEsbys9dS0xKTt1LS0gPjA7KWkgaW4gcj9yW29dPXJbaV06ZGVsZXRlIHJbb10sbys9cyxpKz1zO3JldHVybiByfSxOdD0hIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMmJiFvKGZ1bmN0aW9uKCl7cmV0dXJuIVN0cmluZyhTeW1ib2woKSl9KSxDdD1OdCYmIVN5bWJvbC5zaGFtJiYic3ltYm9sIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcixGdD16KCJ3a3MiKSxCdD1uLlN5bWJvbCxEdD1DdD9CdDpCdCYmQnQud2l0aG91dFNldHRlcnx8RyxxdD1mdW5jdGlvbih0KXtyZXR1cm4gdyhGdCx0KXx8KEZ0W3RdPU50JiZ3KEJ0LHQpP0J0W3RdOkR0KCJTeW1ib2wuIit0KSksRnRbdF19LHp0PU9iamVjdC5rZXlzfHxmdW5jdGlvbih0KXtyZXR1cm4geXQodCxtdCl9LFd0PWk/T2JqZWN0LmRlZmluZVByb3BlcnRpZXM6ZnVuY3Rpb24odCxlKXtqKHQpO2Zvcih2YXIgcixuPXp0KGUpLG89bi5sZW5ndGgsaT0wO28+aTspSS5mKHQscj1uW2krK10sZVtyXSk7cmV0dXJuIHR9LEt0PWl0KCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIpLEd0PSJwcm90b3R5cGUiLCR0PSJzY3JpcHQiLFZ0PVYoIklFX1BST1RPIiksSHQ9ZnVuY3Rpb24oKXt9LFh0PWZ1bmN0aW9uKHQpe3JldHVybiI8IiskdCsiPiIrdCsiPC8iKyR0KyI+In0sWXQ9ZnVuY3Rpb24oKXt0cnl7dHQ9ZG9jdW1lbnQuZG9tYWluJiZuZXcgQWN0aXZlWE9iamVjdCgiaHRtbGZpbGUiKX1jYXRjaCh0KXt9dmFyIHQsZSxyO1l0PXR0P2Z1bmN0aW9uKHQpe3Qud3JpdGUoWHQoIiIpKSx0LmNsb3NlKCk7dmFyIGU9dC5wYXJlbnRXaW5kb3cuT2JqZWN0O3JldHVybiB0PW51bGwsZX0odHQpOihlPXgoImlmcmFtZSIpLHI9ImphdmEiKyR0KyI6IixlLnN0eWxlLmRpc3BsYXk9Im5vbmUiLEt0LmFwcGVuZENoaWxkKGUpLGUuc3JjPVN0cmluZyhyKSwodD1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQpLm9wZW4oKSx0LndyaXRlKFh0KCJkb2N1bWVudC5GPU9iamVjdCIpKSx0LmNsb3NlKCksdC5GKTtmb3IodmFyIG49bXQubGVuZ3RoO24tLTspZGVsZXRlIFl0W0d0XVttdFtuXV07cmV0dXJuIFl0KCl9O0hbVnRdPSEwO3ZhciBKdD1PYmplY3QuY3JlYXRlfHxmdW5jdGlvbih0LGUpe3ZhciByO3JldHVybiBudWxsIT09dD8oSHRbR3RdPWoodCkscj1uZXcgSHQsSHRbR3RdPW51bGwscltWdF09dCk6cj1ZdCgpLHZvaWQgMD09PWU/cjpXdChyLGUpfSxRdD1xdCgidW5zY29wYWJsZXMiKSxadD1BcnJheS5wcm90b3R5cGU7bnVsbD09WnRbUXRdJiZJLmYoWnQsUXQse2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTpKdChudWxsKX0pO3ZhciB0ZT1mdW5jdGlvbih0KXtadFtRdF1bdF09ITB9O0x0KHt0YXJnZXQ6IkFycmF5Iixwcm90bzohMH0se2NvcHlXaXRoaW46X3R9KSx0ZSgiY29weVdpdGhpbiIpO3ZhciBlZT1mdW5jdGlvbih0KXtpZigiZnVuY3Rpb24iIT10eXBlb2YgdCl0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKHQpKyIgaXMgbm90IGEgZnVuY3Rpb24iKTtyZXR1cm4gdH0scmU9ZnVuY3Rpb24odCxlLHIpe2lmKGVlKHQpLHZvaWQgMD09PWUpcmV0dXJuIHQ7c3dpdGNoKHIpe2Nhc2UgMDpyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdC5jYWxsKGUpfTtjYXNlIDE6cmV0dXJuIGZ1bmN0aW9uKHIpe3JldHVybiB0LmNhbGwoZSxyKX07Y2FzZSAyOnJldHVybiBmdW5jdGlvbihyLG4pe3JldHVybiB0LmNhbGwoZSxyLG4pfTtjYXNlIDM6cmV0dXJuIGZ1bmN0aW9uKHIsbixvKXtyZXR1cm4gdC5jYWxsKGUscixuLG8pfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdC5hcHBseShlLGFyZ3VtZW50cyl9fSxuZT1GdW5jdGlvbi5jYWxsLG9lPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gcmUobmUsblt0XS5wcm90b3R5cGVbZV0scil9O29lKCJBcnJheSIsImNvcHlXaXRoaW4iKSxMdCh7dGFyZ2V0OiJBcnJheSIscHJvdG86ITB9LHtmaWxsOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1VdCh0aGlzKSxyPWZ0KGUubGVuZ3RoKSxuPWFyZ3VtZW50cy5sZW5ndGgsbz1wdChuPjE/YXJndW1lbnRzWzFdOnZvaWQgMCxyKSxpPW4+Mj9hcmd1bWVudHNbMl06dm9pZCAwLGE9dm9pZCAwPT09aT9yOnB0KGkscik7YT5vOyllW28rK109dDtyZXR1cm4gZX19KSx0ZSgiZmlsbCIpLG9lKCJBcnJheSIsImZpbGwiKTt2YXIgaWU9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24odCl7cmV0dXJuIkFycmF5Ij09aCh0KX0sYWU9cXQoInNwZWNpZXMiKSx1ZT1mdW5jdGlvbih0LGUpe3ZhciByO3JldHVybiBpZSh0KSYmKCJmdW5jdGlvbiIhPXR5cGVvZihyPXQuY29uc3RydWN0b3IpfHxyIT09QXJyYXkmJiFpZShyLnByb3RvdHlwZSk/eShyKSYmbnVsbD09PShyPXJbYWVdKSYmKHI9dm9pZCAwKTpyPXZvaWQgMCksbmV3KHZvaWQgMD09PXI/QXJyYXk6cikoMD09PWU/MDplKX0sc2U9W10ucHVzaCxjZT1mdW5jdGlvbih0KXt2YXIgZT0xPT10LHI9Mj09dCxuPTM9PXQsbz00PT10LGk9Nj09dCxhPTU9PXR8fGk7cmV0dXJuIGZ1bmN0aW9uKHUscyxjLGYpe2Zvcih2YXIgbCxoLHA9VXQodSksdj1kKHApLGc9cmUocyxjLDMpLHk9ZnQodi5sZW5ndGgpLG09MCxiPWZ8fHVlLHc9ZT9iKHUseSk6cj9iKHUsMCk6dm9pZCAwO3k+bTttKyspaWYoKGF8fG0gaW4gdikmJihoPWcobD12W21dLG0scCksdCkpaWYoZSl3W21dPWg7ZWxzZSBpZihoKXN3aXRjaCh0KXtjYXNlIDM6cmV0dXJuITA7Y2FzZSA1OnJldHVybiBsO2Nhc2UgNjpyZXR1cm4gbTtjYXNlIDI6c2UuY2FsbCh3LGwpfWVsc2UgaWYobylyZXR1cm4hMTtyZXR1cm4gaT8tMTpufHxvP286d319LGZlPXtmb3JFYWNoOmNlKDApLG1hcDpjZSgxKSxmaWx0ZXI6Y2UoMiksc29tZTpjZSgzKSxldmVyeTpjZSg0KSxmaW5kOmNlKDUpLGZpbmRJbmRleDpjZSg2KX0sbGU9T2JqZWN0LmRlZmluZVByb3BlcnR5LGhlPXt9LHBlPWZ1bmN0aW9uKHQpe3Rocm93IHR9LGRlPWZ1bmN0aW9uKHQsZSl7aWYodyhoZSx0KSlyZXR1cm4gaGVbdF07ZXx8KGU9e30pO3ZhciByPVtdW3RdLG49ISF3KGUsIkFDQ0VTU09SUyIpJiZlLkFDQ0VTU09SUyxhPXcoZSwwKT9lWzBdOnBlLHU9dyhlLDEpP2VbMV06dm9pZCAwO3JldHVybiBoZVt0XT0hIXImJiFvKGZ1bmN0aW9uKCl7aWYobiYmIWkpcmV0dXJuITA7dmFyIHQ9e2xlbmd0aDotMX07bj9sZSh0LDEse2VudW1lcmFibGU6ITAsZ2V0OnBlfSk6dFsxXT0xLHIuY2FsbCh0LGEsdSl9KX0sdmU9ZmUuZmluZCxnZT0iZmluZCIseWU9ITAsbWU9ZGUoZ2UpO2dlIGluW10mJkFycmF5KDEpW2dlXShmdW5jdGlvbigpe3llPSExfSksTHQoe3RhcmdldDoiQXJyYXkiLHByb3RvOiEwLGZvcmNlZDp5ZXx8IW1lfSx7ZmluZDpmdW5jdGlvbih0KXtyZXR1cm4gdmUodGhpcyx0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX19KSx0ZShnZSksb2UoIkFycmF5IiwiZmluZCIpO3ZhciBiZT1mZS5maW5kSW5kZXgsd2U9ImZpbmRJbmRleCIsU2U9ITAsRWU9ZGUod2UpO3dlIGluW10mJkFycmF5KDEpW3dlXShmdW5jdGlvbigpe1NlPSExfSksTHQoe3RhcmdldDoiQXJyYXkiLHByb3RvOiEwLGZvcmNlZDpTZXx8IUVlfSx7ZmluZEluZGV4OmZ1bmN0aW9uKHQpe3JldHVybiBiZSh0aGlzLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pLHRlKHdlKSxvZSgiQXJyYXkiLCJmaW5kSW5kZXgiKTt2YXIgeGU9ZnVuY3Rpb24odCxlLHIsbixvLGksYSx1KXtmb3IodmFyIHMsYz1vLGY9MCxsPSEhYSYmcmUoYSx1LDMpO2Y8bjspe2lmKGYgaW4gcil7aWYocz1sP2wocltmXSxmLGUpOnJbZl0saT4wJiZpZShzKSljPXhlKHQsZSxzLGZ0KHMubGVuZ3RoKSxjLGktMSktMTtlbHNle2lmKGM+PTkwMDcxOTkyNTQ3NDA5OTEpdGhyb3cgVHlwZUVycm9yKCJFeGNlZWQgdGhlIGFjY2VwdGFibGUgYXJyYXkgbGVuZ3RoIik7dFtjXT1zfWMrK31mKyt9cmV0dXJuIGN9LEFlPXhlO0x0KHt0YXJnZXQ6IkFycmF5Iixwcm90bzohMH0se2ZsYXRNYXA6ZnVuY3Rpb24odCl7dmFyIGUscj1VdCh0aGlzKSxuPWZ0KHIubGVuZ3RoKTtyZXR1cm4gZWUodCksKGU9dWUociwwKSkubGVuZ3RoPUFlKGUscixyLG4sMCwxLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApLGV9fSksdGUoImZsYXRNYXAiKSxvZSgiQXJyYXkiLCJmbGF0TWFwIiksTHQoe3RhcmdldDoiQXJyYXkiLHByb3RvOiEwfSx7ZmxhdDpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg/YXJndW1lbnRzWzBdOnZvaWQgMCxlPVV0KHRoaXMpLHI9ZnQoZS5sZW5ndGgpLG49dWUoZSwwKTtyZXR1cm4gbi5sZW5ndGg9QWUobixlLGUsciwwLHZvaWQgMD09PXQ/MTpzdCh0KSksbn19KSx0ZSgiZmxhdCIpLG9lKCJBcnJheSIsImZsYXQiKTt2YXIgT2UsUmUsamUsUGU9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUscil7dmFyIG4sbyxpPVN0cmluZyh2KGUpKSxhPXN0KHIpLHU9aS5sZW5ndGg7cmV0dXJuIGE8MHx8YT49dT90PyIiOnZvaWQgMDoobj1pLmNoYXJDb2RlQXQoYSkpPDU1Mjk2fHxuPjU2MzE5fHxhKzE9PT11fHwobz1pLmNoYXJDb2RlQXQoYSsxKSk8NTYzMjB8fG8+NTczNDM/dD9pLmNoYXJBdChhKTpuOnQ/aS5zbGljZShhLGErMik6by01NjMyMCsobi01NTI5Njw8MTApKzY1NTM2fX0sSWU9e2NvZGVBdDpQZSghMSksY2hhckF0OlBlKCEwKX0sVGU9IW8oZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1udWxsLE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgdCkhPT10LnByb3RvdHlwZX0pLGtlPVYoIklFX1BST1RPIiksTGU9T2JqZWN0LnByb3RvdHlwZSxVZT1UZT9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24odCl7cmV0dXJuIHQ9VXQodCksdyh0LGtlKT90W2tlXToiZnVuY3Rpb24iPT10eXBlb2YgdC5jb25zdHJ1Y3RvciYmdCBpbnN0YW5jZW9mIHQuY29uc3RydWN0b3I/dC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU6dCBpbnN0YW5jZW9mIE9iamVjdD9MZTpudWxsfSxNZT1xdCgiaXRlcmF0b3IiKSxfZT0hMTtbXS5rZXlzJiYoIm5leHQiaW4oamU9W10ua2V5cygpKT8oUmU9VWUoVWUoamUpKSkhPT1PYmplY3QucHJvdG90eXBlJiYoT2U9UmUpOl9lPSEwKSxudWxsPT1PZSYmKE9lPXt9KSx3KE9lLE1lKXx8VChPZSxNZSxmdW5jdGlvbigpe3JldHVybiB0aGlzfSk7dmFyIE5lPXtJdGVyYXRvclByb3RvdHlwZTpPZSxCVUdHWV9TQUZBUklfSVRFUkFUT1JTOl9lfSxDZT1JLmYsRmU9cXQoInRvU3RyaW5nVGFnIiksQmU9ZnVuY3Rpb24odCxlLHIpe3QmJiF3KHQ9cj90OnQucHJvdG90eXBlLEZlKSYmQ2UodCxGZSx7Y29uZmlndXJhYmxlOiEwLHZhbHVlOmV9KX0sRGU9e30scWU9TmUuSXRlcmF0b3JQcm90b3R5cGUsemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sV2U9ZnVuY3Rpb24odCxlLHIpe3ZhciBuPWUrIiBJdGVyYXRvciI7cmV0dXJuIHQucHJvdG90eXBlPUp0KHFlLHtuZXh0OmYoMSxyKX0pLEJlKHQsbiwhMSksRGVbbl09emUsdH0sS2U9ZnVuY3Rpb24odCl7aWYoIXkodCkmJm51bGwhPT10KXRocm93IFR5cGVFcnJvcigiQ2FuJ3Qgc2V0ICIrU3RyaW5nKHQpKyIgYXMgYSBwcm90b3R5cGUiKTtyZXR1cm4gdH0sR2U9T2JqZWN0LnNldFByb3RvdHlwZU9mfHwoIl9fcHJvdG9fXyJpbnt9P2Z1bmN0aW9uKCl7dmFyIHQsZT0hMSxyPXt9O3RyeXsodD1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsIl9fcHJvdG9fXyIpLnNldCkuY2FsbChyLFtdKSxlPXIgaW5zdGFuY2VvZiBBcnJheX1jYXRjaCh0KXt9cmV0dXJuIGZ1bmN0aW9uKHIsbil7cmV0dXJuIGoociksS2UobiksZT90LmNhbGwocixuKTpyLl9fcHJvdG9fXz1uLHJ9fSgpOnZvaWQgMCksJGU9TmUuSXRlcmF0b3JQcm90b3R5cGUsVmU9TmUuQlVHR1lfU0FGQVJJX0lURVJBVE9SUyxIZT1xdCgiaXRlcmF0b3IiKSxYZT0ia2V5cyIsWWU9InZhbHVlcyIsSmU9ImVudHJpZXMiLFFlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LFplPWZ1bmN0aW9uKHQsZSxyLG4sbyxpLGEpe1dlKHIsZSxuKTt2YXIgdSxzLGMsZj1mdW5jdGlvbih0KXtpZih0PT09byYmdilyZXR1cm4gdjtpZighVmUmJnQgaW4gcClyZXR1cm4gcFt0XTtzd2l0Y2godCl7Y2FzZSBYZTpjYXNlIFllOmNhc2UgSmU6cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyByKHRoaXMsdCl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgcih0aGlzKX19LGw9ZSsiIEl0ZXJhdG9yIixoPSExLHA9dC5wcm90b3R5cGUsZD1wW0hlXXx8cFsiQEBpdGVyYXRvciJdfHxvJiZwW29dLHY9IVZlJiZkfHxmKG8pLGc9IkFycmF5Ij09ZSYmcC5lbnRyaWVzfHxkO2lmKGcmJih1PVVlKGcuY2FsbChuZXcgdCkpLCRlIT09T2JqZWN0LnByb3RvdHlwZSYmdS5uZXh0JiYoVWUodSkhPT0kZSYmKEdlP0dlKHUsJGUpOiJmdW5jdGlvbiIhPXR5cGVvZiB1W0hlXSYmVCh1LEhlLFFlKSksQmUodSxsLCEwKSkpLG89PVllJiZkJiZkLm5hbWUhPT1ZZSYmKGg9ITAsdj1mdW5jdGlvbigpe3JldHVybiBkLmNhbGwodGhpcyl9KSxwW0hlXSE9PXYmJlQocCxIZSx2KSxEZVtlXT12LG8paWYocz17dmFsdWVzOmYoWWUpLGtleXM6aT92OmYoWGUpLGVudHJpZXM6ZihKZSl9LGEpZm9yKGMgaW4gcykoVmV8fGh8fCEoYyBpbiBwKSkmJnJ0KHAsYyxzW2NdKTtlbHNlIEx0KHt0YXJnZXQ6ZSxwcm90bzohMCxmb3JjZWQ6VmV8fGh9LHMpO3JldHVybiBzfSx0cj1JZS5jaGFyQXQsZXI9IlN0cmluZyBJdGVyYXRvciIscnI9ZXQuc2V0LG5yPWV0LmdldHRlckZvcihlcik7WmUoU3RyaW5nLCJTdHJpbmciLGZ1bmN0aW9uKHQpe3JyKHRoaXMse3R5cGU6ZXIsc3RyaW5nOlN0cmluZyh0KSxpbmRleDowfSl9LGZ1bmN0aW9uKCl7dmFyIHQsZT1ucih0aGlzKSxyPWUuc3RyaW5nLG49ZS5pbmRleDtyZXR1cm4gbj49ci5sZW5ndGg/e3ZhbHVlOnZvaWQgMCxkb25lOiEwfToodD10cihyLG4pLGUuaW5kZXgrPXQubGVuZ3RoLHt2YWx1ZTp0LGRvbmU6ITF9KX0pO3ZhciBvcj1mdW5jdGlvbih0LGUscixuKXt0cnl7cmV0dXJuIG4/ZShqKHIpWzBdLHJbMV0pOmUocil9Y2F0Y2goZSl7dmFyIG89dC5yZXR1cm47dGhyb3cgdm9pZCAwIT09byYmaihvLmNhbGwodCkpLGV9fSxpcj1xdCgiaXRlcmF0b3IiKSxhcj1BcnJheS5wcm90b3R5cGUsdXI9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXQmJihEZS5BcnJheT09PXR8fGFyW2lyXT09PXQpfSxzcj1mdW5jdGlvbih0LGUscil7dmFyIG49bShlKTtuIGluIHQ/SS5mKHQsbixmKDAscikpOnRbbl09cn0sY3I9e307Y3JbcXQoInRvU3RyaW5nVGFnIildPSJ6Ijt2YXIgZnI9IltvYmplY3Qgel0iPT09U3RyaW5nKGNyKSxscj1xdCgidG9TdHJpbmdUYWciKSxocj0iQXJndW1lbnRzIj09aChmdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHN9KCkpLHByPWZyP2g6ZnVuY3Rpb24odCl7dmFyIGUscixuO3JldHVybiB2b2lkIDA9PT10PyJVbmRlZmluZWQiOm51bGw9PT10PyJOdWxsIjoic3RyaW5nIj09dHlwZW9mKHI9ZnVuY3Rpb24odCxlKXt0cnl7cmV0dXJuIHRbZV19Y2F0Y2godCl7fX0oZT1PYmplY3QodCksbHIpKT9yOmhyP2goZSk6Ik9iamVjdCI9PShuPWgoZSkpJiYiZnVuY3Rpb24iPT10eXBlb2YgZS5jYWxsZWU/IkFyZ3VtZW50cyI6bn0sZHI9cXQoIml0ZXJhdG9yIiksdnI9ZnVuY3Rpb24odCl7aWYobnVsbCE9dClyZXR1cm4gdFtkcl18fHRbIkBAaXRlcmF0b3IiXXx8RGVbcHIodCldfSxncj1mdW5jdGlvbih0KXt2YXIgZSxyLG4sbyxpLGEsdT1VdCh0KSxzPSJmdW5jdGlvbiI9PXR5cGVvZiB0aGlzP3RoaXM6QXJyYXksYz1hcmd1bWVudHMubGVuZ3RoLGY9Yz4xP2FyZ3VtZW50c1sxXTp2b2lkIDAsbD12b2lkIDAhPT1mLGg9dnIodSkscD0wO2lmKGwmJihmPXJlKGYsYz4yP2FyZ3VtZW50c1syXTp2b2lkIDAsMikpLG51bGw9PWh8fHM9PUFycmF5JiZ1cihoKSlmb3Iocj1uZXcgcyhlPWZ0KHUubGVuZ3RoKSk7ZT5wO3ArKylhPWw/Zih1W3BdLHApOnVbcF0sc3IocixwLGEpO2Vsc2UgZm9yKGk9KG89aC5jYWxsKHUpKS5uZXh0LHI9bmV3IHM7IShuPWkuY2FsbChvKSkuZG9uZTtwKyspYT1sP29yKG8sZixbbi52YWx1ZSxwXSwhMCk6bi52YWx1ZSxzcihyLHAsYSk7cmV0dXJuIHIubGVuZ3RoPXAscn0seXI9cXQoIml0ZXJhdG9yIiksbXI9ITE7dHJ5e3ZhciBicj0wLHdyPXtuZXh0OmZ1bmN0aW9uKCl7cmV0dXJue2RvbmU6ISFicisrfX0scmV0dXJuOmZ1bmN0aW9uKCl7bXI9ITB9fTt3clt5cl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sQXJyYXkuZnJvbSh3cixmdW5jdGlvbigpe3Rocm93IDJ9KX1jYXRjaCh0KXt9dmFyIFNyPWZ1bmN0aW9uKHQsZSl7aWYoIWUmJiFtcilyZXR1cm4hMTt2YXIgcj0hMTt0cnl7dmFyIG49e307blt5cl09ZnVuY3Rpb24oKXtyZXR1cm57bmV4dDpmdW5jdGlvbigpe3JldHVybntkb25lOnI9ITB9fX19LHQobil9Y2F0Y2godCl7fXJldHVybiByfSxFcj0hU3IoZnVuY3Rpb24odCl7QXJyYXkuZnJvbSh0KX0pO0x0KHt0YXJnZXQ6IkFycmF5IixzdGF0OiEwLGZvcmNlZDpFcn0se2Zyb206Z3J9KTt2YXIgeHI9dnQuaW5jbHVkZXMsQXI9ZGUoImluZGV4T2YiLHtBQ0NFU1NPUlM6ITAsMTowfSk7THQoe3RhcmdldDoiQXJyYXkiLHByb3RvOiEwLGZvcmNlZDohQXJ9LHtpbmNsdWRlczpmdW5jdGlvbih0KXtyZXR1cm4geHIodGhpcyx0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX19KSx0ZSgiaW5jbHVkZXMiKSxvZSgiQXJyYXkiLCJpbmNsdWRlcyIpO3ZhciBPcj0iQXJyYXkgSXRlcmF0b3IiLFJyPWV0LnNldCxqcj1ldC5nZXR0ZXJGb3IoT3IpLFByPVplKEFycmF5LCJBcnJheSIsZnVuY3Rpb24odCxlKXtScih0aGlzLHt0eXBlOk9yLHRhcmdldDpnKHQpLGluZGV4OjAsa2luZDplfSl9LGZ1bmN0aW9uKCl7dmFyIHQ9anIodGhpcyksZT10LnRhcmdldCxyPXQua2luZCxuPXQuaW5kZXgrKztyZXR1cm4hZXx8bj49ZS5sZW5ndGg/KHQudGFyZ2V0PXZvaWQgMCx7dmFsdWU6dm9pZCAwLGRvbmU6ITB9KToia2V5cyI9PXI/e3ZhbHVlOm4sZG9uZTohMX06InZhbHVlcyI9PXI/e3ZhbHVlOmVbbl0sZG9uZTohMX06e3ZhbHVlOltuLGVbbl1dLGRvbmU6ITF9fSwidmFsdWVzIik7RGUuQXJndW1lbnRzPURlLkFycmF5LHRlKCJrZXlzIiksdGUoInZhbHVlcyIpLHRlKCJlbnRyaWVzIiksb2UoIkFycmF5IiwidmFsdWVzIik7dmFyIElyPW8oZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiEoQXJyYXkub2YuY2FsbCh0KWluc3RhbmNlb2YgdCl9KTtMdCh7dGFyZ2V0OiJBcnJheSIsc3RhdDohMCxmb3JjZWQ6SXJ9LHtvZjpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9YXJndW1lbnRzLmxlbmd0aCxyPW5ldygiZnVuY3Rpb24iPT10eXBlb2YgdGhpcz90aGlzOkFycmF5KShlKTtlPnQ7KXNyKHIsdCxhcmd1bWVudHNbdCsrXSk7cmV0dXJuIHIubGVuZ3RoPWUscn19KTt2YXIgVHI9cXQoImhhc0luc3RhbmNlIiksa3I9RnVuY3Rpb24ucHJvdG90eXBlO1RyIGluIGtyfHxJLmYoa3IsVHIse3ZhbHVlOmZ1bmN0aW9uKHQpe2lmKCJmdW5jdGlvbiIhPXR5cGVvZiB0aGlzfHwheSh0KSlyZXR1cm4hMTtpZigheSh0aGlzLnByb3RvdHlwZSkpcmV0dXJuIHQgaW5zdGFuY2VvZiB0aGlzO2Zvcig7dD1VZSh0KTspaWYodGhpcy5wcm90b3R5cGU9PT10KXJldHVybiEwO3JldHVybiExfX0pLHF0KCJoYXNJbnN0YW5jZSIpO3ZhciBMcj1GdW5jdGlvbi5wcm90b3R5cGUsVXI9THIudG9TdHJpbmcsTXI9L15ccypmdW5jdGlvbiAoW14gKF0qKS8sX3I9Im5hbWUiO2kmJiEoX3IgaW4gTHIpJiYoMCxJLmYpKExyLF9yLHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7dHJ5e3JldHVybiBVci5jYWxsKHRoaXMpLm1hdGNoKE1yKVsxXX1jYXRjaCh0KXtyZXR1cm4iIn19fSk7dmFyIE5yPSFvKGZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5pc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSl9KSxDcj1lKGZ1bmN0aW9uKHQpe3ZhciBlPUkuZixyPUcoIm1ldGEiKSxuPTAsbz1PYmplY3QuaXNFeHRlbnNpYmxlfHxmdW5jdGlvbigpe3JldHVybiEwfSxpPWZ1bmN0aW9uKHQpe2UodCxyLHt2YWx1ZTp7b2JqZWN0SUQ6Ik8iKyArK24sd2Vha0RhdGE6e319fSl9LGE9dC5leHBvcnRzPXtSRVFVSVJFRDohMSxmYXN0S2V5OmZ1bmN0aW9uKHQsZSl7aWYoIXkodCkpcmV0dXJuInN5bWJvbCI9PXR5cGVvZiB0P3Q6KCJzdHJpbmciPT10eXBlb2YgdD8iUyI6IlAiKSt0O2lmKCF3KHQscikpe2lmKCFvKHQpKXJldHVybiJGIjtpZighZSlyZXR1cm4iRSI7aSh0KX1yZXR1cm4gdFtyXS5vYmplY3RJRH0sZ2V0V2Vha0RhdGE6ZnVuY3Rpb24odCxlKXtpZighdyh0LHIpKXtpZighbyh0KSlyZXR1cm4hMDtpZighZSlyZXR1cm4hMTtpKHQpfXJldHVybiB0W3JdLndlYWtEYXRhfSxvbkZyZWV6ZTpmdW5jdGlvbih0KXtyZXR1cm4gTnImJmEuUkVRVUlSRUQmJm8odCkmJiF3KHQscikmJmkodCksdH19O0hbcl09ITB9KSxGcj1lKGZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKHQsZSl7dGhpcy5zdG9wcGVkPXQsdGhpcy5yZXN1bHQ9ZX0scj10LmV4cG9ydHM9ZnVuY3Rpb24odCxyLG4sbyxpKXt2YXIgYSx1LHMsYyxmLGwsaCxwPXJlKHIsbixvPzI6MSk7aWYoaSlhPXQ7ZWxzZXtpZigiZnVuY3Rpb24iIT10eXBlb2YodT12cih0KSkpdGhyb3cgVHlwZUVycm9yKCJUYXJnZXQgaXMgbm90IGl0ZXJhYmxlIik7aWYodXIodSkpe2ZvcihzPTAsYz1mdCh0Lmxlbmd0aCk7Yz5zO3MrKylpZigoZj1vP3AoaihoPXRbc10pWzBdLGhbMV0pOnAodFtzXSkpJiZmIGluc3RhbmNlb2YgZSlyZXR1cm4gZjtyZXR1cm4gbmV3IGUoITEpfWE9dS5jYWxsKHQpfWZvcihsPWEubmV4dDshKGg9bC5jYWxsKGEpKS5kb25lOylpZigib2JqZWN0Ij09dHlwZW9mKGY9b3IoYSxwLGgudmFsdWUsbykpJiZmJiZmIGluc3RhbmNlb2YgZSlyZXR1cm4gZjtyZXR1cm4gbmV3IGUoITEpfTtyLnN0b3A9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKCEwLHQpfX0pLEJyPWZ1bmN0aW9uKHQsZSxyKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBUeXBlRXJyb3IoIkluY29ycmVjdCAiKyhyP3IrIiAiOiIiKSsiaW52b2NhdGlvbiIpO3JldHVybiB0fSxEcj1mdW5jdGlvbih0LGUscil7dmFyIG4sbztyZXR1cm4gR2UmJiJmdW5jdGlvbiI9PXR5cGVvZihuPWUuY29uc3RydWN0b3IpJiZuIT09ciYmeShvPW4ucHJvdG90eXBlKSYmbyE9PXIucHJvdG90eXBlJiZHZSh0LG8pLHR9LHFyPWZ1bmN0aW9uKHQsZSxyKXt2YXIgaT0tMSE9PXQuaW5kZXhPZigiTWFwIiksYT0tMSE9PXQuaW5kZXhPZigiV2VhayIpLHU9aT8ic2V0IjoiYWRkIixzPW5bdF0sYz1zJiZzLnByb3RvdHlwZSxmPXMsbD17fSxoPWZ1bmN0aW9uKHQpe3ZhciBlPWNbdF07cnQoYyx0LCJhZGQiPT10P2Z1bmN0aW9uKHQpe3JldHVybiBlLmNhbGwodGhpcywwPT09dD8wOnQpLHRoaXN9OiJkZWxldGUiPT10P2Z1bmN0aW9uKHQpe3JldHVybiEoYSYmIXkodCkpJiZlLmNhbGwodGhpcywwPT09dD8wOnQpfToiZ2V0Ij09dD9mdW5jdGlvbih0KXtyZXR1cm4gYSYmIXkodCk/dm9pZCAwOmUuY2FsbCh0aGlzLDA9PT10PzA6dCl9OiJoYXMiPT10P2Z1bmN0aW9uKHQpe3JldHVybiEoYSYmIXkodCkpJiZlLmNhbGwodGhpcywwPT09dD8wOnQpfTpmdW5jdGlvbih0LHIpe3JldHVybiBlLmNhbGwodGhpcywwPT09dD8wOnQsciksdGhpc30pfTtpZihUdCh0LCJmdW5jdGlvbiIhPXR5cGVvZiBzfHwhKGF8fGMuZm9yRWFjaCYmIW8oZnVuY3Rpb24oKXsobmV3IHMpLmVudHJpZXMoKS5uZXh0KCl9KSkpKWY9ci5nZXRDb25zdHJ1Y3RvcihlLHQsaSx1KSxDci5SRVFVSVJFRD0hMDtlbHNlIGlmKFR0KHQsITApKXt2YXIgcD1uZXcgZixkPXBbdV0oYT97fTotMCwxKSE9cCx2PW8oZnVuY3Rpb24oKXtwLmhhcygxKX0pLGc9U3IoZnVuY3Rpb24odCl7bmV3IHModCl9KSxtPSFhJiZvKGZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBzLGU9NTtlLS07KXRbdV0oZSxlKTtyZXR1cm4hdC5oYXMoLTApfSk7Z3x8KChmPWUoZnVuY3Rpb24oZSxyKXtCcihlLGYsdCk7dmFyIG49RHIobmV3IHMsZSxmKTtyZXR1cm4gbnVsbCE9ciYmRnIocixuW3VdLG4saSksbn0pKS5wcm90b3R5cGU9YyxjLmNvbnN0cnVjdG9yPWYpLCh2fHxtKSYmKGgoImRlbGV0ZSIpLGgoImhhcyIpLGkmJmgoImdldCIpKSwobXx8ZCkmJmgodSksYSYmYy5jbGVhciYmZGVsZXRlIGMuY2xlYXJ9cmV0dXJuIGxbdF09ZixMdCh7Z2xvYmFsOiEwLGZvcmNlZDpmIT1zfSxsKSxCZShmLHQpLGF8fHIuc2V0U3Ryb25nKGYsdCxpKSxmfSx6cj1mdW5jdGlvbih0LGUscil7Zm9yKHZhciBuIGluIGUpcnQodCxuLGVbbl0scik7cmV0dXJuIHR9LFdyPXF0KCJzcGVjaWVzIiksS3I9ZnVuY3Rpb24odCl7dmFyIGU9aXQodCk7aSYmZSYmIWVbV3JdJiYoMCxJLmYpKGUsV3Ise2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc319KX0sR3I9SS5mLCRyPUNyLmZhc3RLZXksVnI9ZXQuc2V0LEhyPWV0LmdldHRlckZvcixYcj17Z2V0Q29uc3RydWN0b3I6ZnVuY3Rpb24odCxlLHIsbil7dmFyIG89dChmdW5jdGlvbih0LGEpe0JyKHQsbyxlKSxWcih0LHt0eXBlOmUsaW5kZXg6SnQobnVsbCksZmlyc3Q6dm9pZCAwLGxhc3Q6dm9pZCAwLHNpemU6MH0pLGl8fCh0LnNpemU9MCksbnVsbCE9YSYmRnIoYSx0W25dLHQscil9KSxhPUhyKGUpLHU9ZnVuY3Rpb24odCxlLHIpe3ZhciBuLG8sdT1hKHQpLGM9cyh0LGUpO3JldHVybiBjP2MudmFsdWU9cjoodS5sYXN0PWM9e2luZGV4Om89JHIoZSwhMCksa2V5OmUsdmFsdWU6cixwcmV2aW91czpuPXUubGFzdCxuZXh0OnZvaWQgMCxyZW1vdmVkOiExfSx1LmZpcnN0fHwodS5maXJzdD1jKSxuJiYobi5uZXh0PWMpLGk/dS5zaXplKys6dC5zaXplKyssIkYiIT09byYmKHUuaW5kZXhbb109YykpLHR9LHM9ZnVuY3Rpb24odCxlKXt2YXIgcixuPWEodCksbz0kcihlKTtpZigiRiIhPT1vKXJldHVybiBuLmluZGV4W29dO2ZvcihyPW4uZmlyc3Q7cjtyPXIubmV4dClpZihyLmtleT09ZSlyZXR1cm4gcn07cmV0dXJuIHpyKG8ucHJvdG90eXBlLHtjbGVhcjpmdW5jdGlvbigpe2Zvcih2YXIgdD1hKHRoaXMpLGU9dC5pbmRleCxyPXQuZmlyc3Q7cjspci5yZW1vdmVkPSEwLHIucHJldmlvdXMmJihyLnByZXZpb3VzPXIucHJldmlvdXMubmV4dD12b2lkIDApLGRlbGV0ZSBlW3IuaW5kZXhdLHI9ci5uZXh0O3QuZmlyc3Q9dC5sYXN0PXZvaWQgMCxpP3Quc2l6ZT0wOnRoaXMuc2l6ZT0wfSxkZWxldGU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxyPWEoZSksbj1zKGUsdCk7aWYobil7dmFyIG89bi5uZXh0LHU9bi5wcmV2aW91cztkZWxldGUgci5pbmRleFtuLmluZGV4XSxuLnJlbW92ZWQ9ITAsdSYmKHUubmV4dD1vKSxvJiYoby5wcmV2aW91cz11KSxyLmZpcnN0PT1uJiYoci5maXJzdD1vKSxyLmxhc3Q9PW4mJihyLmxhc3Q9dSksaT9yLnNpemUtLTplLnNpemUtLX1yZXR1cm4hIW59LGZvckVhY2g6ZnVuY3Rpb24odCl7Zm9yKHZhciBlLHI9YSh0aGlzKSxuPXJlKHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDAsMyk7ZT1lP2UubmV4dDpyLmZpcnN0Oylmb3IobihlLnZhbHVlLGUua2V5LHRoaXMpO2UmJmUucmVtb3ZlZDspZT1lLnByZXZpb3VzfSxoYXM6ZnVuY3Rpb24odCl7cmV0dXJuISFzKHRoaXMsdCl9fSksenIoby5wcm90b3R5cGUscj97Z2V0OmZ1bmN0aW9uKHQpe3ZhciBlPXModGhpcyx0KTtyZXR1cm4gZSYmZS52YWx1ZX0sc2V0OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHUodGhpcywwPT09dD8wOnQsZSl9fTp7YWRkOmZ1bmN0aW9uKHQpe3JldHVybiB1KHRoaXMsdD0wPT09dD8wOnQsdCl9fSksaSYmR3Ioby5wcm90b3R5cGUsInNpemUiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYSh0aGlzKS5zaXplfX0pLG99LHNldFN0cm9uZzpmdW5jdGlvbih0LGUscil7dmFyIG49ZSsiIEl0ZXJhdG9yIixvPUhyKGUpLGk9SHIobik7WmUodCxlLGZ1bmN0aW9uKHQsZSl7VnIodGhpcyx7dHlwZTpuLHRhcmdldDp0LHN0YXRlOm8odCksa2luZDplLGxhc3Q6dm9pZCAwfSl9LGZ1bmN0aW9uKCl7Zm9yKHZhciB0PWkodGhpcyksZT10LmtpbmQscj10Lmxhc3Q7ciYmci5yZW1vdmVkOylyPXIucHJldmlvdXM7cmV0dXJuIHQudGFyZ2V0JiYodC5sYXN0PXI9cj9yLm5leHQ6dC5zdGF0ZS5maXJzdCk/ImtleXMiPT1lP3t2YWx1ZTpyLmtleSxkb25lOiExfToidmFsdWVzIj09ZT97dmFsdWU6ci52YWx1ZSxkb25lOiExfTp7dmFsdWU6W3Iua2V5LHIudmFsdWVdLGRvbmU6ITF9Oih0LnRhcmdldD12b2lkIDAse3ZhbHVlOnZvaWQgMCxkb25lOiEwfSl9LHI/ImVudHJpZXMiOiJ2YWx1ZXMiLCFyLCEwKSxLcihlKX19LFlyPXFyKCJNYXAiLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0KHRoaXMsYXJndW1lbnRzLmxlbmd0aD9hcmd1bWVudHNbMF06dm9pZCAwKX19LFhyKTtmcnx8cnQoT2JqZWN0LnByb3RvdHlwZSwidG9TdHJpbmciLGZyP3t9LnRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIltvYmplY3QgIitwcih0aGlzKSsiXSJ9LHt1bnNhZmU6ITB9KTt2YXIgSnI9e0NTU1J1bGVMaXN0OjAsQ1NTU3R5bGVEZWNsYXJhdGlvbjowLENTU1ZhbHVlTGlzdDowLENsaWVudFJlY3RMaXN0OjAsRE9NUmVjdExpc3Q6MCxET01TdHJpbmdMaXN0OjAsRE9NVG9rZW5MaXN0OjEsRGF0YVRyYW5zZmVySXRlbUxpc3Q6MCxGaWxlTGlzdDowLEhUTUxBbGxDb2xsZWN0aW9uOjAsSFRNTENvbGxlY3Rpb246MCxIVE1MRm9ybUVsZW1lbnQ6MCxIVE1MU2VsZWN0RWxlbWVudDowLE1lZGlhTGlzdDowLE1pbWVUeXBlQXJyYXk6MCxOYW1lZE5vZGVNYXA6MCxOb2RlTGlzdDoxLFBhaW50UmVxdWVzdExpc3Q6MCxQbHVnaW46MCxQbHVnaW5BcnJheTowLFNWR0xlbmd0aExpc3Q6MCxTVkdOdW1iZXJMaXN0OjAsU1ZHUGF0aFNlZ0xpc3Q6MCxTVkdQb2ludExpc3Q6MCxTVkdTdHJpbmdMaXN0OjAsU1ZHVHJhbnNmb3JtTGlzdDowLFNvdXJjZUJ1ZmZlckxpc3Q6MCxTdHlsZVNoZWV0TGlzdDowLFRleHRUcmFja0N1ZUxpc3Q6MCxUZXh0VHJhY2tMaXN0OjAsVG91Y2hMaXN0OjB9LFFyPXF0KCJpdGVyYXRvciIpLFpyPXF0KCJ0b1N0cmluZ1RhZyIpLHRuPVByLnZhbHVlcztmb3IodmFyIGVuIGluIEpyKXt2YXIgcm49bltlbl0sbm49cm4mJnJuLnByb3RvdHlwZTtpZihubil7aWYobm5bUXJdIT09dG4pdHJ5e1Qobm4sUXIsdG4pfWNhdGNoKHQpe25uW1FyXT10bn1pZihubltacl18fFQobm4sWnIsZW4pLEpyW2VuXSlmb3IodmFyIG9uIGluIFByKWlmKG5uW29uXSE9PVByW29uXSl0cnl7VChubixvbixQcltvbl0pfWNhdGNoKHQpe25uW29uXT1Qcltvbl19fX12YXIgYW49ZnVuY3Rpb24odCl7dmFyIGUscixuLG8saT1hcmd1bWVudHMubGVuZ3RoLGE9aT4xP2FyZ3VtZW50c1sxXTp2b2lkIDA7cmV0dXJuIGVlKHRoaXMpLChlPXZvaWQgMCE9PWEpJiZlZShhKSxudWxsPT10P25ldyB0aGlzOihyPVtdLGU/KG49MCxvPXJlKGEsaT4yP2FyZ3VtZW50c1syXTp2b2lkIDAsMiksRnIodCxmdW5jdGlvbih0KXtyLnB1c2gobyh0LG4rKykpfSkpOkZyKHQsci5wdXNoLHIpLG5ldyB0aGlzKHIpKX07THQoe3RhcmdldDoiTWFwIixzdGF0OiEwfSx7ZnJvbTphbn0pO3ZhciB1bj1mdW5jdGlvbigpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLGU9bmV3IEFycmF5KHQpO3QtLTspZVt0XT1hcmd1bWVudHNbdF07cmV0dXJuIG5ldyB0aGlzKGUpfTtMdCh7dGFyZ2V0OiJNYXAiLHN0YXQ6ITB9LHtvZjp1bn0pO3ZhciBzbj1mdW5jdGlvbigpe2Zvcih2YXIgdCxlPWoodGhpcykscj1lZShlLmRlbGV0ZSksbj0hMCxvPTAsaT1hcmd1bWVudHMubGVuZ3RoO288aTtvKyspdD1yLmNhbGwoZSxhcmd1bWVudHNbb10pLG49biYmdDtyZXR1cm4hIW59O0x0KHt0YXJnZXQ6Ik1hcCIscHJvdG86ITAscmVhbDohMCxmb3JjZWQ6cX0se2RlbGV0ZUFsbDpmdW5jdGlvbigpe3JldHVybiBzbi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fSk7dmFyIGNuPWZ1bmN0aW9uKHQpe3ZhciBlPXZyKHQpO2lmKCJmdW5jdGlvbiIhPXR5cGVvZiBlKXRocm93IFR5cGVFcnJvcihTdHJpbmcodCkrIiBpcyBub3QgaXRlcmFibGUiKTtyZXR1cm4gaihlLmNhbGwodCkpfSxmbj1mdW5jdGlvbih0KXtyZXR1cm4gTWFwLnByb3RvdHlwZS5lbnRyaWVzLmNhbGwodCl9O0x0KHt0YXJnZXQ6Ik1hcCIscHJvdG86ITAscmVhbDohMCxmb3JjZWQ6cX0se2V2ZXJ5OmZ1bmN0aW9uKHQpe3ZhciBlPWoodGhpcykscj1mbihlKSxuPXJlKHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDAsMyk7cmV0dXJuIUZyKHIsZnVuY3Rpb24odCxyKXtpZighbihyLHQsZSkpcmV0dXJuIEZyLnN0b3AoKX0sdm9pZCAwLCEwLCEwKS5zdG9wcGVkfX0pO3ZhciBsbj1xdCgic3BlY2llcyIpLGhuPWZ1bmN0aW9uKHQsZSl7dmFyIHIsbj1qKHQpLmNvbnN0cnVjdG9yO3JldHVybiB2b2lkIDA9PT1ufHxudWxsPT0ocj1qKG4pW2xuXSk/ZTplZShyKX07THQoe3RhcmdldDoiTWFwIixwcm90bzohMCxyZWFsOiEwLGZvcmNlZDpxfSx7ZmlsdGVyOmZ1bmN0aW9uKHQpe3ZhciBlPWoodGhpcykscj1mbihlKSxuPXJlKHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDAsMyksbz1uZXcoaG4oZSxpdCgiTWFwIikpKSxpPWVlKG8uc2V0KTtyZXR1cm4gRnIocixmdW5jdGlvbih0LHIpe24ocix0LGUpJiZpLmNhbGwobyx0LHIpfSx2b2lkIDAsITAsITApLG99fSksTHQoe3RhcmdldDoiTWFwIixwcm90bzohMCxyZWFsOiEwLGZvcmNlZDpxfSx7ZmluZDpmdW5jdGlvbih0KXt2YXIgZT1qKHRoaXMpLHI9Zm4oZSksbj1yZSh0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwLDMpO3JldHVybiBGcihyLGZ1bmN0aW9uKHQscil7aWYobihyLHQsZSkpcmV0dXJuIEZyLnN0b3Aocil9LHZvaWQgMCwhMCwhMCkucmVzdWx0fX0pLEx0KHt0YXJnZXQ6Ik1hcCIscHJvdG86ITAscmVhbDohMCxmb3JjZWQ6cX0se2ZpbmRLZXk6ZnVuY3Rpb24odCl7dmFyIGU9aih0aGlzKSxyPWZuKGUpLG49cmUodCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCwzKTtyZXR1cm4gRnIocixmdW5jdGlvbih0LHIpe2lmKG4ocix0LGUpKXJldHVybiBGci5zdG9wKHQpfSx2b2lkIDAsITAsITApLnJlc3VsdH19KSxMdCh7dGFyZ2V0OiJNYXAiLHN0YXQ6ITB9LHtncm91cEJ5OmZ1bmN0aW9uKHQsZSl7dmFyIHI9bmV3IHRoaXM7ZWUoZSk7dmFyIG49ZWUoci5oYXMpLG89ZWUoci5nZXQpLGk9ZWUoci5zZXQpO3JldHVybiBGcih0LGZ1bmN0aW9uKHQpe3ZhciBhPWUodCk7bi5jYWxsKHIsYSk/by5jYWxsKHIsYSkucHVzaCh0KTppLmNhbGwocixhLFt0XSl9KSxyfX0pLEx0KHt0YXJnZXQ6Ik1hcCIscHJvdG86ITAscmVhbDohMCxmb3JjZWQ6cX0se2luY2x1ZGVzOmZ1bmN0aW9uKHQpe3JldHVybiBGcihmbihqKHRoaXMpKSxmdW5jdGlvbihlLHIpe2lmKChuPXIpPT09KG89dCl8fG4hPW4mJm8hPW8pcmV0dXJuIEZyLnN0b3AoKTt2YXIgbixvfSx2b2lkIDAsITAsITApLnN0b3BwZWR9fSksTHQoe3RhcmdldDoiTWFwIixzdGF0OiEwfSx7a2V5Qnk6ZnVuY3Rpb24odCxlKXt2YXIgcj1uZXcgdGhpcztlZShlKTt2YXIgbj1lZShyLnNldCk7cmV0dXJuIEZyKHQsZnVuY3Rpb24odCl7bi5jYWxsKHIsZSh0KSx0KX0pLHJ9fSksTHQoe3RhcmdldDoiTWFwIixwcm90bzohMCxyZWFsOiEwLGZvcmNlZDpxfSx7a2V5T2Y6ZnVuY3Rpb24odCl7cmV0dXJuIEZyKGZuKGoodGhpcykpLGZ1bmN0aW9uKGUscil7aWYocj09PXQpcmV0dXJuIEZyLnN0b3AoZSl9LHZvaWQgMCwhMCwhMCkucmVzdWx0fX0pLEx0KHt0YXJnZXQ6Ik1hcCIscHJvdG86ITAscmVhbDohMCxmb3JjZWQ6cX0se21hcEtleXM6ZnVuY3Rpb24odCl7dmFyIGU9aih0aGlzKSxyPWZuKGUpLG49cmUodCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCwzKSxvPW5ldyhobihlLGl0KCJNYXAiKSkpLGk9ZWUoby5zZXQpO3JldHVybiBGcihyLGZ1bmN0aW9uKHQscil7aS5jYWxsKG8sbihyLHQsZSkscil9LHZvaWQgMCwhMCwhMCksb319KSxMdCh7dGFyZ2V0OiJNYXAiLHByb3RvOiEwLHJlYWw6ITAsZm9yY2VkOnF9LHttYXBWYWx1ZXM6ZnVuY3Rpb24odCl7dmFyIGU9aih0aGlzKSxyPWZuKGUpLG49cmUodCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCwzKSxvPW5ldyhobihlLGl0KCJNYXAiKSkpLGk9ZWUoby5zZXQpO3JldHVybiBGcihyLGZ1bmN0aW9uKHQscil7aS5jYWxsKG8sdCxuKHIsdCxlKSl9LHZvaWQgMCwhMCwhMCksb319KSxMdCh7dGFyZ2V0OiJNYXAiLHByb3RvOiEwLHJlYWw6ITAsZm9yY2VkOnF9LHttZXJnZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9aih0aGlzKSxyPWVlKGUuc2V0KSxuPTA7bjxhcmd1bWVudHMubGVuZ3RoOylGcihhcmd1bWVudHNbbisrXSxyLGUsITApO3JldHVybiBlfX0pLEx0KHt0YXJnZXQ6Ik1hcCIscHJvdG86ITAscmVhbDohMCxmb3JjZWQ6cX0se3JlZHVjZTpmdW5jdGlvbih0KXt2YXIgZT1qKHRoaXMpLHI9Zm4oZSksbj1hcmd1bWVudHMubGVuZ3RoPDIsbz1uP3ZvaWQgMDphcmd1bWVudHNbMV07aWYoZWUodCksRnIocixmdW5jdGlvbihyLGkpe24/KG49ITEsbz1pKTpvPXQobyxpLHIsZSl9LHZvaWQgMCwhMCwhMCksbil0aHJvdyBUeXBlRXJyb3IoIlJlZHVjZSBvZiBlbXB0eSBtYXAgd2l0aCBubyBpbml0aWFsIHZhbHVlIik7cmV0dXJuIG99fSksTHQoe3RhcmdldDoiTWFwIixwcm90bzohMCxyZWFsOiEwLGZvcmNlZDpxfSx7c29tZTpmdW5jdGlvbih0KXt2YXIgZT1qKHRoaXMpLHI9Zm4oZSksbj1yZSh0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwLDMpO3JldHVybiBGcihyLGZ1bmN0aW9uKHQscil7aWYobihyLHQsZSkpcmV0dXJuIEZyLnN0b3AoKX0sdm9pZCAwLCEwLCEwKS5zdG9wcGVkfX0pLEx0KHt0YXJnZXQ6Ik1hcCIscHJvdG86ITAscmVhbDohMCxmb3JjZWQ6cX0se3VwZGF0ZTpmdW5jdGlvbih0LGUpe3ZhciByPWoodGhpcyksbj1hcmd1bWVudHMubGVuZ3RoO2VlKGUpO3ZhciBvPXIuaGFzKHQpO2lmKCFvJiZuPDMpdGhyb3cgVHlwZUVycm9yKCJVcGRhdGluZyBhYnNlbnQgdmFsdWUiKTt2YXIgaT1vP3IuZ2V0KHQpOmVlKG4+Mj9hcmd1bWVudHNbMl06dm9pZCAwKSh0LHIpO3JldHVybiByLnNldCh0LGUoaSx0LHIpKSxyfX0pO3ZhciBwbj1mdW5jdGlvbih0LGUpe3ZhciByLG49aih0aGlzKSxvPWFyZ3VtZW50cy5sZW5ndGg+Mj9hcmd1bWVudHNbMl06dm9pZCAwO2lmKCJmdW5jdGlvbiIhPXR5cGVvZiBlJiYiZnVuY3Rpb24iIT10eXBlb2Ygbyl0aHJvdyBUeXBlRXJyb3IoIkF0IGxlYXN0IG9uZSBjYWxsYmFjayByZXF1aXJlZCIpO3JldHVybiBuLmhhcyh0KT8ocj1uLmdldCh0KSwiZnVuY3Rpb24iPT10eXBlb2YgZSYmKHI9ZShyKSxuLnNldCh0LHIpKSk6ImZ1bmN0aW9uIj09dHlwZW9mIG8mJihyPW8oKSxuLnNldCh0LHIpKSxyfTtMdCh7dGFyZ2V0OiJNYXAiLHByb3RvOiEwLHJlYWw6ITAsZm9yY2VkOnF9LHt1cHNlcnQ6cG59KSxMdCh7dGFyZ2V0OiJNYXAiLHByb3RvOiEwLHJlYWw6ITAsZm9yY2VkOnF9LHt1cGRhdGVPckluc2VydDpwbn0pO3ZhciBkbj0iXHRcblx2XGZcciDCoOGagOKAgOKAgeKAguKAg+KAhOKAheKAhuKAh+KAiOKAieKAiuKAr+KBn+OAgFx1MjAyOFx1MjAyOVx1ZmVmZiIsdm49IlsiK2RuKyJdIixnbj1SZWdFeHAoIl4iK3ZuK3ZuKyIqIikseW49UmVnRXhwKHZuK3ZuKyIqJCIpLG1uPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgcj1TdHJpbmcodihlKSk7cmV0dXJuIDEmdCYmKHI9ci5yZXBsYWNlKGduLCIiKSksMiZ0JiYocj1yLnJlcGxhY2UoeW4sIiIpKSxyfX0sYm49e3N0YXJ0Om1uKDEpLGVuZDptbigyKSx0cmltOm1uKDMpfSx3bj13dC5mLFNuPVIuZixFbj1JLmYseG49Ym4udHJpbSxBbj0iTnVtYmVyIixPbj1uW0FuXSxSbj1Pbi5wcm90b3R5cGUsam49aChKdChSbikpPT1BbixQbj1mdW5jdGlvbih0KXt2YXIgZSxyLG4sbyxpLGEsdSxzLGM9bSh0LCExKTtpZigic3RyaW5nIj09dHlwZW9mIGMmJmMubGVuZ3RoPjIpaWYoNDM9PT0oZT0oYz14bihjKSkuY2hhckNvZGVBdCgwKSl8fDQ1PT09ZSl7aWYoODg9PT0ocj1jLmNoYXJDb2RlQXQoMikpfHwxMjA9PT1yKXJldHVybiBOYU59ZWxzZSBpZig0OD09PWUpe3N3aXRjaChjLmNoYXJDb2RlQXQoMSkpe2Nhc2UgNjY6Y2FzZSA5ODpuPTIsbz00OTticmVhaztjYXNlIDc5OmNhc2UgMTExOm49OCxvPTU1O2JyZWFrO2RlZmF1bHQ6cmV0dXJuK2N9Zm9yKGE9KGk9Yy5zbGljZSgyKSkubGVuZ3RoLHU9MDt1PGE7dSsrKWlmKChzPWkuY2hhckNvZGVBdCh1KSk8NDh8fHM+bylyZXR1cm4gTmFOO3JldHVybiBwYXJzZUludChpLG4pfXJldHVybitjfTtpZihUdChBbiwhT24oIiAwbzEiKXx8IU9uKCIwYjEiKXx8T24oIisweDEiKSkpe2Zvcih2YXIgSW4sVG49ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aDwxPzA6dCxyPXRoaXM7cmV0dXJuIHIgaW5zdGFuY2VvZiBUbiYmKGpuP28oZnVuY3Rpb24oKXtSbi52YWx1ZU9mLmNhbGwocil9KTpoKHIpIT1Bbik/RHIobmV3IE9uKFBuKGUpKSxyLFRuKTpQbihlKX0sa249aT93bihPbik6Ik1BWF9WQUxVRSxNSU5fVkFMVUUsTmFOLE5FR0FUSVZFX0lORklOSVRZLFBPU0lUSVZFX0lORklOSVRZLEVQU0lMT04saXNGaW5pdGUsaXNJbnRlZ2VyLGlzTmFOLGlzU2FmZUludGVnZXIsTUFYX1NBRkVfSU5URUdFUixNSU5fU0FGRV9JTlRFR0VSLHBhcnNlRmxvYXQscGFyc2VJbnQsaXNJbnRlZ2VyIi5zcGxpdCgiLCIpLExuPTA7a24ubGVuZ3RoPkxuO0xuKyspdyhPbixJbj1rbltMbl0pJiYhdyhUbixJbikmJkVuKFRuLEluLFNuKE9uLEluKSk7VG4ucHJvdG90eXBlPVJuLFJuLmNvbnN0cnVjdG9yPVRuLHJ0KG4sQW4sVG4pfUx0KHt0YXJnZXQ6Ik51bWJlciIsc3RhdDohMH0se0VQU0lMT046TWF0aC5wb3coMiwtNTIpfSk7dmFyIFVuPW4uaXNGaW5pdGU7THQoe3RhcmdldDoiTnVtYmVyIixzdGF0OiEwfSx7aXNGaW5pdGU6TnVtYmVyLmlzRmluaXRlfHxmdW5jdGlvbih0KXtyZXR1cm4ibnVtYmVyIj09dHlwZW9mIHQmJlVuKHQpfX0pO3ZhciBNbj1NYXRoLmZsb29yLF9uPWZ1bmN0aW9uKHQpe3JldHVybiF5KHQpJiZpc0Zpbml0ZSh0KSYmTW4odCk9PT10fTtMdCh7dGFyZ2V0OiJOdW1iZXIiLHN0YXQ6ITB9LHtpc0ludGVnZXI6X259KSxMdCh7dGFyZ2V0OiJOdW1iZXIiLHN0YXQ6ITB9LHtpc05hTjpmdW5jdGlvbih0KXtyZXR1cm4gdCE9dH19KTt2YXIgTm49TWF0aC5hYnM7THQoe3RhcmdldDoiTnVtYmVyIixzdGF0OiEwfSx7aXNTYWZlSW50ZWdlcjpmdW5jdGlvbih0KXtyZXR1cm4gX24odCkmJk5uKHQpPD05MDA3MTk5MjU0NzQwOTkxfX0pLEx0KHt0YXJnZXQ6Ik51bWJlciIsc3RhdDohMH0se01BWF9TQUZFX0lOVEVHRVI6OTAwNzE5OTI1NDc0MDk5MX0pLEx0KHt0YXJnZXQ6Ik51bWJlciIsc3RhdDohMH0se01JTl9TQUZFX0lOVEVHRVI6LTkwMDcxOTkyNTQ3NDA5OTF9KTt2YXIgQ249Ym4udHJpbSxGbj1uLnBhcnNlRmxvYXQsQm49MS9GbihkbisiLTAiKSE9LUluZmluaXR5P2Z1bmN0aW9uKHQpe3ZhciBlPUNuKFN0cmluZyh0KSkscj1GbihlKTtyZXR1cm4gMD09PXImJiItIj09ZS5jaGFyQXQoMCk/LTA6cn06Rm47THQoe3RhcmdldDoiTnVtYmVyIixzdGF0OiEwLGZvcmNlZDpOdW1iZXIucGFyc2VGbG9hdCE9Qm59LHtwYXJzZUZsb2F0OkJufSk7dmFyIERuPWJuLnRyaW0scW49bi5wYXJzZUludCx6bj0vXlsrLV0/MFtYeF0vLFduPTghPT1xbihkbisiMDgiKXx8MjIhPT1xbihkbisiMHgxNiIpP2Z1bmN0aW9uKHQsZSl7dmFyIHI9RG4oU3RyaW5nKHQpKTtyZXR1cm4gcW4ocixlPj4+MHx8KHpuLnRlc3Qocik/MTY6MTApKX06cW47THQoe3RhcmdldDoiTnVtYmVyIixzdGF0OiEwLGZvcmNlZDpOdW1iZXIucGFyc2VJbnQhPVdufSx7cGFyc2VJbnQ6V259KTt2YXIgS249Yy5mLEduPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtmb3IodmFyIHIsbj1nKGUpLG89enQobiksYT1vLmxlbmd0aCx1PTAscz1bXTthPnU7KXI9b1t1KytdLGkmJiFLbi5jYWxsKG4scil8fHMucHVzaCh0P1tyLG5bcl1dOm5bcl0pO3JldHVybiBzfX0sJG49e2VudHJpZXM6R24oITApLHZhbHVlczpHbighMSl9LFZuPSRuLmVudHJpZXM7THQoe3RhcmdldDoiT2JqZWN0IixzdGF0OiEwfSx7ZW50cmllczpmdW5jdGlvbih0KXtyZXR1cm4gVm4odCl9fSksTHQoe3RhcmdldDoiT2JqZWN0IixzdGF0OiEwLHNoYW06IWl9LHtnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxyLG49Zyh0KSxvPVIuZixpPUV0KG4pLGE9e30sdT0wO2kubGVuZ3RoPnU7KXZvaWQgMCE9PShyPW8obixlPWlbdSsrXSkpJiZzcihhLGUscik7cmV0dXJuIGF9fSk7dmFyIEhuPW8oZnVuY3Rpb24oKXt6dCgxKX0pO0x0KHt0YXJnZXQ6Ik9iamVjdCIsc3RhdDohMCxmb3JjZWQ6SG59LHtrZXlzOmZ1bmN0aW9uKHQpe3JldHVybiB6dChVdCh0KSl9fSk7dmFyIFhuPU9iamVjdC5pc3x8ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD09PWU/MCE9PXR8fDEvdD09MS9lOnQhPXQmJmUhPWV9O0x0KHt0YXJnZXQ6Ik9iamVjdCIsc3RhdDohMH0se2lzOlhufSk7dmFyIFluPSRuLnZhbHVlcztMdCh7dGFyZ2V0OiJPYmplY3QiLHN0YXQ6ITB9LHt2YWx1ZXM6ZnVuY3Rpb24odCl7cmV0dXJuIFluKHQpfX0pO3ZhciBKbj1pdCgiUmVmbGVjdCIsImFwcGx5IiksUW49RnVuY3Rpb24uYXBwbHksWm49IW8oZnVuY3Rpb24oKXtKbihmdW5jdGlvbigpe30pfSk7THQoe3RhcmdldDoiUmVmbGVjdCIsc3RhdDohMCxmb3JjZWQ6Wm59LHthcHBseTpmdW5jdGlvbih0LGUscil7cmV0dXJuIGVlKHQpLGoociksSm4/Sm4odCxlLHIpOlFuLmNhbGwodCxlLHIpfX0pO3ZhciB0bz1bXS5zbGljZSxlbz17fSxybz1GdW5jdGlvbi5iaW5kfHxmdW5jdGlvbih0KXt2YXIgZT1lZSh0aGlzKSxyPXRvLmNhbGwoYXJndW1lbnRzLDEpLG49ZnVuY3Rpb24oKXt2YXIgbz1yLmNvbmNhdCh0by5jYWxsKGFyZ3VtZW50cykpO3JldHVybiB0aGlzIGluc3RhbmNlb2Ygbj9mdW5jdGlvbih0LGUscil7aWYoIShlIGluIGVvKSl7Zm9yKHZhciBuPVtdLG89MDtvPGU7bysrKW5bb109ImFbIitvKyJdIjtlb1tlXT1GdW5jdGlvbigiQyxhIiwicmV0dXJuIG5ldyBDKCIrbi5qb2luKCIsIikrIikiKX1yZXR1cm4gZW9bZV0odCxyKX0oZSxvLmxlbmd0aCxvKTplLmFwcGx5KHQsbyl9O3JldHVybiB5KGUucHJvdG90eXBlKSYmKG4ucHJvdG90eXBlPWUucHJvdG90eXBlKSxufSxubz1pdCgiUmVmbGVjdCIsImNvbnN0cnVjdCIpLG9vPW8oZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiEobm8oZnVuY3Rpb24oKXt9LFtdLHQpaW5zdGFuY2VvZiB0KX0pLGlvPSFvKGZ1bmN0aW9uKCl7bm8oZnVuY3Rpb24oKXt9KX0pLGFvPW9vfHxpbztMdCh7dGFyZ2V0OiJSZWZsZWN0IixzdGF0OiEwLGZvcmNlZDphbyxzaGFtOmFvfSx7Y29uc3RydWN0OmZ1bmN0aW9uKHQsZSl7ZWUodCksaihlKTt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPDM/dDplZShhcmd1bWVudHNbMl0pO2lmKGlvJiYhb28pcmV0dXJuIG5vKHQsZSxyKTtpZih0PT1yKXtzd2l0Y2goZS5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gbmV3IHQ7Y2FzZSAxOnJldHVybiBuZXcgdChlWzBdKTtjYXNlIDI6cmV0dXJuIG5ldyB0KGVbMF0sZVsxXSk7Y2FzZSAzOnJldHVybiBuZXcgdChlWzBdLGVbMV0sZVsyXSk7Y2FzZSA0OnJldHVybiBuZXcgdChlWzBdLGVbMV0sZVsyXSxlWzNdKX12YXIgbj1bbnVsbF07cmV0dXJuIG4ucHVzaC5hcHBseShuLGUpLG5ldyhyby5hcHBseSh0LG4pKX12YXIgbz1yLnByb3RvdHlwZSxpPUp0KHkobyk/bzpPYmplY3QucHJvdG90eXBlKSxhPUZ1bmN0aW9uLmFwcGx5LmNhbGwodCxpLGUpO3JldHVybiB5KGEpP2E6aX19KTt2YXIgdW89byhmdW5jdGlvbigpe1JlZmxlY3QuZGVmaW5lUHJvcGVydHkoSS5mKHt9LDEse3ZhbHVlOjF9KSwxLHt2YWx1ZToyfSl9KTtMdCh7dGFyZ2V0OiJSZWZsZWN0IixzdGF0OiEwLGZvcmNlZDp1byxzaGFtOiFpfSx7ZGVmaW5lUHJvcGVydHk6ZnVuY3Rpb24odCxlLHIpe2oodCk7dmFyIG49bShlLCEwKTtqKHIpO3RyeXtyZXR1cm4gSS5mKHQsbixyKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19fSk7dmFyIHNvPVIuZjtMdCh7dGFyZ2V0OiJSZWZsZWN0IixzdGF0OiEwfSx7ZGVsZXRlUHJvcGVydHk6ZnVuY3Rpb24odCxlKXt2YXIgcj1zbyhqKHQpLGUpO3JldHVybiEociYmIXIuY29uZmlndXJhYmxlKSYmZGVsZXRlIHRbZV19fSksTHQoe3RhcmdldDoiUmVmbGVjdCIsc3RhdDohMH0se2dldDpmdW5jdGlvbiB0KGUscil7dmFyIG4sbyxpPWFyZ3VtZW50cy5sZW5ndGg8Mz9lOmFyZ3VtZW50c1syXTtyZXR1cm4gaihlKT09PWk/ZVtyXToobj1SLmYoZSxyKSk/dyhuLCJ2YWx1ZSIpP24udmFsdWU6dm9pZCAwPT09bi5nZXQ/dm9pZCAwOm4uZ2V0LmNhbGwoaSk6eShvPVVlKGUpKT90KG8scixpKTp2b2lkIDB9fSksTHQoe3RhcmdldDoiUmVmbGVjdCIsc3RhdDohMCxzaGFtOiFpfSx7Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIFIuZihqKHQpLGUpfX0pLEx0KHt0YXJnZXQ6IlJlZmxlY3QiLHN0YXQ6ITAsc2hhbTohVGV9LHtnZXRQcm90b3R5cGVPZjpmdW5jdGlvbih0KXtyZXR1cm4gVWUoaih0KSl9fSksTHQoe3RhcmdldDoiUmVmbGVjdCIsc3RhdDohMH0se2hhczpmdW5jdGlvbih0LGUpe3JldHVybiBlIGluIHR9fSk7dmFyIGNvPU9iamVjdC5pc0V4dGVuc2libGU7THQoe3RhcmdldDoiUmVmbGVjdCIsc3RhdDohMH0se2lzRXh0ZW5zaWJsZTpmdW5jdGlvbih0KXtyZXR1cm4gaih0KSwhY298fGNvKHQpfX0pLEx0KHt0YXJnZXQ6IlJlZmxlY3QiLHN0YXQ6ITB9LHtvd25LZXlzOkV0fSksTHQoe3RhcmdldDoiUmVmbGVjdCIsc3RhdDohMCxzaGFtOiFOcn0se3ByZXZlbnRFeHRlbnNpb25zOmZ1bmN0aW9uKHQpe2oodCk7dHJ5e3ZhciBlPWl0KCJPYmplY3QiLCJwcmV2ZW50RXh0ZW5zaW9ucyIpO3JldHVybiBlJiZlKHQpLCEwfWNhdGNoKHQpe3JldHVybiExfX19KTt2YXIgZm89byhmdW5jdGlvbigpe3ZhciB0PUkuZih7fSwiYSIse2NvbmZpZ3VyYWJsZTohMH0pO3JldHVybiExIT09UmVmbGVjdC5zZXQoVWUodCksImEiLDEsdCl9KTtMdCh7dGFyZ2V0OiJSZWZsZWN0IixzdGF0OiEwLGZvcmNlZDpmb30se3NldDpmdW5jdGlvbiB0KGUscixuKXt2YXIgbyxpLGE9YXJndW1lbnRzLmxlbmd0aDw0P2U6YXJndW1lbnRzWzNdLHU9Ui5mKGooZSkscik7aWYoIXUpe2lmKHkoaT1VZShlKSkpcmV0dXJuIHQoaSxyLG4sYSk7dT1mKDApfWlmKHcodSwidmFsdWUiKSl7aWYoITE9PT11LndyaXRhYmxlfHwheShhKSlyZXR1cm4hMTtpZihvPVIuZihhLHIpKXtpZihvLmdldHx8by5zZXR8fCExPT09by53cml0YWJsZSlyZXR1cm4hMTtvLnZhbHVlPW4sSS5mKGEscixvKX1lbHNlIEkuZihhLHIsZigwLG4pKTtyZXR1cm4hMH1yZXR1cm4gdm9pZCAwIT09dS5zZXQmJih1LnNldC5jYWxsKGEsbiksITApfX0pLEdlJiZMdCh7dGFyZ2V0OiJSZWZsZWN0IixzdGF0OiEwfSx7c2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24odCxlKXtqKHQpLEtlKGUpO3RyeXtyZXR1cm4gR2UodCxlKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19fSk7dmFyIGxvPUNyLmdldFdlYWtEYXRhLGhvPWV0LnNldCxwbz1ldC5nZXR0ZXJGb3Isdm89ZmUuZmluZCxnbz1mZS5maW5kSW5kZXgseW89MCxtbz1mdW5jdGlvbih0KXtyZXR1cm4gdC5mcm96ZW58fCh0LmZyb3plbj1uZXcgYm8pfSxibz1mdW5jdGlvbigpe3RoaXMuZW50cmllcz1bXX0sd289ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm8odC5lbnRyaWVzLGZ1bmN0aW9uKHQpe3JldHVybiB0WzBdPT09ZX0pfTtiby5wcm90b3R5cGU9e2dldDpmdW5jdGlvbih0KXt2YXIgZT13byh0aGlzLHQpO2lmKGUpcmV0dXJuIGVbMV19LGhhczpmdW5jdGlvbih0KXtyZXR1cm4hIXdvKHRoaXMsdCl9LHNldDpmdW5jdGlvbih0LGUpe3ZhciByPXdvKHRoaXMsdCk7cj9yWzFdPWU6dGhpcy5lbnRyaWVzLnB1c2goW3QsZV0pfSxkZWxldGU6ZnVuY3Rpb24odCl7dmFyIGU9Z28odGhpcy5lbnRyaWVzLGZ1bmN0aW9uKGUpe3JldHVybiBlWzBdPT09dH0pO3JldHVybn5lJiZ0aGlzLmVudHJpZXMuc3BsaWNlKGUsMSksISF+ZX19O3ZhciBTbz17Z2V0Q29uc3RydWN0b3I6ZnVuY3Rpb24odCxlLHIsbil7dmFyIG89dChmdW5jdGlvbih0LGkpe0JyKHQsbyxlKSxobyh0LHt0eXBlOmUsaWQ6eW8rKyxmcm96ZW46dm9pZCAwfSksbnVsbCE9aSYmRnIoaSx0W25dLHQscil9KSxpPXBvKGUpLGE9ZnVuY3Rpb24odCxlLHIpe3ZhciBuPWkodCksbz1sbyhqKGUpLCEwKTtyZXR1cm4hMD09PW8/bW8obikuc2V0KGUscik6b1tuLmlkXT1yLHR9O3JldHVybiB6cihvLnByb3RvdHlwZSx7ZGVsZXRlOmZ1bmN0aW9uKHQpe3ZhciBlPWkodGhpcyk7aWYoIXkodCkpcmV0dXJuITE7dmFyIHI9bG8odCk7cmV0dXJuITA9PT1yP21vKGUpLmRlbGV0ZSh0KTpyJiZ3KHIsZS5pZCkmJmRlbGV0ZSByW2UuaWRdfSxoYXM6ZnVuY3Rpb24odCl7dmFyIGU9aSh0aGlzKTtpZigheSh0KSlyZXR1cm4hMTt2YXIgcj1sbyh0KTtyZXR1cm4hMD09PXI/bW8oZSkuaGFzKHQpOnImJncocixlLmlkKX19KSx6cihvLnByb3RvdHlwZSxyP3tnZXQ6ZnVuY3Rpb24odCl7dmFyIGU9aSh0aGlzKTtpZih5KHQpKXt2YXIgcj1sbyh0KTtyZXR1cm4hMD09PXI/bW8oZSkuZ2V0KHQpOnI/cltlLmlkXTp2b2lkIDB9fSxzZXQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gYSh0aGlzLHQsZSl9fTp7YWRkOmZ1bmN0aW9uKHQpe3JldHVybiBhKHRoaXMsdCwhMCl9fSksb319LEVvPWUoZnVuY3Rpb24odCl7dmFyIGUscj1ldC5lbmZvcmNlLG89IW4uQWN0aXZlWE9iamVjdCYmIkFjdGl2ZVhPYmplY3QiaW4gbixpPU9iamVjdC5pc0V4dGVuc2libGUsYT1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdCh0aGlzLGFyZ3VtZW50cy5sZW5ndGg/YXJndW1lbnRzWzBdOnZvaWQgMCl9fSx1PXQuZXhwb3J0cz1xcigiV2Vha01hcCIsYSxTbyk7aWYoRCYmbyl7ZT1Tby5nZXRDb25zdHJ1Y3RvcihhLCJXZWFrTWFwIiwhMCksQ3IuUkVRVUlSRUQ9ITA7dmFyIHM9dS5wcm90b3R5cGUsYz1zLmRlbGV0ZSxmPXMuaGFzLGw9cy5nZXQsaD1zLnNldDt6cihzLHtkZWxldGU6ZnVuY3Rpb24odCl7aWYoeSh0KSYmIWkodCkpe3ZhciBuPXIodGhpcyk7cmV0dXJuIG4uZnJvemVufHwobi5mcm96ZW49bmV3IGUpLGMuY2FsbCh0aGlzLHQpfHxuLmZyb3plbi5kZWxldGUodCl9cmV0dXJuIGMuY2FsbCh0aGlzLHQpfSxoYXM6ZnVuY3Rpb24odCl7aWYoeSh0KSYmIWkodCkpe3ZhciBuPXIodGhpcyk7cmV0dXJuIG4uZnJvemVufHwobi5mcm96ZW49bmV3IGUpLGYuY2FsbCh0aGlzLHQpfHxuLmZyb3plbi5oYXModCl9cmV0dXJuIGYuY2FsbCh0aGlzLHQpfSxnZXQ6ZnVuY3Rpb24odCl7aWYoeSh0KSYmIWkodCkpe3ZhciBuPXIodGhpcyk7cmV0dXJuIG4uZnJvemVufHwobi5mcm96ZW49bmV3IGUpLGYuY2FsbCh0aGlzLHQpP2wuY2FsbCh0aGlzLHQpOm4uZnJvemVuLmdldCh0KX1yZXR1cm4gbC5jYWxsKHRoaXMsdCl9LHNldDpmdW5jdGlvbih0LG4pe2lmKHkodCkmJiFpKHQpKXt2YXIgbz1yKHRoaXMpO28uZnJvemVufHwoby5mcm96ZW49bmV3IGUpLGYuY2FsbCh0aGlzLHQpP2guY2FsbCh0aGlzLHQsbik6by5mcm96ZW4uc2V0KHQsbil9ZWxzZSBoLmNhbGwodGhpcyx0LG4pO3JldHVybiB0aGlzfX0pfX0pLHhvPXooIm1ldGFkYXRhIiksQW89eG8uc3RvcmV8fCh4by5zdG9yZT1uZXcgRW8pLE9vPWZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1Bby5nZXQodCk7aWYoIW4pe2lmKCFyKXJldHVybjtBby5zZXQodCxuPW5ldyBZcil9dmFyIG89bi5nZXQoZSk7aWYoIW8pe2lmKCFyKXJldHVybjtuLnNldChlLG89bmV3IFlyKX1yZXR1cm4gb30sUm89e3N0b3JlOkFvLGdldE1hcDpPbyxoYXM6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPU9vKGUsciwhMSk7cmV0dXJuIHZvaWQgMCE9PW4mJm4uaGFzKHQpfSxnZXQ6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPU9vKGUsciwhMSk7cmV0dXJuIHZvaWQgMD09PW4/dm9pZCAwOm4uZ2V0KHQpfSxzZXQ6ZnVuY3Rpb24odCxlLHIsbil7T28ocixuLCEwKS5zZXQodCxlKX0sa2V5czpmdW5jdGlvbih0LGUpe3ZhciByPU9vKHQsZSwhMSksbj1bXTtyZXR1cm4gciYmci5mb3JFYWNoKGZ1bmN0aW9uKHQsZSl7bi5wdXNoKGUpfSksbn0sdG9LZXk6ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXR8fCJzeW1ib2wiPT10eXBlb2YgdD90OlN0cmluZyh0KX19LGpvPVJvLnRvS2V5LFBvPVJvLnNldDtMdCh7dGFyZ2V0OiJSZWZsZWN0IixzdGF0OiEwfSx7ZGVmaW5lTWV0YWRhdGE6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg8ND92b2lkIDA6am8oYXJndW1lbnRzWzNdKTtQbyh0LGUsaihyKSxuKX19KTt2YXIgSW89Um8udG9LZXksVG89Um8uZ2V0TWFwLGtvPVJvLnN0b3JlO0x0KHt0YXJnZXQ6IlJlZmxlY3QiLHN0YXQ6ITB9LHtkZWxldGVNZXRhZGF0YTpmdW5jdGlvbih0LGUpe3ZhciByPWFyZ3VtZW50cy5sZW5ndGg8Mz92b2lkIDA6SW8oYXJndW1lbnRzWzJdKSxuPVRvKGooZSksciwhMSk7aWYodm9pZCAwPT09bnx8IW4uZGVsZXRlKHQpKXJldHVybiExO2lmKG4uc2l6ZSlyZXR1cm4hMDt2YXIgbz1rby5nZXQoZSk7cmV0dXJuIG8uZGVsZXRlKHIpLCEhby5zaXplfHxrby5kZWxldGUoZSl9fSk7dmFyIExvPVJvLmhhcyxVbz1Sby5nZXQsTW89Um8udG9LZXksX289ZnVuY3Rpb24odCxlLHIpe2lmKExvKHQsZSxyKSlyZXR1cm4gVW8odCxlLHIpO3ZhciBuPVVlKGUpO3JldHVybiBudWxsIT09bj9fbyh0LG4scik6dm9pZCAwfTtMdCh7dGFyZ2V0OiJSZWZsZWN0IixzdGF0OiEwfSx7Z2V0TWV0YWRhdGE6ZnVuY3Rpb24odCxlKXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPDM/dm9pZCAwOk1vKGFyZ3VtZW50c1syXSk7cmV0dXJuIF9vKHQsaihlKSxyKX19KTt2YXIgTm89cXIoIlNldCIsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQodGhpcyxhcmd1bWVudHMubGVuZ3RoP2FyZ3VtZW50c1swXTp2b2lkIDApfX0sWHIpLENvPVJvLmtleXMsRm89Um8udG9LZXksQm89ZnVuY3Rpb24odCxlKXt2YXIgcj1Dbyh0LGUpLG49VWUodCk7aWYobnVsbD09PW4pcmV0dXJuIHI7dmFyIG8saSxhPUJvKG4sZSk7cmV0dXJuIGEubGVuZ3RoP3IubGVuZ3RoPyhvPW5ldyBObyhyLmNvbmNhdChhKSksRnIobywoaT1bXSkucHVzaCxpKSxpKTphOnJ9O0x0KHt0YXJnZXQ6IlJlZmxlY3QiLHN0YXQ6ITB9LHtnZXRNZXRhZGF0YUtleXM6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aDwyP3ZvaWQgMDpGbyhhcmd1bWVudHNbMV0pO3JldHVybiBCbyhqKHQpLGUpfX0pO3ZhciBEbz1Sby5nZXQscW89Um8udG9LZXk7THQoe3RhcmdldDoiUmVmbGVjdCIsc3RhdDohMH0se2dldE93bk1ldGFkYXRhOmZ1bmN0aW9uKHQsZSl7dmFyIHI9YXJndW1lbnRzLmxlbmd0aDwzP3ZvaWQgMDpxbyhhcmd1bWVudHNbMl0pO3JldHVybiBEbyh0LGooZSkscil9fSk7dmFyIHpvPVJvLmtleXMsV289Um8udG9LZXk7THQoe3RhcmdldDoiUmVmbGVjdCIsc3RhdDohMH0se2dldE93bk1ldGFkYXRhS2V5czpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPDI/dm9pZCAwOldvKGFyZ3VtZW50c1sxXSk7cmV0dXJuIHpvKGoodCksZSl9fSk7dmFyIEtvPVJvLmhhcyxHbz1Sby50b0tleSwkbz1mdW5jdGlvbih0LGUscil7aWYoS28odCxlLHIpKXJldHVybiEwO3ZhciBuPVVlKGUpO3JldHVybiBudWxsIT09biYmJG8odCxuLHIpfTtMdCh7dGFyZ2V0OiJSZWZsZWN0IixzdGF0OiEwfSx7aGFzTWV0YWRhdGE6ZnVuY3Rpb24odCxlKXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPDM/dm9pZCAwOkdvKGFyZ3VtZW50c1syXSk7cmV0dXJuICRvKHQsaihlKSxyKX19KTt2YXIgVm89Um8uaGFzLEhvPVJvLnRvS2V5O0x0KHt0YXJnZXQ6IlJlZmxlY3QiLHN0YXQ6ITB9LHtoYXNPd25NZXRhZGF0YTpmdW5jdGlvbih0LGUpe3ZhciByPWFyZ3VtZW50cy5sZW5ndGg8Mz92b2lkIDA6SG8oYXJndW1lbnRzWzJdKTtyZXR1cm4gVm8odCxqKGUpLHIpfX0pO3ZhciBYbz1Sby50b0tleSxZbz1Sby5zZXQ7THQoe3RhcmdldDoiUmVmbGVjdCIsc3RhdDohMH0se21ldGFkYXRhOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKHIsbil7WW8odCxlLGoociksWG8obikpfX19KTt2YXIgSm89cXQoIm1hdGNoIiksUW89ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIHkodCkmJih2b2lkIDAhPT0oZT10W0pvXSk/ISFlOiJSZWdFeHAiPT1oKHQpKX0sWm89ZnVuY3Rpb24oKXt2YXIgdD1qKHRoaXMpLGU9IiI7cmV0dXJuIHQuZ2xvYmFsJiYoZSs9ImciKSx0Lmlnbm9yZUNhc2UmJihlKz0iaSIpLHQubXVsdGlsaW5lJiYoZSs9Im0iKSx0LmRvdEFsbCYmKGUrPSJzIiksdC51bmljb2RlJiYoZSs9InUiKSx0LnN0aWNreSYmKGUrPSJ5IiksZX07ZnVuY3Rpb24gdGkodCxlKXtyZXR1cm4gUmVnRXhwKHQsZSl9dmFyIGVpPW8oZnVuY3Rpb24oKXt2YXIgdD10aSgiYSIsInkiKTtyZXR1cm4gdC5sYXN0SW5kZXg9MixudWxsIT10LmV4ZWMoImFiY2QiKX0pLHJpPW8oZnVuY3Rpb24oKXt2YXIgdD10aSgiXnIiLCJneSIpO3JldHVybiB0Lmxhc3RJbmRleD0yLG51bGwhPXQuZXhlYygic3RyIil9KSxuaT17VU5TVVBQT1JURURfWTplaSxCUk9LRU5fQ0FSRVQ6cml9LG9pPUkuZixpaT13dC5mLGFpPWV0LnNldCx1aT1xdCgibWF0Y2giKSxzaT1uLlJlZ0V4cCxjaT1zaS5wcm90b3R5cGUsZmk9L2EvZyxsaT0vYS9nLGhpPW5ldyBzaShmaSkhPT1maSxwaT1uaS5VTlNVUFBPUlRFRF9ZO2lmKGkmJlR0KCJSZWdFeHAiLCFoaXx8cGl8fG8oZnVuY3Rpb24oKXtyZXR1cm4gbGlbdWldPSExLHNpKGZpKSE9Zml8fHNpKGxpKT09bGl8fCIvYS9pIiE9c2koZmksImkiKX0pKSl7Zm9yKHZhciBkaT1mdW5jdGlvbih0LGUpe3ZhciByLG49dGhpcyBpbnN0YW5jZW9mIGRpLG89UW8odCksaT12b2lkIDA9PT1lO2lmKCFuJiZvJiZ0LmNvbnN0cnVjdG9yPT09ZGkmJmkpcmV0dXJuIHQ7aGk/byYmIWkmJih0PXQuc291cmNlKTp0IGluc3RhbmNlb2YgZGkmJihpJiYoZT1aby5jYWxsKHQpKSx0PXQuc291cmNlKSxwaSYmKHI9ISFlJiZlLmluZGV4T2YoInkiKT4tMSkmJihlPWUucmVwbGFjZSgveS9nLCIiKSk7dmFyIGE9RHIoaGk/bmV3IHNpKHQsZSk6c2kodCxlKSxuP3RoaXM6Y2ksZGkpO3JldHVybiBwaSYmciYmYWkoYSx7c3RpY2t5OnJ9KSxhfSx2aT1mdW5jdGlvbih0KXt0IGluIGRpfHxvaShkaSx0LHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHNpW3RdfSxzZXQ6ZnVuY3Rpb24oZSl7c2lbdF09ZX19KX0sZ2k9aWkoc2kpLHlpPTA7Z2kubGVuZ3RoPnlpOyl2aShnaVt5aSsrXSk7Y2kuY29uc3RydWN0b3I9ZGksZGkucHJvdG90eXBlPWNpLHJ0KG4sIlJlZ0V4cCIsZGkpfUtyKCJSZWdFeHAiKTt2YXIgbWk9InRvU3RyaW5nIixiaT1SZWdFeHAucHJvdG90eXBlLHdpPWJpW21pXTsobyhmdW5jdGlvbigpe3JldHVybiIvYS9iIiE9d2kuY2FsbCh7c291cmNlOiJhIixmbGFnczoiYiJ9KX0pfHx3aS5uYW1lIT1taSkmJnJ0KFJlZ0V4cC5wcm90b3R5cGUsbWksZnVuY3Rpb24oKXt2YXIgdD1qKHRoaXMpLGU9U3RyaW5nKHQuc291cmNlKSxyPXQuZmxhZ3M7cmV0dXJuIi8iK2UrIi8iK1N0cmluZyh2b2lkIDA9PT1yJiZ0IGluc3RhbmNlb2YgUmVnRXhwJiYhKCJmbGFncyJpbiBiaSk/Wm8uY2FsbCh0KTpyKX0se3Vuc2FmZTohMH0pO3ZhciBTaT1SZWdFeHAucHJvdG90eXBlLmV4ZWMsRWk9U3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlLHhpPVNpLEFpPWZ1bmN0aW9uKCl7dmFyIHQ9L2EvLGU9L2IqL2c7cmV0dXJuIFNpLmNhbGwodCwiYSIpLFNpLmNhbGwoZSwiYSIpLDAhPT10Lmxhc3RJbmRleHx8MCE9PWUubGFzdEluZGV4fSgpLE9pPW5pLlVOU1VQUE9SVEVEX1l8fG5pLkJST0tFTl9DQVJFVCxSaT12b2lkIDAhPT0vKCk/Py8uZXhlYygiIilbMV07KEFpfHxSaXx8T2kpJiYoeGk9ZnVuY3Rpb24odCl7dmFyIGUscixuLG8saT10aGlzLGE9T2kmJmkuc3RpY2t5LHU9Wm8uY2FsbChpKSxzPWkuc291cmNlLGM9MCxmPXQ7cmV0dXJuIGEmJigtMT09PSh1PXUucmVwbGFjZSgieSIsIiIpKS5pbmRleE9mKCJnIikmJih1Kz0iZyIpLGY9U3RyaW5nKHQpLnNsaWNlKGkubGFzdEluZGV4KSxpLmxhc3RJbmRleD4wJiYoIWkubXVsdGlsaW5lfHxpLm11bHRpbGluZSYmIlxuIiE9PXRbaS5sYXN0SW5kZXgtMV0pJiYocz0iKD86ICIrcysiKSIsZj0iICIrZixjKyspLHI9bmV3IFJlZ0V4cCgiXig/OiIrcysiKSIsdSkpLFJpJiYocj1uZXcgUmVnRXhwKCJeIitzKyIkKD8hXFxzKSIsdSkpLEFpJiYoZT1pLmxhc3RJbmRleCksbj1TaS5jYWxsKGE/cjppLGYpLGE/bj8obi5pbnB1dD1uLmlucHV0LnNsaWNlKGMpLG5bMF09blswXS5zbGljZShjKSxuLmluZGV4PWkubGFzdEluZGV4LGkubGFzdEluZGV4Kz1uWzBdLmxlbmd0aCk6aS5sYXN0SW5kZXg9MDpBaSYmbiYmKGkubGFzdEluZGV4PWkuZ2xvYmFsP24uaW5kZXgrblswXS5sZW5ndGg6ZSksUmkmJm4mJm4ubGVuZ3RoPjEmJkVpLmNhbGwoblswXSxyLGZ1bmN0aW9uKCl7Zm9yKG89MTtvPGFyZ3VtZW50cy5sZW5ndGgtMjtvKyspdm9pZCAwPT09YXJndW1lbnRzW29dJiYobltvXT12b2lkIDApfSksbn0pO3ZhciBqaT14aTtMdCh7dGFyZ2V0OiJSZWdFeHAiLHByb3RvOiEwLGZvcmNlZDovLi8uZXhlYyE9PWppfSx7ZXhlYzpqaX0pLGkmJigiZyIhPS8uL2cuZmxhZ3N8fG5pLlVOU1VQUE9SVEVEX1kpJiZJLmYoUmVnRXhwLnByb3RvdHlwZSwiZmxhZ3MiLHtjb25maWd1cmFibGU6ITAsZ2V0OlpvfSk7dmFyIFBpPWV0LmdldCxJaT1SZWdFeHAucHJvdG90eXBlO2kmJm5pLlVOU1VQUE9SVEVEX1kmJigwLEkuZikoUmVnRXhwLnByb3RvdHlwZSwic3RpY2t5Iix7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe2lmKHRoaXMhPT1JaSl7aWYodGhpcyBpbnN0YW5jZW9mIFJlZ0V4cClyZXR1cm4hIVBpKHRoaXMpLnN0aWNreTt0aHJvdyBUeXBlRXJyb3IoIkluY29tcGF0aWJsZSByZWNlaXZlciwgUmVnRXhwIHJlcXVpcmVkIil9fX0pO3ZhciBUaSxraSxMaT0oVGk9ITEsKGtpPS9bYWNdLykuZXhlYz1mdW5jdGlvbigpe3JldHVybiBUaT0hMCwvLi8uZXhlYy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LCEwPT09a2kudGVzdCgiYWJjIikmJlRpKSxVaT0vLi8udGVzdDtMdCh7dGFyZ2V0OiJSZWdFeHAiLHByb3RvOiEwLGZvcmNlZDohTGl9LHt0ZXN0OmZ1bmN0aW9uKHQpe2lmKCJmdW5jdGlvbiIhPXR5cGVvZiB0aGlzLmV4ZWMpcmV0dXJuIFVpLmNhbGwodGhpcyx0KTt2YXIgZT10aGlzLmV4ZWModCk7aWYobnVsbCE9PWUmJiF5KGUpKXRocm93IG5ldyBFcnJvcigiUmVnRXhwIGV4ZWMgbWV0aG9kIHJldHVybmVkIHNvbWV0aGluZyBvdGhlciB0aGFuIGFuIE9iamVjdCBvciBudWxsIik7cmV0dXJuISFlfX0pO3ZhciBNaT1xdCgic3BlY2llcyIpLF9pPSFvKGZ1bmN0aW9uKCl7dmFyIHQ9Ly4vO3JldHVybiB0LmV4ZWM9ZnVuY3Rpb24oKXt2YXIgdD1bXTtyZXR1cm4gdC5ncm91cHM9e2E6IjcifSx0fSwiNyIhPT0iIi5yZXBsYWNlKHQsIiQ8YT4iKX0pLE5pPSIkMCI9PT0iYSIucmVwbGFjZSgvLi8sIiQwIiksQ2k9cXQoInJlcGxhY2UiKSxGaT0hIS8uL1tDaV0mJiIiPT09Ly4vW0NpXSgiYSIsIiQwIiksQmk9IW8oZnVuY3Rpb24oKXt2YXIgdD0vKD86KS8sZT10LmV4ZWM7dC5leGVjPWZ1bmN0aW9uKCl7cmV0dXJuIGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt2YXIgcj0iYWIiLnNwbGl0KHQpO3JldHVybiAyIT09ci5sZW5ndGh8fCJhIiE9PXJbMF18fCJiIiE9PXJbMV19KSxEaT1mdW5jdGlvbih0LGUscixuKXt2YXIgaT1xdCh0KSxhPSFvKGZ1bmN0aW9uKCl7dmFyIGU9e307cmV0dXJuIGVbaV09ZnVuY3Rpb24oKXtyZXR1cm4gN30sNyE9IiJbdF0oZSl9KSx1PWEmJiFvKGZ1bmN0aW9uKCl7dmFyIGU9ITEscj0vYS87cmV0dXJuInNwbGl0Ij09PXQmJigocj17fSkuY29uc3RydWN0b3I9e30sci5jb25zdHJ1Y3RvcltNaV09ZnVuY3Rpb24oKXtyZXR1cm4gcn0sci5mbGFncz0iIixyW2ldPS8uL1tpXSksci5leGVjPWZ1bmN0aW9uKCl7cmV0dXJuIGU9ITAsbnVsbH0scltpXSgiIiksIWV9KTtpZighYXx8IXV8fCJyZXBsYWNlIj09PXQmJighX2l8fCFOaXx8RmkpfHwic3BsaXQiPT09dCYmIUJpKXt2YXIgcz0vLi9baV0sYz1yKGksIiJbdF0sZnVuY3Rpb24odCxlLHIsbixvKXtyZXR1cm4gZS5leGVjPT09amk/YSYmIW8/e2RvbmU6ITAsdmFsdWU6cy5jYWxsKGUscixuKX06e2RvbmU6ITAsdmFsdWU6dC5jYWxsKHIsZSxuKX06e2RvbmU6ITF9fSx7UkVQTEFDRV9LRUVQU18kMDpOaSxSRUdFWFBfUkVQTEFDRV9TVUJTVElUVVRFU19VTkRFRklORURfQ0FQVFVSRTpGaX0pLGY9Y1sxXTtydChTdHJpbmcucHJvdG90eXBlLHQsY1swXSkscnQoUmVnRXhwLnByb3RvdHlwZSxpLDI9PWU/ZnVuY3Rpb24odCxlKXtyZXR1cm4gZi5jYWxsKHQsdGhpcyxlKX06ZnVuY3Rpb24odCl7cmV0dXJuIGYuY2FsbCh0LHRoaXMpfSl9biYmVChSZWdFeHAucHJvdG90eXBlW2ldLCJzaGFtIiwhMCl9LHFpPUllLmNoYXJBdCx6aT1mdW5jdGlvbih0LGUscil7cmV0dXJuIGUrKHI/cWkodCxlKS5sZW5ndGg6MSl9LFdpPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dC5leGVjO2lmKCJmdW5jdGlvbiI9PXR5cGVvZiByKXt2YXIgbj1yLmNhbGwodCxlKTtpZigib2JqZWN0IiE9dHlwZW9mIG4pdGhyb3cgVHlwZUVycm9yKCJSZWdFeHAgZXhlYyBtZXRob2QgcmV0dXJuZWQgc29tZXRoaW5nIG90aGVyIHRoYW4gYW4gT2JqZWN0IG9yIG51bGwiKTtyZXR1cm4gbn1pZigiUmVnRXhwIiE9PWgodCkpdGhyb3cgVHlwZUVycm9yKCJSZWdFeHAjZXhlYyBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHJlY2VpdmVyIik7cmV0dXJuIGppLmNhbGwodCxlKX07RGkoIm1hdGNoIiwxLGZ1bmN0aW9uKHQsZSxyKXtyZXR1cm5bZnVuY3Rpb24oZSl7dmFyIHI9dih0aGlzKSxuPW51bGw9PWU/dm9pZCAwOmVbdF07cmV0dXJuIHZvaWQgMCE9PW4/bi5jYWxsKGUscik6bmV3IFJlZ0V4cChlKVt0XShTdHJpbmcocikpfSxmdW5jdGlvbih0KXt2YXIgbj1yKGUsdCx0aGlzKTtpZihuLmRvbmUpcmV0dXJuIG4udmFsdWU7dmFyIG89aih0KSxpPVN0cmluZyh0aGlzKTtpZighby5nbG9iYWwpcmV0dXJuIFdpKG8saSk7dmFyIGE9by51bmljb2RlO28ubGFzdEluZGV4PTA7Zm9yKHZhciB1LHM9W10sYz0wO251bGwhPT0odT1XaShvLGkpKTspe3ZhciBmPVN0cmluZyh1WzBdKTtzW2NdPWYsIiI9PT1mJiYoby5sYXN0SW5kZXg9emkoaSxmdChvLmxhc3RJbmRleCksYSkpLGMrK31yZXR1cm4gMD09PWM/bnVsbDpzfV19KTt2YXIgS2k9TWF0aC5tYXgsR2k9TWF0aC5taW4sJGk9TWF0aC5mbG9vcixWaT0vXCQoWyQmJ2BdfFxkXGQ/fDxbXj5dKj4pL2csSGk9L1wkKFskJidgXXxcZFxkPykvZztEaSgicmVwbGFjZSIsMixmdW5jdGlvbih0LGUscixuKXt2YXIgbz1uLlJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFLGk9bi5SRVBMQUNFX0tFRVBTXyQwLGE9bz8iJCI6IiQwIjtyZXR1cm5bZnVuY3Rpb24ocixuKXt2YXIgbz12KHRoaXMpLGk9bnVsbD09cj92b2lkIDA6clt0XTtyZXR1cm4gdm9pZCAwIT09aT9pLmNhbGwocixvLG4pOmUuY2FsbChTdHJpbmcobykscixuKX0sZnVuY3Rpb24odCxuKXtpZighbyYmaXx8InN0cmluZyI9PXR5cGVvZiBuJiYtMT09PW4uaW5kZXhPZihhKSl7dmFyIHM9cihlLHQsdGhpcyxuKTtpZihzLmRvbmUpcmV0dXJuIHMudmFsdWV9dmFyIGM9aih0KSxmPVN0cmluZyh0aGlzKSxsPSJmdW5jdGlvbiI9PXR5cGVvZiBuO2x8fChuPVN0cmluZyhuKSk7dmFyIGg9Yy5nbG9iYWw7aWYoaCl7dmFyIHA9Yy51bmljb2RlO2MubGFzdEluZGV4PTB9Zm9yKHZhciBkPVtdOzspe3ZhciB2PVdpKGMsZik7aWYobnVsbD09PXYpYnJlYWs7aWYoZC5wdXNoKHYpLCFoKWJyZWFrOyIiPT09U3RyaW5nKHZbMF0pJiYoYy5sYXN0SW5kZXg9emkoZixmdChjLmxhc3RJbmRleCkscCkpfWZvcih2YXIgZyx5PSIiLG09MCxiPTA7YjxkLmxlbmd0aDtiKyspe3Y9ZFtiXTtmb3IodmFyIHc9U3RyaW5nKHZbMF0pLFM9S2koR2koc3Qodi5pbmRleCksZi5sZW5ndGgpLDApLEU9W10seD0xO3g8di5sZW5ndGg7eCsrKUUucHVzaCh2b2lkIDA9PT0oZz12W3hdKT9nOlN0cmluZyhnKSk7dmFyIEE9di5ncm91cHM7aWYobCl7dmFyIE89W3ddLmNvbmNhdChFLFMsZik7dm9pZCAwIT09QSYmTy5wdXNoKEEpO3ZhciBSPVN0cmluZyhuLmFwcGx5KHZvaWQgMCxPKSl9ZWxzZSBSPXUodyxmLFMsRSxBLG4pO1M+PW0mJih5Kz1mLnNsaWNlKG0sUykrUixtPVMrdy5sZW5ndGgpfXJldHVybiB5K2Yuc2xpY2UobSl9XTtmdW5jdGlvbiB1KHQscixuLG8saSxhKXt2YXIgdT1uK3QubGVuZ3RoLHM9by5sZW5ndGgsYz1IaTtyZXR1cm4gdm9pZCAwIT09aSYmKGk9VXQoaSksYz1WaSksZS5jYWxsKGEsYyxmdW5jdGlvbihlLGEpe3ZhciBjO3N3aXRjaChhLmNoYXJBdCgwKSl7Y2FzZSIkIjpyZXR1cm4iJCI7Y2FzZSImIjpyZXR1cm4gdDtjYXNlImAiOnJldHVybiByLnNsaWNlKDAsbik7Y2FzZSInIjpyZXR1cm4gci5zbGljZSh1KTtjYXNlIjwiOmM9aVthLnNsaWNlKDEsLTEpXTticmVhaztkZWZhdWx0OnZhciBmPSthO2lmKDA9PT1mKXJldHVybiBlO2lmKGY+cyl7dmFyIGw9JGkoZi8xMCk7cmV0dXJuIDA9PT1sP2U6bDw9cz92b2lkIDA9PT1vW2wtMV0/YS5jaGFyQXQoMSk6b1tsLTFdK2EuY2hhckF0KDEpOmV9Yz1vW2YtMV19cmV0dXJuIHZvaWQgMD09PWM/IiI6Y30pfX0pLERpKCJzZWFyY2giLDEsZnVuY3Rpb24odCxlLHIpe3JldHVybltmdW5jdGlvbihlKXt2YXIgcj12KHRoaXMpLG49bnVsbD09ZT92b2lkIDA6ZVt0XTtyZXR1cm4gdm9pZCAwIT09bj9uLmNhbGwoZSxyKTpuZXcgUmVnRXhwKGUpW3RdKFN0cmluZyhyKSl9LGZ1bmN0aW9uKHQpe3ZhciBuPXIoZSx0LHRoaXMpO2lmKG4uZG9uZSlyZXR1cm4gbi52YWx1ZTt2YXIgbz1qKHQpLGk9U3RyaW5nKHRoaXMpLGE9by5sYXN0SW5kZXg7WG4oYSwwKXx8KG8ubGFzdEluZGV4PTApO3ZhciB1PVdpKG8saSk7cmV0dXJuIFhuKG8ubGFzdEluZGV4LGEpfHwoby5sYXN0SW5kZXg9YSksbnVsbD09PXU/LTE6dS5pbmRleH1dfSk7dmFyIFhpPVtdLnB1c2gsWWk9TWF0aC5taW4sSmk9NDI5NDk2NzI5NSxRaT0hbyhmdW5jdGlvbigpe3JldHVybiFSZWdFeHAoSmksInkiKX0pO0RpKCJzcGxpdCIsMixmdW5jdGlvbih0LGUscil7dmFyIG47cmV0dXJuIG49ImMiPT0iYWJiYyIuc3BsaXQoLyhiKSovKVsxXXx8NCE9InRlc3QiLnNwbGl0KC8oPzopLywtMSkubGVuZ3RofHwyIT0iYWIiLnNwbGl0KC8oPzphYikqLykubGVuZ3RofHw0IT0iLiIuc3BsaXQoLyguPykoLj8pLykubGVuZ3RofHwiLiIuc3BsaXQoLygpKCkvKS5sZW5ndGg+MXx8IiIuc3BsaXQoLy4/LykubGVuZ3RoP2Z1bmN0aW9uKHQscil7dmFyIG49U3RyaW5nKHYodGhpcykpLG89dm9pZCAwPT09cj9KaTpyPj4+MDtpZigwPT09bylyZXR1cm5bXTtpZih2b2lkIDA9PT10KXJldHVybltuXTtpZighUW8odCkpcmV0dXJuIGUuY2FsbChuLHQsbyk7Zm9yKHZhciBpLGEsdSxzPVtdLGM9MCxmPW5ldyBSZWdFeHAodC5zb3VyY2UsKHQuaWdub3JlQ2FzZT8iaSI6IiIpKyh0Lm11bHRpbGluZT8ibSI6IiIpKyh0LnVuaWNvZGU/InUiOiIiKSsodC5zdGlja3k/InkiOiIiKSsiZyIpOyhpPWppLmNhbGwoZixuKSkmJiEoKGE9Zi5sYXN0SW5kZXgpPmMmJihzLnB1c2gobi5zbGljZShjLGkuaW5kZXgpKSxpLmxlbmd0aD4xJiZpLmluZGV4PG4ubGVuZ3RoJiZYaS5hcHBseShzLGkuc2xpY2UoMSkpLHU9aVswXS5sZW5ndGgsYz1hLHMubGVuZ3RoPj1vKSk7KWYubGFzdEluZGV4PT09aS5pbmRleCYmZi5sYXN0SW5kZXgrKztyZXR1cm4gYz09PW4ubGVuZ3RoPyF1JiZmLnRlc3QoIiIpfHxzLnB1c2goIiIpOnMucHVzaChuLnNsaWNlKGMpKSxzLmxlbmd0aD5vP3Muc2xpY2UoMCxvKTpzfToiMCIuc3BsaXQodm9pZCAwLDApLmxlbmd0aD9mdW5jdGlvbih0LHIpe3JldHVybiB2b2lkIDA9PT10JiYwPT09cj9bXTplLmNhbGwodGhpcyx0LHIpfTplLFtmdW5jdGlvbihlLHIpe3ZhciBvPXYodGhpcyksaT1udWxsPT1lP3ZvaWQgMDplW3RdO3JldHVybiB2b2lkIDAhPT1pP2kuY2FsbChlLG8scik6bi5jYWxsKFN0cmluZyhvKSxlLHIpfSxmdW5jdGlvbih0LG8pe3ZhciBpPXIobix0LHRoaXMsbyxuIT09ZSk7aWYoaS5kb25lKXJldHVybiBpLnZhbHVlO3ZhciBhPWoodCksdT1TdHJpbmcodGhpcykscz1obihhLFJlZ0V4cCksYz1hLnVuaWNvZGUsZj1uZXcgcyhRaT9hOiJeKD86IithLnNvdXJjZSsiKSIsKGEuaWdub3JlQ2FzZT8iaSI6IiIpKyhhLm11bHRpbGluZT8ibSI6IiIpKyhhLnVuaWNvZGU/InUiOiIiKSsoUWk/InkiOiJnIikpLGw9dm9pZCAwPT09bz9KaTpvPj4+MDtpZigwPT09bClyZXR1cm5bXTtpZigwPT09dS5sZW5ndGgpcmV0dXJuIG51bGw9PT1XaShmLHUpP1t1XTpbXTtmb3IodmFyIGg9MCxwPTAsZD1bXTtwPHUubGVuZ3RoOyl7Zi5sYXN0SW5kZXg9UWk/cDowO3ZhciB2LGc9V2koZixRaT91OnUuc2xpY2UocCkpO2lmKG51bGw9PT1nfHwodj1ZaShmdChmLmxhc3RJbmRleCsoUWk/MDpwKSksdS5sZW5ndGgpKT09PWgpcD16aSh1LHAsYyk7ZWxzZXtpZihkLnB1c2godS5zbGljZShoLHApKSxkLmxlbmd0aD09PWwpcmV0dXJuIGQ7Zm9yKHZhciB5PTE7eTw9Zy5sZW5ndGgtMTt5KyspaWYoZC5wdXNoKGdbeV0pLGQubGVuZ3RoPT09bClyZXR1cm4gZDtwPWg9dn19cmV0dXJuIGQucHVzaCh1LnNsaWNlKGgpKSxkfV19LCFRaSksTHQoe3RhcmdldDoiU2V0IixzdGF0OiEwfSx7ZnJvbTphbn0pLEx0KHt0YXJnZXQ6IlNldCIsc3RhdDohMH0se29mOnVufSk7dmFyIFppPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PWoodGhpcyksZT1lZSh0LmFkZCkscj0wLG49YXJndW1lbnRzLmxlbmd0aDtyPG47cisrKWUuY2FsbCh0LGFyZ3VtZW50c1tyXSk7cmV0dXJuIHR9O0x0KHt0YXJnZXQ6IlNldCIscHJvdG86ITAscmVhbDohMCxmb3JjZWQ6cX0se2FkZEFsbDpmdW5jdGlvbigpe3JldHVybiBaaS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fSksTHQoe3RhcmdldDoiU2V0Iixwcm90bzohMCxyZWFsOiEwLGZvcmNlZDpxfSx7ZGVsZXRlQWxsOmZ1bmN0aW9uKCl7cmV0dXJuIHNuLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19KTt2YXIgdGE9ZnVuY3Rpb24odCl7cmV0dXJuIFNldC5wcm90b3R5cGUudmFsdWVzLmNhbGwodCl9O0x0KHt0YXJnZXQ6IlNldCIscHJvdG86ITAscmVhbDohMCxmb3JjZWQ6cX0se2V2ZXJ5OmZ1bmN0aW9uKHQpe3ZhciBlPWoodGhpcykscj10YShlKSxuPXJlKHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDAsMyk7cmV0dXJuIUZyKHIsZnVuY3Rpb24odCl7aWYoIW4odCx0LGUpKXJldHVybiBGci5zdG9wKCl9LHZvaWQgMCwhMSwhMCkuc3RvcHBlZH19KSxMdCh7dGFyZ2V0OiJTZXQiLHByb3RvOiEwLHJlYWw6ITAsZm9yY2VkOnF9LHtkaWZmZXJlbmNlOmZ1bmN0aW9uKHQpe3ZhciBlPWoodGhpcykscj1uZXcoaG4oZSxpdCgiU2V0IikpKShlKSxuPWVlKHIuZGVsZXRlKTtyZXR1cm4gRnIodCxmdW5jdGlvbih0KXtuLmNhbGwocix0KX0pLHJ9fSksTHQoe3RhcmdldDoiU2V0Iixwcm90bzohMCxyZWFsOiEwLGZvcmNlZDpxfSx7ZmlsdGVyOmZ1bmN0aW9uKHQpe3ZhciBlPWoodGhpcykscj10YShlKSxuPXJlKHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDAsMyksbz1uZXcoaG4oZSxpdCgiU2V0IikpKSxpPWVlKG8uYWRkKTtyZXR1cm4gRnIocixmdW5jdGlvbih0KXtuKHQsdCxlKSYmaS5jYWxsKG8sdCl9LHZvaWQgMCwhMSwhMCksb319KSxMdCh7dGFyZ2V0OiJTZXQiLHByb3RvOiEwLHJlYWw6ITAsZm9yY2VkOnF9LHtmaW5kOmZ1bmN0aW9uKHQpe3ZhciBlPWoodGhpcykscj10YShlKSxuPXJlKHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDAsMyk7cmV0dXJuIEZyKHIsZnVuY3Rpb24odCl7aWYobih0LHQsZSkpcmV0dXJuIEZyLnN0b3AodCl9LHZvaWQgMCwhMSwhMCkucmVzdWx0fX0pLEx0KHt0YXJnZXQ6IlNldCIscHJvdG86ITAscmVhbDohMCxmb3JjZWQ6cX0se2ludGVyc2VjdGlvbjpmdW5jdGlvbih0KXt2YXIgZT1qKHRoaXMpLHI9bmV3KGhuKGUsaXQoIlNldCIpKSksbj1lZShlLmhhcyksbz1lZShyLmFkZCk7cmV0dXJuIEZyKHQsZnVuY3Rpb24odCl7bi5jYWxsKGUsdCkmJm8uY2FsbChyLHQpfSkscn19KSxMdCh7dGFyZ2V0OiJTZXQiLHByb3RvOiEwLHJlYWw6ITAsZm9yY2VkOnF9LHtpc0Rpc2pvaW50RnJvbTpmdW5jdGlvbih0KXt2YXIgZT1qKHRoaXMpLHI9ZWUoZS5oYXMpO3JldHVybiFGcih0LGZ1bmN0aW9uKHQpe2lmKCEwPT09ci5jYWxsKGUsdCkpcmV0dXJuIEZyLnN0b3AoKX0pLnN0b3BwZWR9fSksTHQoe3RhcmdldDoiU2V0Iixwcm90bzohMCxyZWFsOiEwLGZvcmNlZDpxfSx7aXNTdWJzZXRPZjpmdW5jdGlvbih0KXt2YXIgZT1jbih0aGlzKSxyPWoodCksbj1yLmhhcztyZXR1cm4iZnVuY3Rpb24iIT10eXBlb2YgbiYmKHI9bmV3KGl0KCJTZXQiKSkodCksbj1lZShyLmhhcykpLCFGcihlLGZ1bmN0aW9uKHQpe2lmKCExPT09bi5jYWxsKHIsdCkpcmV0dXJuIEZyLnN0b3AoKX0sdm9pZCAwLCExLCEwKS5zdG9wcGVkfX0pLEx0KHt0YXJnZXQ6IlNldCIscHJvdG86ITAscmVhbDohMCxmb3JjZWQ6cX0se2lzU3VwZXJzZXRPZjpmdW5jdGlvbih0KXt2YXIgZT1qKHRoaXMpLHI9ZWUoZS5oYXMpO3JldHVybiFGcih0LGZ1bmN0aW9uKHQpe2lmKCExPT09ci5jYWxsKGUsdCkpcmV0dXJuIEZyLnN0b3AoKX0pLnN0b3BwZWR9fSksTHQoe3RhcmdldDoiU2V0Iixwcm90bzohMCxyZWFsOiEwLGZvcmNlZDpxfSx7am9pbjpmdW5jdGlvbih0KXt2YXIgZT1qKHRoaXMpLHI9dGEoZSksbj12b2lkIDA9PT10PyIsIjpTdHJpbmcodCksbz1bXTtyZXR1cm4gRnIocixvLnB1c2gsbywhMSwhMCksby5qb2luKG4pfX0pLEx0KHt0YXJnZXQ6IlNldCIscHJvdG86ITAscmVhbDohMCxmb3JjZWQ6cX0se21hcDpmdW5jdGlvbih0KXt2YXIgZT1qKHRoaXMpLHI9dGEoZSksbj1yZSh0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwLDMpLG89bmV3KGhuKGUsaXQoIlNldCIpKSksaT1lZShvLmFkZCk7cmV0dXJuIEZyKHIsZnVuY3Rpb24odCl7aS5jYWxsKG8sbih0LHQsZSkpfSx2b2lkIDAsITEsITApLG99fSksTHQoe3RhcmdldDoiU2V0Iixwcm90bzohMCxyZWFsOiEwLGZvcmNlZDpxfSx7cmVkdWNlOmZ1bmN0aW9uKHQpe3ZhciBlPWoodGhpcykscj10YShlKSxuPWFyZ3VtZW50cy5sZW5ndGg8MixvPW4/dm9pZCAwOmFyZ3VtZW50c1sxXTtpZihlZSh0KSxGcihyLGZ1bmN0aW9uKHIpe24/KG49ITEsbz1yKTpvPXQobyxyLHIsZSl9LHZvaWQgMCwhMSwhMCksbil0aHJvdyBUeXBlRXJyb3IoIlJlZHVjZSBvZiBlbXB0eSBzZXQgd2l0aCBubyBpbml0aWFsIHZhbHVlIik7cmV0dXJuIG99fSksTHQoe3RhcmdldDoiU2V0Iixwcm90bzohMCxyZWFsOiEwLGZvcmNlZDpxfSx7c29tZTpmdW5jdGlvbih0KXt2YXIgZT1qKHRoaXMpLHI9dGEoZSksbj1yZSh0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwLDMpO3JldHVybiBGcihyLGZ1bmN0aW9uKHQpe2lmKG4odCx0LGUpKXJldHVybiBGci5zdG9wKCl9LHZvaWQgMCwhMSwhMCkuc3RvcHBlZH19KSxMdCh7dGFyZ2V0OiJTZXQiLHByb3RvOiEwLHJlYWw6ITAsZm9yY2VkOnF9LHtzeW1tZXRyaWNEaWZmZXJlbmNlOmZ1bmN0aW9uKHQpe3ZhciBlPWoodGhpcykscj1uZXcoaG4oZSxpdCgiU2V0IikpKShlKSxuPWVlKHIuZGVsZXRlKSxvPWVlKHIuYWRkKTtyZXR1cm4gRnIodCxmdW5jdGlvbih0KXtuLmNhbGwocix0KXx8by5jYWxsKHIsdCl9KSxyfX0pLEx0KHt0YXJnZXQ6IlNldCIscHJvdG86ITAscmVhbDohMCxmb3JjZWQ6cX0se3VuaW9uOmZ1bmN0aW9uKHQpe3ZhciBlPWoodGhpcykscj1uZXcoaG4oZSxpdCgiU2V0IikpKShlKTtyZXR1cm4gRnIodCxlZShyLmFkZCkscikscn19KTt2YXIgZWEscmEsbmE9aXQoIm5hdmlnYXRvciIsInVzZXJBZ2VudCIpfHwiIixvYT1uLnByb2Nlc3MsaWE9b2EmJm9hLnZlcnNpb25zLGFhPWlhJiZpYS52ODthYT9yYT0oZWE9YWEuc3BsaXQoIi4iKSlbMF0rZWFbMV06bmEmJighKGVhPW5hLm1hdGNoKC9FZGdlXC8oXGQrKS8pKXx8ZWFbMV0+PTc0KSYmKGVhPW5hLm1hdGNoKC9DaHJvbWVcLyhcZCspLykpJiYocmE9ZWFbMV0pO3ZhciB1YT1yYSYmK3JhLHNhPXF0KCJzcGVjaWVzIiksY2E9cXQoImlzQ29uY2F0U3ByZWFkYWJsZSIpLGZhPTkwMDcxOTkyNTQ3NDA5OTEsbGE9Ik1heGltdW0gYWxsb3dlZCBpbmRleCBleGNlZWRlZCIsaGE9dWE+PTUxfHwhbyhmdW5jdGlvbigpe3ZhciB0PVtdO3JldHVybiB0W2NhXT0hMSx0LmNvbmNhdCgpWzBdIT09dH0pLHBhPXVhPj01MXx8IW8oZnVuY3Rpb24oKXt2YXIgdD1bXTtyZXR1cm4odC5jb25zdHJ1Y3Rvcj17fSlbc2FdPWZ1bmN0aW9uKCl7cmV0dXJue2ZvbzoxfX0sMSE9PXQuY29uY2F0KEJvb2xlYW4pLmZvb30pLGRhPWZ1bmN0aW9uKHQpe2lmKCF5KHQpKXJldHVybiExO3ZhciBlPXRbY2FdO3JldHVybiB2b2lkIDAhPT1lPyEhZTppZSh0KX07THQoe3RhcmdldDoiQXJyYXkiLHByb3RvOiEwLGZvcmNlZDohaGF8fCFwYX0se2NvbmNhdDpmdW5jdGlvbih0KXt2YXIgZSxyLG4sbyxpLGE9VXQodGhpcyksdT11ZShhLDApLHM9MDtmb3IoZT0tMSxuPWFyZ3VtZW50cy5sZW5ndGg7ZTxuO2UrKylpZihkYShpPS0xPT09ZT9hOmFyZ3VtZW50c1tlXSkpe2lmKHMrKG89ZnQoaS5sZW5ndGgpKT5mYSl0aHJvdyBUeXBlRXJyb3IobGEpO2ZvcihyPTA7cjxvO3IrKyxzKyspciBpbiBpJiZzcih1LHMsaVtyXSl9ZWxzZXtpZihzPj1mYSl0aHJvdyBUeXBlRXJyb3IobGEpO3NyKHUscysrLGkpfXJldHVybiB1Lmxlbmd0aD1zLHV9fSk7dmFyIHZhPXd0LmYsZ2E9e30udG9TdHJpbmcseWE9Im9iamVjdCI9PXR5cGVvZiB3aW5kb3cmJndpbmRvdyYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM/T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KTpbXSxtYT17ZjpmdW5jdGlvbih0KXtyZXR1cm4geWEmJiJbb2JqZWN0IFdpbmRvd10iPT1nYS5jYWxsKHQpP2Z1bmN0aW9uKHQpe3RyeXtyZXR1cm4gdmEodCl9Y2F0Y2godCl7cmV0dXJuIHlhLnNsaWNlKCl9fSh0KTp2YShnKHQpKX19LGJhPXtmOnF0fSx3YT1JLmYsU2E9ZnVuY3Rpb24odCl7dmFyIGU9bnQuU3ltYm9sfHwobnQuU3ltYm9sPXt9KTt3KGUsdCl8fHdhKGUsdCx7dmFsdWU6YmEuZih0KX0pfSxFYT1mZS5mb3JFYWNoLHhhPVYoImhpZGRlbiIpLEFhPSJTeW1ib2wiLE9hPSJwcm90b3R5cGUiLFJhPXF0KCJ0b1ByaW1pdGl2ZSIpLGphPWV0LnNldCxQYT1ldC5nZXR0ZXJGb3IoQWEpLElhPU9iamVjdFtPYV0sVGE9bi5TeW1ib2wsa2E9aXQoIkpTT04iLCJzdHJpbmdpZnkiKSxMYT1SLmYsVWE9SS5mLE1hPW1hLmYsX2E9Yy5mLE5hPXooInN5bWJvbHMiKSxDYT16KCJvcC1zeW1ib2xzIiksRmE9eigic3RyaW5nLXRvLXN5bWJvbC1yZWdpc3RyeSIpLEJhPXooInN5bWJvbC10by1zdHJpbmctcmVnaXN0cnkiKSxEYT16KCJ3a3MiKSxxYT1uLlFPYmplY3QsemE9IXFhfHwhcWFbT2FdfHwhcWFbT2FdLmZpbmRDaGlsZCxXYT1pJiZvKGZ1bmN0aW9uKCl7cmV0dXJuIDchPUp0KFVhKHt9LCJhIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFVhKHRoaXMsImEiLHt2YWx1ZTo3fSkuYX19KSkuYX0pP2Z1bmN0aW9uKHQsZSxyKXt2YXIgbj1MYShJYSxlKTtuJiZkZWxldGUgSWFbZV0sVWEodCxlLHIpLG4mJnQhPT1JYSYmVWEoSWEsZSxuKX06VWEsS2E9ZnVuY3Rpb24odCxlKXt2YXIgcj1OYVt0XT1KdChUYVtPYV0pO3JldHVybiBqYShyLHt0eXBlOkFhLHRhZzp0LGRlc2NyaXB0aW9uOmV9KSxpfHwoci5kZXNjcmlwdGlvbj1lKSxyfSxHYT1DdD9mdW5jdGlvbih0KXtyZXR1cm4ic3ltYm9sIj09dHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QodClpbnN0YW5jZW9mIFRhfSwkYT1mdW5jdGlvbih0LGUscil7dD09PUlhJiYkYShDYSxlLHIpLGoodCk7dmFyIG49bShlLCEwKTtyZXR1cm4gaihyKSx3KE5hLG4pPyhyLmVudW1lcmFibGU/KHcodCx4YSkmJnRbeGFdW25dJiYodFt4YV1bbl09ITEpLHI9SnQocix7ZW51bWVyYWJsZTpmKDAsITEpfSkpOih3KHQseGEpfHxVYSh0LHhhLGYoMSx7fSkpLHRbeGFdW25dPSEwKSxXYSh0LG4scikpOlVhKHQsbixyKX0sVmE9ZnVuY3Rpb24odCxlKXtqKHQpO3ZhciByPWcoZSksbj16dChyKS5jb25jYXQoSmEocikpO3JldHVybiBFYShuLGZ1bmN0aW9uKGUpe2kmJiFIYS5jYWxsKHIsZSl8fCRhKHQsZSxyW2VdKX0pLHR9LEhhPWZ1bmN0aW9uKHQpe3ZhciBlPW0odCwhMCkscj1fYS5jYWxsKHRoaXMsZSk7cmV0dXJuISh0aGlzPT09SWEmJncoTmEsZSkmJiF3KENhLGUpKSYmKCEocnx8IXcodGhpcyxlKXx8IXcoTmEsZSl8fHcodGhpcyx4YSkmJnRoaXNbeGFdW2VdKXx8cil9LFhhPWZ1bmN0aW9uKHQsZSl7dmFyIHI9Zyh0KSxuPW0oZSwhMCk7aWYociE9PUlhfHwhdyhOYSxuKXx8dyhDYSxuKSl7dmFyIG89TGEocixuKTtyZXR1cm4hb3x8IXcoTmEsbil8fHcocix4YSkmJnJbeGFdW25dfHwoby5lbnVtZXJhYmxlPSEwKSxvfX0sWWE9ZnVuY3Rpb24odCl7dmFyIGU9TWEoZyh0KSkscj1bXTtyZXR1cm4gRWEoZSxmdW5jdGlvbih0KXt3KE5hLHQpfHx3KEgsdCl8fHIucHVzaCh0KX0pLHJ9LEphPWZ1bmN0aW9uKHQpe3ZhciBlPXQ9PT1JYSxyPU1hKGU/Q2E6Zyh0KSksbj1bXTtyZXR1cm4gRWEocixmdW5jdGlvbih0KXshdyhOYSx0KXx8ZSYmIXcoSWEsdCl8fG4ucHVzaChOYVt0XSl9KSxufTtpZihOdHx8KFRhPWZ1bmN0aW9uKCl7aWYodGhpcyBpbnN0YW5jZW9mIFRhKXRocm93IFR5cGVFcnJvcigiU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIik7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP1N0cmluZyhhcmd1bWVudHNbMF0pOnZvaWQgMCxlPUcodCkscj1mdW5jdGlvbih0KXt0aGlzPT09SWEmJnIuY2FsbChDYSx0KSx3KHRoaXMseGEpJiZ3KHRoaXNbeGFdLGUpJiYodGhpc1t4YV1bZV09ITEpLFdhKHRoaXMsZSxmKDEsdCkpfTtyZXR1cm4gaSYmemEmJldhKElhLGUse2NvbmZpZ3VyYWJsZTohMCxzZXQ6cn0pLEthKGUsdCl9LHJ0KFRhW09hXSwidG9TdHJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIFBhKHRoaXMpLnRhZ30pLHJ0KFRhLCJ3aXRob3V0U2V0dGVyIixmdW5jdGlvbih0KXtyZXR1cm4gS2EoRyh0KSx0KX0pLGMuZj1IYSxJLmY9JGEsUi5mPVhhLHd0LmY9bWEuZj1ZYSxTdC5mPUphLGJhLmY9ZnVuY3Rpb24odCl7cmV0dXJuIEthKHF0KHQpLHQpfSxpJiYoVWEoVGFbT2FdLCJkZXNjcmlwdGlvbiIse2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gUGEodGhpcykuZGVzY3JpcHRpb259fSkscnQoSWEsInByb3BlcnR5SXNFbnVtZXJhYmxlIixIYSx7dW5zYWZlOiEwfSkpKSxMdCh7Z2xvYmFsOiEwLHdyYXA6ITAsZm9yY2VkOiFOdCxzaGFtOiFOdH0se1N5bWJvbDpUYX0pLEVhKHp0KERhKSxmdW5jdGlvbih0KXtTYSh0KX0pLEx0KHt0YXJnZXQ6QWEsc3RhdDohMCxmb3JjZWQ6IU50fSx7Zm9yOmZ1bmN0aW9uKHQpe3ZhciBlPVN0cmluZyh0KTtpZih3KEZhLGUpKXJldHVybiBGYVtlXTt2YXIgcj1UYShlKTtyZXR1cm4gRmFbZV09cixCYVtyXT1lLHJ9LGtleUZvcjpmdW5jdGlvbih0KXtpZighR2EodCkpdGhyb3cgVHlwZUVycm9yKHQrIiBpcyBub3QgYSBzeW1ib2wiKTtpZih3KEJhLHQpKXJldHVybiBCYVt0XX0sdXNlU2V0dGVyOmZ1bmN0aW9uKCl7emE9ITB9LHVzZVNpbXBsZTpmdW5jdGlvbigpe3phPSExfX0pLEx0KHt0YXJnZXQ6Ik9iamVjdCIsc3RhdDohMCxmb3JjZWQ6IU50LHNoYW06IWl9LHtjcmVhdGU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09ZT9KdCh0KTpWYShKdCh0KSxlKX0sZGVmaW5lUHJvcGVydHk6JGEsZGVmaW5lUHJvcGVydGllczpWYSxnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6WGF9KSxMdCh7dGFyZ2V0OiJPYmplY3QiLHN0YXQ6ITAsZm9yY2VkOiFOdH0se2dldE93blByb3BlcnR5TmFtZXM6WWEsZ2V0T3duUHJvcGVydHlTeW1ib2xzOkphfSksTHQoe3RhcmdldDoiT2JqZWN0IixzdGF0OiEwLGZvcmNlZDpvKGZ1bmN0aW9uKCl7U3QuZigxKX0pfSx7Z2V0T3duUHJvcGVydHlTeW1ib2xzOmZ1bmN0aW9uKHQpe3JldHVybiBTdC5mKFV0KHQpKX19KSxrYSl7dmFyIFFhPSFOdHx8byhmdW5jdGlvbigpe3ZhciB0PVRhKCk7cmV0dXJuIltudWxsXSIhPWthKFt0XSl8fCJ7fSIhPWthKHthOnR9KXx8Int9IiE9a2EoT2JqZWN0KHQpKX0pO0x0KHt0YXJnZXQ6IkpTT04iLHN0YXQ6ITAsZm9yY2VkOlFhfSx7c3RyaW5naWZ5OmZ1bmN0aW9uKHQsZSxyKXtmb3IodmFyIG4sbz1bdF0saT0xO2FyZ3VtZW50cy5sZW5ndGg+aTspby5wdXNoKGFyZ3VtZW50c1tpKytdKTtpZihuPWUsKHkoZSl8fHZvaWQgMCE9PXQpJiYhR2EodCkpcmV0dXJuIGllKGUpfHwoZT1mdW5jdGlvbih0LGUpe2lmKCJmdW5jdGlvbiI9PXR5cGVvZiBuJiYoZT1uLmNhbGwodGhpcyx0LGUpKSwhR2EoZSkpcmV0dXJuIGV9KSxvWzFdPWUsa2EuYXBwbHkobnVsbCxvKX19KX1UYVtPYV1bUmFdfHxUKFRhW09hXSxSYSxUYVtPYV0udmFsdWVPZiksQmUoVGEsQWEpLEhbeGFdPSEwLFNhKCJhc3luY0l0ZXJhdG9yIik7dmFyIFphPUkuZix0dT1uLlN5bWJvbDtpZihpJiYiZnVuY3Rpb24iPT10eXBlb2YgdHUmJighKCJkZXNjcmlwdGlvbiJpbiB0dS5wcm90b3R5cGUpfHx2b2lkIDAhPT10dSgpLmRlc2NyaXB0aW9uKSl7dmFyIGV1PXt9LHJ1PWZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aDwxfHx2b2lkIDA9PT1hcmd1bWVudHNbMF0/dm9pZCAwOlN0cmluZyhhcmd1bWVudHNbMF0pLGU9dGhpcyBpbnN0YW5jZW9mIHJ1P25ldyB0dSh0KTp2b2lkIDA9PT10P3R1KCk6dHUodCk7cmV0dXJuIiI9PT10JiYoZXVbZV09ITApLGV9O3h0KHJ1LHR1KTt2YXIgbnU9cnUucHJvdG90eXBlPXR1LnByb3RvdHlwZTtudS5jb25zdHJ1Y3Rvcj1ydTt2YXIgb3U9bnUudG9TdHJpbmcsaXU9IlN5bWJvbCh0ZXN0KSI9PVN0cmluZyh0dSgidGVzdCIpKSxhdT0vXlN5bWJvbFwoKC4qKVwpW14pXSskLztaYShudSwiZGVzY3JpcHRpb24iLHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7dmFyIHQ9eSh0aGlzKT90aGlzLnZhbHVlT2YoKTp0aGlzLGU9b3UuY2FsbCh0KTtpZih3KGV1LHQpKXJldHVybiIiO3ZhciByPWl1P2Uuc2xpY2UoNywtMSk6ZS5yZXBsYWNlKGF1LCIkMSIpO3JldHVybiIiPT09cj92b2lkIDA6cn19KSxMdCh7Z2xvYmFsOiEwLGZvcmNlZDohMH0se1N5bWJvbDpydX0pfVNhKCJoYXNJbnN0YW5jZSIpLFNhKCJpc0NvbmNhdFNwcmVhZGFibGUiKSxTYSgiaXRlcmF0b3IiKSxTYSgibWF0Y2giKSxTYSgibWF0Y2hBbGwiKSxTYSgicmVwbGFjZSIpLFNhKCJzZWFyY2giKSxTYSgic3BlY2llcyIpLFNhKCJzcGxpdCIpLFNhKCJ0b1ByaW1pdGl2ZSIpLFNhKCJ0b1N0cmluZ1RhZyIpLFNhKCJ1bnNjb3BhYmxlcyIpLEJlKE1hdGgsIk1hdGgiLCEwKSxCZShuLkpTT04sIkpTT04iLCEwKSxTYSgiYXN5bmNEaXNwb3NlIiksU2EoImRpc3Bvc2UiKSxTYSgib2JzZXJ2YWJsZSIpLFNhKCJwYXR0ZXJuTWF0Y2giKSxTYSgicmVwbGFjZUFsbCIpLGJhLmYoImFzeW5jSXRlcmF0b3IiKTt2YXIgdXU9SWUuY29kZUF0O0x0KHt0YXJnZXQ6IlN0cmluZyIscHJvdG86ITB9LHtjb2RlUG9pbnRBdDpmdW5jdGlvbih0KXtyZXR1cm4gdXUodGhpcyx0KX19KSxvZSgiU3RyaW5nIiwiY29kZVBvaW50QXQiKTt2YXIgc3UsY3U9ZnVuY3Rpb24odCl7aWYoUW8odCkpdGhyb3cgVHlwZUVycm9yKCJUaGUgbWV0aG9kIGRvZXNuJ3QgYWNjZXB0IHJlZ3VsYXIgZXhwcmVzc2lvbnMiKTtyZXR1cm4gdH0sZnU9cXQoIm1hdGNoIiksbHU9ZnVuY3Rpb24odCl7dmFyIGU9Ly4vO3RyeXsiLy4vIlt0XShlKX1jYXRjaChyKXt0cnl7cmV0dXJuIGVbZnVdPSExLCIvLi8iW3RdKGUpfWNhdGNoKHQpe319cmV0dXJuITF9LGh1PVIuZixwdT0iIi5lbmRzV2l0aCxkdT1NYXRoLm1pbix2dT1sdSgiZW5kc1dpdGgiKSxndT0hKHZ1fHwoc3U9aHUoU3RyaW5nLnByb3RvdHlwZSwiZW5kc1dpdGgiKSwhc3V8fHN1LndyaXRhYmxlKSk7THQoe3RhcmdldDoiU3RyaW5nIixwcm90bzohMCxmb3JjZWQ6IWd1JiYhdnV9LHtlbmRzV2l0aDpmdW5jdGlvbih0KXt2YXIgZT1TdHJpbmcodih0aGlzKSk7Y3UodCk7dmFyIHI9YXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDAsbj1mdChlLmxlbmd0aCksbz12b2lkIDA9PT1yP246ZHUoZnQociksbiksaT1TdHJpbmcodCk7cmV0dXJuIHB1P3B1LmNhbGwoZSxpLG8pOmUuc2xpY2Uoby1pLmxlbmd0aCxvKT09PWl9fSksb2UoIlN0cmluZyIsImVuZHNXaXRoIik7dmFyIHl1PVN0cmluZy5mcm9tQ2hhckNvZGUsbXU9U3RyaW5nLmZyb21Db2RlUG9pbnQ7THQoe3RhcmdldDoiU3RyaW5nIixzdGF0OiEwLGZvcmNlZDohIW11JiYxIT1tdS5sZW5ndGh9LHtmcm9tQ29kZVBvaW50OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxyPVtdLG49YXJndW1lbnRzLmxlbmd0aCxvPTA7bj5vOyl7aWYoZT0rYXJndW1lbnRzW28rK10scHQoZSwxMTE0MTExKSE9PWUpdGhyb3cgUmFuZ2VFcnJvcihlKyIgaXMgbm90IGEgdmFsaWQgY29kZSBwb2ludCIpO3IucHVzaChlPDY1NTM2P3l1KGUpOnl1KDU1Mjk2KygoZS09NjU1MzYpPj4xMCksZSUxMDI0KzU2MzIwKSl9cmV0dXJuIHIuam9pbigiIil9fSksTHQoe3RhcmdldDoiU3RyaW5nIixwcm90bzohMCxmb3JjZWQ6IWx1KCJpbmNsdWRlcyIpfSx7aW5jbHVkZXM6ZnVuY3Rpb24odCl7cmV0dXJuISF+U3RyaW5nKHYodGhpcykpLmluZGV4T2YoY3UodCksYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pLG9lKCJTdHJpbmciLCJpbmNsdWRlcyIpO3ZhciBidT0iIi5yZXBlYXR8fGZ1bmN0aW9uKHQpe3ZhciBlPVN0cmluZyh2KHRoaXMpKSxyPSIiLG49c3QodCk7aWYobjwwfHxJbmZpbml0eT09bil0aHJvdyBSYW5nZUVycm9yKCJXcm9uZyBudW1iZXIgb2YgcmVwZXRpdGlvbnMiKTtmb3IoO24+MDsobj4+Pj0xKSYmKGUrPWUpKTEmbiYmKHIrPWUpO3JldHVybiByfSx3dT1NYXRoLmNlaWwsU3U9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUscixuKXt2YXIgbyxpLGE9U3RyaW5nKHYoZSkpLHU9YS5sZW5ndGgscz12b2lkIDA9PT1uPyIgIjpTdHJpbmcobiksYz1mdChyKTtyZXR1cm4gYzw9dXx8IiI9PXM/YTooKGk9YnUuY2FsbChzLHd1KChvPWMtdSkvcy5sZW5ndGgpKSkubGVuZ3RoPm8mJihpPWkuc2xpY2UoMCxvKSksdD9hK2k6aSthKX19LEV1PXtzdGFydDpTdSghMSksZW5kOlN1KCEwKX0seHU9L1ZlcnNpb25cLzEwXC5cZCsoXC5cZCspPyggTW9iaWxlXC9cdyspPyBTYWZhcmlcLy8udGVzdChuYSksQXU9RXUuc3RhcnQ7THQoe3RhcmdldDoiU3RyaW5nIixwcm90bzohMCxmb3JjZWQ6eHV9LHtwYWRTdGFydDpmdW5jdGlvbih0KXtyZXR1cm4gQXUodGhpcyx0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX19KSxvZSgiU3RyaW5nIiwicGFkU3RhcnQiKTt2YXIgT3U9RXUuZW5kO0x0KHt0YXJnZXQ6IlN0cmluZyIscHJvdG86ITAsZm9yY2VkOnh1fSx7cGFkRW5kOmZ1bmN0aW9uKHQpe3JldHVybiBPdSh0aGlzLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pLG9lKCJTdHJpbmciLCJwYWRFbmQiKSxMdCh7dGFyZ2V0OiJTdHJpbmciLHN0YXQ6ITB9LHtyYXc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPWcodC5yYXcpLHI9ZnQoZS5sZW5ndGgpLG49YXJndW1lbnRzLmxlbmd0aCxvPVtdLGk9MDtyPmk7KW8ucHVzaChTdHJpbmcoZVtpKytdKSksaTxuJiZvLnB1c2goU3RyaW5nKGFyZ3VtZW50c1tpXSkpO3JldHVybiBvLmpvaW4oIiIpfX0pLEx0KHt0YXJnZXQ6IlN0cmluZyIscHJvdG86ITB9LHtyZXBlYXQ6YnV9KSxvZSgiU3RyaW5nIiwicmVwZWF0Iik7dmFyIFJ1PVIuZixqdT0iIi5zdGFydHNXaXRoLFB1PU1hdGgubWluLEl1PWx1KCJzdGFydHNXaXRoIiksVHU9IUl1JiYhIWZ1bmN0aW9uKCl7dmFyIHQ9UnUoU3RyaW5nLnByb3RvdHlwZSwic3RhcnRzV2l0aCIpO3JldHVybiB0JiYhdC53cml0YWJsZX0oKTtMdCh7dGFyZ2V0OiJTdHJpbmciLHByb3RvOiEwLGZvcmNlZDohVHUmJiFJdX0se3N0YXJ0c1dpdGg6ZnVuY3Rpb24odCl7dmFyIGU9U3RyaW5nKHYodGhpcykpO2N1KHQpO3ZhciByPWZ0KFB1KGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwLGUubGVuZ3RoKSksbj1TdHJpbmcodCk7cmV0dXJuIGp1P2p1LmNhbGwoZSxuLHIpOmUuc2xpY2UocixyK24ubGVuZ3RoKT09PW59fSksb2UoIlN0cmluZyIsInN0YXJ0c1dpdGgiKTt2YXIga3U9ZnVuY3Rpb24odCl7cmV0dXJuIG8oZnVuY3Rpb24oKXtyZXR1cm4hIWRuW3RdKCl8fCLigIvCheGgjiIhPSLigIvCheGgjiJbdF0oKXx8ZG5bdF0ubmFtZSE9PXR9KX0sTHU9Ym4uc3RhcnQsVXU9a3UoInRyaW1TdGFydCIpLE11PVV1P2Z1bmN0aW9uKCl7cmV0dXJuIEx1KHRoaXMpfToiIi50cmltU3RhcnQ7THQoe3RhcmdldDoiU3RyaW5nIixwcm90bzohMCxmb3JjZWQ6VXV9LHt0cmltU3RhcnQ6TXUsdHJpbUxlZnQ6TXV9KSxvZSgiU3RyaW5nIiwidHJpbUxlZnQiKTt2YXIgX3U9Ym4uZW5kLE51PWt1KCJ0cmltRW5kIiksQ3U9TnU/ZnVuY3Rpb24oKXtyZXR1cm4gX3UodGhpcyl9OiIiLnRyaW1FbmQ7THQoe3RhcmdldDoiU3RyaW5nIixwcm90bzohMCxmb3JjZWQ6TnV9LHt0cmltRW5kOkN1LHRyaW1SaWdodDpDdX0pLG9lKCJTdHJpbmciLCJ0cmltUmlnaHQiKTt2YXIgRnU9cXQoIml0ZXJhdG9yIiksQnU9IW8oZnVuY3Rpb24oKXt2YXIgdD1uZXcgVVJMKCJiP2E9MSZiPTImYz0zIiwiaHR0cDovL2EiKSxlPXQuc2VhcmNoUGFyYW1zLHI9IiI7cmV0dXJuIHQucGF0aG5hbWU9ImMlMjBkIixlLmZvckVhY2goZnVuY3Rpb24odCxuKXtlLmRlbGV0ZSgiYiIpLHIrPW4rdH0pLCFlLnNvcnR8fCJodHRwOi8vYS9jJTIwZD9hPTEmYz0zIiE9PXQuaHJlZnx8IjMiIT09ZS5nZXQoImMiKXx8ImE9MSIhPT1TdHJpbmcobmV3IFVSTFNlYXJjaFBhcmFtcygiP2E9MSIpKXx8IWVbRnVdfHwiYSIhPT1uZXcgVVJMKCJodHRwczovL2FAYiIpLnVzZXJuYW1lfHwiYiIhPT1uZXcgVVJMU2VhcmNoUGFyYW1zKG5ldyBVUkxTZWFyY2hQYXJhbXMoImE9YiIpKS5nZXQoImEiKXx8InhuLS1lMWF5YmMiIT09bmV3IFVSTCgiaHR0cDovL9GC0LXRgdGCIikuaG9zdHx8IiMlRDAlQjEiIT09bmV3IFVSTCgiaHR0cDovL2Ej0LEiKS5oYXNofHwiYTFjMyIhPT1yfHwieCIhPT1uZXcgVVJMKCJodHRwOi8veCIsdm9pZCAwKS5ob3N0fSksRHU9T2JqZWN0LmFzc2lnbixxdT1PYmplY3QuZGVmaW5lUHJvcGVydHksenU9IUR1fHxvKGZ1bmN0aW9uKCl7aWYoaSYmMSE9PUR1KHtiOjF9LER1KHF1KHt9LCJhIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtxdSh0aGlzLCJiIix7dmFsdWU6MyxlbnVtZXJhYmxlOiExfSl9fSkse2I6Mn0pKS5iKXJldHVybiEwO3ZhciB0PXt9LGU9e30scj1TeW1ib2woKSxuPSJhYmNkZWZnaGlqa2xtbm9wcXJzdCI7cmV0dXJuIHRbcl09NyxuLnNwbGl0KCIiKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2VbdF09dH0pLDchPUR1KHt9LHQpW3JdfHx6dChEdSh7fSxlKSkuam9pbigiIikhPW59KT9mdW5jdGlvbih0LGUpe2Zvcih2YXIgcj1VdCh0KSxuPWFyZ3VtZW50cy5sZW5ndGgsbz0xLGE9U3QuZix1PWMuZjtuPm87KWZvcih2YXIgcyxmPWQoYXJndW1lbnRzW28rK10pLGw9YT96dChmKS5jb25jYXQoYShmKSk6enQoZiksaD1sLmxlbmd0aCxwPTA7aD5wOylzPWxbcCsrXSxpJiYhdS5jYWxsKGYscyl8fChyW3NdPWZbc10pO3JldHVybiByfTpEdSxXdT0yMTQ3NDgzNjQ3LEt1PS9bXlwwLVx1MDA3RV0vLEd1PS9bLlx1MzAwMlx1RkYwRVx1RkY2MV0vZywkdT0iT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MiLFZ1PU1hdGguZmxvb3IsSHU9U3RyaW5nLmZyb21DaGFyQ29kZSxYdT1mdW5jdGlvbih0KXtyZXR1cm4gdCsyMis3NSoodDwyNil9LFl1PWZ1bmN0aW9uKHQsZSxyKXt2YXIgbj0wO2Zvcih0PXI/VnUodC83MDApOnQ+PjEsdCs9VnUodC9lKTt0PjQ1NTtuKz0zNil0PVZ1KHQvMzUpO3JldHVybiBWdShuKzM2KnQvKHQrMzgpKX0sSnU9ZnVuY3Rpb24odCl7dmFyIGU9W107dD1mdW5jdGlvbih0KXtmb3IodmFyIGU9W10scj0wLG49dC5sZW5ndGg7cjxuOyl7dmFyIG89dC5jaGFyQ29kZUF0KHIrKyk7aWYobz49NTUyOTYmJm88PTU2MzE5JiZyPG4pe3ZhciBpPXQuY2hhckNvZGVBdChyKyspOzU2MzIwPT0oNjQ1MTImaSk/ZS5wdXNoKCgoMTAyMyZvKTw8MTApKygxMDIzJmkpKzY1NTM2KTooZS5wdXNoKG8pLHItLSl9ZWxzZSBlLnB1c2gobyl9cmV0dXJuIGV9KHQpO3ZhciByLG4sbz10Lmxlbmd0aCxpPTEyOCxhPTAsdT03Mjtmb3Iocj0wO3I8dC5sZW5ndGg7cisrKShuPXRbcl0pPDEyOCYmZS5wdXNoKEh1KG4pKTt2YXIgcz1lLmxlbmd0aCxjPXM7Zm9yKHMmJmUucHVzaCgiLSIpO2M8bzspe3ZhciBmPVd1O2ZvcihyPTA7cjx0Lmxlbmd0aDtyKyspKG49dFtyXSk+PWkmJm48ZiYmKGY9bik7dmFyIGw9YysxO2lmKGYtaT5WdSgoV3UtYSkvbCkpdGhyb3cgUmFuZ2VFcnJvcigkdSk7Zm9yKGErPShmLWkpKmwsaT1mLHI9MDtyPHQubGVuZ3RoO3IrKyl7aWYoKG49dFtyXSk8aSYmKythPld1KXRocm93IFJhbmdlRXJyb3IoJHUpO2lmKG49PWkpe2Zvcih2YXIgaD1hLHA9MzY7O3ArPTM2KXt2YXIgZD1wPD11PzE6cD49dSsyNj8yNjpwLXU7aWYoaDxkKWJyZWFrO3ZhciB2PWgtZCxnPTM2LWQ7ZS5wdXNoKEh1KFh1KGQrdiVnKSkpLGg9VnUodi9nKX1lLnB1c2goSHUoWHUoaCkpKSx1PVl1KGEsbCxjPT1zKSxhPTAsKytjfX0rK2EsKytpfXJldHVybiBlLmpvaW4oIiIpfSxRdT1pdCgiZmV0Y2giKSxadT1pdCgiSGVhZGVycyIpLHRzPXF0KCJpdGVyYXRvciIpLGVzPSJVUkxTZWFyY2hQYXJhbXMiLHJzPWVzKyJJdGVyYXRvciIsbnM9ZXQuc2V0LG9zPWV0LmdldHRlckZvcihlcyksaXM9ZXQuZ2V0dGVyRm9yKHJzKSxhcz0vXCsvZyx1cz1BcnJheSg0KSxzcz1mdW5jdGlvbih0KXtyZXR1cm4gdXNbdC0xXXx8KHVzW3QtMV09UmVnRXhwKCIoKD86JVtcXGRhLWZdezJ9KXsiK3QrIn0pIiwiZ2kiKSl9LGNzPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHQpfWNhdGNoKGUpe3JldHVybiB0fX0sZnM9ZnVuY3Rpb24odCl7dmFyIGU9dC5yZXBsYWNlKGFzLCIgIikscj00O3RyeXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGUpfWNhdGNoKHQpe2Zvcig7cjspZT1lLnJlcGxhY2Uoc3Moci0tKSxjcyk7cmV0dXJuIGV9fSxscz0vWyEnKCl+XXwlMjAvZyxocz17IiEiOiIlMjEiLCInIjoiJTI3IiwiKCI6IiUyOCIsIikiOiIlMjkiLCJ+IjoiJTdFIiwiJTIwIjoiKyJ9LHBzPWZ1bmN0aW9uKHQpe3JldHVybiBoc1t0XX0sZHM9ZnVuY3Rpb24odCl7cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh0KS5yZXBsYWNlKGxzLHBzKX0sdnM9ZnVuY3Rpb24odCxlKXtpZihlKWZvcih2YXIgcixuLG89ZS5zcGxpdCgiJiIpLGk9MDtpPG8ubGVuZ3RoOykocj1vW2krK10pLmxlbmd0aCYmKG49ci5zcGxpdCgiPSIpLHQucHVzaCh7a2V5OmZzKG4uc2hpZnQoKSksdmFsdWU6ZnMobi5qb2luKCI9IikpfSkpfSxncz1mdW5jdGlvbih0KXt0aGlzLmVudHJpZXMubGVuZ3RoPTAsdnModGhpcy5lbnRyaWVzLHQpfSx5cz1mdW5jdGlvbih0LGUpe2lmKHQ8ZSl0aHJvdyBUeXBlRXJyb3IoIk5vdCBlbm91Z2ggYXJndW1lbnRzIil9LG1zPVdlKGZ1bmN0aW9uKHQsZSl7bnModGhpcyx7dHlwZTpycyxpdGVyYXRvcjpjbihvcyh0KS5lbnRyaWVzKSxraW5kOmV9KX0sIkl0ZXJhdG9yIixmdW5jdGlvbigpe3ZhciB0PWlzKHRoaXMpLGU9dC5raW5kLHI9dC5pdGVyYXRvci5uZXh0KCksbj1yLnZhbHVlO3JldHVybiByLmRvbmV8fChyLnZhbHVlPSJrZXlzIj09PWU/bi5rZXk6InZhbHVlcyI9PT1lP24udmFsdWU6W24ua2V5LG4udmFsdWVdKSxyfSksYnM9ZnVuY3Rpb24oKXtCcih0aGlzLGJzLGVzKTt2YXIgdCxlLHIsbixvLGksYSx1LHMsYz1hcmd1bWVudHMubGVuZ3RoPjA/YXJndW1lbnRzWzBdOnZvaWQgMCxmPVtdO2lmKG5zKHRoaXMse3R5cGU6ZXMsZW50cmllczpmLHVwZGF0ZVVSTDpmdW5jdGlvbigpe30sdXBkYXRlU2VhcmNoUGFyYW1zOmdzfSksdm9pZCAwIT09YylpZih5KGMpKWlmKCJmdW5jdGlvbiI9PXR5cGVvZih0PXZyKGMpKSlmb3Iocj0oZT10LmNhbGwoYykpLm5leHQ7IShuPXIuY2FsbChlKSkuZG9uZTspe2lmKChhPShpPShvPWNuKGoobi52YWx1ZSkpKS5uZXh0KS5jYWxsKG8pKS5kb25lfHwodT1pLmNhbGwobykpLmRvbmV8fCFpLmNhbGwobykuZG9uZSl0aHJvdyBUeXBlRXJyb3IoIkV4cGVjdGVkIHNlcXVlbmNlIHdpdGggbGVuZ3RoIDIiKTtmLnB1c2goe2tleTphLnZhbHVlKyIiLHZhbHVlOnUudmFsdWUrIiJ9KX1lbHNlIGZvcihzIGluIGMpdyhjLHMpJiZmLnB1c2goe2tleTpzLHZhbHVlOmNbc10rIiJ9KTtlbHNlIHZzKGYsInN0cmluZyI9PXR5cGVvZiBjPyI/Ij09PWMuY2hhckF0KDApP2Muc2xpY2UoMSk6YzpjKyIiKX0sd3M9YnMucHJvdG90eXBlO3pyKHdzLHthcHBlbmQ6ZnVuY3Rpb24odCxlKXt5cyhhcmd1bWVudHMubGVuZ3RoLDIpO3ZhciByPW9zKHRoaXMpO3IuZW50cmllcy5wdXNoKHtrZXk6dCsiIix2YWx1ZTplKyIifSksci51cGRhdGVVUkwoKX0sZGVsZXRlOmZ1bmN0aW9uKHQpe3lzKGFyZ3VtZW50cy5sZW5ndGgsMSk7Zm9yKHZhciBlPW9zKHRoaXMpLHI9ZS5lbnRyaWVzLG49dCsiIixvPTA7bzxyLmxlbmd0aDspcltvXS5rZXk9PT1uP3Iuc3BsaWNlKG8sMSk6bysrO2UudXBkYXRlVVJMKCl9LGdldDpmdW5jdGlvbih0KXt5cyhhcmd1bWVudHMubGVuZ3RoLDEpO2Zvcih2YXIgZT1vcyh0aGlzKS5lbnRyaWVzLHI9dCsiIixuPTA7bjxlLmxlbmd0aDtuKyspaWYoZVtuXS5rZXk9PT1yKXJldHVybiBlW25dLnZhbHVlO3JldHVybiBudWxsfSxnZXRBbGw6ZnVuY3Rpb24odCl7eXMoYXJndW1lbnRzLmxlbmd0aCwxKTtmb3IodmFyIGU9b3ModGhpcykuZW50cmllcyxyPXQrIiIsbj1bXSxvPTA7bzxlLmxlbmd0aDtvKyspZVtvXS5rZXk9PT1yJiZuLnB1c2goZVtvXS52YWx1ZSk7cmV0dXJuIG59LGhhczpmdW5jdGlvbih0KXt5cyhhcmd1bWVudHMubGVuZ3RoLDEpO2Zvcih2YXIgZT1vcyh0aGlzKS5lbnRyaWVzLHI9dCsiIixuPTA7bjxlLmxlbmd0aDspaWYoZVtuKytdLmtleT09PXIpcmV0dXJuITA7cmV0dXJuITF9LHNldDpmdW5jdGlvbih0LGUpe3lzKGFyZ3VtZW50cy5sZW5ndGgsMSk7Zm9yKHZhciByLG49b3ModGhpcyksbz1uLmVudHJpZXMsaT0hMSxhPXQrIiIsdT1lKyIiLHM9MDtzPG8ubGVuZ3RoO3MrKykocj1vW3NdKS5rZXk9PT1hJiYoaT9vLnNwbGljZShzLS0sMSk6KGk9ITAsci52YWx1ZT11KSk7aXx8by5wdXNoKHtrZXk6YSx2YWx1ZTp1fSksbi51cGRhdGVVUkwoKX0sc29ydDpmdW5jdGlvbigpe3ZhciB0LGUscixuPW9zKHRoaXMpLG89bi5lbnRyaWVzLGk9by5zbGljZSgpO2ZvcihvLmxlbmd0aD0wLHI9MDtyPGkubGVuZ3RoO3IrKyl7Zm9yKHQ9aVtyXSxlPTA7ZTxyO2UrKylpZihvW2VdLmtleT50LmtleSl7by5zcGxpY2UoZSwwLHQpO2JyZWFrfWU9PT1yJiZvLnB1c2godCl9bi51cGRhdGVVUkwoKX0sZm9yRWFjaDpmdW5jdGlvbih0KXtmb3IodmFyIGUscj1vcyh0aGlzKS5lbnRyaWVzLG49cmUodCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCwzKSxvPTA7bzxyLmxlbmd0aDspbigoZT1yW28rK10pLnZhbHVlLGUua2V5LHRoaXMpfSxrZXlzOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBtcyh0aGlzLCJrZXlzIil9LHZhbHVlczpmdW5jdGlvbigpe3JldHVybiBuZXcgbXModGhpcywidmFsdWVzIil9LGVudHJpZXM6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG1zKHRoaXMsImVudHJpZXMiKX19LHtlbnVtZXJhYmxlOiEwfSkscnQod3MsdHMsd3MuZW50cmllcykscnQod3MsInRvU3RyaW5nIixmdW5jdGlvbigpe2Zvcih2YXIgdCxlPW9zKHRoaXMpLmVudHJpZXMscj1bXSxuPTA7bjxlLmxlbmd0aDspdD1lW24rK10sci5wdXNoKGRzKHQua2V5KSsiPSIrZHModC52YWx1ZSkpO3JldHVybiByLmpvaW4oIiYiKX0se2VudW1lcmFibGU6ITB9KSxCZShicyxlcyksTHQoe2dsb2JhbDohMCxmb3JjZWQ6IUJ1fSx7VVJMU2VhcmNoUGFyYW1zOmJzfSksQnV8fCJmdW5jdGlvbiIhPXR5cGVvZiBRdXx8ImZ1bmN0aW9uIiE9dHlwZW9mIFp1fHxMdCh7Z2xvYmFsOiEwLGVudW1lcmFibGU6ITAsZm9yY2VkOiEwfSx7ZmV0Y2g6ZnVuY3Rpb24odCl7dmFyIGUscixuLG89W3RdO3JldHVybiBhcmd1bWVudHMubGVuZ3RoPjEmJih5KGU9YXJndW1lbnRzWzFdKSYmcHIocj1lLmJvZHkpPT09ZXMmJigobj1lLmhlYWRlcnM/bmV3IFp1KGUuaGVhZGVycyk6bmV3IFp1KS5oYXMoImNvbnRlbnQtdHlwZSIpfHxuLnNldCgiY29udGVudC10eXBlIiwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgiKSxlPUp0KGUse2JvZHk6ZigwLFN0cmluZyhyKSksaGVhZGVyczpmKDAsbil9KSksby5wdXNoKGUpKSxRdS5hcHBseSh0aGlzLG8pfX0pO3ZhciBTcyxFcz17VVJMU2VhcmNoUGFyYW1zOmJzLGdldFN0YXRlOm9zfSx4cz1JZS5jb2RlQXQsQXM9bi5VUkwsT3M9RXMuVVJMU2VhcmNoUGFyYW1zLFJzPUVzLmdldFN0YXRlLGpzPWV0LnNldCxQcz1ldC5nZXR0ZXJGb3IoIlVSTCIpLElzPU1hdGguZmxvb3IsVHM9TWF0aC5wb3csa3M9IkludmFsaWQgc2NoZW1lIixMcz0iSW52YWxpZCBob3N0IixVcz0iSW52YWxpZCBwb3J0IixNcz0vW0EtWmEtel0vLF9zPS9bXGQrLS5BLVphLXpdLyxOcz0vXGQvLENzPS9eKDB4fDBYKS8sRnM9L15bMC03XSskLyxCcz0vXlxkKyQvLERzPS9eW1xkQS1GYS1mXSskLyxxcz0vW1x1MDAwMFx1MDAwOVx1MDAwQVx1MDAwRCAjJS86P0BbXFxdXS8senM9L1tcdTAwMDBcdTAwMDlcdTAwMEFcdTAwMEQgIy86P0BbXFxdXS8sV3M9L15bXHUwMDAwLVx1MDAxRiBdK3xbXHUwMDAwLVx1MDAxRiBdKyQvZyxLcz0vW1x1MDAwOVx1MDAwQVx1MDAwRF0vZyxHcz1mdW5jdGlvbih0LGUpe3ZhciByLG4sbztpZigiWyI9PWUuY2hhckF0KDApKXtpZigiXSIhPWUuY2hhckF0KGUubGVuZ3RoLTEpKXJldHVybiBMcztpZighKHI9VnMoZS5zbGljZSgxLC0xKSkpKXJldHVybiBMczt0Lmhvc3Q9cn1lbHNlIGlmKGVjKHQpKXtpZihlPWZ1bmN0aW9uKHQpe3ZhciBlLHIsbj1bXSxvPXQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKEd1LCIuIikuc3BsaXQoIi4iKTtmb3IoZT0wO2U8by5sZW5ndGg7ZSsrKW4ucHVzaChLdS50ZXN0KHI9b1tlXSk/InhuLS0iK0p1KHIpOnIpO3JldHVybiBuLmpvaW4oIi4iKX0oZSkscXMudGVzdChlKSlyZXR1cm4gTHM7aWYobnVsbD09PShyPSRzKGUpKSlyZXR1cm4gTHM7dC5ob3N0PXJ9ZWxzZXtpZih6cy50ZXN0KGUpKXJldHVybiBMcztmb3Iocj0iIixuPWdyKGUpLG89MDtvPG4ubGVuZ3RoO28rKylyKz1acyhuW29dLFhzKTt0Lmhvc3Q9cn19LCRzPWZ1bmN0aW9uKHQpe3ZhciBlLHIsbixvLGksYSx1LHM9dC5zcGxpdCgiLiIpO2lmKHMubGVuZ3RoJiYiIj09c1tzLmxlbmd0aC0xXSYmcy5wb3AoKSwoZT1zLmxlbmd0aCk+NClyZXR1cm4gdDtmb3Iocj1bXSxuPTA7bjxlO24rKyl7aWYoIiI9PShvPXNbbl0pKXJldHVybiB0O2lmKGk9MTAsby5sZW5ndGg+MSYmIjAiPT1vLmNoYXJBdCgwKSYmKGk9Q3MudGVzdChvKT8xNjo4LG89by5zbGljZSg4PT1pPzE6MikpLCIiPT09bylhPTA7ZWxzZXtpZighKDEwPT1pP0JzOjg9PWk/RnM6RHMpLnRlc3QobykpcmV0dXJuIHQ7YT1wYXJzZUludChvLGkpfXIucHVzaChhKX1mb3Iobj0wO248ZTtuKyspaWYoYT1yW25dLG49PWUtMSl7aWYoYT49VHMoMjU2LDUtZSkpcmV0dXJuIG51bGx9ZWxzZSBpZihhPjI1NSlyZXR1cm4gbnVsbDtmb3IodT1yLnBvcCgpLG49MDtuPHIubGVuZ3RoO24rKyl1Kz1yW25dKlRzKDI1NiwzLW4pO3JldHVybiB1fSxWcz1mdW5jdGlvbih0KXt2YXIgZSxyLG4sbyxpLGEsdSxzPVswLDAsMCwwLDAsMCwwLDBdLGM9MCxmPW51bGwsbD0wLGg9ZnVuY3Rpb24oKXtyZXR1cm4gdC5jaGFyQXQobCl9O2lmKCI6Ij09aCgpKXtpZigiOiIhPXQuY2hhckF0KDEpKXJldHVybjtsKz0yLGY9KytjfWZvcig7aCgpOyl7aWYoOD09YylyZXR1cm47aWYoIjoiIT1oKCkpe2ZvcihlPXI9MDtyPDQmJkRzLnRlc3QoaCgpKTspZT0xNiplK3BhcnNlSW50KGgoKSwxNiksbCsrLHIrKztpZigiLiI9PWgoKSl7aWYoMD09cilyZXR1cm47aWYobC09cixjPjYpcmV0dXJuO2ZvcihuPTA7aCgpOyl7aWYobz1udWxsLG4+MCl7aWYoISgiLiI9PWgoKSYmbjw0KSlyZXR1cm47bCsrfWlmKCFOcy50ZXN0KGgoKSkpcmV0dXJuO2Zvcig7TnMudGVzdChoKCkpOyl7aWYoaT1wYXJzZUludChoKCksMTApLG51bGw9PT1vKW89aTtlbHNle2lmKDA9PW8pcmV0dXJuO289MTAqbytpfWlmKG8+MjU1KXJldHVybjtsKyt9c1tjXT0yNTYqc1tjXStvLDIhPSsrbiYmNCE9bnx8YysrfWlmKDQhPW4pcmV0dXJuO2JyZWFrfWlmKCI6Ij09aCgpKXtpZihsKyssIWgoKSlyZXR1cm59ZWxzZSBpZihoKCkpcmV0dXJuO3NbYysrXT1lfWVsc2V7aWYobnVsbCE9PWYpcmV0dXJuO2wrKyxmPSsrY319aWYobnVsbCE9PWYpZm9yKGE9Yy1mLGM9NzswIT1jJiZhPjA7KXU9c1tjXSxzW2MtLV09c1tmK2EtMV0sc1tmKy0tYV09dTtlbHNlIGlmKDghPWMpcmV0dXJuO3JldHVybiBzfSxIcz1mdW5jdGlvbih0KXt2YXIgZSxyLG4sbztpZigibnVtYmVyIj09dHlwZW9mIHQpe2ZvcihlPVtdLHI9MDtyPDQ7cisrKWUudW5zaGlmdCh0JTI1NiksdD1Jcyh0LzI1Nik7cmV0dXJuIGUuam9pbigiLiIpfWlmKCJvYmplY3QiPT10eXBlb2YgdCl7Zm9yKGU9IiIsbj1mdW5jdGlvbih0KXtmb3IodmFyIGU9bnVsbCxyPTEsbj1udWxsLG89MCxpPTA7aTw4O2krKykwIT09dFtpXT8obz5yJiYoZT1uLHI9byksbj1udWxsLG89MCk6KG51bGw9PT1uJiYobj1pKSwrK28pO3JldHVybiBvPnImJihlPW4scj1vKSxlfSh0KSxyPTA7cjw4O3IrKylvJiYwPT09dFtyXXx8KG8mJihvPSExKSxuPT09cj8oZSs9cj8iOiI6Ijo6IixvPSEwKTooZSs9dFtyXS50b1N0cmluZygxNikscjw3JiYoZSs9IjoiKSkpO3JldHVybiJbIitlKyJdIn1yZXR1cm4gdH0sWHM9e30sWXM9enUoe30sWHMseyIgIjoxLCciJzoxLCI8IjoxLCI+IjoxLCJgIjoxfSksSnM9enUoe30sWXMseyIjIjoxLCI/IjoxLCJ7IjoxLCJ9IjoxfSksUXM9enUoe30sSnMseyIvIjoxLCI6IjoxLCI7IjoxLCI9IjoxLCJAIjoxLCJbIjoxLCJcXCI6MSwiXSI6MSwiXiI6MSwifCI6MX0pLFpzPWZ1bmN0aW9uKHQsZSl7dmFyIHI9eHModCwwKTtyZXR1cm4gcj4zMiYmcjwxMjcmJiF3KGUsdCk/dDplbmNvZGVVUklDb21wb25lbnQodCl9LHRjPXtmdHA6MjEsZmlsZTpudWxsLGh0dHA6ODAsaHR0cHM6NDQzLHdzOjgwLHdzczo0NDN9LGVjPWZ1bmN0aW9uKHQpe3JldHVybiB3KHRjLHQuc2NoZW1lKX0scmM9ZnVuY3Rpb24odCl7cmV0dXJuIiIhPXQudXNlcm5hbWV8fCIiIT10LnBhc3N3b3JkfSxuYz1mdW5jdGlvbih0KXtyZXR1cm4hdC5ob3N0fHx0LmNhbm5vdEJlQUJhc2VVUkx8fCJmaWxlIj09dC5zY2hlbWV9LG9jPWZ1bmN0aW9uKHQsZSl7dmFyIHI7cmV0dXJuIDI9PXQubGVuZ3RoJiZNcy50ZXN0KHQuY2hhckF0KDApKSYmKCI6Ij09KHI9dC5jaGFyQXQoMSkpfHwhZSYmInwiPT1yKX0saWM9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIHQubGVuZ3RoPjEmJm9jKHQuc2xpY2UoMCwyKSkmJigyPT10Lmxlbmd0aHx8Ii8iPT09KGU9dC5jaGFyQXQoMikpfHwiXFwiPT09ZXx8Ij8iPT09ZXx8IiMiPT09ZSl9LGFjPWZ1bmN0aW9uKHQpe3ZhciBlPXQucGF0aCxyPWUubGVuZ3RoOyFyfHwiZmlsZSI9PXQuc2NoZW1lJiYxPT1yJiZvYyhlWzBdLCEwKXx8ZS5wb3AoKX0sdWM9ZnVuY3Rpb24odCl7cmV0dXJuIi4iPT09dHx8IiUyZSI9PT10LnRvTG93ZXJDYXNlKCl9LHNjPXt9LGNjPXt9LGZjPXt9LGxjPXt9LGhjPXt9LHBjPXt9LGRjPXt9LHZjPXt9LGdjPXt9LHljPXt9LG1jPXt9LGJjPXt9LHdjPXt9LFNjPXt9LEVjPXt9LHhjPXt9LEFjPXt9LE9jPXt9LFJjPXt9LGpjPXt9LFBjPXt9LEljPWZ1bmN0aW9uKHQsZSxyLG4pe3ZhciBvLGksYSx1LHMsYz1yfHxzYyxmPTAsbD0iIixoPSExLHA9ITEsZD0hMTtmb3Iocnx8KHQuc2NoZW1lPSIiLHQudXNlcm5hbWU9IiIsdC5wYXNzd29yZD0iIix0Lmhvc3Q9bnVsbCx0LnBvcnQ9bnVsbCx0LnBhdGg9W10sdC5xdWVyeT1udWxsLHQuZnJhZ21lbnQ9bnVsbCx0LmNhbm5vdEJlQUJhc2VVUkw9ITEsZT1lLnJlcGxhY2UoV3MsIiIpKSxlPWUucmVwbGFjZShLcywiIiksbz1ncihlKTtmPD1vLmxlbmd0aDspe3N3aXRjaChpPW9bZl0sYyl7Y2FzZSBzYzppZighaXx8IU1zLnRlc3QoaSkpe2lmKHIpcmV0dXJuIGtzO2M9ZmM7Y29udGludWV9bCs9aS50b0xvd2VyQ2FzZSgpLGM9Y2M7YnJlYWs7Y2FzZSBjYzppZihpJiYoX3MudGVzdChpKXx8IisiPT1pfHwiLSI9PWl8fCIuIj09aSkpbCs9aS50b0xvd2VyQ2FzZSgpO2Vsc2V7aWYoIjoiIT1pKXtpZihyKXJldHVybiBrcztsPSIiLGM9ZmMsZj0wO2NvbnRpbnVlfWlmKHImJihlYyh0KSE9dyh0YyxsKXx8ImZpbGUiPT1sJiYocmModCl8fG51bGwhPT10LnBvcnQpfHwiZmlsZSI9PXQuc2NoZW1lJiYhdC5ob3N0KSlyZXR1cm47aWYodC5zY2hlbWU9bCxyKXJldHVybiB2b2lkKGVjKHQpJiZ0Y1t0LnNjaGVtZV09PXQucG9ydCYmKHQucG9ydD1udWxsKSk7bD0iIiwiZmlsZSI9PXQuc2NoZW1lP2M9U2M6ZWModCkmJm4mJm4uc2NoZW1lPT10LnNjaGVtZT9jPWxjOmVjKHQpP2M9dmM6Ii8iPT1vW2YrMV0/KGM9aGMsZisrKToodC5jYW5ub3RCZUFCYXNlVVJMPSEwLHQucGF0aC5wdXNoKCIiKSxjPVJjKX1icmVhaztjYXNlIGZjOmlmKCFufHxuLmNhbm5vdEJlQUJhc2VVUkwmJiIjIiE9aSlyZXR1cm4ga3M7aWYobi5jYW5ub3RCZUFCYXNlVVJMJiYiIyI9PWkpe3Quc2NoZW1lPW4uc2NoZW1lLHQucGF0aD1uLnBhdGguc2xpY2UoKSx0LnF1ZXJ5PW4ucXVlcnksdC5mcmFnbWVudD0iIix0LmNhbm5vdEJlQUJhc2VVUkw9ITAsYz1QYzticmVha31jPSJmaWxlIj09bi5zY2hlbWU/U2M6cGM7Y29udGludWU7Y2FzZSBsYzppZigiLyIhPWl8fCIvIiE9b1tmKzFdKXtjPXBjO2NvbnRpbnVlfWM9Z2MsZisrO2JyZWFrO2Nhc2UgaGM6aWYoIi8iPT1pKXtjPXljO2JyZWFrfWM9T2M7Y29udGludWU7Y2FzZSBwYzppZih0LnNjaGVtZT1uLnNjaGVtZSxpPT1Tcyl0LnVzZXJuYW1lPW4udXNlcm5hbWUsdC5wYXNzd29yZD1uLnBhc3N3b3JkLHQuaG9zdD1uLmhvc3QsdC5wb3J0PW4ucG9ydCx0LnBhdGg9bi5wYXRoLnNsaWNlKCksdC5xdWVyeT1uLnF1ZXJ5O2Vsc2UgaWYoIi8iPT1pfHwiXFwiPT1pJiZlYyh0KSljPWRjO2Vsc2UgaWYoIj8iPT1pKXQudXNlcm5hbWU9bi51c2VybmFtZSx0LnBhc3N3b3JkPW4ucGFzc3dvcmQsdC5ob3N0PW4uaG9zdCx0LnBvcnQ9bi5wb3J0LHQucGF0aD1uLnBhdGguc2xpY2UoKSx0LnF1ZXJ5PSIiLGM9amM7ZWxzZXtpZigiIyIhPWkpe3QudXNlcm5hbWU9bi51c2VybmFtZSx0LnBhc3N3b3JkPW4ucGFzc3dvcmQsdC5ob3N0PW4uaG9zdCx0LnBvcnQ9bi5wb3J0LHQucGF0aD1uLnBhdGguc2xpY2UoKSx0LnBhdGgucG9wKCksYz1PYztjb250aW51ZX10LnVzZXJuYW1lPW4udXNlcm5hbWUsdC5wYXNzd29yZD1uLnBhc3N3b3JkLHQuaG9zdD1uLmhvc3QsdC5wb3J0PW4ucG9ydCx0LnBhdGg9bi5wYXRoLnNsaWNlKCksdC5xdWVyeT1uLnF1ZXJ5LHQuZnJhZ21lbnQ9IiIsYz1QY31icmVhaztjYXNlIGRjOmlmKCFlYyh0KXx8Ii8iIT1pJiYiXFwiIT1pKXtpZigiLyIhPWkpe3QudXNlcm5hbWU9bi51c2VybmFtZSx0LnBhc3N3b3JkPW4ucGFzc3dvcmQsdC5ob3N0PW4uaG9zdCx0LnBvcnQ9bi5wb3J0LGM9T2M7Y29udGludWV9Yz15Y31lbHNlIGM9Z2M7YnJlYWs7Y2FzZSB2YzppZihjPWdjLCIvIiE9aXx8Ii8iIT1sLmNoYXJBdChmKzEpKWNvbnRpbnVlO2YrKzticmVhaztjYXNlIGdjOmlmKCIvIiE9aSYmIlxcIiE9aSl7Yz15Yztjb250aW51ZX1icmVhaztjYXNlIHljOmlmKCJAIj09aSl7aCYmKGw9IiU0MCIrbCksaD0hMCxhPWdyKGwpO2Zvcih2YXIgdj0wO3Y8YS5sZW5ndGg7disrKXt2YXIgZz1hW3ZdO2lmKCI6IiE9Z3x8ZCl7dmFyIHk9WnMoZyxRcyk7ZD90LnBhc3N3b3JkKz15OnQudXNlcm5hbWUrPXl9ZWxzZSBkPSEwfWw9IiJ9ZWxzZSBpZihpPT1Tc3x8Ii8iPT1pfHwiPyI9PWl8fCIjIj09aXx8IlxcIj09aSYmZWModCkpe2lmKGgmJiIiPT1sKXJldHVybiJJbnZhbGlkIGF1dGhvcml0eSI7Zi09Z3IobCkubGVuZ3RoKzEsbD0iIixjPW1jfWVsc2UgbCs9aTticmVhaztjYXNlIG1jOmNhc2UgYmM6aWYociYmImZpbGUiPT10LnNjaGVtZSl7Yz14Yztjb250aW51ZX1pZigiOiIhPWl8fHApe2lmKGk9PVNzfHwiLyI9PWl8fCI/Ij09aXx8IiMiPT1pfHwiXFwiPT1pJiZlYyh0KSl7aWYoZWModCkmJiIiPT1sKXJldHVybiBMcztpZihyJiYiIj09bCYmKHJjKHQpfHxudWxsIT09dC5wb3J0KSlyZXR1cm47aWYodT1Hcyh0LGwpKXJldHVybiB1O2lmKGw9IiIsYz1BYyxyKXJldHVybjtjb250aW51ZX0iWyI9PWk/cD0hMDoiXSI9PWkmJihwPSExKSxsKz1pfWVsc2V7aWYoIiI9PWwpcmV0dXJuIExzO2lmKHU9R3ModCxsKSlyZXR1cm4gdTtpZihsPSIiLGM9d2Mscj09YmMpcmV0dXJufWJyZWFrO2Nhc2Ugd2M6aWYoIU5zLnRlc3QoaSkpe2lmKGk9PVNzfHwiLyI9PWl8fCI/Ij09aXx8IiMiPT1pfHwiXFwiPT1pJiZlYyh0KXx8cil7aWYoIiIhPWwpe3ZhciBtPXBhcnNlSW50KGwsMTApO2lmKG0+NjU1MzUpcmV0dXJuIFVzO3QucG9ydD1lYyh0KSYmbT09PXRjW3Quc2NoZW1lXT9udWxsOm0sbD0iIn1pZihyKXJldHVybjtjPUFjO2NvbnRpbnVlfXJldHVybiBVc31sKz1pO2JyZWFrO2Nhc2UgU2M6aWYodC5zY2hlbWU9ImZpbGUiLCIvIj09aXx8IlxcIj09aSljPUVjO2Vsc2V7aWYoIW58fCJmaWxlIiE9bi5zY2hlbWUpe2M9T2M7Y29udGludWV9aWYoaT09U3MpdC5ob3N0PW4uaG9zdCx0LnBhdGg9bi5wYXRoLnNsaWNlKCksdC5xdWVyeT1uLnF1ZXJ5O2Vsc2UgaWYoIj8iPT1pKXQuaG9zdD1uLmhvc3QsdC5wYXRoPW4ucGF0aC5zbGljZSgpLHQucXVlcnk9IiIsYz1qYztlbHNle2lmKCIjIiE9aSl7aWMoby5zbGljZShmKS5qb2luKCIiKSl8fCh0Lmhvc3Q9bi5ob3N0LHQucGF0aD1uLnBhdGguc2xpY2UoKSxhYyh0KSksYz1PYztjb250aW51ZX10Lmhvc3Q9bi5ob3N0LHQucGF0aD1uLnBhdGguc2xpY2UoKSx0LnF1ZXJ5PW4ucXVlcnksdC5mcmFnbWVudD0iIixjPVBjfX1icmVhaztjYXNlIEVjOmlmKCIvIj09aXx8IlxcIj09aSl7Yz14YzticmVha31uJiYiZmlsZSI9PW4uc2NoZW1lJiYhaWMoby5zbGljZShmKS5qb2luKCIiKSkmJihvYyhuLnBhdGhbMF0sITApP3QucGF0aC5wdXNoKG4ucGF0aFswXSk6dC5ob3N0PW4uaG9zdCksYz1PYztjb250aW51ZTtjYXNlIHhjOmlmKGk9PVNzfHwiLyI9PWl8fCJcXCI9PWl8fCI/Ij09aXx8IiMiPT1pKXtpZighciYmb2MobCkpYz1PYztlbHNlIGlmKCIiPT1sKXtpZih0Lmhvc3Q9IiIscilyZXR1cm47Yz1BY31lbHNle2lmKHU9R3ModCxsKSlyZXR1cm4gdTtpZigibG9jYWxob3N0Ij09dC5ob3N0JiYodC5ob3N0PSIiKSxyKXJldHVybjtsPSIiLGM9QWN9Y29udGludWV9bCs9aTticmVhaztjYXNlIEFjOmlmKGVjKHQpKXtpZihjPU9jLCIvIiE9aSYmIlxcIiE9aSljb250aW51ZX1lbHNlIGlmKHJ8fCI/IiE9aSlpZihyfHwiIyIhPWkpe2lmKGkhPVNzJiYoYz1PYywiLyIhPWkpKWNvbnRpbnVlfWVsc2UgdC5mcmFnbWVudD0iIixjPVBjO2Vsc2UgdC5xdWVyeT0iIixjPWpjO2JyZWFrO2Nhc2UgT2M6aWYoaT09U3N8fCIvIj09aXx8IlxcIj09aSYmZWModCl8fCFyJiYoIj8iPT1pfHwiIyI9PWkpKXtpZigiLi4iPT09KHM9KHM9bCkudG9Mb3dlckNhc2UoKSl8fCIlMmUuIj09PXN8fCIuJTJlIj09PXN8fCIlMmUlMmUiPT09cz8oYWModCksIi8iPT1pfHwiXFwiPT1pJiZlYyh0KXx8dC5wYXRoLnB1c2goIiIpKTp1YyhsKT8iLyI9PWl8fCJcXCI9PWkmJmVjKHQpfHx0LnBhdGgucHVzaCgiIik6KCJmaWxlIj09dC5zY2hlbWUmJiF0LnBhdGgubGVuZ3RoJiZvYyhsKSYmKHQuaG9zdCYmKHQuaG9zdD0iIiksbD1sLmNoYXJBdCgwKSsiOiIpLHQucGF0aC5wdXNoKGwpKSxsPSIiLCJmaWxlIj09dC5zY2hlbWUmJihpPT1Tc3x8Ij8iPT1pfHwiIyI9PWkpKWZvcig7dC5wYXRoLmxlbmd0aD4xJiYiIj09PXQucGF0aFswXTspdC5wYXRoLnNoaWZ0KCk7Ij8iPT1pPyh0LnF1ZXJ5PSIiLGM9amMpOiIjIj09aSYmKHQuZnJhZ21lbnQ9IiIsYz1QYyl9ZWxzZSBsKz1acyhpLEpzKTticmVhaztjYXNlIFJjOiI/Ij09aT8odC5xdWVyeT0iIixjPWpjKToiIyI9PWk/KHQuZnJhZ21lbnQ9IiIsYz1QYyk6aSE9U3MmJih0LnBhdGhbMF0rPVpzKGksWHMpKTticmVhaztjYXNlIGpjOnJ8fCIjIiE9aT9pIT1TcyYmKCInIj09aSYmZWModCk/dC5xdWVyeSs9IiUyNyI6dC5xdWVyeSs9IiMiPT1pPyIlMjMiOlpzKGksWHMpKToodC5mcmFnbWVudD0iIixjPVBjKTticmVhaztjYXNlIFBjOmkhPVNzJiYodC5mcmFnbWVudCs9WnMoaSxZcykpfWYrK319LFRjPWZ1bmN0aW9uKHQpe3ZhciBlLHIsbj1Ccih0aGlzLFRjLCJVUkwiKSxvPWFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwLGE9U3RyaW5nKHQpLHU9anMobix7dHlwZToiVVJMIn0pO2lmKHZvaWQgMCE9PW8paWYobyBpbnN0YW5jZW9mIFRjKWU9UHMobyk7ZWxzZSBpZihyPUljKGU9e30sU3RyaW5nKG8pKSl0aHJvdyBUeXBlRXJyb3Iocik7aWYocj1JYyh1LGEsbnVsbCxlKSl0aHJvdyBUeXBlRXJyb3Iocik7dmFyIHM9dS5zZWFyY2hQYXJhbXM9bmV3IE9zLGM9UnMocyk7Yy51cGRhdGVTZWFyY2hQYXJhbXModS5xdWVyeSksYy51cGRhdGVVUkw9ZnVuY3Rpb24oKXt1LnF1ZXJ5PVN0cmluZyhzKXx8bnVsbH0saXx8KG4uaHJlZj1MYy5jYWxsKG4pLG4ub3JpZ2luPVVjLmNhbGwobiksbi5wcm90b2NvbD1NYy5jYWxsKG4pLG4udXNlcm5hbWU9X2MuY2FsbChuKSxuLnBhc3N3b3JkPU5jLmNhbGwobiksbi5ob3N0PUNjLmNhbGwobiksbi5ob3N0bmFtZT1GYy5jYWxsKG4pLG4ucG9ydD1CYy5jYWxsKG4pLG4ucGF0aG5hbWU9RGMuY2FsbChuKSxuLnNlYXJjaD1xYy5jYWxsKG4pLG4uc2VhcmNoUGFyYW1zPXpjLmNhbGwobiksbi5oYXNoPVdjLmNhbGwobikpfSxrYz1UYy5wcm90b3R5cGUsTGM9ZnVuY3Rpb24oKXt2YXIgdD1Qcyh0aGlzKSxlPXQuc2NoZW1lLHI9dC51c2VybmFtZSxuPXQucGFzc3dvcmQsbz10Lmhvc3QsaT10LnBvcnQsYT10LnBhdGgsdT10LnF1ZXJ5LHM9dC5mcmFnbWVudCxjPWUrIjoiO3JldHVybiBudWxsIT09bz8oYys9Ii8vIixyYyh0KSYmKGMrPXIrKG4/IjoiK246IiIpKyJAIiksYys9SHMobyksbnVsbCE9PWkmJihjKz0iOiIraSkpOiJmaWxlIj09ZSYmKGMrPSIvLyIpLGMrPXQuY2Fubm90QmVBQmFzZVVSTD9hWzBdOmEubGVuZ3RoPyIvIithLmpvaW4oIi8iKToiIixudWxsIT09dSYmKGMrPSI/Iit1KSxudWxsIT09cyYmKGMrPSIjIitzKSxjfSxVYz1mdW5jdGlvbigpe3ZhciB0PVBzKHRoaXMpLGU9dC5zY2hlbWUscj10LnBvcnQ7aWYoImJsb2IiPT1lKXRyeXtyZXR1cm4gbmV3IFVSTChlLnBhdGhbMF0pLm9yaWdpbn1jYXRjaCh0KXtyZXR1cm4ibnVsbCJ9cmV0dXJuImZpbGUiIT1lJiZlYyh0KT9lKyI6Ly8iK0hzKHQuaG9zdCkrKG51bGwhPT1yPyI6IityOiIiKToibnVsbCJ9LE1jPWZ1bmN0aW9uKCl7cmV0dXJuIFBzKHRoaXMpLnNjaGVtZSsiOiJ9LF9jPWZ1bmN0aW9uKCl7cmV0dXJuIFBzKHRoaXMpLnVzZXJuYW1lfSxOYz1mdW5jdGlvbigpe3JldHVybiBQcyh0aGlzKS5wYXNzd29yZH0sQ2M9ZnVuY3Rpb24oKXt2YXIgdD1Qcyh0aGlzKSxlPXQuaG9zdCxyPXQucG9ydDtyZXR1cm4gbnVsbD09PWU/IiI6bnVsbD09PXI/SHMoZSk6SHMoZSkrIjoiK3J9LEZjPWZ1bmN0aW9uKCl7dmFyIHQ9UHModGhpcykuaG9zdDtyZXR1cm4gbnVsbD09PXQ/IiI6SHModCl9LEJjPWZ1bmN0aW9uKCl7dmFyIHQ9UHModGhpcykucG9ydDtyZXR1cm4gbnVsbD09PXQ/IiI6U3RyaW5nKHQpfSxEYz1mdW5jdGlvbigpe3ZhciB0PVBzKHRoaXMpLGU9dC5wYXRoO3JldHVybiB0LmNhbm5vdEJlQUJhc2VVUkw/ZVswXTplLmxlbmd0aD8iLyIrZS5qb2luKCIvIik6IiJ9LHFjPWZ1bmN0aW9uKCl7dmFyIHQ9UHModGhpcykucXVlcnk7cmV0dXJuIHQ/Ij8iK3Q6IiJ9LHpjPWZ1bmN0aW9uKCl7cmV0dXJuIFBzKHRoaXMpLnNlYXJjaFBhcmFtc30sV2M9ZnVuY3Rpb24oKXt2YXIgdD1Qcyh0aGlzKS5mcmFnbWVudDtyZXR1cm4gdD8iIyIrdDoiIn0sS2M9ZnVuY3Rpb24odCxlKXtyZXR1cm57Z2V0OnQsc2V0OmUsY29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITB9fTtpZihpJiZXdChrYyx7aHJlZjpLYyhMYyxmdW5jdGlvbih0KXt2YXIgZT1Qcyh0aGlzKSxyPVN0cmluZyh0KSxuPUljKGUscik7aWYobil0aHJvdyBUeXBlRXJyb3Iobik7UnMoZS5zZWFyY2hQYXJhbXMpLnVwZGF0ZVNlYXJjaFBhcmFtcyhlLnF1ZXJ5KX0pLG9yaWdpbjpLYyhVYykscHJvdG9jb2w6S2MoTWMsZnVuY3Rpb24odCl7dmFyIGU9UHModGhpcyk7SWMoZSxTdHJpbmcodCkrIjoiLHNjKX0pLHVzZXJuYW1lOktjKF9jLGZ1bmN0aW9uKHQpe3ZhciBlPVBzKHRoaXMpLHI9Z3IoU3RyaW5nKHQpKTtpZighbmMoZSkpe2UudXNlcm5hbWU9IiI7Zm9yKHZhciBuPTA7bjxyLmxlbmd0aDtuKyspZS51c2VybmFtZSs9WnMocltuXSxRcyl9fSkscGFzc3dvcmQ6S2MoTmMsZnVuY3Rpb24odCl7dmFyIGU9UHModGhpcykscj1ncihTdHJpbmcodCkpO2lmKCFuYyhlKSl7ZS5wYXNzd29yZD0iIjtmb3IodmFyIG49MDtuPHIubGVuZ3RoO24rKyllLnBhc3N3b3JkKz1acyhyW25dLFFzKX19KSxob3N0OktjKENjLGZ1bmN0aW9uKHQpe3ZhciBlPVBzKHRoaXMpO2UuY2Fubm90QmVBQmFzZVVSTHx8SWMoZSxTdHJpbmcodCksbWMpfSksaG9zdG5hbWU6S2MoRmMsZnVuY3Rpb24odCl7dmFyIGU9UHModGhpcyk7ZS5jYW5ub3RCZUFCYXNlVVJMfHxJYyhlLFN0cmluZyh0KSxiYyl9KSxwb3J0OktjKEJjLGZ1bmN0aW9uKHQpe3ZhciBlPVBzKHRoaXMpO25jKGUpfHwoIiI9PSh0PVN0cmluZyh0KSk/ZS5wb3J0PW51bGw6SWMoZSx0LHdjKSl9KSxwYXRobmFtZTpLYyhEYyxmdW5jdGlvbih0KXt2YXIgZT1Qcyh0aGlzKTtlLmNhbm5vdEJlQUJhc2VVUkx8fChlLnBhdGg9W10sSWMoZSx0KyIiLEFjKSl9KSxzZWFyY2g6S2MocWMsZnVuY3Rpb24odCl7dmFyIGU9UHModGhpcyk7IiI9PSh0PVN0cmluZyh0KSk/ZS5xdWVyeT1udWxsOigiPyI9PXQuY2hhckF0KDApJiYodD10LnNsaWNlKDEpKSxlLnF1ZXJ5PSIiLEljKGUsdCxqYykpLFJzKGUuc2VhcmNoUGFyYW1zKS51cGRhdGVTZWFyY2hQYXJhbXMoZS5xdWVyeSl9KSxzZWFyY2hQYXJhbXM6S2MoemMpLGhhc2g6S2MoV2MsZnVuY3Rpb24odCl7dmFyIGU9UHModGhpcyk7IiIhPSh0PVN0cmluZyh0KSk/KCIjIj09dC5jaGFyQXQoMCkmJih0PXQuc2xpY2UoMSkpLGUuZnJhZ21lbnQ9IiIsSWMoZSx0LFBjKSk6ZS5mcmFnbWVudD1udWxsfSl9KSxydChrYywidG9KU09OIixmdW5jdGlvbigpe3JldHVybiBMYy5jYWxsKHRoaXMpfSx7ZW51bWVyYWJsZTohMH0pLHJ0KGtjLCJ0b1N0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gTGMuY2FsbCh0aGlzKX0se2VudW1lcmFibGU6ITB9KSxBcyl7dmFyIEdjPUFzLmNyZWF0ZU9iamVjdFVSTCwkYz1Bcy5yZXZva2VPYmplY3RVUkw7R2MmJnJ0KFRjLCJjcmVhdGVPYmplY3RVUkwiLGZ1bmN0aW9uKHQpe3JldHVybiBHYy5hcHBseShBcyxhcmd1bWVudHMpfSksJGMmJnJ0KFRjLCJyZXZva2VPYmplY3RVUkwiLGZ1bmN0aW9uKHQpe3JldHVybiAkYy5hcHBseShBcyxhcmd1bWVudHMpfSl9QmUoVGMsIlVSTCIpLEx0KHtnbG9iYWw6ITAsZm9yY2VkOiFCdSxzaGFtOiFpfSx7VVJMOlRjfSksTHQoe3RhcmdldDoiVVJMIixwcm90bzohMCxlbnVtZXJhYmxlOiEwfSx7dG9KU09OOmZ1bmN0aW9uKCl7cmV0dXJuIFVSTC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzKX19KSxMdCh7dGFyZ2V0OiJXZWFrTWFwIixzdGF0OiEwfSx7ZnJvbTphbn0pLEx0KHt0YXJnZXQ6IldlYWtNYXAiLHN0YXQ6ITB9LHtvZjp1bn0pLEx0KHt0YXJnZXQ6IldlYWtNYXAiLHByb3RvOiEwLHJlYWw6ITAsZm9yY2VkOnF9LHtkZWxldGVBbGw6ZnVuY3Rpb24oKXtyZXR1cm4gc24uYXBwbHkodGhpcyxhcmd1bWVudHMpfX0pLEx0KHt0YXJnZXQ6IldlYWtNYXAiLHByb3RvOiEwLHJlYWw6ITAsZm9yY2VkOnF9LHt1cHNlcnQ6cG59KSxxcigiV2Vha1NldCIsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQodGhpcyxhcmd1bWVudHMubGVuZ3RoP2FyZ3VtZW50c1swXTp2b2lkIDApfX0sU28pLEx0KHt0YXJnZXQ6IldlYWtTZXQiLHByb3RvOiEwLHJlYWw6ITAsZm9yY2VkOnF9LHthZGRBbGw6ZnVuY3Rpb24oKXtyZXR1cm4gWmkuYXBwbHkodGhpcyxhcmd1bWVudHMpfX0pLEx0KHt0YXJnZXQ6IldlYWtTZXQiLHByb3RvOiEwLHJlYWw6ITAsZm9yY2VkOnF9LHtkZWxldGVBbGw6ZnVuY3Rpb24oKXtyZXR1cm4gc24uYXBwbHkodGhpcyxhcmd1bWVudHMpfX0pLEx0KHt0YXJnZXQ6IldlYWtTZXQiLHN0YXQ6ITB9LHtmcm9tOmFufSksTHQoe3RhcmdldDoiV2Vha1NldCIsc3RhdDohMH0se29mOnVufSk7dmFyIFZjLEhjLFhjLFljPW4uUHJvbWlzZSxKYz0vKGlwaG9uZXxpcG9kfGlwYWQpLiphcHBsZXdlYmtpdC9pLnRlc3QobmEpLFFjPW4ubG9jYXRpb24sWmM9bi5zZXRJbW1lZGlhdGUsdGY9bi5jbGVhckltbWVkaWF0ZSxlZj1uLnByb2Nlc3MscmY9bi5NZXNzYWdlQ2hhbm5lbCxuZj1uLkRpc3BhdGNoLG9mPTAsYWY9e30sdWY9Im9ucmVhZHlzdGF0ZWNoYW5nZSIsc2Y9ZnVuY3Rpb24odCl7aWYoYWYuaGFzT3duUHJvcGVydHkodCkpe3ZhciBlPWFmW3RdO2RlbGV0ZSBhZlt0XSxlKCl9fSxjZj1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtzZih0KX19LGZmPWZ1bmN0aW9uKHQpe3NmKHQuZGF0YSl9LGxmPWZ1bmN0aW9uKHQpe24ucG9zdE1lc3NhZ2UodCsiIixRYy5wcm90b2NvbCsiLy8iK1FjLmhvc3QpfTtaYyYmdGZ8fChaYz1mdW5jdGlvbih0KXtmb3IodmFyIGU9W10scj0xO2FyZ3VtZW50cy5sZW5ndGg+cjspZS5wdXNoKGFyZ3VtZW50c1tyKytdKTtyZXR1cm4gYWZbKytvZl09ZnVuY3Rpb24oKXsoImZ1bmN0aW9uIj09dHlwZW9mIHQ/dDpGdW5jdGlvbih0KSkuYXBwbHkodm9pZCAwLGUpfSxWYyhvZiksb2Z9LHRmPWZ1bmN0aW9uKHQpe2RlbGV0ZSBhZlt0XX0sInByb2Nlc3MiPT1oKGVmKT9WYz1mdW5jdGlvbih0KXtlZi5uZXh0VGljayhjZih0KSl9Om5mJiZuZi5ub3c/VmM9ZnVuY3Rpb24odCl7bmYubm93KGNmKHQpKX06cmYmJiFKYz8oWGM9KEhjPW5ldyByZikucG9ydDIsSGMucG9ydDEub25tZXNzYWdlPWZmLFZjPXJlKFhjLnBvc3RNZXNzYWdlLFhjLDEpKTohbi5hZGRFdmVudExpc3RlbmVyfHwiZnVuY3Rpb24iIT10eXBlb2YgcG9zdE1lc3NhZ2V8fG4uaW1wb3J0U2NyaXB0c3x8byhsZil8fCJmaWxlOiI9PT1RYy5wcm90b2NvbD9WYz11ZiBpbiB4KCJzY3JpcHQiKT9mdW5jdGlvbih0KXtLdC5hcHBlbmRDaGlsZCh4KCJzY3JpcHQiKSlbdWZdPWZ1bmN0aW9uKCl7S3QucmVtb3ZlQ2hpbGQodGhpcyksc2YodCl9fTpmdW5jdGlvbih0KXtzZXRUaW1lb3V0KGNmKHQpLDApfTooVmM9bGYsbi5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIixmZiwhMSkpKTt2YXIgaGYscGYsZGYsdmYsZ2YseWYsbWYsYmYsd2Y9e3NldDpaYyxjbGVhcjp0Zn0sU2Y9Ui5mLEVmPXdmLnNldCx4Zj1uLk11dGF0aW9uT2JzZXJ2ZXJ8fG4uV2ViS2l0TXV0YXRpb25PYnNlcnZlcixBZj1uLnByb2Nlc3MsT2Y9bi5Qcm9taXNlLFJmPSJwcm9jZXNzIj09aChBZiksamY9U2YobiwicXVldWVNaWNyb3Rhc2siKSxQZj1qZiYmamYudmFsdWU7UGZ8fChoZj1mdW5jdGlvbigpe3ZhciB0LGU7Zm9yKFJmJiYodD1BZi5kb21haW4pJiZ0LmV4aXQoKTtwZjspe2U9cGYuZm4scGY9cGYubmV4dDt0cnl7ZSgpfWNhdGNoKHQpe3Rocm93IHBmP3ZmKCk6ZGY9dm9pZCAwLHR9fWRmPXZvaWQgMCx0JiZ0LmVudGVyKCl9LFJmP3ZmPWZ1bmN0aW9uKCl7QWYubmV4dFRpY2soaGYpfTp4ZiYmIUpjPyhnZj0hMCx5Zj1kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgiIiksbmV3IHhmKGhmKS5vYnNlcnZlKHlmLHtjaGFyYWN0ZXJEYXRhOiEwfSksdmY9ZnVuY3Rpb24oKXt5Zi5kYXRhPWdmPSFnZn0pOk9mJiZPZi5yZXNvbHZlPyhtZj1PZi5yZXNvbHZlKHZvaWQgMCksYmY9bWYudGhlbix2Zj1mdW5jdGlvbigpe2JmLmNhbGwobWYsaGYpfSk6dmY9ZnVuY3Rpb24oKXtFZi5jYWxsKG4saGYpfSk7dmFyIElmLFRmLGtmLExmLFVmPVBmfHxmdW5jdGlvbih0KXt2YXIgZT17Zm46dCxuZXh0OnZvaWQgMH07ZGYmJihkZi5uZXh0PWUpLHBmfHwocGY9ZSx2ZigpKSxkZj1lfSxNZj1mdW5jdGlvbih0KXt2YXIgZSxyO3RoaXMucHJvbWlzZT1uZXcgdChmdW5jdGlvbih0LG4pe2lmKHZvaWQgMCE9PWV8fHZvaWQgMCE9PXIpdGhyb3cgVHlwZUVycm9yKCJCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvciIpO2U9dCxyPW59KSx0aGlzLnJlc29sdmU9ZWUoZSksdGhpcy5yZWplY3Q9ZWUocil9LF9mPXtmOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgTWYodCl9fSxOZj1mdW5jdGlvbih0LGUpe2lmKGoodCkseShlKSYmZS5jb25zdHJ1Y3Rvcj09PXQpcmV0dXJuIGU7dmFyIHI9X2YuZih0KTtyZXR1cm4oMCxyLnJlc29sdmUpKGUpLHIucHJvbWlzZX0sQ2Y9ZnVuY3Rpb24odCl7dHJ5e3JldHVybntlcnJvcjohMSx2YWx1ZTp0KCl9fWNhdGNoKHQpe3JldHVybntlcnJvcjohMCx2YWx1ZTp0fX19LEZmPXdmLnNldCxCZj1xdCgic3BlY2llcyIpLERmPSJQcm9taXNlIixxZj1ldC5nZXQsemY9ZXQuc2V0LFdmPWV0LmdldHRlckZvcihEZiksS2Y9WWMsR2Y9bi5UeXBlRXJyb3IsJGY9bi5kb2N1bWVudCxWZj1uLnByb2Nlc3MsSGY9aXQoImZldGNoIiksWGY9X2YuZixZZj1YZixKZj0icHJvY2VzcyI9PWgoVmYpLFFmPSEhKCRmJiYkZi5jcmVhdGVFdmVudCYmbi5kaXNwYXRjaEV2ZW50KSxaZj0idW5oYW5kbGVkcmVqZWN0aW9uIix0bD1UdChEZixmdW5jdGlvbigpe2lmKEYoS2YpPT09U3RyaW5nKEtmKSl7aWYoNjY9PT11YSlyZXR1cm4hMDtpZighSmYmJiJmdW5jdGlvbiIhPXR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQpcmV0dXJuITB9aWYodWE+PTUxJiYvbmF0aXZlIGNvZGUvLnRlc3QoS2YpKXJldHVybiExO3ZhciB0PUtmLnJlc29sdmUoMSksZT1mdW5jdGlvbih0KXt0KGZ1bmN0aW9uKCl7fSxmdW5jdGlvbigpe30pfTtyZXR1cm4odC5jb25zdHJ1Y3Rvcj17fSlbQmZdPWUsISh0LnRoZW4oZnVuY3Rpb24oKXt9KWluc3RhbmNlb2YgZSl9KSxlbD10bHx8IVNyKGZ1bmN0aW9uKHQpe0tmLmFsbCh0KS5jYXRjaChmdW5jdGlvbigpe30pfSkscmw9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuISgheSh0KXx8ImZ1bmN0aW9uIiE9dHlwZW9mKGU9dC50aGVuKSkmJmV9LG5sPWZ1bmN0aW9uKHQsZSxyKXtpZighZS5ub3RpZmllZCl7ZS5ub3RpZmllZD0hMDt2YXIgbj1lLnJlYWN0aW9ucztVZihmdW5jdGlvbigpe2Zvcih2YXIgbz1lLnZhbHVlLGk9MT09ZS5zdGF0ZSxhPTA7bi5sZW5ndGg+YTspe3ZhciB1LHMsYyxmPW5bYSsrXSxsPWk/Zi5vazpmLmZhaWwsaD1mLnJlc29sdmUscD1mLnJlamVjdCxkPWYuZG9tYWluO3RyeXtsPyhpfHwoMj09PWUucmVqZWN0aW9uJiZ1bCh0LGUpLGUucmVqZWN0aW9uPTEpLCEwPT09bD91PW86KGQmJmQuZW50ZXIoKSx1PWwobyksZCYmKGQuZXhpdCgpLGM9ITApKSx1PT09Zi5wcm9taXNlP3AoR2YoIlByb21pc2UtY2hhaW4gY3ljbGUiKSk6KHM9cmwodSkpP3MuY2FsbCh1LGgscCk6aCh1KSk6cChvKX1jYXRjaCh0KXtkJiYhYyYmZC5leGl0KCkscCh0KX19ZS5yZWFjdGlvbnM9W10sZS5ub3RpZmllZD0hMSxyJiYhZS5yZWplY3Rpb24mJmlsKHQsZSl9KX19LG9sPWZ1bmN0aW9uKHQsZSxyKXt2YXIgbyxpO1FmPygobz0kZi5jcmVhdGVFdmVudCgiRXZlbnQiKSkucHJvbWlzZT1lLG8ucmVhc29uPXIsby5pbml0RXZlbnQodCwhMSwhMCksbi5kaXNwYXRjaEV2ZW50KG8pKTpvPXtwcm9taXNlOmUscmVhc29uOnJ9LChpPW5bIm9uIit0XSk/aShvKTp0PT09WmYmJmZ1bmN0aW9uKHQsZSl7dmFyIHI9bi5jb25zb2xlO3ImJnIuZXJyb3ImJigxPT09YXJndW1lbnRzLmxlbmd0aD9yLmVycm9yKHQpOnIuZXJyb3IodCxlKSl9KCJVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24iLHIpfSxpbD1mdW5jdGlvbih0LGUpe0ZmLmNhbGwobixmdW5jdGlvbigpe3ZhciByLG49ZS52YWx1ZTtpZihhbChlKSYmKHI9Q2YoZnVuY3Rpb24oKXtKZj9WZi5lbWl0KCJ1bmhhbmRsZWRSZWplY3Rpb24iLG4sdCk6b2woWmYsdCxuKX0pLGUucmVqZWN0aW9uPUpmfHxhbChlKT8yOjEsci5lcnJvcikpdGhyb3cgci52YWx1ZX0pfSxhbD1mdW5jdGlvbih0KXtyZXR1cm4gMSE9PXQucmVqZWN0aW9uJiYhdC5wYXJlbnR9LHVsPWZ1bmN0aW9uKHQsZSl7RmYuY2FsbChuLGZ1bmN0aW9uKCl7SmY/VmYuZW1pdCgicmVqZWN0aW9uSGFuZGxlZCIsdCk6b2woInJlamVjdGlvbmhhbmRsZWQiLHQsZS52YWx1ZSl9KX0sc2w9ZnVuY3Rpb24odCxlLHIsbil7cmV0dXJuIGZ1bmN0aW9uKG8pe3QoZSxyLG8sbil9fSxjbD1mdW5jdGlvbih0LGUscixuKXtlLmRvbmV8fChlLmRvbmU9ITAsbiYmKGU9biksZS52YWx1ZT1yLGUuc3RhdGU9MixubCh0LGUsITApKX0sZmw9ZnVuY3Rpb24odCxlLHIsbil7aWYoIWUuZG9uZSl7ZS5kb25lPSEwLG4mJihlPW4pO3RyeXtpZih0PT09cil0aHJvdyBHZigiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGYiKTt2YXIgbz1ybChyKTtvP1VmKGZ1bmN0aW9uKCl7dmFyIG49e2RvbmU6ITF9O3RyeXtvLmNhbGwocixzbChmbCx0LG4sZSksc2woY2wsdCxuLGUpKX1jYXRjaChyKXtjbCh0LG4scixlKX19KTooZS52YWx1ZT1yLGUuc3RhdGU9MSxubCh0LGUsITEpKX1jYXRjaChyKXtjbCh0LHtkb25lOiExfSxyLGUpfX19O3RsJiYoS2Y9ZnVuY3Rpb24odCl7QnIodGhpcyxLZixEZiksZWUodCksSWYuY2FsbCh0aGlzKTt2YXIgZT1xZih0aGlzKTt0cnl7dChzbChmbCx0aGlzLGUpLHNsKGNsLHRoaXMsZSkpfWNhdGNoKHQpe2NsKHRoaXMsZSx0KX19LChJZj1mdW5jdGlvbih0KXt6Zih0aGlzLHt0eXBlOkRmLGRvbmU6ITEsbm90aWZpZWQ6ITEscGFyZW50OiExLHJlYWN0aW9uczpbXSxyZWplY3Rpb246ITEsc3RhdGU6MCx2YWx1ZTp2b2lkIDB9KX0pLnByb3RvdHlwZT16cihLZi5wcm90b3R5cGUse3RoZW46ZnVuY3Rpb24odCxlKXt2YXIgcj1XZih0aGlzKSxuPVhmKGhuKHRoaXMsS2YpKTtyZXR1cm4gbi5vaz0iZnVuY3Rpb24iIT10eXBlb2YgdHx8dCxuLmZhaWw9ImZ1bmN0aW9uIj09dHlwZW9mIGUmJmUsbi5kb21haW49SmY/VmYuZG9tYWluOnZvaWQgMCxyLnBhcmVudD0hMCxyLnJlYWN0aW9ucy5wdXNoKG4pLDAhPXIuc3RhdGUmJm5sKHRoaXMsciwhMSksbi5wcm9taXNlfSxjYXRjaDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aGVuKHZvaWQgMCx0KX19KSxUZj1mdW5jdGlvbigpe3ZhciB0PW5ldyBJZixlPXFmKHQpO3RoaXMucHJvbWlzZT10LHRoaXMucmVzb2x2ZT1zbChmbCx0LGUpLHRoaXMucmVqZWN0PXNsKGNsLHQsZSl9LF9mLmY9WGY9ZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT1LZnx8dD09PWtmP25ldyBUZih0KTpZZih0KX0sImZ1bmN0aW9uIj09dHlwZW9mIFljJiYoTGY9WWMucHJvdG90eXBlLnRoZW4scnQoWWMucHJvdG90eXBlLCJ0aGVuIixmdW5jdGlvbih0LGUpe3ZhciByPXRoaXM7cmV0dXJuIG5ldyBLZihmdW5jdGlvbih0LGUpe0xmLmNhbGwocix0LGUpfSkudGhlbih0LGUpfSx7dW5zYWZlOiEwfSksImZ1bmN0aW9uIj09dHlwZW9mIEhmJiZMdCh7Z2xvYmFsOiEwLGVudW1lcmFibGU6ITAsZm9yY2VkOiEwfSx7ZmV0Y2g6ZnVuY3Rpb24odCl7cmV0dXJuIE5mKEtmLEhmLmFwcGx5KG4sYXJndW1lbnRzKSl9fSkpKSxMdCh7Z2xvYmFsOiEwLHdyYXA6ITAsZm9yY2VkOnRsfSx7UHJvbWlzZTpLZn0pLEJlKEtmLERmLCExKSxLcihEZiksa2Y9aXQoRGYpLEx0KHt0YXJnZXQ6RGYsc3RhdDohMCxmb3JjZWQ6dGx9LHtyZWplY3Q6ZnVuY3Rpb24odCl7dmFyIGU9WGYodGhpcyk7cmV0dXJuIGUucmVqZWN0LmNhbGwodm9pZCAwLHQpLGUucHJvbWlzZX19KSxMdCh7dGFyZ2V0OkRmLHN0YXQ6ITAsZm9yY2VkOnRsfSx7cmVzb2x2ZTpmdW5jdGlvbih0KXtyZXR1cm4gTmYodGhpcyx0KX19KSxMdCh7dGFyZ2V0OkRmLHN0YXQ6ITAsZm9yY2VkOmVsfSx7YWxsOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMscj1YZihlKSxuPXIucmVzb2x2ZSxvPXIucmVqZWN0LGk9Q2YoZnVuY3Rpb24oKXt2YXIgcj1lZShlLnJlc29sdmUpLGk9W10sYT0wLHU9MTtGcih0LGZ1bmN0aW9uKHQpe3ZhciBzPWErKyxjPSExO2kucHVzaCh2b2lkIDApLHUrKyxyLmNhbGwoZSx0KS50aGVuKGZ1bmN0aW9uKHQpe2N8fChjPSEwLGlbc109dCwtLXV8fG4oaSkpfSxvKX0pLC0tdXx8bihpKX0pO3JldHVybiBpLmVycm9yJiZvKGkudmFsdWUpLHIucHJvbWlzZX0scmFjZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLHI9WGYoZSksbj1yLnJlamVjdCxvPUNmKGZ1bmN0aW9uKCl7dmFyIG89ZWUoZS5yZXNvbHZlKTtGcih0LGZ1bmN0aW9uKHQpe28uY2FsbChlLHQpLnRoZW4oci5yZXNvbHZlLG4pfSl9KTtyZXR1cm4gby5lcnJvciYmbihvLnZhbHVlKSxyLnByb21pc2V9fSksTHQoe3RhcmdldDoiUHJvbWlzZSIsc3RhdDohMH0se2FsbFNldHRsZWQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxyPV9mLmYoZSksbj1yLnJlc29sdmUsbz1yLnJlamVjdCxpPUNmKGZ1bmN0aW9uKCl7dmFyIHI9ZWUoZS5yZXNvbHZlKSxvPVtdLGk9MCxhPTE7RnIodCxmdW5jdGlvbih0KXt2YXIgdT1pKysscz0hMTtvLnB1c2godm9pZCAwKSxhKyssci5jYWxsKGUsdCkudGhlbihmdW5jdGlvbih0KXtzfHwocz0hMCxvW3VdPXtzdGF0dXM6ImZ1bGZpbGxlZCIsdmFsdWU6dH0sLS1hfHxuKG8pKX0sZnVuY3Rpb24odCl7c3x8KHM9ITAsb1t1XT17c3RhdHVzOiJyZWplY3RlZCIscmVhc29uOnR9LC0tYXx8bihvKSl9KX0pLC0tYXx8bihvKX0pO3JldHVybiBpLmVycm9yJiZvKGkudmFsdWUpLHIucHJvbWlzZX19KTt2YXIgbGw9ISFZYyYmbyhmdW5jdGlvbigpe1ljLnByb3RvdHlwZS5maW5hbGx5LmNhbGwoe3RoZW46ZnVuY3Rpb24oKXt9fSxmdW5jdGlvbigpe30pfSk7THQoe3RhcmdldDoiUHJvbWlzZSIscHJvdG86ITAscmVhbDohMCxmb3JjZWQ6bGx9LHtmaW5hbGx5OmZ1bmN0aW9uKHQpe3ZhciBlPWhuKHRoaXMsaXQoIlByb21pc2UiKSkscj0iZnVuY3Rpb24iPT10eXBlb2YgdDtyZXR1cm4gdGhpcy50aGVuKHI/ZnVuY3Rpb24ocil7cmV0dXJuIE5mKGUsdCgpKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KX06dCxyP2Z1bmN0aW9uKHIpe3JldHVybiBOZihlLHQoKSkudGhlbihmdW5jdGlvbigpe3Rocm93IHJ9KX06dCl9fSksImZ1bmN0aW9uIiE9dHlwZW9mIFljfHxZYy5wcm90b3R5cGUuZmluYWxseXx8cnQoWWMucHJvdG90eXBlLCJmaW5hbGx5IixpdCgiUHJvbWlzZSIpLnByb3RvdHlwZS5maW5hbGx5KTt2YXIgaGw9ZXQuc2V0LHBsPWV0LmdldHRlckZvcigiQWdncmVnYXRlRXJyb3IiKSxkbD1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXM7aWYoIShyIGluc3RhbmNlb2YgZGwpKXJldHVybiBuZXcgZGwodCxlKTtHZSYmKHI9R2UobmV3IEVycm9yKGUpLFVlKHIpKSk7dmFyIG49W107cmV0dXJuIEZyKHQsbi5wdXNoLG4pLGk/aGwocix7ZXJyb3JzOm4sdHlwZToiQWdncmVnYXRlRXJyb3IifSk6ci5lcnJvcnM9bix2b2lkIDAhPT1lJiZUKHIsIm1lc3NhZ2UiLFN0cmluZyhlKSkscn07ZGwucHJvdG90eXBlPUp0KEVycm9yLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6Zig1LGRsKSxtZXNzYWdlOmYoNSwiIiksbmFtZTpmKDUsIkFnZ3JlZ2F0ZUVycm9yIil9KSxpJiZJLmYoZGwucHJvdG90eXBlLCJlcnJvcnMiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcGwodGhpcykuZXJyb3JzfSxjb25maWd1cmFibGU6ITB9KSxMdCh7Z2xvYmFsOiEwfSx7QWdncmVnYXRlRXJyb3I6ZGx9KSxMdCh7dGFyZ2V0OiJQcm9taXNlIixzdGF0OiEwfSx7dHJ5OmZ1bmN0aW9uKHQpe3ZhciBlPV9mLmYodGhpcykscj1DZih0KTtyZXR1cm4oci5lcnJvcj9lLnJlamVjdDplLnJlc29sdmUpKHIudmFsdWUpLGUucHJvbWlzZX19KTt2YXIgdmw9Ik5vIG9uZSBwcm9taXNlIHJlc29sdmVkIjtMdCh7dGFyZ2V0OiJQcm9taXNlIixzdGF0OiEwfSx7YW55OmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMscj1fZi5mKGUpLG49ci5yZXNvbHZlLG89ci5yZWplY3QsaT1DZihmdW5jdGlvbigpe3ZhciByPWVlKGUucmVzb2x2ZSksaT1bXSxhPTAsdT0xLHM9ITE7RnIodCxmdW5jdGlvbih0KXt2YXIgYz1hKyssZj0hMTtpLnB1c2godm9pZCAwKSx1Kyssci5jYWxsKGUsdCkudGhlbihmdW5jdGlvbih0KXtmfHxzfHwocz0hMCxuKHQpKX0sZnVuY3Rpb24odCl7Znx8c3x8KGY9ITAsaVtjXT10LC0tdXx8byhuZXcoaXQoIkFnZ3JlZ2F0ZUVycm9yIikpKGksdmwpKSl9KX0pLC0tdXx8byhuZXcoaXQoIkFnZ3JlZ2F0ZUVycm9yIikpKGksdmwpKX0pO3JldHVybiBpLmVycm9yJiZvKGkudmFsdWUpLHIucHJvbWlzZX19KSxvZSgiUHJvbWlzZSIsImZpbmFsbHkiKTt2YXIgZ2w9IlVSTFNlYXJjaFBhcmFtcyJpbiBzZWxmLHlsPSJTeW1ib2wiaW4gc2VsZiYmIml0ZXJhdG9yImluIFN5bWJvbCxtbD0iRmlsZVJlYWRlciJpbiBzZWxmJiYiQmxvYiJpbiBzZWxmJiZmdW5jdGlvbigpe3RyeXtyZXR1cm4gbmV3IEJsb2IsITB9Y2F0Y2godCl7cmV0dXJuITF9fSgpLGJsPSJGb3JtRGF0YSJpbiBzZWxmLHdsPSJBcnJheUJ1ZmZlciJpbiBzZWxmO2lmKHdsKXZhciBTbD1bIltvYmplY3QgSW50OEFycmF5XSIsIltvYmplY3QgVWludDhBcnJheV0iLCJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSIsIltvYmplY3QgSW50MTZBcnJheV0iLCJbb2JqZWN0IFVpbnQxNkFycmF5XSIsIltvYmplY3QgSW50MzJBcnJheV0iLCJbb2JqZWN0IFVpbnQzMkFycmF5XSIsIltvYmplY3QgRmxvYXQzMkFycmF5XSIsIltvYmplY3QgRmxvYXQ2NEFycmF5XSJdLEVsPUFycmF5QnVmZmVyLmlzVmlld3x8ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlNsLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpKT4tMX07ZnVuY3Rpb24geGwodCl7aWYoInN0cmluZyIhPXR5cGVvZiB0JiYodD1TdHJpbmcodCkpLC9bXmEtejAtOVwtIyQlJicqKy5eX2B8fl0vaS50ZXN0KHQpKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lIik7cmV0dXJuIHQudG9Mb3dlckNhc2UoKX1mdW5jdGlvbiBBbCh0KXtyZXR1cm4ic3RyaW5nIiE9dHlwZW9mIHQmJih0PVN0cmluZyh0KSksdH1mdW5jdGlvbiBPbCh0KXt2YXIgZT17bmV4dDpmdW5jdGlvbigpe3ZhciBlPXQuc2hpZnQoKTtyZXR1cm57ZG9uZTp2b2lkIDA9PT1lLHZhbHVlOmV9fX07cmV0dXJuIHlsJiYoZVtTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIGV9KSxlfWZ1bmN0aW9uIFJsKHQpe3RoaXMubWFwPXt9LHQgaW5zdGFuY2VvZiBSbD90LmZvckVhY2goZnVuY3Rpb24odCxlKXt0aGlzLmFwcGVuZChlLHQpfSx0aGlzKTpBcnJheS5pc0FycmF5KHQpP3QuZm9yRWFjaChmdW5jdGlvbih0KXt0aGlzLmFwcGVuZCh0WzBdLHRbMV0pfSx0aGlzKTp0JiZPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3RoaXMuYXBwZW5kKGUsdFtlXSl9LHRoaXMpfWZ1bmN0aW9uIGpsKHQpe2lmKHQuYm9keVVzZWQpcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoIkFscmVhZHkgcmVhZCIpKTt0LmJvZHlVc2VkPSEwfWZ1bmN0aW9uIFBsKHQpe3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihlLHIpe3Qub25sb2FkPWZ1bmN0aW9uKCl7ZSh0LnJlc3VsdCl9LHQub25lcnJvcj1mdW5jdGlvbigpe3IodC5lcnJvcil9fSl9ZnVuY3Rpb24gSWwodCl7dmFyIGU9bmV3IEZpbGVSZWFkZXIscj1QbChlKTtyZXR1cm4gZS5yZWFkQXNBcnJheUJ1ZmZlcih0KSxyfWZ1bmN0aW9uIFRsKHQpe2lmKHQuc2xpY2UpcmV0dXJuIHQuc2xpY2UoMCk7dmFyIGU9bmV3IFVpbnQ4QXJyYXkodC5ieXRlTGVuZ3RoKTtyZXR1cm4gZS5zZXQobmV3IFVpbnQ4QXJyYXkodCkpLGUuYnVmZmVyfWZ1bmN0aW9uIGtsKCl7cmV0dXJuIHRoaXMuYm9keVVzZWQ9ITEsdGhpcy5faW5pdEJvZHk9ZnVuY3Rpb24odCl7dmFyIGU7dGhpcy5fYm9keUluaXQ9dCx0PyJzdHJpbmciPT10eXBlb2YgdD90aGlzLl9ib2R5VGV4dD10Om1sJiZCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKHQpP3RoaXMuX2JvZHlCbG9iPXQ6YmwmJkZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKHQpP3RoaXMuX2JvZHlGb3JtRGF0YT10OmdsJiZVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YodCk/dGhpcy5fYm9keVRleHQ9dC50b1N0cmluZygpOndsJiZtbCYmKGU9dCkmJkRhdGFWaWV3LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGUpPyh0aGlzLl9ib2R5QXJyYXlCdWZmZXI9VGwodC5idWZmZXIpLHRoaXMuX2JvZHlJbml0PW5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSk6d2wmJihBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZih0KXx8RWwodCkpP3RoaXMuX2JvZHlBcnJheUJ1ZmZlcj1UbCh0KTp0aGlzLl9ib2R5VGV4dD10PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KTp0aGlzLl9ib2R5VGV4dD0iIix0aGlzLmhlYWRlcnMuZ2V0KCJjb250ZW50LXR5cGUiKXx8KCJzdHJpbmciPT10eXBlb2YgdD90aGlzLmhlYWRlcnMuc2V0KCJjb250ZW50LXR5cGUiLCJ0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgiKTp0aGlzLl9ib2R5QmxvYiYmdGhpcy5fYm9keUJsb2IudHlwZT90aGlzLmhlYWRlcnMuc2V0KCJjb250ZW50LXR5cGUiLHRoaXMuX2JvZHlCbG9iLnR5cGUpOmdsJiZVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YodCkmJnRoaXMuaGVhZGVycy5zZXQoImNvbnRlbnQtdHlwZSIsImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04IikpfSxtbCYmKHRoaXMuYmxvYj1mdW5jdGlvbigpe3ZhciB0PWpsKHRoaXMpO2lmKHQpcmV0dXJuIHQ7aWYodGhpcy5fYm9keUJsb2IpcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYik7aWYodGhpcy5fYm9keUFycmF5QnVmZmVyKXJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKTtpZih0aGlzLl9ib2R5Rm9ybURhdGEpdGhyb3cgbmV3IEVycm9yKCJjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2IiKTtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKX0sdGhpcy5hcnJheUJ1ZmZlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9ib2R5QXJyYXlCdWZmZXI/amwodGhpcyl8fFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpOnRoaXMuYmxvYigpLnRoZW4oSWwpfSksdGhpcy50ZXh0PWZ1bmN0aW9uKCl7dmFyIHQ9amwodGhpcyk7aWYodClyZXR1cm4gdDtpZih0aGlzLl9ib2R5QmxvYilyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9bmV3IEZpbGVSZWFkZXIscj1QbChlKTtyZXR1cm4gZS5yZWFkQXNUZXh0KHQpLHJ9KHRoaXMuX2JvZHlCbG9iKTtpZih0aGlzLl9ib2R5QXJyYXlCdWZmZXIpcmV0dXJuIFByb21pc2UucmVzb2x2ZShmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IFVpbnQ4QXJyYXkodCkscj1uZXcgQXJyYXkoZS5sZW5ndGgpLG49MDtuPGUubGVuZ3RoO24rKylyW25dPVN0cmluZy5mcm9tQ2hhckNvZGUoZVtuXSk7cmV0dXJuIHIuam9pbigiIil9KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpO2lmKHRoaXMuX2JvZHlGb3JtRGF0YSl0aHJvdyBuZXcgRXJyb3IoImNvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCIpO3JldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpfSxibCYmKHRoaXMuZm9ybURhdGE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50ZXh0KCkudGhlbihNbCl9KSx0aGlzLmpzb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKX0sdGhpc31SbC5wcm90b3R5cGUuYXBwZW5kPWZ1bmN0aW9uKHQsZSl7dD14bCh0KSxlPUFsKGUpO3ZhciByPXRoaXMubWFwW3RdO3RoaXMubWFwW3RdPXI/cisiLCAiK2U6ZX0sUmwucHJvdG90eXBlLmRlbGV0ZT1mdW5jdGlvbih0KXtkZWxldGUgdGhpcy5tYXBbeGwodCldfSxSbC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe3JldHVybiB0PXhsKHQpLHRoaXMuaGFzKHQpP3RoaXMubWFwW3RdOm51bGx9LFJsLnByb3RvdHlwZS5oYXM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KHhsKHQpKX0sUmwucHJvdG90eXBlLnNldD1mdW5jdGlvbih0LGUpe3RoaXMubWFwW3hsKHQpXT1BbChlKX0sUmwucHJvdG90eXBlLmZvckVhY2g9ZnVuY3Rpb24odCxlKXtmb3IodmFyIHIgaW4gdGhpcy5tYXApdGhpcy5tYXAuaGFzT3duUHJvcGVydHkocikmJnQuY2FsbChlLHRoaXMubWFwW3JdLHIsdGhpcyl9LFJsLnByb3RvdHlwZS5rZXlzPWZ1bmN0aW9uKCl7dmFyIHQ9W107cmV0dXJuIHRoaXMuZm9yRWFjaChmdW5jdGlvbihlLHIpe3QucHVzaChyKX0pLE9sKHQpfSxSbC5wcm90b3R5cGUudmFsdWVzPWZ1bmN0aW9uKCl7dmFyIHQ9W107cmV0dXJuIHRoaXMuZm9yRWFjaChmdW5jdGlvbihlKXt0LnB1c2goZSl9KSxPbCh0KX0sUmwucHJvdG90eXBlLmVudHJpZXM9ZnVuY3Rpb24oKXt2YXIgdD1bXTtyZXR1cm4gdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGUscil7dC5wdXNoKFtyLGVdKX0pLE9sKHQpfSx5bCYmKFJsLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdPVJsLnByb3RvdHlwZS5lbnRyaWVzKTt2YXIgTGw9WyJERUxFVEUiLCJHRVQiLCJIRUFEIiwiT1BUSU9OUyIsIlBPU1QiLCJQVVQiXTtmdW5jdGlvbiBVbCh0LGUpe3ZhciByLG4sbz0oZT1lfHx7fSkuYm9keTtpZih0IGluc3RhbmNlb2YgVWwpe2lmKHQuYm9keVVzZWQpdGhyb3cgbmV3IFR5cGVFcnJvcigiQWxyZWFkeSByZWFkIik7dGhpcy51cmw9dC51cmwsdGhpcy5jcmVkZW50aWFscz10LmNyZWRlbnRpYWxzLGUuaGVhZGVyc3x8KHRoaXMuaGVhZGVycz1uZXcgUmwodC5oZWFkZXJzKSksdGhpcy5tZXRob2Q9dC5tZXRob2QsdGhpcy5tb2RlPXQubW9kZSx0aGlzLnNpZ25hbD10LnNpZ25hbCxvfHxudWxsPT10Ll9ib2R5SW5pdHx8KG89dC5fYm9keUluaXQsdC5ib2R5VXNlZD0hMCl9ZWxzZSB0aGlzLnVybD1TdHJpbmcodCk7aWYodGhpcy5jcmVkZW50aWFscz1lLmNyZWRlbnRpYWxzfHx0aGlzLmNyZWRlbnRpYWxzfHwic2FtZS1vcmlnaW4iLCFlLmhlYWRlcnMmJnRoaXMuaGVhZGVyc3x8KHRoaXMuaGVhZGVycz1uZXcgUmwoZS5oZWFkZXJzKSksdGhpcy5tZXRob2Q9KG49KHI9ZS5tZXRob2R8fHRoaXMubWV0aG9kfHwiR0VUIikudG9VcHBlckNhc2UoKSxMbC5pbmRleE9mKG4pPi0xP246ciksdGhpcy5tb2RlPWUubW9kZXx8dGhpcy5tb2RlfHxudWxsLHRoaXMuc2lnbmFsPWUuc2lnbmFsfHx0aGlzLnNpZ25hbCx0aGlzLnJlZmVycmVyPW51bGwsKCJHRVQiPT09dGhpcy5tZXRob2R8fCJIRUFEIj09PXRoaXMubWV0aG9kKSYmbyl0aHJvdyBuZXcgVHlwZUVycm9yKCJCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cyIpO3RoaXMuX2luaXRCb2R5KG8pfWZ1bmN0aW9uIE1sKHQpe3ZhciBlPW5ldyBGb3JtRGF0YTtyZXR1cm4gdC50cmltKCkuc3BsaXQoIiYiKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2lmKHQpe3ZhciByPXQuc3BsaXQoIj0iKSxuPXIuc2hpZnQoKS5yZXBsYWNlKC9cKy9nLCIgIiksbz1yLmpvaW4oIj0iKS5yZXBsYWNlKC9cKy9nLCIgIik7ZS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG4pLGRlY29kZVVSSUNvbXBvbmVudChvKSl9fSksZX1mdW5jdGlvbiBfbCh0LGUpe2V8fChlPXt9KSx0aGlzLnR5cGU9ImRlZmF1bHQiLHRoaXMuc3RhdHVzPXZvaWQgMD09PWUuc3RhdHVzPzIwMDplLnN0YXR1cyx0aGlzLm9rPXRoaXMuc3RhdHVzPj0yMDAmJnRoaXMuc3RhdHVzPDMwMCx0aGlzLnN0YXR1c1RleHQ9InN0YXR1c1RleHQiaW4gZT9lLnN0YXR1c1RleHQ6Ik9LIix0aGlzLmhlYWRlcnM9bmV3IFJsKGUuaGVhZGVycyksdGhpcy51cmw9ZS51cmx8fCIiLHRoaXMuX2luaXRCb2R5KHQpfVVsLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBuZXcgVWwodGhpcyx7Ym9keTp0aGlzLl9ib2R5SW5pdH0pfSxrbC5jYWxsKFVsLnByb3RvdHlwZSksa2wuY2FsbChfbC5wcm90b3R5cGUpLF9sLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBuZXcgX2wodGhpcy5fYm9keUluaXQse3N0YXR1czp0aGlzLnN0YXR1cyxzdGF0dXNUZXh0OnRoaXMuc3RhdHVzVGV4dCxoZWFkZXJzOm5ldyBSbCh0aGlzLmhlYWRlcnMpLHVybDp0aGlzLnVybH0pfSxfbC5lcnJvcj1mdW5jdGlvbigpe3ZhciB0PW5ldyBfbChudWxsLHtzdGF0dXM6MCxzdGF0dXNUZXh0OiIifSk7cmV0dXJuIHQudHlwZT0iZXJyb3IiLHR9O3ZhciBObD1bMzAxLDMwMiwzMDMsMzA3LDMwOF07X2wucmVkaXJlY3Q9ZnVuY3Rpb24odCxlKXtpZigtMT09PU5sLmluZGV4T2YoZSkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkludmFsaWQgc3RhdHVzIGNvZGUiKTtyZXR1cm4gbmV3IF9sKG51bGwse3N0YXR1czplLGhlYWRlcnM6e2xvY2F0aW9uOnR9fSl9O3ZhciBDbD1zZWxmLkRPTUV4Y2VwdGlvbjt0cnl7bmV3IENsfWNhdGNoKHQpeyhDbD1mdW5jdGlvbih0LGUpe3RoaXMubWVzc2FnZT10LHRoaXMubmFtZT1lO3ZhciByPUVycm9yKHQpO3RoaXMuc3RhY2s9ci5zdGFja30pLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSksQ2wucHJvdG90eXBlLmNvbnN0cnVjdG9yPUNsfWZ1bmN0aW9uIEZsKHQsZSl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHIsbil7dmFyIG89bmV3IFVsKHQsZSk7aWYoby5zaWduYWwmJm8uc2lnbmFsLmFib3J0ZWQpcmV0dXJuIG4obmV3IENsKCJBYm9ydGVkIiwiQWJvcnRFcnJvciIpKTt2YXIgaT1uZXcgWE1MSHR0cFJlcXVlc3Q7ZnVuY3Rpb24gYSgpe2kuYWJvcnQoKX1pLm9ubG9hZD1mdW5jdGlvbigpe3ZhciB0LGUsbj17c3RhdHVzOmkuc3RhdHVzLHN0YXR1c1RleHQ6aS5zdGF0dXNUZXh0LGhlYWRlcnM6KHQ9aS5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKXx8IiIsZT1uZXcgUmwsdC5yZXBsYWNlKC9ccj9cbltcdCBdKy9nLCIgIikuc3BsaXQoL1xyP1xuLykuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgcj10LnNwbGl0KCI6Iiksbj1yLnNoaWZ0KCkudHJpbSgpO2lmKG4pe3ZhciBvPXIuam9pbigiOiIpLnRyaW0oKTtlLmFwcGVuZChuLG8pfX0pLGUpfTtuLnVybD0icmVzcG9uc2VVUkwiaW4gaT9pLnJlc3BvbnNlVVJMOm4uaGVhZGVycy5nZXQoIlgtUmVxdWVzdC1VUkwiKSxyKG5ldyBfbCgicmVzcG9uc2UiaW4gaT9pLnJlc3BvbnNlOmkucmVzcG9uc2VUZXh0LG4pKX0saS5vbmVycm9yPWZ1bmN0aW9uKCl7bihuZXcgVHlwZUVycm9yKCJOZXR3b3JrIHJlcXVlc3QgZmFpbGVkIikpfSxpLm9udGltZW91dD1mdW5jdGlvbigpe24obmV3IFR5cGVFcnJvcigiTmV0d29yayByZXF1ZXN0IGZhaWxlZCIpKX0saS5vbmFib3J0PWZ1bmN0aW9uKCl7bihuZXcgQ2woIkFib3J0ZWQiLCJBYm9ydEVycm9yIikpfSxpLm9wZW4oby5tZXRob2Qsby51cmwsITApLCJpbmNsdWRlIj09PW8uY3JlZGVudGlhbHM/aS53aXRoQ3JlZGVudGlhbHM9ITA6Im9taXQiPT09by5jcmVkZW50aWFscyYmKGkud2l0aENyZWRlbnRpYWxzPSExKSwicmVzcG9uc2VUeXBlImluIGkmJm1sJiYoaS5yZXNwb25zZVR5cGU9ImJsb2IiKSxvLmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih0LGUpe2kuc2V0UmVxdWVzdEhlYWRlcihlLHQpfSksby5zaWduYWwmJihvLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCJhYm9ydCIsYSksaS5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXs0PT09aS5yZWFkeVN0YXRlJiZvLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCJhYm9ydCIsYSl9KSxpLnNlbmQodm9pZCAwPT09by5fYm9keUluaXQ/bnVsbDpvLl9ib2R5SW5pdCl9KX1GbC5wb2x5ZmlsbD0hMCxzZWxmLmZldGNofHwoc2VsZi5mZXRjaD1GbCxzZWxmLkhlYWRlcnM9Umwsc2VsZi5SZXF1ZXN0PVVsLHNlbGYuUmVzcG9uc2U9X2wpO3ZhciBCbD1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLERsPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkscWw9T2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSx6bD1mdW5jdGlvbigpe3RyeXtpZighT2JqZWN0LmFzc2lnbilyZXR1cm4hMTt2YXIgdD1uZXcgU3RyaW5nKCJhYmMiKTtpZih0WzVdPSJkZSIsIjUiPT09T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModClbMF0pcmV0dXJuITE7Zm9yKHZhciBlPXt9LHI9MDtyPDEwO3IrKyllWyJfIitTdHJpbmcuZnJvbUNoYXJDb2RlKHIpXT1yO2lmKCIwMTIzNDU2Nzg5IiE9PU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGUpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZVt0XX0pLmpvaW4oIiIpKXJldHVybiExO3ZhciBuPXt9O3JldHVybiJhYmNkZWZnaGlqa2xtbm9wcXJzdCIuc3BsaXQoIiIpLmZvckVhY2goZnVuY3Rpb24odCl7blt0XT10fSksImFiY2RlZmdoaWprbG1ub3BxcnN0Ij09PU9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sbikpLmpvaW4oIiIpfWNhdGNoKHQpe3JldHVybiExfX0oKT9PYmplY3QuYXNzaWduOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByLG4sbz1mdW5jdGlvbih0KXtpZihudWxsPT10KXRocm93IG5ldyBUeXBlRXJyb3IoIk9iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkIik7cmV0dXJuIE9iamVjdCh0KX0odCksaT0xO2k8YXJndW1lbnRzLmxlbmd0aDtpKyspe2Zvcih2YXIgYSBpbiByPU9iamVjdChhcmd1bWVudHNbaV0pKURsLmNhbGwocixhKSYmKG9bYV09clthXSk7aWYoQmwpe249Qmwocik7Zm9yKHZhciB1PTA7dTxuLmxlbmd0aDt1KyspcWwuY2FsbChyLG5bdV0pJiYob1tuW3VdXT1yW25bdV1dKX19cmV0dXJuIG99O09iamVjdC5hc3NpZ249emx9KCk7Cg==\")\nassets.set(\"/_next/static/chunks/webpack-76fd8b39fe914c29.js\", \"data:application/javascript;base64,IWZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO3ZhciBlLHQscixuLG8sdSxpLGMsZixhPXt9LGw9e307ZnVuY3Rpb24gcyhlKXt2YXIgdD1sW2VdO2lmKHZvaWQgMCE9PXQpcmV0dXJuIHQuZXhwb3J0czt2YXIgcj1sW2VdPXtleHBvcnRzOnt9fSxuPSEwO3RyeXthW2VdKHIsci5leHBvcnRzLHMpLG49ITF9ZmluYWxseXtuJiZkZWxldGUgbFtlXX1yZXR1cm4gci5leHBvcnRzfXMubT1hLGU9W10scy5PPWZ1bmN0aW9uKHQscixuLG8pe2lmKHIpe289b3x8MDtmb3IodmFyIHU9ZS5sZW5ndGg7dT4wJiZlW3UtMV1bMl0+bzt1LS0pZVt1XT1lW3UtMV07ZVt1XT1bcixuLG9dO3JldHVybn1mb3IodmFyIGk9MS8wLHU9MDt1PGUubGVuZ3RoO3UrKyl7Zm9yKHZhciByPWVbdV1bMF0sbj1lW3VdWzFdLG89ZVt1XVsyXSxjPSEwLGY9MDtmPHIubGVuZ3RoO2YrKylpPj1vJiZPYmplY3Qua2V5cyhzLk8pLmV2ZXJ5KGZ1bmN0aW9uKGUpe3JldHVybiBzLk9bZV0ocltmXSl9KT9yLnNwbGljZShmLS0sMSk6KGM9ITEsbzxpJiYoaT1vKSk7aWYoYyl7ZS5zcGxpY2UodS0tLDEpO3ZhciBhPW4oKTt2b2lkIDAhPT1hJiYodD1hKX19cmV0dXJuIHR9LHI9T2JqZWN0LmdldFByb3RvdHlwZU9mP2Z1bmN0aW9uKGUpe3JldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSl9OmZ1bmN0aW9uKGUpe3JldHVybiBlLl9fcHJvdG9fX30scy50PWZ1bmN0aW9uKGUsbil7aWYoMSZuJiYoZT10aGlzKGUpKSw4Jm58fCJvYmplY3QiPT10eXBlb2YgZSYmZSYmKDQmbiYmZS5fX2VzTW9kdWxlfHwxNiZuJiYiZnVuY3Rpb24iPT10eXBlb2YgZS50aGVuKSlyZXR1cm4gZTt2YXIgbz1PYmplY3QuY3JlYXRlKG51bGwpO3MucihvKTt2YXIgdT17fTt0PXR8fFtudWxsLHIoe30pLHIoW10pLHIocildO2Zvcih2YXIgaT0yJm4mJmU7Im9iamVjdCI9PXR5cGVvZiBpJiYhfnQuaW5kZXhPZihpKTtpPXIoaSkpT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaSkuZm9yRWFjaChmdW5jdGlvbih0KXt1W3RdPWZ1bmN0aW9uKCl7cmV0dXJuIGVbdF19fSk7cmV0dXJuIHUuZGVmYXVsdD1mdW5jdGlvbigpe3JldHVybiBlfSxzLmQobyx1KSxvfSxzLmQ9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gdClzLm8odCxyKSYmIXMubyhlLHIpJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLHtlbnVtZXJhYmxlOiEwLGdldDp0W3JdfSl9LHMuZj17fSxzLmU9ZnVuY3Rpb24oZSl7cmV0dXJuIFByb21pc2UuYWxsKE9iamVjdC5rZXlzKHMuZikucmVkdWNlKGZ1bmN0aW9uKHQscil7cmV0dXJuIHMuZltyXShlLHQpLHR9LFtdKSl9LHMudT1mdW5jdGlvbihlKXt9LHMubWluaUNzc0Y9ZnVuY3Rpb24oZSl7cmV0dXJuInN0YXRpYy9jc3MvMTEwYTM1ZWE3YzgxYjg5OS5jc3MifSxzLm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LG49e30sbz0iX05fRToiLHMubD1mdW5jdGlvbihlLHQscix1KXtpZihuW2VdKXtuW2VdLnB1c2godCk7cmV0dXJufWlmKHZvaWQgMCE9PXIpZm9yKHZhciBpLGMsZj1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgic2NyaXB0IiksYT0wO2E8Zi5sZW5ndGg7YSsrKXt2YXIgbD1mW2FdO2lmKGwuZ2V0QXR0cmlidXRlKCJzcmMiKT09ZXx8bC5nZXRBdHRyaWJ1dGUoImRhdGEtd2VicGFjayIpPT1vK3Ipe2k9bDticmVha319aXx8KGM9ITAsKGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic2NyaXB0IikpLmNoYXJzZXQ9InV0Zi04IixpLnRpbWVvdXQ9MTIwLHMubmMmJmkuc2V0QXR0cmlidXRlKCJub25jZSIscy5uYyksaS5zZXRBdHRyaWJ1dGUoImRhdGEtd2VicGFjayIsbytyKSxpLnNyYz1zLnR1KGUpKSxuW2VdPVt0XTt2YXIgZD1mdW5jdGlvbih0LHIpe2kub25lcnJvcj1pLm9ubG9hZD1udWxsLGNsZWFyVGltZW91dChwKTt2YXIgbz1uW2VdO2lmKGRlbGV0ZSBuW2VdLGkucGFyZW50Tm9kZSYmaS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGkpLG8mJm8uZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gZShyKX0pLHQpcmV0dXJuIHQocil9LHA9c2V0VGltZW91dChkLmJpbmQobnVsbCx2b2lkIDAse3R5cGU6InRpbWVvdXQiLHRhcmdldDppfSksMTJlNCk7aS5vbmVycm9yPWQuYmluZChudWxsLGkub25lcnJvciksaS5vbmxvYWQ9ZC5iaW5kKG51bGwsaS5vbmxvYWQpLGMmJmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoaSl9LHMucj1mdW5jdGlvbihlKXsidW5kZWZpbmVkIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOiJNb2R1bGUifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pfSxzLnR0PWZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMD09PXUmJih1PXtjcmVhdGVTY3JpcHRVUkw6ZnVuY3Rpb24oZSl7cmV0dXJuIGV9fSwidW5kZWZpbmVkIiE9dHlwZW9mIHRydXN0ZWRUeXBlcyYmdHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeSYmKHU9dHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeSgibmV4dGpzI2J1bmRsZXIiLHUpKSksdX0scy50dT1mdW5jdGlvbihlKXtyZXR1cm4gcy50dCgpLmNyZWF0ZVNjcmlwdFVSTChlKX0scy5wPSIvX25leHQvIixpPXsyNzI6MH0scy5mLmo9ZnVuY3Rpb24oZSx0KXt2YXIgcj1zLm8oaSxlKT9pW2VdOnZvaWQgMDtpZigwIT09cil7aWYocil0LnB1c2goclsyXSk7ZWxzZSBpZigyNzIhPWUpe3ZhciBuPW5ldyBQcm9taXNlKGZ1bmN0aW9uKHQsbil7cj1pW2VdPVt0LG5dfSk7dC5wdXNoKHJbMl09bik7dmFyIG89cy5wK3MudShlKSx1PUVycm9yKCk7cy5sKG8sZnVuY3Rpb24odCl7aWYocy5vKGksZSkmJigwIT09KHI9aVtlXSkmJihpW2VdPXZvaWQgMCkscikpe3ZhciBuPXQmJigibG9hZCI9PT10LnR5cGU/Im1pc3NpbmciOnQudHlwZSksbz10JiZ0LnRhcmdldCYmdC50YXJnZXQuc3JjO3UubWVzc2FnZT0iTG9hZGluZyBjaHVuayAiK2UrIiBmYWlsZWQuXG4oIituKyI6ICIrbysiKSIsdS5uYW1lPSJDaHVua0xvYWRFcnJvciIsdS50eXBlPW4sdS5yZXF1ZXN0PW8sclsxXSh1KX19LCJjaHVuay0iK2UsZSl9ZWxzZSBpW2VdPTB9fSxzLk8uaj1mdW5jdGlvbihlKXtyZXR1cm4gMD09PWlbZV19LGM9ZnVuY3Rpb24oZSx0KXt2YXIgcixuLG89dFswXSx1PXRbMV0sYz10WzJdLGY9MDtpZihvLnNvbWUoZnVuY3Rpb24oZSl7cmV0dXJuIDAhPT1pW2VdfSkpe2ZvcihyIGluIHUpcy5vKHUscikmJihzLm1bcl09dVtyXSk7aWYoYyl2YXIgYT1jKHMpfWZvcihlJiZlKHQpO2Y8by5sZW5ndGg7ZisrKW49b1tmXSxzLm8oaSxuKSYmaVtuXSYmaVtuXVswXSgpLGlbbl09MDtyZXR1cm4gcy5PKGEpfSwoZj1zZWxmLndlYnBhY2tDaHVua19OX0U9c2VsZi53ZWJwYWNrQ2h1bmtfTl9FfHxbXSkuZm9yRWFjaChjLmJpbmQobnVsbCwwKSksZi5wdXNoPWMuYmluZChudWxsLGYucHVzaC5iaW5kKGYpKX0oKTs=\")\nassets.set(\"/_next/static/css/110a35ea7c81b899.css\", \"data:text/css;base64,LyoKISB0YWlsd2luZGNzcyB2My4zLjMgfCBNSVQgTGljZW5zZSB8IGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tCiovKiw6YWZ0ZXIsOmJlZm9yZXtib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym9yZGVyOjAgc29saWQgI2U1ZTdlYn06YWZ0ZXIsOmJlZm9yZXstLXR3LWNvbnRlbnQ6IiJ9aHRtbHtsaW5lLWhlaWdodDoxLjU7LXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OjEwMCU7LW1vei10YWItc2l6ZTo0Oy1vLXRhYi1zaXplOjQ7dGFiLXNpemU6NDtmb250LWZhbWlseTp1aS1zYW5zLXNlcmlmLHN5c3RlbS11aSwtYXBwbGUtc3lzdGVtLEJsaW5rTWFjU3lzdGVtRm9udCxTZWdvZSBVSSxSb2JvdG8sSGVsdmV0aWNhIE5ldWUsQXJpYWwsTm90byBTYW5zLHNhbnMtc2VyaWYsQXBwbGUgQ29sb3IgRW1vamksU2Vnb2UgVUkgRW1vamksU2Vnb2UgVUkgU3ltYm9sLE5vdG8gQ29sb3IgRW1vamk7Zm9udC1mZWF0dXJlLXNldHRpbmdzOm5vcm1hbDtmb250LXZhcmlhdGlvbi1zZXR0aW5nczpub3JtYWx9Ym9keXttYXJnaW46MDtsaW5lLWhlaWdodDppbmhlcml0fWhye2hlaWdodDowO2NvbG9yOmluaGVyaXQ7Ym9yZGVyLXRvcC13aWR0aDoxcHh9YWJicjp3aGVyZShbdGl0bGVdKXstd2Via2l0LXRleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmUgZG90dGVkO3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmUgZG90dGVkfWgxLGgyLGgzLGg0LGg1LGg2e2ZvbnQtc2l6ZTppbmhlcml0O2ZvbnQtd2VpZ2h0OmluaGVyaXR9YXtjb2xvcjppbmhlcml0O3RleHQtZGVjb3JhdGlvbjppbmhlcml0fWIsc3Ryb25ne2ZvbnQtd2VpZ2h0OmJvbGRlcn1jb2RlLGtiZCxwcmUsc2FtcHtmb250LWZhbWlseTp1aS1tb25vc3BhY2UsU0ZNb25vLVJlZ3VsYXIsTWVubG8sTW9uYWNvLENvbnNvbGFzLExpYmVyYXRpb24gTW9ubyxDb3VyaWVyIE5ldyxtb25vc3BhY2U7Zm9udC1zaXplOjFlbX1zbWFsbHtmb250LXNpemU6ODAlfXN1YixzdXB7Zm9udC1zaXplOjc1JTtsaW5lLWhlaWdodDowO3Bvc2l0aW9uOnJlbGF0aXZlO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lfXN1Yntib3R0b206LS4yNWVtfXN1cHt0b3A6LS41ZW19dGFibGV7dGV4dC1pbmRlbnQ6MDtib3JkZXItY29sb3I6aW5oZXJpdDtib3JkZXItY29sbGFwc2U6Y29sbGFwc2V9YnV0dG9uLGlucHV0LG9wdGdyb3VwLHNlbGVjdCx0ZXh0YXJlYXtmb250LWZhbWlseTppbmhlcml0O2ZvbnQtZmVhdHVyZS1zZXR0aW5nczppbmhlcml0O2ZvbnQtdmFyaWF0aW9uLXNldHRpbmdzOmluaGVyaXQ7Zm9udC1zaXplOjEwMCU7Zm9udC13ZWlnaHQ6aW5oZXJpdDtsaW5lLWhlaWdodDppbmhlcml0O2NvbG9yOmluaGVyaXQ7bWFyZ2luOjA7cGFkZGluZzowfWJ1dHRvbixzZWxlY3R7dGV4dC10cmFuc2Zvcm06bm9uZX1bdHlwZT1idXR0b25dLFt0eXBlPXJlc2V0XSxbdHlwZT1zdWJtaXRdLGJ1dHRvbnstd2Via2l0LWFwcGVhcmFuY2U6YnV0dG9uO2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7YmFja2dyb3VuZC1pbWFnZTpub25lfTotbW96LWZvY3VzcmluZ3tvdXRsaW5lOmF1dG99Oi1tb3otdWktaW52YWxpZHtib3gtc2hhZG93Om5vbmV9cHJvZ3Jlc3N7dmVydGljYWwtYWxpZ246YmFzZWxpbmV9Ojotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLDo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbntoZWlnaHQ6YXV0b31bdHlwZT1zZWFyY2hdey13ZWJraXQtYXBwZWFyYW5jZTp0ZXh0ZmllbGQ7b3V0bGluZS1vZmZzZXQ6LTJweH06Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb257LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmV9Ojotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbnstd2Via2l0LWFwcGVhcmFuY2U6YnV0dG9uO2ZvbnQ6aW5oZXJpdH1zdW1tYXJ5e2Rpc3BsYXk6bGlzdC1pdGVtfWJsb2NrcXVvdGUsZGQsZGwsZmlndXJlLGgxLGgyLGgzLGg0LGg1LGg2LGhyLHAscHJle21hcmdpbjowfWZpZWxkc2V0e21hcmdpbjowfWZpZWxkc2V0LGxlZ2VuZHtwYWRkaW5nOjB9bWVudSxvbCx1bHtsaXN0LXN0eWxlOm5vbmU7bWFyZ2luOjA7cGFkZGluZzowfWRpYWxvZ3twYWRkaW5nOjB9dGV4dGFyZWF7cmVzaXplOnZlcnRpY2FsfWlucHV0OjotbW96LXBsYWNlaG9sZGVyLHRleHRhcmVhOjotbW96LXBsYWNlaG9sZGVye29wYWNpdHk6MTtjb2xvcjojOWNhM2FmfWlucHV0OjpwbGFjZWhvbGRlcix0ZXh0YXJlYTo6cGxhY2Vob2xkZXJ7b3BhY2l0eToxO2NvbG9yOiM5Y2EzYWZ9W3JvbGU9YnV0dG9uXSxidXR0b257Y3Vyc29yOnBvaW50ZXJ9OmRpc2FibGVke2N1cnNvcjpkZWZhdWx0fWF1ZGlvLGNhbnZhcyxlbWJlZCxpZnJhbWUsaW1nLG9iamVjdCxzdmcsdmlkZW97ZGlzcGxheTpibG9jazt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9aW1nLHZpZGVve21heC13aWR0aDoxMDAlO2hlaWdodDphdXRvfVtoaWRkZW5de2Rpc3BsYXk6bm9uZX0qLDphZnRlciw6YmVmb3Jley0tdHctYm9yZGVyLXNwYWNpbmcteDowOy0tdHctYm9yZGVyLXNwYWNpbmcteTowOy0tdHctdHJhbnNsYXRlLXg6MDstLXR3LXRyYW5zbGF0ZS15OjA7LS10dy1yb3RhdGU6MDstLXR3LXNrZXcteDowOy0tdHctc2tldy15OjA7LS10dy1zY2FsZS14OjE7LS10dy1zY2FsZS15OjE7LS10dy1wYW4teDogOy0tdHctcGFuLXk6IDstLXR3LXBpbmNoLXpvb206IDstLXR3LXNjcm9sbC1zbmFwLXN0cmljdG5lc3M6cHJveGltaXR5Oy0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbjogOy0tdHctZ3JhZGllbnQtdmlhLXBvc2l0aW9uOiA7LS10dy1ncmFkaWVudC10by1wb3NpdGlvbjogOy0tdHctb3JkaW5hbDogOy0tdHctc2xhc2hlZC16ZXJvOiA7LS10dy1udW1lcmljLWZpZ3VyZTogOy0tdHctbnVtZXJpYy1zcGFjaW5nOiA7LS10dy1udW1lcmljLWZyYWN0aW9uOiA7LS10dy1yaW5nLWluc2V0OiA7LS10dy1yaW5nLW9mZnNldC13aWR0aDowcHg7LS10dy1yaW5nLW9mZnNldC1jb2xvcjojZmZmOy0tdHctcmluZy1jb2xvcjpyZ2JhKDU5LDEzMCwyNDYsLjUpOy0tdHctcmluZy1vZmZzZXQtc2hhZG93OjAgMCAjMDAwMDstLXR3LXJpbmctc2hhZG93OjAgMCAjMDAwMDstLXR3LXNoYWRvdzowIDAgIzAwMDA7LS10dy1zaGFkb3ctY29sb3JlZDowIDAgIzAwMDA7LS10dy1ibHVyOiA7LS10dy1icmlnaHRuZXNzOiA7LS10dy1jb250cmFzdDogOy0tdHctZ3JheXNjYWxlOiA7LS10dy1odWUtcm90YXRlOiA7LS10dy1pbnZlcnQ6IDstLXR3LXNhdHVyYXRlOiA7LS10dy1zZXBpYTogOy0tdHctZHJvcC1zaGFkb3c6IDstLXR3LWJhY2tkcm9wLWJsdXI6IDstLXR3LWJhY2tkcm9wLWJyaWdodG5lc3M6IDstLXR3LWJhY2tkcm9wLWNvbnRyYXN0OiA7LS10dy1iYWNrZHJvcC1ncmF5c2NhbGU6IDstLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGU6IDstLXR3LWJhY2tkcm9wLWludmVydDogOy0tdHctYmFja2Ryb3Atb3BhY2l0eTogOy0tdHctYmFja2Ryb3Atc2F0dXJhdGU6IDstLXR3LWJhY2tkcm9wLXNlcGlhOiB9OjpiYWNrZHJvcHstLXR3LWJvcmRlci1zcGFjaW5nLXg6MDstLXR3LWJvcmRlci1zcGFjaW5nLXk6MDstLXR3LXRyYW5zbGF0ZS14OjA7LS10dy10cmFuc2xhdGUteTowOy0tdHctcm90YXRlOjA7LS10dy1za2V3LXg6MDstLXR3LXNrZXcteTowOy0tdHctc2NhbGUteDoxOy0tdHctc2NhbGUteToxOy0tdHctcGFuLXg6IDstLXR3LXBhbi15OiA7LS10dy1waW5jaC16b29tOiA7LS10dy1zY3JvbGwtc25hcC1zdHJpY3RuZXNzOnByb3hpbWl0eTstLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb246IDstLXR3LWdyYWRpZW50LXZpYS1wb3NpdGlvbjogOy0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb246IDstLXR3LW9yZGluYWw6IDstLXR3LXNsYXNoZWQtemVybzogOy0tdHctbnVtZXJpYy1maWd1cmU6IDstLXR3LW51bWVyaWMtc3BhY2luZzogOy0tdHctbnVtZXJpYy1mcmFjdGlvbjogOy0tdHctcmluZy1pbnNldDogOy0tdHctcmluZy1vZmZzZXQtd2lkdGg6MHB4Oy0tdHctcmluZy1vZmZzZXQtY29sb3I6I2ZmZjstLXR3LXJpbmctY29sb3I6cmdiYSg1OSwxMzAsMjQ2LC41KTstLXR3LXJpbmctb2Zmc2V0LXNoYWRvdzowIDAgIzAwMDA7LS10dy1yaW5nLXNoYWRvdzowIDAgIzAwMDA7LS10dy1zaGFkb3c6MCAwICMwMDAwOy0tdHctc2hhZG93LWNvbG9yZWQ6MCAwICMwMDAwOy0tdHctYmx1cjogOy0tdHctYnJpZ2h0bmVzczogOy0tdHctY29udHJhc3Q6IDstLXR3LWdyYXlzY2FsZTogOy0tdHctaHVlLXJvdGF0ZTogOy0tdHctaW52ZXJ0OiA7LS10dy1zYXR1cmF0ZTogOy0tdHctc2VwaWE6IDstLXR3LWRyb3Atc2hhZG93OiA7LS10dy1iYWNrZHJvcC1ibHVyOiA7LS10dy1iYWNrZHJvcC1icmlnaHRuZXNzOiA7LS10dy1iYWNrZHJvcC1jb250cmFzdDogOy0tdHctYmFja2Ryb3AtZ3JheXNjYWxlOiA7LS10dy1iYWNrZHJvcC1odWUtcm90YXRlOiA7LS10dy1iYWNrZHJvcC1pbnZlcnQ6IDstLXR3LWJhY2tkcm9wLW9wYWNpdHk6IDstLXR3LWJhY2tkcm9wLXNhdHVyYXRlOiA7LS10dy1iYWNrZHJvcC1zZXBpYTogfS5wb2ludGVyLWV2ZW50cy1ub25le3BvaW50ZXItZXZlbnRzOm5vbmV9LmZpeGVke3Bvc2l0aW9uOmZpeGVkfS5yZWxhdGl2ZXtwb3NpdGlvbjpyZWxhdGl2ZX0uYm90dG9tLTB7Ym90dG9tOjB9LmxlZnQtMHtsZWZ0OjB9LnRvcC0we3RvcDowfS56LTEwe3otaW5kZXg6MTB9LnotXFstMVxde3otaW5kZXg6LTF9Lm0tMHttYXJnaW46MH0ubWItM3ttYXJnaW4tYm90dG9tOi43NXJlbX0ubWItMzJ7bWFyZ2luLWJvdHRvbTo4cmVtfS5pbmxpbmUtYmxvY2t7ZGlzcGxheTppbmxpbmUtYmxvY2t9LmZsZXh7ZGlzcGxheTpmbGV4fS5ncmlke2Rpc3BsYXk6Z3JpZH0uaC00OHtoZWlnaHQ6MTJyZW19Lm1pbi1oLXNjcmVlbnttaW4taGVpZ2h0OjEwMHZofS53LWZ1bGx7d2lkdGg6MTAwJX0ubWF4LXctNXhse21heC13aWR0aDo2NHJlbX0ubWF4LXctXFszMGNoXF17bWF4LXdpZHRoOjMwY2h9LmZsZXgtY29se2ZsZXgtZGlyZWN0aW9uOmNvbHVtbn0ucGxhY2UtaXRlbXMtY2VudGVye3BsYWNlLWl0ZW1zOmNlbnRlcn0uaXRlbXMtZW5ke2FsaWduLWl0ZW1zOmZsZXgtZW5kfS5pdGVtcy1jZW50ZXJ7YWxpZ24taXRlbXM6Y2VudGVyfS5qdXN0aWZ5LWNlbnRlcntqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS5qdXN0aWZ5LWJldHdlZW57anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59LmdhcC0ye2dhcDouNXJlbX0ucm91bmRlZC1sZ3tib3JkZXItcmFkaXVzOi41cmVtfS5ib3JkZXJ7Ym9yZGVyLXdpZHRoOjFweH0uYm9yZGVyLWJ7Ym9yZGVyLWJvdHRvbS13aWR0aDoxcHh9LmJvcmRlci1ncmF5LTMwMHstLXR3LWJvcmRlci1vcGFjaXR5OjE7Ym9yZGVyLWNvbG9yOnJnYigyMDkgMjEzIDIxOS92YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpfS5ib3JkZXItdHJhbnNwYXJlbnR7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50fS5iZy1ncmFkaWVudC10by1ie2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSx2YXIoLS10dy1ncmFkaWVudC1zdG9wcykpfS5iZy1ncmFkaWVudC10by10e2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIHRvcCx2YXIoLS10dy1ncmFkaWVudC1zdG9wcykpfS5mcm9tLXdoaXRley0tdHctZ3JhZGllbnQtZnJvbTojZmZmIHZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pOy0tdHctZ3JhZGllbnQtdG86aHNsYSgwLDAlLDEwMCUsMCkgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pOy0tdHctZ3JhZGllbnQtc3RvcHM6dmFyKC0tdHctZ3JhZGllbnQtZnJvbSksdmFyKC0tdHctZ3JhZGllbnQtdG8pfS5mcm9tLXppbmMtMjAwey0tdHctZ3JhZGllbnQtZnJvbTojZTRlNGU3IHZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pOy0tdHctZ3JhZGllbnQtdG86aHNsYSgyNDAsNiUsOTAlLDApIHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKTstLXR3LWdyYWRpZW50LXN0b3BzOnZhcigtLXR3LWdyYWRpZW50LWZyb20pLHZhcigtLXR3LWdyYWRpZW50LXRvKX0udmlhLXdoaXRley0tdHctZ3JhZGllbnQtdG86aHNsYSgwLDAlLDEwMCUsMCkgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pOy0tdHctZ3JhZGllbnQtc3RvcHM6dmFyKC0tdHctZ3JhZGllbnQtZnJvbSksI2ZmZiB2YXIoLS10dy1ncmFkaWVudC12aWEtcG9zaXRpb24pLHZhcigtLXR3LWdyYWRpZW50LXRvKX0ucC0yNHtwYWRkaW5nOjZyZW19LnAtOHtwYWRkaW5nOjJyZW19LnB4LTV7cGFkZGluZy1sZWZ0OjEuMjVyZW07cGFkZGluZy1yaWdodDoxLjI1cmVtfS5weS00e3BhZGRpbmctdG9wOjFyZW07cGFkZGluZy1ib3R0b206MXJlbX0ucGItNntwYWRkaW5nLWJvdHRvbToxLjVyZW19LnB0LTh7cGFkZGluZy10b3A6MnJlbX0udGV4dC1jZW50ZXJ7dGV4dC1hbGlnbjpjZW50ZXJ9LmZvbnQtbW9ub3tmb250LWZhbWlseTp1aS1tb25vc3BhY2UsU0ZNb25vLVJlZ3VsYXIsTWVubG8sTW9uYWNvLENvbnNvbGFzLExpYmVyYXRpb24gTW9ubyxDb3VyaWVyIE5ldyxtb25vc3BhY2V9LnRleHQtMnhse2ZvbnQtc2l6ZToxLjVyZW07bGluZS1oZWlnaHQ6MnJlbX0udGV4dC1zbXtmb250LXNpemU6Ljg3NXJlbTtsaW5lLWhlaWdodDoxLjI1cmVtfS5mb250LWJvbGR7Zm9udC13ZWlnaHQ6NzAwfS5mb250LXNlbWlib2xke2ZvbnQtd2VpZ2h0OjYwMH0ub3BhY2l0eS01MHtvcGFjaXR5Oi41fS5iYWNrZHJvcC1ibHVyLTJ4bHstLXR3LWJhY2tkcm9wLWJsdXI6Ymx1cig0MHB4KTstd2Via2l0LWJhY2tkcm9wLWZpbHRlcjp2YXIoLS10dy1iYWNrZHJvcC1ibHVyKSB2YXIoLS10dy1iYWNrZHJvcC1icmlnaHRuZXNzKSB2YXIoLS10dy1iYWNrZHJvcC1jb250cmFzdCkgdmFyKC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlKSB2YXIoLS10dy1iYWNrZHJvcC1odWUtcm90YXRlKSB2YXIoLS10dy1iYWNrZHJvcC1pbnZlcnQpIHZhcigtLXR3LWJhY2tkcm9wLW9wYWNpdHkpIHZhcigtLXR3LWJhY2tkcm9wLXNhdHVyYXRlKSB2YXIoLS10dy1iYWNrZHJvcC1zZXBpYSk7YmFja2Ryb3AtZmlsdGVyOnZhcigtLXR3LWJhY2tkcm9wLWJsdXIpIHZhcigtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3MpIHZhcigtLXR3LWJhY2tkcm9wLWNvbnRyYXN0KSB2YXIoLS10dy1iYWNrZHJvcC1ncmF5c2NhbGUpIHZhcigtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGUpIHZhcigtLXR3LWJhY2tkcm9wLWludmVydCkgdmFyKC0tdHctYmFja2Ryb3Atb3BhY2l0eSkgdmFyKC0tdHctYmFja2Ryb3Atc2F0dXJhdGUpIHZhcigtLXR3LWJhY2tkcm9wLXNlcGlhKX0udHJhbnNpdGlvbi1jb2xvcnN7dHJhbnNpdGlvbi1wcm9wZXJ0eTpjb2xvcixiYWNrZ3JvdW5kLWNvbG9yLGJvcmRlci1jb2xvcix0ZXh0LWRlY29yYXRpb24tY29sb3IsZmlsbCxzdHJva2U7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC40LDAsLjIsMSk7dHJhbnNpdGlvbi1kdXJhdGlvbjouMTVzfS50cmFuc2l0aW9uLXRyYW5zZm9ybXt0cmFuc2l0aW9uLXByb3BlcnR5OnRyYW5zZm9ybTt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjQsMCwuMiwxKTt0cmFuc2l0aW9uLWR1cmF0aW9uOi4xNXN9OnJvb3R7LS1mb3JlZ3JvdW5kLXJnYjowLDAsMDstLWJhY2tncm91bmQtc3RhcnQtcmdiOjIxNCwyMTksMjIwOy0tYmFja2dyb3VuZC1lbmQtcmdiOjI1NSwyNTUsMjU1fUBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6ZGFyayl7OnJvb3R7LS1mb3JlZ3JvdW5kLXJnYjoyNTUsMjU1LDI1NTstLWJhY2tncm91bmQtc3RhcnQtcmdiOjAsMCwwOy0tYmFja2dyb3VuZC1lbmQtcmdiOjAsMCwwfX1ib2R5e2NvbG9yOnJnYih2YXIoLS1mb3JlZ3JvdW5kLXJnYikpO2JhY2tncm91bmQ6bGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSx0cmFuc3BhcmVudCxyZ2IodmFyKC0tYmFja2dyb3VuZC1lbmQtcmdiKSkpIHJnYih2YXIoLS1iYWNrZ3JvdW5kLXN0YXJ0LXJnYikpfS5iZWZvcmVcOmFic29sdXRlOmJlZm9yZXtjb250ZW50OnZhcigtLXR3LWNvbnRlbnQpO3Bvc2l0aW9uOmFic29sdXRlfS5iZWZvcmVcOmgtXFszMDBweFxdOmJlZm9yZXtjb250ZW50OnZhcigtLXR3LWNvbnRlbnQpO2hlaWdodDozMDBweH0uYmVmb3JlXDp3LVxbNDgwcHhcXTpiZWZvcmV7Y29udGVudDp2YXIoLS10dy1jb250ZW50KTt3aWR0aDo0ODBweH0uYmVmb3JlXDotdHJhbnNsYXRlLXgtMVwvMjpiZWZvcmV7Y29udGVudDp2YXIoLS10dy1jb250ZW50KTstLXR3LXRyYW5zbGF0ZS14Oi01MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZSh2YXIoLS10dy10cmFuc2xhdGUteCksdmFyKC0tdHctdHJhbnNsYXRlLXkpKSByb3RhdGUodmFyKC0tdHctcm90YXRlKSkgc2tld1godmFyKC0tdHctc2tldy14KSkgc2tld1kodmFyKC0tdHctc2tldy15KSkgc2NhbGVYKHZhcigtLXR3LXNjYWxlLXgpKSBzY2FsZVkodmFyKC0tdHctc2NhbGUteSkpfS5iZWZvcmVcOnJvdW5kZWQtZnVsbDpiZWZvcmV7Y29udGVudDp2YXIoLS10dy1jb250ZW50KTtib3JkZXItcmFkaXVzOjk5OTlweH0uYmVmb3JlXDpiZy1ncmFkaWVudC1yYWRpYWw6YmVmb3Jle2NvbnRlbnQ6dmFyKC0tdHctY29udGVudCk7YmFja2dyb3VuZC1pbWFnZTpyYWRpYWwtZ3JhZGllbnQodmFyKC0tdHctZ3JhZGllbnQtc3RvcHMpKX0uYmVmb3JlXDpmcm9tLXdoaXRlOmJlZm9yZXtjb250ZW50OnZhcigtLXR3LWNvbnRlbnQpOy0tdHctZ3JhZGllbnQtZnJvbTojZmZmIHZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pOy0tdHctZ3JhZGllbnQtdG86aHNsYSgwLDAlLDEwMCUsMCkgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pOy0tdHctZ3JhZGllbnQtc3RvcHM6dmFyKC0tdHctZ3JhZGllbnQtZnJvbSksdmFyKC0tdHctZ3JhZGllbnQtdG8pfS5iZWZvcmVcOnRvLXRyYW5zcGFyZW50OmJlZm9yZXtjb250ZW50OnZhcigtLXR3LWNvbnRlbnQpOy0tdHctZ3JhZGllbnQtdG86dHJhbnNwYXJlbnQgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pfS5iZWZvcmVcOmJsdXItMnhsOmJlZm9yZXtjb250ZW50OnZhcigtLXR3LWNvbnRlbnQpOy0tdHctYmx1cjpibHVyKDQwcHgpO2ZpbHRlcjp2YXIoLS10dy1ibHVyKSB2YXIoLS10dy1icmlnaHRuZXNzKSB2YXIoLS10dy1jb250cmFzdCkgdmFyKC0tdHctZ3JheXNjYWxlKSB2YXIoLS10dy1odWUtcm90YXRlKSB2YXIoLS10dy1pbnZlcnQpIHZhcigtLXR3LXNhdHVyYXRlKSB2YXIoLS10dy1zZXBpYSkgdmFyKC0tdHctZHJvcC1zaGFkb3cpfS5iZWZvcmVcOmNvbnRlbnQtXFtcJ1wnXF06YmVmb3Jley0tdHctY29udGVudDoiIjtjb250ZW50OnZhcigtLXR3LWNvbnRlbnQpfS5hZnRlclw6YWJzb2x1dGU6YWZ0ZXJ7Y29udGVudDp2YXIoLS10dy1jb250ZW50KTtwb3NpdGlvbjphYnNvbHV0ZX0uYWZ0ZXJcOi16LTIwOmFmdGVye2NvbnRlbnQ6dmFyKC0tdHctY29udGVudCk7ei1pbmRleDotMjB9LmFmdGVyXDpoLVxbMTgwcHhcXTphZnRlcntjb250ZW50OnZhcigtLXR3LWNvbnRlbnQpO2hlaWdodDoxODBweH0uYWZ0ZXJcOnctXFsyNDBweFxdOmFmdGVye2NvbnRlbnQ6dmFyKC0tdHctY29udGVudCk7d2lkdGg6MjQwcHh9LmFmdGVyXDp0cmFuc2xhdGUteC0xXC8zOmFmdGVye2NvbnRlbnQ6dmFyKC0tdHctY29udGVudCk7LS10dy10cmFuc2xhdGUteDozMy4zMzMzMzMlO3RyYW5zZm9ybTp0cmFuc2xhdGUodmFyKC0tdHctdHJhbnNsYXRlLXgpLHZhcigtLXR3LXRyYW5zbGF0ZS15KSkgcm90YXRlKHZhcigtLXR3LXJvdGF0ZSkpIHNrZXdYKHZhcigtLXR3LXNrZXcteCkpIHNrZXdZKHZhcigtLXR3LXNrZXcteSkpIHNjYWxlWCh2YXIoLS10dy1zY2FsZS14KSkgc2NhbGVZKHZhcigtLXR3LXNjYWxlLXkpKX0uYWZ0ZXJcOmJnLWdyYWRpZW50LWNvbmljOmFmdGVye2NvbnRlbnQ6dmFyKC0tdHctY29udGVudCk7YmFja2dyb3VuZC1pbWFnZTpjb25pYy1ncmFkaWVudChmcm9tIDE4MGRlZyBhdCA1MCUgNTAlLHZhcigtLXR3LWdyYWRpZW50LXN0b3BzKSl9LmFmdGVyXDpmcm9tLXNreS0yMDA6YWZ0ZXJ7Y29udGVudDp2YXIoLS10dy1jb250ZW50KTstLXR3LWdyYWRpZW50LWZyb206I2JhZTZmZCB2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKTstLXR3LWdyYWRpZW50LXRvOnJnYmEoMTg2LDIzMCwyNTMsMCkgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pOy0tdHctZ3JhZGllbnQtc3RvcHM6dmFyKC0tdHctZ3JhZGllbnQtZnJvbSksdmFyKC0tdHctZ3JhZGllbnQtdG8pfS5hZnRlclw6dmlhLWJsdWUtMjAwOmFmdGVye2NvbnRlbnQ6dmFyKC0tdHctY29udGVudCk7LS10dy1ncmFkaWVudC10bzpyZ2JhKDE5MSwyMTksMjU0LDApIHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKTstLXR3LWdyYWRpZW50LXN0b3BzOnZhcigtLXR3LWdyYWRpZW50LWZyb20pLCNiZmRiZmUgdmFyKC0tdHctZ3JhZGllbnQtdmlhLXBvc2l0aW9uKSx2YXIoLS10dy1ncmFkaWVudC10byl9LmFmdGVyXDpibHVyLTJ4bDphZnRlcntjb250ZW50OnZhcigtLXR3LWNvbnRlbnQpOy0tdHctYmx1cjpibHVyKDQwcHgpO2ZpbHRlcjp2YXIoLS10dy1ibHVyKSB2YXIoLS10dy1icmlnaHRuZXNzKSB2YXIoLS10dy1jb250cmFzdCkgdmFyKC0tdHctZ3JheXNjYWxlKSB2YXIoLS10dy1odWUtcm90YXRlKSB2YXIoLS10dy1pbnZlcnQpIHZhcigtLXR3LXNhdHVyYXRlKSB2YXIoLS10dy1zZXBpYSkgdmFyKC0tdHctZHJvcC1zaGFkb3cpfS5hZnRlclw6Y29udGVudC1cW1wnXCdcXTphZnRlcnstLXR3LWNvbnRlbnQ6IiI7Y29udGVudDp2YXIoLS10dy1jb250ZW50KX0uaG92ZXJcOmJvcmRlci1ncmF5LTMwMDpob3ZlcnstLXR3LWJvcmRlci1vcGFjaXR5OjE7Ym9yZGVyLWNvbG9yOnJnYigyMDkgMjEzIDIxOS92YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpfS5ob3Zlclw6YmctZ3JheS0xMDA6aG92ZXJ7LS10dy1iZy1vcGFjaXR5OjE7YmFja2dyb3VuZC1jb2xvcjpyZ2IoMjQzIDI0NCAyNDYvdmFyKC0tdHctYmctb3BhY2l0eSkpfS5ncm91cDpob3ZlciAuZ3JvdXAtaG92ZXJcOnRyYW5zbGF0ZS14LTF7LS10dy10cmFuc2xhdGUteDowLjI1cmVtO3RyYW5zZm9ybTp0cmFuc2xhdGUodmFyKC0tdHctdHJhbnNsYXRlLXgpLHZhcigtLXR3LXRyYW5zbGF0ZS15KSkgcm90YXRlKHZhcigtLXR3LXJvdGF0ZSkpIHNrZXdYKHZhcigtLXR3LXNrZXcteCkpIHNrZXdZKHZhcigtLXR3LXNrZXcteSkpIHNjYWxlWCh2YXIoLS10dy1zY2FsZS14KSkgc2NhbGVZKHZhcigtLXR3LXNjYWxlLXkpKX1AbWVkaWEgKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246cmVkdWNlKXsubW90aW9uLXJlZHVjZVw6dHJhbnNmb3JtLW5vbmV7dHJhbnNmb3JtOm5vbmV9fUBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6ZGFyayl7LmRhcmtcOmJvcmRlci1uZXV0cmFsLTgwMHstLXR3LWJvcmRlci1vcGFjaXR5OjE7Ym9yZGVyLWNvbG9yOnJnYigzOCAzOCAzOC92YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpfS5kYXJrXDpiZy16aW5jLTgwMFwvMzB7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDM5LDM5LDQyLC4zKX0uZGFya1w6ZnJvbS1ibGFja3stLXR3LWdyYWRpZW50LWZyb206IzAwMCB2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKTstLXR3LWdyYWRpZW50LXRvOnRyYW5zcGFyZW50IHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKTstLXR3LWdyYWRpZW50LXN0b3BzOnZhcigtLXR3LWdyYWRpZW50LWZyb20pLHZhcigtLXR3LWdyYWRpZW50LXRvKX0uZGFya1w6ZnJvbS1pbmhlcml0ey0tdHctZ3JhZGllbnQtZnJvbTppbmhlcml0IHZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pOy0tdHctZ3JhZGllbnQtdG86aHNsYSgwLDAlLDEwMCUsMCkgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pOy0tdHctZ3JhZGllbnQtc3RvcHM6dmFyKC0tdHctZ3JhZGllbnQtZnJvbSksdmFyKC0tdHctZ3JhZGllbnQtdG8pfS5kYXJrXDp2aWEtYmxhY2t7LS10dy1ncmFkaWVudC10bzp0cmFuc3BhcmVudCB2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbik7LS10dy1ncmFkaWVudC1zdG9wczp2YXIoLS10dy1ncmFkaWVudC1mcm9tKSwjMDAwIHZhcigtLXR3LWdyYWRpZW50LXZpYS1wb3NpdGlvbiksdmFyKC0tdHctZ3JhZGllbnQtdG8pfS5kYXJrXDpkcm9wLXNoYWRvdy1cWzBfMF8wXC4zcmVtX1wjZmZmZmZmNzBcXXstLXR3LWRyb3Atc2hhZG93OmRyb3Atc2hhZG93KDAgMCAwLjNyZW0gI2ZmZmZmZjcwKX0uZGFya1w6ZHJvcC1zaGFkb3ctXFswXzBfMFwuM3JlbV9cI2ZmZmZmZjcwXF0sLmRhcmtcOmludmVydHtmaWx0ZXI6dmFyKC0tdHctYmx1cikgdmFyKC0tdHctYnJpZ2h0bmVzcykgdmFyKC0tdHctY29udHJhc3QpIHZhcigtLXR3LWdyYXlzY2FsZSkgdmFyKC0tdHctaHVlLXJvdGF0ZSkgdmFyKC0tdHctaW52ZXJ0KSB2YXIoLS10dy1zYXR1cmF0ZSkgdmFyKC0tdHctc2VwaWEpIHZhcigtLXR3LWRyb3Atc2hhZG93KX0uZGFya1w6aW52ZXJ0ey0tdHctaW52ZXJ0OmludmVydCgxMDAlKX0uYmVmb3JlXDpkYXJrXDpiZy1ncmFkaWVudC10by1icjpiZWZvcmV7Y29udGVudDp2YXIoLS10dy1jb250ZW50KTtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudCh0byBib3R0b20gcmlnaHQsdmFyKC0tdHctZ3JhZGllbnQtc3RvcHMpKX0uYmVmb3JlXDpkYXJrXDpmcm9tLXRyYW5zcGFyZW50OmJlZm9yZXtjb250ZW50OnZhcigtLXR3LWNvbnRlbnQpOy0tdHctZ3JhZGllbnQtZnJvbTp0cmFuc3BhcmVudCB2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKTstLXR3LWdyYWRpZW50LXRvOnRyYW5zcGFyZW50IHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKTstLXR3LWdyYWRpZW50LXN0b3BzOnZhcigtLXR3LWdyYWRpZW50LWZyb20pLHZhcigtLXR3LWdyYWRpZW50LXRvKX0uYmVmb3JlXDpkYXJrXDp0by1ibHVlLTcwMDpiZWZvcmV7Y29udGVudDp2YXIoLS10dy1jb250ZW50KTstLXR3LWdyYWRpZW50LXRvOiMxZDRlZDggdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pfS5iZWZvcmVcOmRhcmtcOm9wYWNpdHktMTA6YmVmb3Jle2NvbnRlbnQ6dmFyKC0tdHctY29udGVudCk7b3BhY2l0eTouMX0uYWZ0ZXJcOmRhcmtcOmZyb20tc2t5LTkwMDphZnRlcntjb250ZW50OnZhcigtLXR3LWNvbnRlbnQpOy0tdHctZ3JhZGllbnQtZnJvbTojMGM0YTZlIHZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pOy0tdHctZ3JhZGllbnQtdG86cmdiYSgxMiw3NCwxMTAsMCkgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pOy0tdHctZ3JhZGllbnQtc3RvcHM6dmFyKC0tdHctZ3JhZGllbnQtZnJvbSksdmFyKC0tdHctZ3JhZGllbnQtdG8pfS5hZnRlclw6ZGFya1w6dmlhLVxbXCMwMTQxZmZcXTphZnRlcntjb250ZW50OnZhcigtLXR3LWNvbnRlbnQpOy0tdHctZ3JhZGllbnQtdG86cmdiYSgxLDY1LDI1NSwwKSB2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbik7LS10dy1ncmFkaWVudC1zdG9wczp2YXIoLS10dy1ncmFkaWVudC1mcm9tKSwjMDE0MWZmIHZhcigtLXR3LWdyYWRpZW50LXZpYS1wb3NpdGlvbiksdmFyKC0tdHctZ3JhZGllbnQtdG8pfS5hZnRlclw6ZGFya1w6b3BhY2l0eS00MDphZnRlcntjb250ZW50OnZhcigtLXR3LWNvbnRlbnQpO29wYWNpdHk6LjR9LmhvdmVyXDpkYXJrXDpib3JkZXItbmV1dHJhbC03MDA6aG92ZXJ7LS10dy1ib3JkZXItb3BhY2l0eToxO2JvcmRlci1jb2xvcjpyZ2IoNjQgNjQgNjQvdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKX0uaG92ZXJcOmRhcmtcOmJnLW5ldXRyYWwtODAwXC8zMDpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMzgsMzgsMzgsLjMpfX1AbWVkaWEgKG1pbi13aWR0aDoxMDI0cHgpey5sZ1w6cG9pbnRlci1ldmVudHMtYXV0b3twb2ludGVyLWV2ZW50czphdXRvfS5sZ1w6c3RhdGlje3Bvc2l0aW9uOnN0YXRpY30ubGdcOm1iLTB7bWFyZ2luLWJvdHRvbTowfS5sZ1w6ZmxleHtkaXNwbGF5OmZsZXh9LmxnXDpoLWF1dG97aGVpZ2h0OmF1dG99LmxnXDp3LWF1dG97d2lkdGg6YXV0b30ubGdcOmdyaWQtY29scy00e2dyaWQtdGVtcGxhdGUtY29sdW1uczpyZXBlYXQoNCxtaW5tYXgoMCwxZnIpKX0ubGdcOnJvdW5kZWQteGx7Ym9yZGVyLXJhZGl1czouNzVyZW19LmxnXDpib3JkZXJ7Ym9yZGVyLXdpZHRoOjFweH0ubGdcOmJnLWdyYXktMjAwey0tdHctYmctb3BhY2l0eToxO2JhY2tncm91bmQtY29sb3I6cmdiKDIyOSAyMzEgMjM1L3ZhcigtLXR3LWJnLW9wYWNpdHkpKX0ubGdcOmJnLW5vbmV7YmFja2dyb3VuZC1pbWFnZTpub25lfS5sZ1w6cC0we3BhZGRpbmc6MH0ubGdcOnAtNHtwYWRkaW5nOjFyZW19LmxnXDp0ZXh0LWxlZnR7dGV4dC1hbGlnbjpsZWZ0fS5iZWZvcmVcOmxnXDpoLVxbMzYwcHhcXTpiZWZvcmV7Y29udGVudDp2YXIoLS10dy1jb250ZW50KTtoZWlnaHQ6MzYwcHh9QG1lZGlhIChwcmVmZXJzLWNvbG9yLXNjaGVtZTpkYXJrKXsubGdcOmRhcmtcOmJnLXppbmMtODAwXC8zMHtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMzksMzksNDIsLjMpfX19QGZvbnQtZmFjZXtmb250LWZhbWlseTpfX0ludGVyXzIwOTUxZjtmb250LXN0eWxlOm5vcm1hbDtmb250LXdlaWdodDoxMDAgOTAwO2ZvbnQtZGlzcGxheTpzd2FwO3NyYzp1cmwoL19uZXh0L3N0YXRpYy9tZWRpYS9kMWQ5NDU4YjY5MDA0MTI3LXMud29mZjIpIGZvcm1hdCgid29mZjIiKTt1bmljb2RlLXJhbmdlOlUrMDQ2MC0wNTJmLFUrMWM4MC0xYzg4LFUrMjBiNCxVKzJkZTAtMmRmZixVK2E2NDAtYTY5ZixVK2ZlMmUtZmUyZn1AZm9udC1mYWNle2ZvbnQtZmFtaWx5Ol9fSW50ZXJfMjA5NTFmO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtd2VpZ2h0OjEwMCA5MDA7Zm9udC1kaXNwbGF5OnN3YXA7c3JjOnVybCgvX25leHQvc3RhdGljL21lZGlhL2I5NjcxNThiYzdkN2E5ZmItcy53b2ZmMikgZm9ybWF0KCJ3b2ZmMiIpO3VuaWNvZGUtcmFuZ2U6VSswMzAxLFUrMDQwMC0wNDVmLFUrMDQ5MC0wNDkxLFUrMDRiMC0wNGIxLFUrMjExNn1AZm9udC1mYWNle2ZvbnQtZmFtaWx5Ol9fSW50ZXJfMjA5NTFmO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtd2VpZ2h0OjEwMCA5MDA7Zm9udC1kaXNwbGF5OnN3YXA7c3JjOnVybCgvX25leHQvc3RhdGljL21lZGlhL2FlOWFlNjcxNmQ0ZjhiZjgtcy53b2ZmMikgZm9ybWF0KCJ3b2ZmMiIpO3VuaWNvZGUtcmFuZ2U6VSsxZj8/fUBmb250LWZhY2V7Zm9udC1mYW1pbHk6X19JbnRlcl8yMDk1MWY7Zm9udC1zdHlsZTpub3JtYWw7Zm9udC13ZWlnaHQ6MTAwIDkwMDtmb250LWRpc3BsYXk6c3dhcDtzcmM6dXJsKC9fbmV4dC9zdGF0aWMvbWVkaWEvYzBmNWVjNWJiZjU5MTNiNy1zLndvZmYyKSBmb3JtYXQoIndvZmYyIik7dW5pY29kZS1yYW5nZTpVKzAzNzAtMDNmZn1AZm9udC1mYWNle2ZvbnQtZmFtaWx5Ol9fSW50ZXJfMjA5NTFmO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtd2VpZ2h0OjEwMCA5MDA7Zm9udC1kaXNwbGF5OnN3YXA7c3JjOnVybCgvX25leHQvc3RhdGljL21lZGlhL2IxZGIzZTI4YWY5ZWY5NGEtcy53b2ZmMikgZm9ybWF0KCJ3b2ZmMiIpO3VuaWNvZGUtcmFuZ2U6VSswMTAyLTAxMDMsVSswMTEwLTAxMTEsVSswMTI4LTAxMjksVSswMTY4LTAxNjksVSswMWEwLTAxYTEsVSswMWFmLTAxYjAsVSswMzAwLTAzMDEsVSswMzAzLTAzMDQsVSswMzA4LTAzMDksVSswMzIzLFUrMDMyOSxVKzFlYTAtMWVmOSxVKzIwYWJ9QGZvbnQtZmFjZXtmb250LWZhbWlseTpfX0ludGVyXzIwOTUxZjtmb250LXN0eWxlOm5vcm1hbDtmb250LXdlaWdodDoxMDAgOTAwO2ZvbnQtZGlzcGxheTpzd2FwO3NyYzp1cmwoL19uZXh0L3N0YXRpYy9tZWRpYS85YzRmMzQ1NjljOWIzNmNhLXMud29mZjIpIGZvcm1hdCgid29mZjIiKTt1bmljb2RlLXJhbmdlOlUrMDEwMC0wMmFmLFUrMDMwNCxVKzAzMDgsVSswMzI5LFUrMWUwMC0xZTlmLFUrMWVmMi0xZWZmLFUrMjAyMCxVKzIwYTAtMjBhYixVKzIwYWQtMjBjZixVKzIxMTMsVSsyYzYwLTJjN2YsVSthNzIwLWE3ZmZ9QGZvbnQtZmFjZXtmb250LWZhbWlseTpfX0ludGVyXzIwOTUxZjtmb250LXN0eWxlOm5vcm1hbDtmb250LXdlaWdodDoxMDAgOTAwO2ZvbnQtZGlzcGxheTpzd2FwO3NyYzp1cmwoL19uZXh0L3N0YXRpYy9tZWRpYS8yYWFmMDcyM2U3MjBlOGI5LXMucC53b2ZmMikgZm9ybWF0KCJ3b2ZmMiIpO3VuaWNvZGUtcmFuZ2U6VSswMD8/LFUrMDEzMSxVKzAxNTItMDE1MyxVKzAyYmItMDJiYyxVKzAyYzYsVSswMmRhLFUrMDJkYyxVKzAzMDQsVSswMzA4LFUrMDMyOSxVKzIwMDAtMjA2ZixVKzIwNzQsVSsyMGFjLFUrMjEyMixVKzIxOTEsVSsyMTkzLFUrMjIxMixVKzIyMTUsVStmZWZmLFUrZmZmZH1AZm9udC1mYWNle2ZvbnQtZmFtaWx5Ol9fSW50ZXJfRmFsbGJhY2tfMjA5NTFmO3NyYzpsb2NhbCgiQXJpYWwiKTthc2NlbnQtb3ZlcnJpZGU6OTAuMjAlO2Rlc2NlbnQtb3ZlcnJpZGU6MjIuNDglO2xpbmUtZ2FwLW92ZXJyaWRlOjAuMDAlO3NpemUtYWRqdXN0OjEwNy40MCV9Ll9fY2xhc3NOYW1lXzIwOTUxZntmb250LWZhbWlseTpfX0ludGVyXzIwOTUxZixfX0ludGVyX0ZhbGxiYWNrXzIwOTUxZjtmb250LXN0eWxlOm5vcm1hbH0=\")\nassets.set(\"/_next/static/media/2aaf0723e720e8b9-s.p.woff2\", \"data:font/woff2;base64,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\")\nassets.set(\"/_next/static/media/9c4f34569c9b36ca-s.woff2\", \"data:font/woff2;base64,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\")\nassets.set(\"/_next/static/media/ae9ae6716d4f8bf8-s.woff2\", \"data:font/woff2;base64,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\")\nassets.set(\"/_next/static/media/b1db3e28af9ef94a-s.woff2\", \"data:font/woff2;base64,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\")\nassets.set(\"/_next/static/media/b967158bc7d7a9fb-s.woff2\", \"data:font/woff2;base64,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\")\nassets.set(\"/_next/static/media/c0f5ec5bbf5913b7-s.woff2\", \"data:font/woff2;base64,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\")\nassets.set(\"/_next/static/media/d1d9458b69004127-s.woff2\", \"data:font/woff2;base64,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\")\nassets.set(\"/_next/static/zQzGHJ6-ukNP3bepOhekP/_buildManifest.js\", \"data:application/javascript;base64,c2VsZi5fX0JVSUxEX01BTklGRVNUPXtfX3Jld3JpdGVzOntiZWZvcmVGaWxlczpbXSxhZnRlckZpbGVzOltdLGZhbGxiYWNrOltdfSwiL19lcnJvciI6WyJzdGF0aWMvY2h1bmtzL3BhZ2VzL19lcnJvci1jOTJkNWM0YmIyYjQ5OTI2LmpzIl0sc29ydGVkUGFnZXM6WyIvX2FwcCIsIi9fZXJyb3IiXX0sc2VsZi5fX0JVSUxEX01BTklGRVNUX0NCJiZzZWxmLl9fQlVJTERfTUFOSUZFU1RfQ0IoKTs=\")\nassets.set(\"/_next/static/zQzGHJ6-ukNP3bepOhekP/_ssgManifest.js\", \"data:application/javascript;base64,c2VsZi5fX1NTR19NQU5JRkVTVD1uZXcgU2V0KFtdKTtzZWxmLl9fU1NHX01BTklGRVNUX0NCJiZzZWxmLl9fU1NHX01BTklGRVNUX0NCKCk=\")\nassets.set(\"/favicon.ico\", \"data:image/x-icon;base64,AAABAAQAEBAAAAEAIAAoBQAARgAAACAgAAABACAAKBQAAG4FAAAwMAAAAQAgACgtAACWGQAAAAAAAAEAIACNHgAAvkYAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAABdAAAAugAAALoAAABdAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAKAAAADyAAAA/wAAAP8AAAD/AAAA/wAAAPIAAACgAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAOAAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAOAAAAA4AAAAAAAAAAAAAAAAAAAAHwAAAOIAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA4gAAAB8AAAAAAAAAAAAAAKEAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAChAAAAAAAAACMAAAD0AAAA/wAAAP9PT0//rq6u/6urq/+rq6v/q6ur/6urq/+tra3/Z2dn/wAAAP8AAAD/AAAA9AAAACMAAABZAAAA/wAAAP8AAAD/Hx8f/+3t7f///////////////////////f39/zU1Nf8AAAD/AAAA/wAAAP8AAABZAAAAuwAAAP8AAAD/AAAA/wAAAP9ra2v//////////////////////46Ojv8AAAD/AAAA/wAAAP8AAAD/AAAAuwAAALsAAAD/AAAA/wAAAP8AAAD/CQkJ/83Nzf///////////+Tk5P8YGBj/AAAA/wAAAP8AAAD/AAAA/wAAALsAAABZAAAA/wAAAP8AAAD/AAAA/wAAAP9KSkr//f39//////9ra2v/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAABZAAAAIwAAAPQAAAD/AAAA/wAAAP8AAAD/AQEB/7a2tv/V1dX/CQkJ/wAAAP8AAAD/AAAA/wAAAP8AAAD0AAAAIwAAAAAAAAChAAAA/wAAAP8AAAD/AAAA/wAAAP8xMTH/RERE/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAoQAAAAAAAAAAAAAAHwAAAOIAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA4gAAAB8AAAAAAAAAAAAAAAAAAAA4AAAA4AAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA4AAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAACgAAAA8gAAAP8AAAD/AAAA/wAAAP8AAADyAAAAoAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAABdAAAAugAAALoAAABdAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAgAAAAQAAAAAEAIAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAsAAAAVQAAAIEAAADoAAAA6AAAAIEAAABVAAAALAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACoAAACFAAAA0gAAAPkAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD5AAAA0gAAAIUAAAAqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAACWAAAA8wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAPMAAACWAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABRAAAA4QAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADhAAAAUQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcgAAAPsAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD7AAAAcgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHIAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAcgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABPAAAA+wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD7AAAATwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGwAAAOQAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADjAAAAGwAAAAAAAAAAAAAAAAAAAAAAAACXAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAACXAAAAAAAAAAAAAAAAAAAAKAAAAPUAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAPQAAAAnAAAAAAAAAAAAAACGAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/ODg4/4uLi/+IiIj/iIiI/4iIiP+IiIj/iIiI/4iIiP+IiIj/iIiI/4iIiP+IiIj/iIiI/4iIiP+JiYn/X19f/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAIYAAAAAAAAABwAAANQAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8eHh7/7u7u//////////////////////////////////////////////////////////////////////9TU1P/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA1AAAAAcAAAArAAAA+gAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP9oaGj/////////////////////////////////////////////////////////////////rq6u/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD6AAAAKwAAAFQAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wgICP/Ly8v///////////////////////////////////////////////////////T09P8sLCz/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAABUAAAAggAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/0dHR//9/f3/////////////////////////////////////////////////jY2N/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAIEAAADpAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/62trf///////////////////////////////////////////+Tk5P8XFxf/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA6QAAAOkAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/Kysr//Pz8///////////////////////////////////////ampq/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADpAAAAgQAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/i4uL/////////////////////////////////8zMzP8ICAj/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAIIAAABUAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8WFhb/4+Pj///////////////////////9/f3/SUlJ/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAVAAAACsAAAD6AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP9oaGj//////////////////////6+vr/8BAQH/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAPoAAAArAAAABwAAANQAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wgICP/Ly8v////////////09PT/LCws/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA1AAAAAcAAAAAAAAAhgAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/0dHR//9/f3//////42Njf8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAACGAAAAAAAAAAAAAAAnAAAA9AAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/7Gxsf/s7Oz/FxcX/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA9QAAACgAAAAAAAAAAAAAAAAAAACXAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/MzMz/19fX/8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAACXAAAAAAAAAAAAAAAAAAAAAAAAABoAAADjAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA5AAAABsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE8AAAD7AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAPsAAABPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHIAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAcgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHIAAAD7AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA+wAAAHIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFEAAADhAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAOEAAABRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAACWAAAA8wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAPMAAACWAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAqAAAAhQAAANIAAAD5AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA+QAAANIAAACFAAAAKgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAACwAAABVAAAAgQAAAOgAAADoAAAAgQAAAFUAAAAsAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAwAAAAYAAAAAEAIAAAAAAAAC0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAKAAAAEwAAABqAAAAswAAAPgAAAD3AAAAswAAAGoAAABLAAAAKAAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAVgAAAKAAAADYAAAA+AAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA+AAAANgAAACgAAAAVQAAABMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJQAAAIsAAADhAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAOEAAACLAAAAJgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYAAACLAAAA7wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA7wAAAIsAAAAWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUQAAANwAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADcAAAAUgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAACKAAAA/gAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/gAAAIoAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwAAAK0AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAACtAAAADwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPAAAAuAAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAuAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAACuAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAK4AAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIoAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAACKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAP0AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD9AAAATwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVAAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA3wAAABUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACLAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAIsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMAAADxAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAPEAAAAjAAAAAAAAAAAAAAAAAAAAAAAAAIwAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAACLAAAAAAAAAAAAAAAAAAAAEQAAAOQAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8kJCT/aGho/2VlZf9lZWX/ZWVl/2VlZf9lZWX/ZWVl/2VlZf9lZWX/ZWVl/2VlZf9lZWX/ZWVl/2VlZf9lZWX/ZWVl/2VlZf9lZWX/ZWVl/2VlZf9lZWX/ZWVl/1BQUP8BAQH/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADkAAAAEQAAAAAAAAAAAAAAVQAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8cHBz/6+vr/////////////////////////////////////////////////////////////////////////////////////////////////////////////////3Nzc/8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAVQAAAAAAAAAAAAAAoQAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/ZWVl////////////////////////////////////////////////////////////////////////////////////////////////////////////zMzM/wgICP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAoQAAAAAAAAAJAAAA2gAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/BwcH/8nJyf/////////////////////////////////////////////////////////////////////////////////////////////////9/f3/SEhI/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA2gAAAAkAAAAoAAAA+QAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/0VFRf/8/Pz///////////////////////////////////////////////////////////////////////////////////////////+urq7/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA+AAAACgAAABLAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP+qqqr///////////////////////////////////////////////////////////////////////////////////////T09P8sLCz/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAEwAAABqAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8pKSn/8vLy/////////////////////////////////////////////////////////////////////////////////4yMjP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAGoAAAC0AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/iIiI////////////////////////////////////////////////////////////////////////////4+Pj/xYWFv8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAALMAAAD4AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/FBQU/+Hh4f//////////////////////////////////////////////////////////////////////aWlp/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAPgAAAD4AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/2VlZf/////////////////////////////////////////////////////////////////Ly8v/CAgI/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAPgAAACzAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wcHB//Jycn///////////////////////////////////////////////////////39/f9ISEj/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAALQAAABqAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP9FRUX//Pz8/////////////////////////////////////////////////66u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AAAAAAAAAAAAAAAAAAAAAAAVAAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA3wAAABUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATwAAAP0AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD9AAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIoAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAACKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAACuAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAK4AAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAuAAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAuAAAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwAAAK0AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAACtAAAADwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAACKAAAA/gAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/gAAAIoAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUgAAANwAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADcAAAAUQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYAAACLAAAA7wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA7wAAAIsAAAAWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJgAAAIsAAADhAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAOEAAACLAAAAJQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAVQAAAKAAAADYAAAA+AAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA+AAAANgAAACgAAAAVgAAABMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAKAAAAEsAAABqAAAAswAAAPcAAAD4AAAAswAAAGoAAABMAAAAKAAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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\")\nassets.set(\"/index.html\", \"data:text/html;base64,PCFET0NUWVBFIGh0bWw+PGh0bWwgbGFuZz0iZW4iPjxoZWFkPjxtZXRhIGNoYXJTZXQ9InV0Zi04Ii8+PGxpbmsgcmVsPSJwcmVsb2FkIiBhcz0iZm9udCIgaHJlZj0iL19uZXh0L3N0YXRpYy9tZWRpYS8yYWFmMDcyM2U3MjBlOGI5LXMucC53b2ZmMiIgY3Jvc3NvcmlnaW49IiIgdHlwZT0iZm9udC93b2ZmMiIvPjxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iL19uZXh0L3N0YXRpYy9jc3MvMTEwYTM1ZWE3YzgxYjg5OS5jc3MiIGRhdGEtcHJlY2VkZW5jZT0ibmV4dCIvPjxsaW5rIHJlbD0icHJlbG9hZCIgaHJlZj0iL19uZXh0L3N0YXRpYy9jaHVua3Mvd2VicGFjay03NmZkOGIzOWZlOTE0YzI5LmpzIiBhcz0ic2NyaXB0Ii8+PGxpbmsgcmVsPSJwcmVsb2FkIiBocmVmPSIvX25leHQvc3RhdGljL2NodW5rcy9iY2U2MGZjMS0zMTM4ZmM2M2U4NDM1OWQ5LmpzIiBhcz0ic2NyaXB0Ii8+PGxpbmsgcmVsPSJwcmVsb2FkIiBocmVmPSIvX25leHQvc3RhdGljL2NodW5rcy85NjEtZTY0MzczMjVhMTU1ZGRmYS5qcyIgYXM9InNjcmlwdCIvPjxsaW5rIHJlbD0icHJlbG9hZCIgaHJlZj0iL19uZXh0L3N0YXRpYy9jaHVua3MvbWFpbi1hcHAtOTUxMWQ4OGQ5NDAwNGE3YS5qcyIgYXM9InNjcmlwdCIvPjx0aXRsZT5DcmVhdGUgTmV4dCBBcHA8L3RpdGxlPjxtZXRhIG5hbWU9ImRlc2NyaXB0aW9uIiBjb250ZW50PSJHZW5lcmF0ZWQgYnkgY3JlYXRlIG5leHQgYXBwIi8+PG1ldGEgbmFtZT0idmlld3BvcnQiIGNvbnRlbnQ9IndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xIi8+PGxpbmsgcmVsPSJpY29uIiBocmVmPSIvZmF2aWNvbi5pY28iIHR5cGU9ImltYWdlL3gtaWNvbiIgc2l6ZXM9ImFueSIvPjxtZXRhIG5hbWU9Im5leHQtc2l6ZS1hZGp1c3QiLz48c2NyaXB0IHNyYz0iL19uZXh0L3N0YXRpYy9jaHVua3MvcG9seWZpbGxzLTc4YzkyZmFjN2FhOGZkZDguanMiIG5vTW9kdWxlPSIiPjwvc2NyaXB0PjwvaGVhZD48Ym9keSBjbGFzcz0iX19jbGFzc05hbWVfMjA5NTFmIj48bWFpbiBjbGFzcz0iZmxleCBtaW4taC1zY3JlZW4gZmxleC1jb2wgaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiBwLTI0Ij48ZGl2IGNsYXNzPSJ6LTEwIHctZnVsbCBtYXgtdy01eGwgaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiBmb250LW1vbm8gdGV4dC1zbSBsZzpmbGV4Ij48cCBjbGFzcz0iZml4ZWQgbGVmdC0wIHRvcC0wIGZsZXggdy1mdWxsIGp1c3RpZnktY2VudGVyIGJvcmRlci1iIGJvcmRlci1ncmF5LTMwMCBiZy1ncmFkaWVudC10by1iIGZyb20temluYy0yMDAgcGItNiBwdC04IGJhY2tkcm9wLWJsdXItMnhsIGRhcms6Ym9yZGVyLW5ldXRyYWwtODAwIGRhcms6YmctemluYy04MDAvMzAgZGFyazpmcm9tLWluaGVyaXQgbGc6c3RhdGljIGxnOnctYXV0byAgbGc6cm91bmRlZC14bCBsZzpib3JkZXIgbGc6YmctZ3JheS0yMDAgbGc6cC00IGxnOmRhcms6YmctemluYy04MDAvMzAiPkdldCBzdGFydGVkIGJ5IGVkaXRpbmfCoDxjb2RlIGNsYXNzPSJmb250LW1vbm8gZm9udC1ib2xkIj5hcHAvcGFnZS50c3g8L2NvZGU+PC9wPjxkaXYgY2xhc3M9ImZpeGVkIGJvdHRvbS0wIGxlZnQtMCBmbGV4IGgtNDggdy1mdWxsIGl0ZW1zLWVuZCBqdXN0aWZ5LWNlbnRlciBiZy1ncmFkaWVudC10by10IGZyb20td2hpdGUgdmlhLXdoaXRlIGRhcms6ZnJvbS1ibGFjayBkYXJrOnZpYS1ibGFjayBsZzpzdGF0aWMgbGc6aC1hdXRvIGxnOnctYXV0byBsZzpiZy1ub25lIj48YSBjbGFzcz0icG9pbnRlci1ldmVudHMtbm9uZSBmbGV4IHBsYWNlLWl0ZW1zLWNlbnRlciBnYXAtMiBwLTggbGc6cG9pbnRlci1ldmVudHMtYXV0byBsZzpwLTAiIGhyZWY9Imh0dHBzOi8vdmVyY2VsLmNvbT91dG1fc291cmNlPWNyZWF0ZS1uZXh0LWFwcCZhbXA7dXRtX21lZGl1bT1hcHBkaXItdGVtcGxhdGUmYW1wO3V0bV9jYW1wYWlnbj1jcmVhdGUtbmV4dC1hcHAiIHRhcmdldD0iX2JsYW5rIiByZWw9Im5vb3BlbmVyIG5vcmVmZXJyZXIiPkJ5PCEtLSAtLT4gPGltZyBhbHQ9IlZlcmNlbCBMb2dvIiBmZXRjaFByaW9yaXR5PSJoaWdoIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjI0IiBkZWNvZGluZz0iYXN5bmMiIGRhdGEtbmltZz0iMSIgY2xhc3M9ImRhcms6aW52ZXJ0IiBzdHlsZT0iY29sb3I6dHJhbnNwYXJlbnQiIHNyYz0iL3ZlcmNlbC5zdmciLz48L2E+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0icmVsYXRpdmUgZmxleCBwbGFjZS1pdGVtcy1jZW50ZXIgYmVmb3JlOmFic29sdXRlIGJlZm9yZTpoLVszMDBweF0gYmVmb3JlOnctWzQ4MHB4XSBiZWZvcmU6LXRyYW5zbGF0ZS14LTEvMiBiZWZvcmU6cm91bmRlZC1mdWxsIGJlZm9yZTpiZy1ncmFkaWVudC1yYWRpYWwgYmVmb3JlOmZyb20td2hpdGUgYmVmb3JlOnRvLXRyYW5zcGFyZW50IGJlZm9yZTpibHVyLTJ4bCBiZWZvcmU6Y29udGVudC1bJiN4Mjc7JiN4Mjc7XSBhZnRlcjphYnNvbHV0ZSBhZnRlcjotei0yMCBhZnRlcjpoLVsxODBweF0gYWZ0ZXI6dy1bMjQwcHhdIGFmdGVyOnRyYW5zbGF0ZS14LTEvMyBhZnRlcjpiZy1ncmFkaWVudC1jb25pYyBhZnRlcjpmcm9tLXNreS0yMDAgYWZ0ZXI6dmlhLWJsdWUtMjAwIGFmdGVyOmJsdXItMnhsIGFmdGVyOmNvbnRlbnQtWyYjeDI3OyYjeDI3O10gYmVmb3JlOmRhcms6YmctZ3JhZGllbnQtdG8tYnIgYmVmb3JlOmRhcms6ZnJvbS10cmFuc3BhcmVudCBiZWZvcmU6ZGFyazp0by1ibHVlLTcwMCBiZWZvcmU6ZGFyazpvcGFjaXR5LTEwIGFmdGVyOmRhcms6ZnJvbS1za3ktOTAwIGFmdGVyOmRhcms6dmlhLVsjMDE0MWZmXSBhZnRlcjpkYXJrOm9wYWNpdHktNDAgYmVmb3JlOmxnOmgtWzM2MHB4XSB6LVstMV0iPjxpbWcgYWx0PSJOZXh0LmpzIExvZ28iIGZldGNoUHJpb3JpdHk9ImhpZ2giIHdpZHRoPSIxODAiIGhlaWdodD0iMzciIGRlY29kaW5nPSJhc3luYyIgZGF0YS1uaW1nPSIxIiBjbGFzcz0icmVsYXRpdmUgZGFyazpkcm9wLXNoYWRvdy1bMF8wXzAuM3JlbV8jZmZmZmZmNzBdIGRhcms6aW52ZXJ0IiBzdHlsZT0iY29sb3I6dHJhbnNwYXJlbnQiIHNyYz0iL25leHQuc3ZnIi8+PC9kaXY+PGRpdiBjbGFzcz0ibWItMzIgZ3JpZCB0ZXh0LWNlbnRlciBsZzptYi0wIGxnOmdyaWQtY29scy00IGxnOnRleHQtbGVmdCI+PGEgaHJlZj0iaHR0cHM6Ly9uZXh0anMub3JnL2RvY3M/dXRtX3NvdXJjZT1jcmVhdGUtbmV4dC1hcHAmYW1wO3V0bV9tZWRpdW09YXBwZGlyLXRlbXBsYXRlJmFtcDt1dG1fY2FtcGFpZ249Y3JlYXRlLW5leHQtYXBwIiBjbGFzcz0iZ3JvdXAgcm91bmRlZC1sZyBib3JkZXIgYm9yZGVyLXRyYW5zcGFyZW50IHB4LTUgcHktNCB0cmFuc2l0aW9uLWNvbG9ycyBob3Zlcjpib3JkZXItZ3JheS0zMDAgaG92ZXI6YmctZ3JheS0xMDAgaG92ZXI6ZGFyazpib3JkZXItbmV1dHJhbC03MDAgaG92ZXI6ZGFyazpiZy1uZXV0cmFsLTgwMC8zMCIgdGFyZ2V0PSJfYmxhbmsiIHJlbD0ibm9vcGVuZXIgbm9yZWZlcnJlciI+PGgyIGNsYXNzPSJtYi0zIHRleHQtMnhsIGZvbnQtc2VtaWJvbGQiPkRvY3M8IS0tIC0tPiA8c3BhbiBjbGFzcz0iaW5saW5lLWJsb2NrIHRyYW5zaXRpb24tdHJhbnNmb3JtIGdyb3VwLWhvdmVyOnRyYW5zbGF0ZS14LTEgbW90aW9uLXJlZHVjZTp0cmFuc2Zvcm0tbm9uZSI+LSZndDs8L3NwYW4+PC9oMj48cCBjbGFzcz0ibS0wIG1heC13LVszMGNoXSB0ZXh0LXNtIG9wYWNpdHktNTAiPkZpbmQgaW4tZGVwdGggaW5mb3JtYXRpb24gYWJvdXQgTmV4dC5qcyBmZWF0dXJlcyBhbmQgQVBJLjwvcD48L2E+PGEgaHJlZj0iaHR0cHM6Ly9uZXh0anMub3JnL2xlYXJuP3V0bV9zb3VyY2U9Y3JlYXRlLW5leHQtYXBwJmFtcDt1dG1fbWVkaXVtPWFwcGRpci10ZW1wbGF0ZS10dyZhbXA7dXRtX2NhbXBhaWduPWNyZWF0ZS1uZXh0LWFwcCIgY2xhc3M9Imdyb3VwIHJvdW5kZWQtbGcgYm9yZGVyIGJvcmRlci10cmFuc3BhcmVudCBweC01IHB5LTQgdHJhbnNpdGlvbi1jb2xvcnMgaG92ZXI6Ym9yZGVyLWdyYXktMzAwIGhvdmVyOmJnLWdyYXktMTAwIGhvdmVyOmRhcms6Ym9yZGVyLW5ldXRyYWwtNzAwIGhvdmVyOmRhcms6YmctbmV1dHJhbC04MDAvMzAiIHRhcmdldD0iX2JsYW5rIiByZWw9Im5vb3BlbmVyIG5vcmVmZXJyZXIiPjxoMiBjbGFzcz0ibWItMyB0ZXh0LTJ4bCBmb250LXNlbWlib2xkIj5MZWFybjwhLS0gLS0+IDxzcGFuIGNsYXNzPSJpbmxpbmUtYmxvY2sgdHJhbnNpdGlvbi10cmFuc2Zvcm0gZ3JvdXAtaG92ZXI6dHJhbnNsYXRlLXgtMSBtb3Rpb24tcmVkdWNlOnRyYW5zZm9ybS1ub25lIj4tJmd0Ozwvc3Bhbj48L2gyPjxwIGNsYXNzPSJtLTAgbWF4LXctWzMwY2hdIHRleHQtc20gb3BhY2l0eS01MCI+TGVhcm4gYWJvdXQgTmV4dC5qcyBpbiBhbiBpbnRlcmFjdGl2ZSBjb3Vyc2Ugd2l0aMKgcXVpenplcyE8L3A+PC9hPjxhIGhyZWY9Imh0dHBzOi8vdmVyY2VsLmNvbS90ZW1wbGF0ZXM/ZnJhbWV3b3JrPW5leHQuanMmYW1wO3V0bV9zb3VyY2U9Y3JlYXRlLW5leHQtYXBwJmFtcDt1dG1fbWVkaXVtPWFwcGRpci10ZW1wbGF0ZSZhbXA7dXRtX2NhbXBhaWduPWNyZWF0ZS1uZXh0LWFwcCIgY2xhc3M9Imdyb3VwIHJvdW5kZWQtbGcgYm9yZGVyIGJvcmRlci10cmFuc3BhcmVudCBweC01IHB5LTQgdHJhbnNpdGlvbi1jb2xvcnMgaG92ZXI6Ym9yZGVyLWdyYXktMzAwIGhvdmVyOmJnLWdyYXktMTAwIGhvdmVyOmRhcms6Ym9yZGVyLW5ldXRyYWwtNzAwIGhvdmVyOmRhcms6YmctbmV1dHJhbC04MDAvMzAiIHRhcmdldD0iX2JsYW5rIiByZWw9Im5vb3BlbmVyIG5vcmVmZXJyZXIiPjxoMiBjbGFzcz0ibWItMyB0ZXh0LTJ4bCBmb250LXNlbWlib2xkIj5UZW1wbGF0ZXM8IS0tIC0tPiA8c3BhbiBjbGFzcz0iaW5saW5lLWJsb2NrIHRyYW5zaXRpb24tdHJhbnNmb3JtIGdyb3VwLWhvdmVyOnRyYW5zbGF0ZS14LTEgbW90aW9uLXJlZHVjZTp0cmFuc2Zvcm0tbm9uZSI+LSZndDs8L3NwYW4+PC9oMj48cCBjbGFzcz0ibS0wIG1heC13LVszMGNoXSB0ZXh0LXNtIG9wYWNpdHktNTAiPkV4cGxvcmUgdGhlIE5leHQuanMgMTMgcGxheWdyb3VuZC48L3A+PC9hPjxhIGhyZWY9Imh0dHBzOi8vdmVyY2VsLmNvbS9uZXc/dXRtX3NvdXJjZT1jcmVhdGUtbmV4dC1hcHAmYW1wO3V0bV9tZWRpdW09YXBwZGlyLXRlbXBsYXRlJmFtcDt1dG1fY2FtcGFpZ249Y3JlYXRlLW5leHQtYXBwIiBjbGFzcz0iZ3JvdXAgcm91bmRlZC1sZyBib3JkZXIgYm9yZGVyLXRyYW5zcGFyZW50IHB4LTUgcHktNCB0cmFuc2l0aW9uLWNvbG9ycyBob3Zlcjpib3JkZXItZ3JheS0zMDAgaG92ZXI6YmctZ3JheS0xMDAgaG92ZXI6ZGFyazpib3JkZXItbmV1dHJhbC03MDAgaG92ZXI6ZGFyazpiZy1uZXV0cmFsLTgwMC8zMCIgdGFyZ2V0PSJfYmxhbmsiIHJlbD0ibm9vcGVuZXIgbm9yZWZlcnJlciI+PGgyIGNsYXNzPSJtYi0zIHRleHQtMnhsIGZvbnQtc2VtaWJvbGQiPkRlcGxveTwhLS0gLS0+IDxzcGFuIGNsYXNzPSJpbmxpbmUtYmxvY2sgdHJhbnNpdGlvbi10cmFuc2Zvcm0gZ3JvdXAtaG92ZXI6dHJhbnNsYXRlLXgtMSBtb3Rpb24tcmVkdWNlOnRyYW5zZm9ybS1ub25lIj4tJmd0Ozwvc3Bhbj48L2gyPjxwIGNsYXNzPSJtLTAgbWF4LXctWzMwY2hdIHRleHQtc20gb3BhY2l0eS01MCI+SW5zdGFudGx5IGRlcGxveSB5b3VyIE5leHQuanMgc2l0ZSB0byBhIHNoYXJlYWJsZSBVUkwgd2l0aCBWZXJjZWwuPC9wPjwvYT48L2Rpdj48L21haW4+PHNjcmlwdCBzcmM9Ii9fbmV4dC9zdGF0aWMvY2h1bmtzL3dlYnBhY2stNzZmZDhiMzlmZTkxNGMyOS5qcyIgYXN5bmM9IiI+PC9zY3JpcHQ+PHNjcmlwdCBzcmM9Ii9fbmV4dC9zdGF0aWMvY2h1bmtzL2JjZTYwZmMxLTMxMzhmYzYzZTg0MzU5ZDkuanMiIGFzeW5jPSIiPjwvc2NyaXB0PjxzY3JpcHQgc3JjPSIvX25leHQvc3RhdGljL2NodW5rcy85NjEtZTY0MzczMjVhMTU1ZGRmYS5qcyIgYXN5bmM9IiI+PC9zY3JpcHQ+PHNjcmlwdCBzcmM9Ii9fbmV4dC9zdGF0aWMvY2h1bmtzL21haW4tYXBwLTk1MTFkODhkOTQwMDRhN2EuanMiIGFzeW5jPSIiPjwvc2NyaXB0PjxzY3JpcHQ+KHNlbGYuX19uZXh0X2Y9c2VsZi5fX25leHRfZnx8W10pLnB1c2goWzBdKTwvc2NyaXB0PjxzY3JpcHQ+c2VsZi5fX25leHRfZi5wdXNoKFsxLCIxOkhMW1wiL19uZXh0L3N0YXRpYy9tZWRpYS8yYWFmMDcyM2U3MjBlOGI5LXMucC53b2ZmMlwiLHtcImFzXCI6XCJmb250XCIsXCJ0eXBlXCI6XCJmb250L3dvZmYyXCJ9XVxuMjpITFtcIi9fbmV4dC9zdGF0aWMvY3NzLzExMGEzNWVhN2M4MWI4OTkuY3NzXCIse1wiYXNcIjpcInN0eWxlXCJ9XVxuMDpcIiRMM1wiXG4iXSk8L3NjcmlwdD48c2NyaXB0PnNlbGYuX19uZXh0X2YucHVzaChbMSwiNDpJe1wiaWRcIjo4MDk1LFwiY2h1bmtzXCI6W1wiMjcyOnN0YXRpYy9jaHVua3Mvd2VicGFjay03NmZkOGIzOWZlOTE0YzI5LmpzXCIsXCIyNTM6c3RhdGljL2NodW5rcy9iY2U2MGZjMS0zMTM4ZmM2M2U4NDM1OWQ5LmpzXCIsXCI5NjE6c3RhdGljL2NodW5rcy85NjEtZTY0MzczMjVhMTU1ZGRmYS5qc1wiXSxcIm5hbWVcIjpcImRlZmF1bHRcIixcImFzeW5jXCI6ZmFsc2V9XG42Okl7XCJpZFwiOjEyMjMsXCJjaHVua3NcIjpbXCIyNzI6c3RhdGljL2NodW5rcy93ZWJwYWNrLTc2ZmQ4YjM5ZmU5MTRjMjkuanNcIixcIjI1MzpzdGF0aWMvY2h1bmtzL2JjZTYwZmMxLTMxMzhmYzYzZTg0MzU5ZDkuanNcIixcIjk2MTpzdGF0aWMvY2h1bmtzLzk2MS1lNjQzNzMyNWExNTVkZGZhLmpzXCJdLFwibmFtZVwiOlwiR2xvYmFsRXJyb3JcIixcImFzeW5jXCI6ZmFsc2V9XG44Okl7XCJpZFwiOjM0NjYsXCJjaHVua3NcIjpbXCIyNzI6c3RhdGljL2NodW5rcy93ZWJwYWNrLTc2ZmQ4YjM5ZmU5MTRjMjkuanNcIixcIjI1MzpzdGF0aWMvY2h1bmtzL2JjZTYwZmMxLTMxMzhmYzYzZTg0MyJdKTwvc2NyaXB0PjxzY3JpcHQ+c2VsZi5fX25leHRfZi5wdXNoKFsxLCI1OWQ5LmpzXCIsXCI5NjE6c3RhdGljL2NodW5rcy85NjEtZTY0MzczMjVhMTU1ZGRmYS5qc1wiXSxcIm5hbWVcIjpcImRlZmF1bHRcIixcImFzeW5jXCI6ZmFsc2V9XG45Okl7XCJpZFwiOjM3MixcImNodW5rc1wiOltcIjI3MjpzdGF0aWMvY2h1bmtzL3dlYnBhY2stNzZmZDhiMzlmZTkxNGMyOS5qc1wiLFwiMjUzOnN0YXRpYy9jaHVua3MvYmNlNjBmYzEtMzEzOGZjNjNlODQzNTlkOS5qc1wiLFwiOTYxOnN0YXRpYy9jaHVua3MvOTYxLWU2NDM3MzI1YTE1NWRkZmEuanNcIl0sXCJuYW1lXCI6XCJkZWZhdWx0XCIsXCJhc3luY1wiOmZhbHNlfVxuYTpJe1wiaWRcIjozMjQwLFwiY2h1bmtzXCI6W1wiOTMxOnN0YXRpYy9jaHVua3MvYXBwL3BhZ2UtNjZmY2U1ZDFmMWUyYzU4MS5qc1wiXSxcIm5hbWVcIjpcIkltYWdlXCIsXCJhc3luY1wiOmZhbHNlfVxuIl0pPC9zY3JpcHQ+PHNjcmlwdD5zZWxmLl9fbmV4dF9mLnB1c2goWzEsIjM6W1tbXCIkXCIsXCJsaW5rXCIsXCIwXCIse1wicmVsXCI6XCJzdHlsZXNoZWV0XCIsXCJocmVmXCI6XCIvX25leHQvc3RhdGljL2Nzcy8xMTBhMzVlYTdjODFiODk5LmNzc1wiLFwicHJlY2VkZW5jZVwiOlwibmV4dFwifV1dLFtcIiRcIixcIiRMNFwiLG51bGwse1wiYnVpbGRJZFwiOlwielF6R0hKNi11a05QM2JlcE9oZWtQXCIsXCJhc3NldFByZWZpeFwiOlwiXCIsXCJpbml0aWFsQ2Fub25pY2FsVXJsXCI6XCIvXCIsXCJpbml0aWFsVHJlZVwiOltcIlwiLHtcImNoaWxkcmVuXCI6W1wiX19QQUdFX19cIix7fV19LFwiJHVuZGVmaW5lZFwiLFwiJHVuZGVmaW5lZFwiLHRydWVdLFwiaW5pdGlhbEhlYWRcIjpcIiRMNVwiLFwiZ2xvYmFsRXJyb3JDb21wb25lbnRcIjpcIiQ2XCIsXCJub3RGb3VuZFwiOltcIiRcIixcImh0bWxcIixudWxsLHtcImlkXCI6XCJfX25leHRfZXJyb3JfX1wiLFwiY2hpbGRyZW5cIjpbW1wiJFwiLFwiaGVhZFwiLG51bGwse1wiY2hpbGRyZW5cIjpcIiR1bmRlZmluZWRcIn1dLFtcIiRcIixcImJvZHlcIixudWxsLHtcImNoaWxkcmVuXCI6W1wiJEw3XCIsXCIkdW5kZWZpbmVkXCIsW1tcIiRcIixcInRpdGxlXCIsbnVsbCx7XCJjaGlsZHJlblwiOlwiNDA0OiBUaGlzIHBhZ2UgY291bGQgbm90IGJlIGZvdW5kLlwifV0sW1wiJFwiLFwiZGl2XCIsbnVsbCx7XCJzdHlsZVwiOntcImZvbnRGYW1pbHlcIjpcInN5c3RlbS11aSxcXFwiU2Vnb2UgVUlcXFwiLFJvYm90byxIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZixcXFwiQXBwbGUgQ29sb3IgRW1vamlcXFwiLFxcXCJTZWdvZSBVSSBFbW9qaVxcXCJcIixcImhlaWdodFwiOlwiMTAwdmhcIixcInRleHRBbGlnblwiOlwiY2VudGVyXCIsXCJkaXNwbGF5XCI6XCJmbGV4XCIsXCJmbGV4RGlyZWN0aW9uXCI6XCJjb2x1bW5cIixcImFsaWduSXRlbXNcIjpcImNlbnRlclwiLFwianVzdGlmeUNvbnRlbnRcIjpcImNlbnRlclwifSxcImNoaWxkcmVuXCI6W1wiJFwiLFwiZGl2XCIsbnVsbCx7XCJjaGlsZHJlblwiOltbXCIkXCIsXCJzdHlsZVwiLG51bGwse1wiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjp7XCJfX2h0bWxcIjpcImJvZHl7Y29sb3I6IzAwMDtiYWNrZ3JvdW5kOiNmZmY7bWFyZ2luOjB9Lm5leHQtZXJyb3ItaDF7Ym9yZGVyLXJpZ2h0OjFweCBzb2xpZCByZ2JhKDAsMCwwLC4zKX1AbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOmRhcmspe2JvZHl7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kOiMwMDB9Lm5leHQtZXJyb3ItaDF7Ym9yZGVyLXJpZ2h0OjFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LC4zKX19XCJ9fV0sW1wiJFwiLFwiaDFcIixudWxsLHtcImNsYXNzTmFtZVwiOlwibmV4dC1lcnJvci1oMVwiLFwic3R5bGVcIjp7XCJkaXNwbGF5XCI6XCJpbmxpbmUtYmxvY2tcIixcIm1hcmdpblwiOlwiMCAyMHB4IDAgMFwiLFwicGFkZGluZ1wiOlwiMCAyM3B4IDAgMFwiLFwiZm9udFNpemVcIjoyNCxcImZvbnRXZWlnaHRcIjo1MDAsXCJ2ZXJ0aWNhbEFsaWduXCI6XCJ0b3BcIixcImxpbmVIZWlnaHRcIjpcIjQ5cHhcIn0sXCJjaGlsZHJlblwiOlwiNDA0XCJ9XSxbXCIkXCIsXCJkaXZcIixudWxsLHtcInN0eWxlXCI6e1wiZGlzcGxheVwiOlwiaW5saW5lLWJsb2NrXCJ9LFwiY2hpbGRyZW5cIjpbXCIkXCIsXCJoMlwiLG51bGwse1wic3R5bGVcIjp7XCJmb250U2l6ZVwiOjE0LFwiZm9udFdlaWdodFwiOjQwMCxcImxpbmVIZWlnaHRcIjpcIjQ5cHhcIixcIm1hcmdpblwiOjB9LFwiY2hpbGRyZW5cIjpcIlRoaXMgcGFnZSBjb3VsZCBub3QgYmUgZm91bmQuXCJ9XX1dXX1dfV1dXX1dXX1dLFwiYXNOb3RGb3VuZFwiOmZhbHNlLFwiY2hpbGRyZW5cIjpbW1wiJFwiLFwiaHRtbFwiLG51bGwse1wibGFuZ1wiOlwiZW5cIixcImNoaWxkcmVuXCI6W1wiJFwiLFwiYm9keVwiLG51bGwse1wiY2xhc3NOYW1lXCI6XCJfX2NsYXNzTmFtZV8yMDk1MWZcIixcImNoaWxkcmVuXCI6W1wiJFwiLFwiJEw4XCIsbnVsbCx7XCJwYXJhbGxlbFJvdXRlcktleVwiOlwiY2hpbGRyZW5cIixcInNlZ21lbnRQYXRoXCI6W1wiY2hpbGRyZW5cIl0sXCJlcnJvclwiOlwiJHVuZGVmaW5lZFwiLFwiZXJyb3JTdHlsZXNcIjpcIiR1bmRlZmluZWRcIixcImxvYWRpbmdcIjpcIiR1bmRlZmluZWRcIixcImxvYWRpbmdTdHlsZXNcIjpcIiR1bmRlZmluZWRcIixcImhhc0xvYWRpbmdcIjpmYWxzZSxcInRlbXBsYXRlXCI6W1wiJFwiLFwiJEw5XCIsbnVsbCx7fV0sXCJ0ZW1wbGF0ZVN0eWxlc1wiOlwiJHVuZGVmaW5lZFwiLFwibm90Rm91bmRcIjpcIiR1bmRlZmluZWRcIixcIm5vdEZvdW5kU3R5bGVzXCI6XCIkdW5kZWZpbmVkXCIsXCJjaGlsZFByb3BcIjp7XCJjdXJyZW50XCI6W1tcIiRcIixcIm1haW5cIixudWxsLHtcImNsYXNzTmFtZVwiOlwiZmxleCBtaW4taC1zY3JlZW4gZmxleC1jb2wgaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiBwLTI0XCIsXCJjaGlsZHJlblwiOltbXCIkXCIsXCJkaXZcIixudWxsLHtcImNsYXNzTmFtZVwiOlwiei0xMCB3LWZ1bGwgbWF4LXctNXhsIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gZm9udC1tb25vIHRleHQtc20gbGc6ZmxleFwiLFwiY2hpbGRyZW5cIjpbW1wiJFwiLFwicFwiLG51bGwse1wiY2xhc3NOYW1lXCI6XCJmaXhlZCBsZWZ0LTAgdG9wLTAgZmxleCB3LWZ1bGwganVzdGlmeS1jZW50ZXIgYm9yZGVyLWIgYm9yZGVyLWdyYXktMzAwIGJnLWdyYWRpZW50LXRvLWIgZnJvbS16aW5jLTIwMCBwYi02IHB0LTggYmFja2Ryb3AtYmx1ci0yeGwgZGFyazpib3JkZXItbmV1dHJhbC04MDAgZGFyazpiZy16aW5jLTgwMC8zMCBkYXJrOmZyb20taW5oZXJpdCBsZzpzdGF0aWMgbGc6dy1hdXRvICBsZzpyb3VuZGVkLXhsIGxnOmJvcmRlciBsZzpiZy1ncmF5LTIwMCBsZzpwLTQgbGc6ZGFyazpiZy16aW5jLTgwMC8zMFwiLFwiY2hpbGRyZW5cIjpbXCJHZXQgc3RhcnRlZCBieSBlZGl0aW5nwqBcIixbXCIkXCIsXCJjb2RlXCIsbnVsbCx7XCJjbGFzc05hbWVcIjpcImZvbnQtbW9ubyBmb250LWJvbGRcIixcImNoaWxkcmVuXCI6XCJhcHAvcGFnZS50c3hcIn1dXX1dLFtcIiRcIixcImRpdlwiLG51bGwse1wiY2xhc3NOYW1lXCI6XCJmaXhlZCBib3R0b20tMCBsZWZ0LTAgZmxleCBoLTQ4IHctZnVsbCBpdGVtcy1lbmQganVzdGlmeS1jZW50ZXIgYmctZ3JhZGllbnQtdG8tdCBmcm9tLXdoaXRlIHZpYS13aGl0ZSBkYXJrOmZyb20tYmxhY2sgZGFyazp2aWEtYmxhY2sgbGc6c3RhdGljIGxnOmgtYXV0byBsZzp3LWF1dG8gbGc6Ymctbm9uZVwiLFwiY2hpbGRyZW5cIjpbXCIkXCIsXCJhXCIsbnVsbCx7XCJjbGFzc05hbWVcIjpcInBvaW50ZXItZXZlbnRzLW5vbmUgZmxleCBwbGFjZS1pdGVtcy1jZW50ZXIgZ2FwLTIgcC04IGxnOnBvaW50ZXItZXZlbnRzLWF1dG8gbGc6cC0wXCIsXCJocmVmXCI6XCJodHRwczovL3ZlcmNlbC5jb20/dXRtX3NvdXJjZT1jcmVhdGUtbmV4dC1hcHBcdTAwMjZ1dG1fbWVkaXVtPWFwcGRpci10ZW1wbGF0ZVx1MDAyNnV0bV9jYW1wYWlnbj1jcmVhdGUtbmV4dC1hcHBcIixcInRhcmdldFwiOlwiX2JsYW5rXCIsXCJyZWxcIjpcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIixcImNoaWxkcmVuXCI6W1wiQnlcIixcIiBcIixbXCIkXCIsXCIkTGFcIixudWxsLHtcInNyY1wiOlwiL3ZlcmNlbC5zdmdcIixcImFsdFwiOlwiVmVyY2VsIExvZ29cIixcImNsYXNzTmFtZVwiOlwiZGFyazppbnZlcnRcIixcIndpZHRoXCI6MTAwLFwiaGVpZ2h0XCI6MjQsXCJwcmlvcml0eVwiOnRydWV9XV19XX1dXX1dLFtcIiRcIixcImRpdlwiLG51bGwse1wiY2xhc3NOYW1lXCI6XCJyZWxhdGl2ZSBmbGV4IHBsYWNlLWl0ZW1zLWNlbnRlciBiZWZvcmU6YWJzb2x1dGUgYmVmb3JlOmgtWzMwMHB4XSBiZWZvcmU6dy1bNDgwcHhdIGJlZm9yZTotdHJhbnNsYXRlLXgtMS8yIGJlZm9yZTpyb3VuZGVkLWZ1bGwgYmVmb3JlOmJnLWdyYWRpZW50LXJhZGlhbCBiZWZvcmU6ZnJvbS13aGl0ZSBiZWZvcmU6dG8tdHJhbnNwYXJlbnQgYmVmb3JlOmJsdXItMnhsIGJlZm9yZTpjb250ZW50LVsnJ10gYWZ0ZXI6YWJzb2x1dGUgYWZ0ZXI6LXotMjAgYWZ0ZXI6aC1bMTgwcHhdIGFmdGVyOnctWzI0MHB4XSBhZnRlcjp0cmFuc2xhdGUteC0xLzMgYWZ0ZXI6YmctZ3JhZGllbnQtY29uaWMgYWZ0ZXI6ZnJvbS1za3ktMjAwIGFmdGVyOnZpYS1ibHVlLTIwMCBhZnRlcjpibHVyLTJ4bCBhZnRlcjpjb250ZW50LVsnJ10gYmVmb3JlOmRhcms6YmctZ3JhZGllbnQtdG8tYnIgYmVmb3JlOmRhcms6ZnJvbS10cmFuc3BhcmVudCBiZWZvcmU6ZGFyazp0by1ibHVlLTcwMCBiZWZvcmU6ZGFyazpvcGFjaXR5LTEwIGFmdGVyOmRhcms6ZnJvbS1za3ktOTAwIGFmdGVyOmRhcms6dmlhLVsjMDE0MWZmXSBhZnRlcjpkYXJrOm9wYWNpdHktNDAgYmVmb3JlOmxnOmgtWzM2MHB4XSB6LVstMV1cIixcImNoaWxkcmVuXCI6W1wiJFwiLFwiJExhXCIsbnVsbCx7XCJjbGFzc05hbWVcIjpcInJlbGF0aXZlIGRhcms6ZHJvcC1zaGFkb3ctWzBfMF8wLjNyZW1fI2ZmZmZmZjcwXSBkYXJrOmludmVydFwiLFwic3JjXCI6XCIvbmV4dC5zdmdcIixcImFsdFwiOlwiTmV4dC5qcyBMb2dvXCIsXCJ3aWR0aFwiOjE4MCxcImhlaWdodFwiOjM3LFwicHJpb3JpdHlcIjp0cnVlfV19XSxbXCIkXCIsXCJkaXZcIixudWxsLHtcImNsYXNzTmFtZVwiOlwibWItMzIgZ3JpZCB0ZXh0LWNlbnRlciBsZzptYi0wIGxnOmdyaWQtY29scy00IGxnOnRleHQtbGVmdFwiLFwiY2hpbGRyZW5cIjpbW1wiJFwiLFwiYVwiLG51bGwse1wiaHJlZlwiOlwiaHR0cHM6Ly9uZXh0anMub3JnL2RvY3M/dXRtX3NvdXJjZT1jcmVhdGUtbmV4dC1hcHBcdTAwMjZ1dG1fbWVkaXVtPWFwcGRpci10ZW1wbGF0ZVx1MDAyNnV0bV9jYW1wYWlnbj1jcmVhdGUtbmV4dC1hcHBcIixcImNsYXNzTmFtZVwiOlwiZ3JvdXAgcm91bmRlZC1sZyBib3JkZXIgYm9yZGVyLXRyYW5zcGFyZW50IHB4LTUgcHktNCB0cmFuc2l0aW9uLWNvbG9ycyBob3Zlcjpib3JkZXItZ3JheS0zMDAgaG92ZXI6YmctZ3JheS0xMDAgaG92ZXI6ZGFyazpib3JkZXItbmV1dHJhbC03MDAgaG92ZXI6ZGFyazpiZy1uZXV0cmFsLTgwMC8zMFwiLFwidGFyZ2V0XCI6XCJfYmxhbmtcIixcInJlbFwiOlwibm9vcGVuZXIgbm9yZWZlcnJlclwiLFwiY2hpbGRyZW5cIjpbW1wiJFwiLFwiaDJcIixudWxsLHtcImNsYXNzTmFtZVwiOlwibWItMyB0ZXh0LTJ4bCBmb250LXNlbWlib2xkXCIsXCJjaGlsZHJlblwiOltcIkRvY3NcIixcIiBcIixbXCIkXCIsXCJzcGFuXCIsbnVsbCx7XCJjbGFzc05hbWVcIjpcImlubGluZS1ibG9jayB0cmFuc2l0aW9uLXRyYW5zZm9ybSBncm91cC1ob3Zlcjp0cmFuc2xhdGUteC0xIG1vdGlvbi1yZWR1Y2U6dHJhbnNmb3JtLW5vbmVcIixcImNoaWxkcmVuXCI6XCItXHUwMDNlXCJ9XV19XSxbXCIkXCIsXCJwXCIsbnVsbCx7XCJjbGFzc05hbWVcIjpcIm0tMCBtYXgtdy1bMzBjaF0gdGV4dC1zbSBvcGFjaXR5LTUwXCIsXCJjaGlsZHJlblwiOlwiRmluZCBpbi1kZXB0aCBpbmZvcm1hdGlvbiBhYm91dCBOZXh0LmpzIGZlYXR1cmVzIGFuZCBBUEkuXCJ9XV19XSxbXCIkXCIsXCJhXCIsbnVsbCx7XCJocmVmXCI6XCJodHRwczovL25leHRqcy5vcmcvbGVhcm4/dXRtX3NvdXJjZT1jcmVhdGUtbmV4dC1hcHBcdTAwMjZ1dG1fbWVkaXVtPWFwcGRpci10ZW1wbGF0ZS10d1x1MDAyNnV0bV9jYW1wYWlnbj1jcmVhdGUtbmV4dC1hcHBcIixcImNsYXNzTmFtZVwiOlwiZ3JvdXAgcm91bmRlZC1sZyBib3JkZXIgYm9yZGVyLXRyYW5zcGFyZW50IHB4LTUgcHktNCB0cmFuc2l0aW9uLWNvbG9ycyBob3Zlcjpib3JkZXItZ3JheS0zMDAgaG92ZXI6YmctZ3JheS0xMDAgaG92ZXI6ZGFyazpib3JkZXItbmV1dHJhbC03MDAgaG92ZXI6ZGFyazpiZy1uZXV0cmFsLTgwMC8zMFwiLFwidGFyZ2V0XCI6XCJfYmxhbmtcIixcInJlbFwiOlwibm9vcGVuZXIgbm9yZWZlcnJlclwiLFwiY2hpbGRyZW5cIjpbW1wiJFwiLFwiaDJcIixudWxsLHtcImNsYXNzTmFtZVwiOlwibWItMyB0ZXh0LTJ4bCBmb250LXNlbWlib2xkXCIsXCJjaGlsZHJlblwiOltcIkxlYXJuXCIsXCIgXCIsW1wiJFwiLFwic3BhblwiLG51bGwse1wiY2xhc3NOYW1lXCI6XCJpbmxpbmUtYmxvY2sgdHJhbnNpdGlvbi10cmFuc2Zvcm0gZ3JvdXAtaG92ZXI6dHJhbnNsYXRlLXgtMSBtb3Rpb24tcmVkdWNlOnRyYW5zZm9ybS1ub25lXCIsXCJjaGlsZHJlblwiOlwiLVx1MDAzZVwifV1dfV0sW1wiJFwiLFwicFwiLG51bGwse1wiY2xhc3NOYW1lXCI6XCJtLTAgbWF4LXctWzMwY2hdIHRleHQtc20gb3BhY2l0eS01MFwiLFwiY2hpbGRyZW5cIjpcIkxlYXJuIGFib3V0IE5leHQuanMgaW4gYW4gaW50ZXJhY3RpdmUgY291cnNlIHdpdGjCoHF1aXp6ZXMhXCJ9XV19XSxbXCIkXCIsXCJhXCIsbnVsbCx7XCJocmVmXCI6XCJodHRwczovL3ZlcmNlbC5jb20vdGVtcGxhdGVzP2ZyYW1ld29yaz1uZXh0LmpzXHUwMDI2dXRtX3NvdXJjZT1jcmVhdGUtbmV4dC1hcHBcdTAwMjZ1dG1fbWVkaXVtPWFwcGRpci10ZW1wbGF0ZVx1MDAyNnV0bV9jYW1wYWlnbj1jcmVhdGUtbmV4dC1hcHBcIixcImNsYXNzTmFtZVwiOlwiZ3JvdXAgcm91bmRlZC1sZyBib3JkZXIgYm9yZGVyLXRyYW5zcGFyZW50IHB4LTUgcHktNCB0cmFuc2l0aW9uLWNvbG9ycyBob3Zlcjpib3JkZXItZ3JheS0zMDAgaG92ZXI6YmctZ3JheS0xMDAgaG92ZXI6ZGFyazpib3JkZXItbmV1dHJhbC03MDAgaG92ZXI6ZGFyazpiZy1uZXV0cmFsLTgwMC8zMFwiLFwidGFyZ2V0XCI6XCJfYmxhbmtcIixcInJlbFwiOlwibm9vcGVuZXIgbm9yZWZlcnJlclwiLFwiY2hpbGRyZW5cIjpbW1wiJFwiLFwiaDJcIixudWxsLHtcImNsYXNzTmFtZVwiOlwibWItMyB0ZXh0LTJ4bCBmb250LXNlbWlib2xkXCIsXCJjaGlsZHJlblwiOltcIlRlbXBsYXRlc1wiLFwiIFwiLFtcIiRcIixcInNwYW5cIixudWxsLHtcImNsYXNzTmFtZVwiOlwiaW5saW5lLWJsb2NrIHRyYW5zaXRpb24tdHJhbnNmb3JtIGdyb3VwLWhvdmVyOnRyYW5zbGF0ZS14LTEgbW90aW9uLXJlZHVjZTp0cmFuc2Zvcm0tbm9uZVwiLFwiY2hpbGRyZW5cIjpcIi1cdTAwM2VcIn1dXX1dLFtcIiRcIixcInBcIixudWxsLHtcImNsYXNzTmFtZVwiOlwibS0wIG1heC13LVszMGNoXSB0ZXh0LXNtIG9wYWNpdHktNTBcIixcImNoaWxkcmVuXCI6XCJFeHBsb3JlIHRoZSBOZXh0LmpzIDEzIHBsYXlncm91bmQuXCJ9XV19XSxbXCIkXCIsXCJhXCIsbnVsbCx7XCJocmVmXCI6XCJodHRwczovL3ZlcmNlbC5jb20vbmV3P3V0bV9zb3VyY2U9Y3JlYXRlLW5leHQtYXBwXHUwMDI2dXRtX21lZGl1bT1hcHBkaXItdGVtcGxhdGVcdTAwMjZ1dG1fY2FtcGFpZ249Y3JlYXRlLW5leHQtYXBwXCIsXCJjbGFzc05hbWVcIjpcImdyb3VwIHJvdW5kZWQtbGcgYm9yZGVyIGJvcmRlci10cmFuc3BhcmVudCBweC01IHB5LTQgdHJhbnNpdGlvbi1jb2xvcnMgaG92ZXI6Ym9yZGVyLWdyYXktMzAwIGhvdmVyOmJnLWdyYXktMTAwIGhvdmVyOmRhcms6Ym9yZGVyLW5ldXRyYWwtNzAwIGhvdmVyOmRhcms6YmctbmV1dHJhbC04MDAvMzBcIixcInRhcmdldFwiOlwiX2JsYW5rXCIsXCJyZWxcIjpcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIixcImNoaWxkcmVuXCI6W1tcIiRcIixcImgyXCIsbnVsbCx7XCJjbGFzc05hbWVcIjpcIm1iLTMgdGV4dC0yeGwgZm9udC1zZW1pYm9sZFwiLFwiY2hpbGRyZW5cIjpbXCJEZXBsb3lcIixcIiBcIixbXCIkXCIsXCJzcGFuXCIsbnVsbCx7XCJjbGFzc05hbWVcIjpcImlubGluZS1ibG9jayB0cmFuc2l0aW9uLXRyYW5zZm9ybSBncm91cC1ob3Zlcjp0cmFuc2xhdGUteC0xIG1vdGlvbi1yZWR1Y2U6dHJhbnNmb3JtLW5vbmVcIixcImNoaWxkcmVuXCI6XCItXHUwMDNlXCJ9XV19XSxbXCIkXCIsXCJwXCIsbnVsbCx7XCJjbGFzc05hbWVcIjpcIm0tMCBtYXgtdy1bMzBjaF0gdGV4dC1zbSBvcGFjaXR5LTUwXCIsXCJjaGlsZHJlblwiOlwiSW5zdGFudGx5IGRlcGxveSB5b3VyIE5leHQuanMgc2l0ZSB0byBhIHNoYXJlYWJsZSBVUkwgd2l0aCBWZXJjZWwuXCJ9XV19XV19XV19XSxudWxsXSxcInNlZ21lbnRcIjpcIl9fUEFHRV9fXCJ9LFwic3R5bGVzXCI6W119XX1dfV0sbnVsbF19XV1cbiJdKTwvc2NyaXB0PjxzY3JpcHQ+c2VsZi5fX25leHRfZi5wdXNoKFsxLCI1OltbXCIkXCIsXCJtZXRhXCIsXCIwXCIse1wiY2hhclNldFwiOlwidXRmLThcIn1dLFtcIiRcIixcInRpdGxlXCIsXCIxXCIse1wiY2hpbGRyZW5cIjpcIkNyZWF0ZSBOZXh0IEFwcFwifV0sW1wiJFwiLFwibWV0YVwiLFwiMlwiLHtcIm5hbWVcIjpcImRlc2NyaXB0aW9uXCIsXCJjb250ZW50XCI6XCJHZW5lcmF0ZWQgYnkgY3JlYXRlIG5leHQgYXBwXCJ9XSxbXCIkXCIsXCJtZXRhXCIsXCIzXCIse1wibmFtZVwiOlwidmlld3BvcnRcIixcImNvbnRlbnRcIjpcIndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xXCJ9XSxbXCIkXCIsXCJsaW5rXCIsXCI0XCIse1wicmVsXCI6XCJpY29uXCIsXCJocmVmXCI6XCIvZmF2aWNvbi5pY29cIixcInR5cGVcIjpcImltYWdlL3gtaWNvblwiLFwic2l6ZXNcIjpcImFueVwifV0sW1wiJFwiLFwibWV0YVwiLFwiNVwiLHtcIm5hbWVcIjpcIm5leHQtc2l6ZS1hZGp1c3RcIn1dXVxuNzpbW1wiJFwiLFwibWV0YVwiLFwiMFwiLHtcImNoYXJTZXRcIjpcInV0Zi04XCJ9XSxbXCIkXCIsXCJ0aXRsZVwiLFwiMVwiLHtcImNoaWxkcmVuXCI6XCJDcmVhdGUgTmV4dCBBcHBcIn1dLFtcIiRcIixcIm1ldGFcIixcIjJcIix7XCJuYW1lXCI6XCJkZXNjcmlwIl0pPC9zY3JpcHQ+PHNjcmlwdD5zZWxmLl9fbmV4dF9mLnB1c2goWzEsInRpb25cIixcImNvbnRlbnRcIjpcIkdlbmVyYXRlZCBieSBjcmVhdGUgbmV4dCBhcHBcIn1dLFtcIiRcIixcIm1ldGFcIixcIjNcIix7XCJuYW1lXCI6XCJ2aWV3cG9ydFwiLFwiY29udGVudFwiOlwid2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTFcIn1dLFtcIiRcIixcImxpbmtcIixcIjRcIix7XCJyZWxcIjpcImljb25cIixcImhyZWZcIjpcIi9mYXZpY29uLmljb1wiLFwidHlwZVwiOlwiaW1hZ2UveC1pY29uXCIsXCJzaXplc1wiOlwiYW55XCJ9XSxbXCIkXCIsXCJtZXRhXCIsXCI1XCIse1wibmFtZVwiOlwibmV4dC1zaXplLWFkanVzdFwifV1dXG4iXSk8L3NjcmlwdD48L2JvZHk+PC9odG1sPg==\")\nassets.set(\"/index.txt\", \"data:text/plain;base64,MTpITFsiL19uZXh0L3N0YXRpYy9tZWRpYS8yYWFmMDcyM2U3MjBlOGI5LXMucC53b2ZmMiIseyJhcyI6ImZvbnQiLCJ0eXBlIjoiZm9udC93b2ZmMiJ9XQoyOkhMWyIvX25leHQvc3RhdGljL2Nzcy8xMTBhMzVlYTdjODFiODk5LmNzcyIseyJhcyI6InN0eWxlIn1dCjA6WyJ6UXpHSEo2LXVrTlAzYmVwT2hla1AiLFtbWyIiLHsiY2hpbGRyZW4iOlsiX19QQUdFX18iLHt9XX0sIiR1bmRlZmluZWQiLCIkdW5kZWZpbmVkIix0cnVlXSwiJEwzIixbW1siJCIsImxpbmsiLCIwIix7InJlbCI6InN0eWxlc2hlZXQiLCJocmVmIjoiL19uZXh0L3N0YXRpYy9jc3MvMTEwYTM1ZWE3YzgxYjg5OS5jc3MiLCJwcmVjZWRlbmNlIjoibmV4dCJ9XV0sIiRMNCJdXV1dCjU6SXsiaWQiOjM0NjYsImNodW5rcyI6WyIyNzI6c3RhdGljL2NodW5rcy93ZWJwYWNrLTc2ZmQ4YjM5ZmU5MTRjMjkuanMiLCIyNTM6c3RhdGljL2NodW5rcy9iY2U2MGZjMS0zMTM4ZmM2M2U4NDM1OWQ5LmpzIiwiOTYxOnN0YXRpYy9jaHVua3MvOTYxLWU2NDM3MzI1YTE1NWRkZmEuanMiXSwibmFtZSI6ImRlZmF1bHQiLCJhc3luYyI6ZmFsc2V9CjY6SXsiaWQiOjM3MiwiY2h1bmtzIjpbIjI3MjpzdGF0aWMvY2h1bmtzL3dlYnBhY2stNzZmZDhiMzlmZTkxNGMyOS5qcyIsIjI1MzpzdGF0aWMvY2h1bmtzL2JjZTYwZmMxLTMxMzhmYzYzZTg0MzU5ZDkuanMiLCI5NjE6c3RhdGljL2NodW5rcy85NjEtZTY0MzczMjVhMTU1ZGRmYS5qcyJdLCJuYW1lIjoiZGVmYXVsdCIsImFzeW5jIjpmYWxzZX0KNzpJeyJpZCI6MzI0MCwiY2h1bmtzIjpbIjkzMTpzdGF0aWMvY2h1bmtzL2FwcC9wYWdlLTY2ZmNlNWQxZjFlMmM1ODEuanMiXSwibmFtZSI6IkltYWdlIiwiYXN5bmMiOmZhbHNlfQozOltbIiQiLCJodG1sIixudWxsLHsibGFuZyI6ImVuIiwiY2hpbGRyZW4iOlsiJCIsImJvZHkiLG51bGwseyJjbGFzc05hbWUiOiJfX2NsYXNzTmFtZV8yMDk1MWYiLCJjaGlsZHJlbiI6WyIkIiwiJEw1IixudWxsLHsicGFyYWxsZWxSb3V0ZXJLZXkiOiJjaGlsZHJlbiIsInNlZ21lbnRQYXRoIjpbImNoaWxkcmVuIl0sImVycm9yIjoiJHVuZGVmaW5lZCIsImVycm9yU3R5bGVzIjoiJHVuZGVmaW5lZCIsImxvYWRpbmciOiIkdW5kZWZpbmVkIiwibG9hZGluZ1N0eWxlcyI6IiR1bmRlZmluZWQiLCJoYXNMb2FkaW5nIjpmYWxzZSwidGVtcGxhdGUiOlsiJCIsIiRMNiIsbnVsbCx7fV0sInRlbXBsYXRlU3R5bGVzIjoiJHVuZGVmaW5lZCIsIm5vdEZvdW5kIjoiJHVuZGVmaW5lZCIsIm5vdEZvdW5kU3R5bGVzIjoiJHVuZGVmaW5lZCIsImNoaWxkUHJvcCI6eyJjdXJyZW50IjpbWyIkIiwibWFpbiIsbnVsbCx7ImNsYXNzTmFtZSI6ImZsZXggbWluLWgtc2NyZWVuIGZsZXgtY29sIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gcC0yNCIsImNoaWxkcmVuIjpbWyIkIiwiZGl2IixudWxsLHsiY2xhc3NOYW1lIjoiei0xMCB3LWZ1bGwgbWF4LXctNXhsIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gZm9udC1tb25vIHRleHQtc20gbGc6ZmxleCIsImNoaWxkcmVuIjpbWyIkIiwicCIsbnVsbCx7ImNsYXNzTmFtZSI6ImZpeGVkIGxlZnQtMCB0b3AtMCBmbGV4IHctZnVsbCBqdXN0aWZ5LWNlbnRlciBib3JkZXItYiBib3JkZXItZ3JheS0zMDAgYmctZ3JhZGllbnQtdG8tYiBmcm9tLXppbmMtMjAwIHBiLTYgcHQtOCBiYWNrZHJvcC1ibHVyLTJ4bCBkYXJrOmJvcmRlci1uZXV0cmFsLTgwMCBkYXJrOmJnLXppbmMtODAwLzMwIGRhcms6ZnJvbS1pbmhlcml0IGxnOnN0YXRpYyBsZzp3LWF1dG8gIGxnOnJvdW5kZWQteGwgbGc6Ym9yZGVyIGxnOmJnLWdyYXktMjAwIGxnOnAtNCBsZzpkYXJrOmJnLXppbmMtODAwLzMwIiwiY2hpbGRyZW4iOlsiR2V0IHN0YXJ0ZWQgYnkgZWRpdGluZ8KgIixbIiQiLCJjb2RlIixudWxsLHsiY2xhc3NOYW1lIjoiZm9udC1tb25vIGZvbnQtYm9sZCIsImNoaWxkcmVuIjoiYXBwL3BhZ2UudHN4In1dXX1dLFsiJCIsImRpdiIsbnVsbCx7ImNsYXNzTmFtZSI6ImZpeGVkIGJvdHRvbS0wIGxlZnQtMCBmbGV4IGgtNDggdy1mdWxsIGl0ZW1zLWVuZCBqdXN0aWZ5LWNlbnRlciBiZy1ncmFkaWVudC10by10IGZyb20td2hpdGUgdmlhLXdoaXRlIGRhcms6ZnJvbS1ibGFjayBkYXJrOnZpYS1ibGFjayBsZzpzdGF0aWMgbGc6aC1hdXRvIGxnOnctYXV0byBsZzpiZy1ub25lIiwiY2hpbGRyZW4iOlsiJCIsImEiLG51bGwseyJjbGFzc05hbWUiOiJwb2ludGVyLWV2ZW50cy1ub25lIGZsZXggcGxhY2UtaXRlbXMtY2VudGVyIGdhcC0yIHAtOCBsZzpwb2ludGVyLWV2ZW50cy1hdXRvIGxnOnAtMCIsImhyZWYiOiJodHRwczovL3ZlcmNlbC5jb20/dXRtX3NvdXJjZT1jcmVhdGUtbmV4dC1hcHAmdXRtX21lZGl1bT1hcHBkaXItdGVtcGxhdGUmdXRtX2NhbXBhaWduPWNyZWF0ZS1uZXh0LWFwcCIsInRhcmdldCI6Il9ibGFuayIsInJlbCI6Im5vb3BlbmVyIG5vcmVmZXJyZXIiLCJjaGlsZHJlbiI6WyJCeSIsIiAiLFsiJCIsIiRMNyIsbnVsbCx7InNyYyI6Ii92ZXJjZWwuc3ZnIiwiYWx0IjoiVmVyY2VsIExvZ28iLCJjbGFzc05hbWUiOiJkYXJrOmludmVydCIsIndpZHRoIjoxMDAsImhlaWdodCI6MjQsInByaW9yaXR5Ijp0cnVlfV1dfV19XV19XSxbIiQiLCJkaXYiLG51bGwseyJjbGFzc05hbWUiOiJyZWxhdGl2ZSBmbGV4IHBsYWNlLWl0ZW1zLWNlbnRlciBiZWZvcmU6YWJzb2x1dGUgYmVmb3JlOmgtWzMwMHB4XSBiZWZvcmU6dy1bNDgwcHhdIGJlZm9yZTotdHJhbnNsYXRlLXgtMS8yIGJlZm9yZTpyb3VuZGVkLWZ1bGwgYmVmb3JlOmJnLWdyYWRpZW50LXJhZGlhbCBiZWZvcmU6ZnJvbS13aGl0ZSBiZWZvcmU6dG8tdHJhbnNwYXJlbnQgYmVmb3JlOmJsdXItMnhsIGJlZm9yZTpjb250ZW50LVsnJ10gYWZ0ZXI6YWJzb2x1dGUgYWZ0ZXI6LXotMjAgYWZ0ZXI6aC1bMTgwcHhdIGFmdGVyOnctWzI0MHB4XSBhZnRlcjp0cmFuc2xhdGUteC0xLzMgYWZ0ZXI6YmctZ3JhZGllbnQtY29uaWMgYWZ0ZXI6ZnJvbS1za3ktMjAwIGFmdGVyOnZpYS1ibHVlLTIwMCBhZnRlcjpibHVyLTJ4bCBhZnRlcjpjb250ZW50LVsnJ10gYmVmb3JlOmRhcms6YmctZ3JhZGllbnQtdG8tYnIgYmVmb3JlOmRhcms6ZnJvbS10cmFuc3BhcmVudCBiZWZvcmU6ZGFyazp0by1ibHVlLTcwMCBiZWZvcmU6ZGFyazpvcGFjaXR5LTEwIGFmdGVyOmRhcms6ZnJvbS1za3ktOTAwIGFmdGVyOmRhcms6dmlhLVsjMDE0MWZmXSBhZnRlcjpkYXJrOm9wYWNpdHktNDAgYmVmb3JlOmxnOmgtWzM2MHB4XSB6LVstMV0iLCJjaGlsZHJlbiI6WyIkIiwiJEw3IixudWxsLHsiY2xhc3NOYW1lIjoicmVsYXRpdmUgZGFyazpkcm9wLXNoYWRvdy1bMF8wXzAuM3JlbV8jZmZmZmZmNzBdIGRhcms6aW52ZXJ0Iiwic3JjIjoiL25leHQuc3ZnIiwiYWx0IjoiTmV4dC5qcyBMb2dvIiwid2lkdGgiOjE4MCwiaGVpZ2h0IjozNywicHJpb3JpdHkiOnRydWV9XX1dLFsiJCIsImRpdiIsbnVsbCx7ImNsYXNzTmFtZSI6Im1iLTMyIGdyaWQgdGV4dC1jZW50ZXIgbGc6bWItMCBsZzpncmlkLWNvbHMtNCBsZzp0ZXh0LWxlZnQiLCJjaGlsZHJlbiI6W1siJCIsImEiLG51bGwseyJocmVmIjoiaHR0cHM6Ly9uZXh0anMub3JnL2RvY3M/dXRtX3NvdXJjZT1jcmVhdGUtbmV4dC1hcHAmdXRtX21lZGl1bT1hcHBkaXItdGVtcGxhdGUmdXRtX2NhbXBhaWduPWNyZWF0ZS1uZXh0LWFwcCIsImNsYXNzTmFtZSI6Imdyb3VwIHJvdW5kZWQtbGcgYm9yZGVyIGJvcmRlci10cmFuc3BhcmVudCBweC01IHB5LTQgdHJhbnNpdGlvbi1jb2xvcnMgaG92ZXI6Ym9yZGVyLWdyYXktMzAwIGhvdmVyOmJnLWdyYXktMTAwIGhvdmVyOmRhcms6Ym9yZGVyLW5ldXRyYWwtNzAwIGhvdmVyOmRhcms6YmctbmV1dHJhbC04MDAvMzAiLCJ0YXJnZXQiOiJfYmxhbmsiLCJyZWwiOiJub29wZW5lciBub3JlZmVycmVyIiwiY2hpbGRyZW4iOltbIiQiLCJoMiIsbnVsbCx7ImNsYXNzTmFtZSI6Im1iLTMgdGV4dC0yeGwgZm9udC1zZW1pYm9sZCIsImNoaWxkcmVuIjpbIkRvY3MiLCIgIixbIiQiLCJzcGFuIixudWxsLHsiY2xhc3NOYW1lIjoiaW5saW5lLWJsb2NrIHRyYW5zaXRpb24tdHJhbnNmb3JtIGdyb3VwLWhvdmVyOnRyYW5zbGF0ZS14LTEgbW90aW9uLXJlZHVjZTp0cmFuc2Zvcm0tbm9uZSIsImNoaWxkcmVuIjoiLT4ifV1dfV0sWyIkIiwicCIsbnVsbCx7ImNsYXNzTmFtZSI6Im0tMCBtYXgtdy1bMzBjaF0gdGV4dC1zbSBvcGFjaXR5LTUwIiwiY2hpbGRyZW4iOiJGaW5kIGluLWRlcHRoIGluZm9ybWF0aW9uIGFib3V0IE5leHQuanMgZmVhdHVyZXMgYW5kIEFQSS4ifV1dfV0sWyIkIiwiYSIsbnVsbCx7ImhyZWYiOiJodHRwczovL25leHRqcy5vcmcvbGVhcm4/dXRtX3NvdXJjZT1jcmVhdGUtbmV4dC1hcHAmdXRtX21lZGl1bT1hcHBkaXItdGVtcGxhdGUtdHcmdXRtX2NhbXBhaWduPWNyZWF0ZS1uZXh0LWFwcCIsImNsYXNzTmFtZSI6Imdyb3VwIHJvdW5kZWQtbGcgYm9yZGVyIGJvcmRlci10cmFuc3BhcmVudCBweC01IHB5LTQgdHJhbnNpdGlvbi1jb2xvcnMgaG92ZXI6Ym9yZGVyLWdyYXktMzAwIGhvdmVyOmJnLWdyYXktMTAwIGhvdmVyOmRhcms6Ym9yZGVyLW5ldXRyYWwtNzAwIGhvdmVyOmRhcms6YmctbmV1dHJhbC04MDAvMzAiLCJ0YXJnZXQiOiJfYmxhbmsiLCJyZWwiOiJub29wZW5lciBub3JlZmVycmVyIiwiY2hpbGRyZW4iOltbIiQiLCJoMiIsbnVsbCx7ImNsYXNzTmFtZSI6Im1iLTMgdGV4dC0yeGwgZm9udC1zZW1pYm9sZCIsImNoaWxkcmVuIjpbIkxlYXJuIiwiICIsWyIkIiwic3BhbiIsbnVsbCx7ImNsYXNzTmFtZSI6ImlubGluZS1ibG9jayB0cmFuc2l0aW9uLXRyYW5zZm9ybSBncm91cC1ob3Zlcjp0cmFuc2xhdGUteC0xIG1vdGlvbi1yZWR1Y2U6dHJhbnNmb3JtLW5vbmUiLCJjaGlsZHJlbiI6Ii0+In1dXX1dLFsiJCIsInAiLG51bGwseyJjbGFzc05hbWUiOiJtLTAgbWF4LXctWzMwY2hdIHRleHQtc20gb3BhY2l0eS01MCIsImNoaWxkcmVuIjoiTGVhcm4gYWJvdXQgTmV4dC5qcyBpbiBhbiBpbnRlcmFjdGl2ZSBjb3Vyc2Ugd2l0aMKgcXVpenplcyEifV1dfV0sWyIkIiwiYSIsbnVsbCx7ImhyZWYiOiJodHRwczovL3ZlcmNlbC5jb20vdGVtcGxhdGVzP2ZyYW1ld29yaz1uZXh0LmpzJnV0bV9zb3VyY2U9Y3JlYXRlLW5leHQtYXBwJnV0bV9tZWRpdW09YXBwZGlyLXRlbXBsYXRlJnV0bV9jYW1wYWlnbj1jcmVhdGUtbmV4dC1hcHAiLCJjbGFzc05hbWUiOiJncm91cCByb3VuZGVkLWxnIGJvcmRlciBib3JkZXItdHJhbnNwYXJlbnQgcHgtNSBweS00IHRyYW5zaXRpb24tY29sb3JzIGhvdmVyOmJvcmRlci1ncmF5LTMwMCBob3ZlcjpiZy1ncmF5LTEwMCBob3ZlcjpkYXJrOmJvcmRlci1uZXV0cmFsLTcwMCBob3ZlcjpkYXJrOmJnLW5ldXRyYWwtODAwLzMwIiwidGFyZ2V0IjoiX2JsYW5rIiwicmVsIjoibm9vcGVuZXIgbm9yZWZlcnJlciIsImNoaWxkcmVuIjpbWyIkIiwiaDIiLG51bGwseyJjbGFzc05hbWUiOiJtYi0zIHRleHQtMnhsIGZvbnQtc2VtaWJvbGQiLCJjaGlsZHJlbiI6WyJUZW1wbGF0ZXMiLCIgIixbIiQiLCJzcGFuIixudWxsLHsiY2xhc3NOYW1lIjoiaW5saW5lLWJsb2NrIHRyYW5zaXRpb24tdHJhbnNmb3JtIGdyb3VwLWhvdmVyOnRyYW5zbGF0ZS14LTEgbW90aW9uLXJlZHVjZTp0cmFuc2Zvcm0tbm9uZSIsImNoaWxkcmVuIjoiLT4ifV1dfV0sWyIkIiwicCIsbnVsbCx7ImNsYXNzTmFtZSI6Im0tMCBtYXgtdy1bMzBjaF0gdGV4dC1zbSBvcGFjaXR5LTUwIiwiY2hpbGRyZW4iOiJFeHBsb3JlIHRoZSBOZXh0LmpzIDEzIHBsYXlncm91bmQuIn1dXX1dLFsiJCIsImEiLG51bGwseyJocmVmIjoiaHR0cHM6Ly92ZXJjZWwuY29tL25ldz91dG1fc291cmNlPWNyZWF0ZS1uZXh0LWFwcCZ1dG1fbWVkaXVtPWFwcGRpci10ZW1wbGF0ZSZ1dG1fY2FtcGFpZ249Y3JlYXRlLW5leHQtYXBwIiwiY2xhc3NOYW1lIjoiZ3JvdXAgcm91bmRlZC1sZyBib3JkZXIgYm9yZGVyLXRyYW5zcGFyZW50IHB4LTUgcHktNCB0cmFuc2l0aW9uLWNvbG9ycyBob3Zlcjpib3JkZXItZ3JheS0zMDAgaG92ZXI6YmctZ3JheS0xMDAgaG92ZXI6ZGFyazpib3JkZXItbmV1dHJhbC03MDAgaG92ZXI6ZGFyazpiZy1uZXV0cmFsLTgwMC8zMCIsInRhcmdldCI6Il9ibGFuayIsInJlbCI6Im5vb3BlbmVyIG5vcmVmZXJyZXIiLCJjaGlsZHJlbiI6W1siJCIsImgyIixudWxsLHsiY2xhc3NOYW1lIjoibWItMyB0ZXh0LTJ4bCBmb250LXNlbWlib2xkIiwiY2hpbGRyZW4iOlsiRGVwbG95IiwiICIsWyIkIiwic3BhbiIsbnVsbCx7ImNsYXNzTmFtZSI6ImlubGluZS1ibG9jayB0cmFuc2l0aW9uLXRyYW5zZm9ybSBncm91cC1ob3Zlcjp0cmFuc2xhdGUteC0xIG1vdGlvbi1yZWR1Y2U6dHJhbnNmb3JtLW5vbmUiLCJjaGlsZHJlbiI6Ii0+In1dXX1dLFsiJCIsInAiLG51bGwseyJjbGFzc05hbWUiOiJtLTAgbWF4LXctWzMwY2hdIHRleHQtc20gb3BhY2l0eS01MCIsImNoaWxkcmVuIjoiSW5zdGFudGx5IGRlcGxveSB5b3VyIE5leHQuanMgc2l0ZSB0byBhIHNoYXJlYWJsZSBVUkwgd2l0aCBWZXJjZWwuIn1dXX1dXX1dXX1dLG51bGxdLCJzZWdtZW50IjoiX19QQUdFX18ifSwic3R5bGVzIjpbXX1dfV19XSxudWxsXQo0OltbIiQiLCJtZXRhIiwiMCIseyJjaGFyU2V0IjoidXRmLTgifV0sWyIkIiwidGl0bGUiLCIxIix7ImNoaWxkcmVuIjoiQ3JlYXRlIE5leHQgQXBwIn1dLFsiJCIsIm1ldGEiLCIyIix7Im5hbWUiOiJkZXNjcmlwdGlvbiIsImNvbnRlbnQiOiJHZW5lcmF0ZWQgYnkgY3JlYXRlIG5leHQgYXBwIn1dLFsiJCIsIm1ldGEiLCIzIix7Im5hbWUiOiJ2aWV3cG9ydCIsImNvbnRlbnQiOiJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MSJ9XSxbIiQiLCJsaW5rIiwiNCIseyJyZWwiOiJpY29uIiwiaHJlZiI6Ii9mYXZpY29uLmljbyIsInR5cGUiOiJpbWFnZS94LWljb24iLCJzaXplcyI6ImFueSJ9XSxbIiQiLCJtZXRhIiwiNSIseyJuYW1lIjoibmV4dC1zaXplLWFkanVzdCJ9XV0K\")\nassets.set(\"/next.svg\", \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAzOTQgODAiPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik0yNjIgMGg2OC41djEyLjdoLTI3LjJ2NjYuNmgtMTMuNlYxMi43SDI2MlYwWk0xNDkgMHYxMi43SDk0djIwLjRoNDQuM3YxMi42SDk0djIxaDU1djEyLjZIODAuNVYwaDY4Ljd6bTM0LjMgMGgtMTcuOGw2My44IDc5LjRoMTcuOWwtMzItMzkuNyAzMi0zOS42aC0xNy45bC0yMyAyOC42LTIzLTI4LjZ6bTE4LjMgNTYuNy05LTExLTI3LjEgMzMuN2gxNy44bDE4LjMtMjIuN3oiLz48cGF0aCBmaWxsPSIjMDAwIiBkPSJNODEgNzkuMyAxNyAwSDB2NzkuM2gxMy42VjE3bDUwLjIgNjIuM0g4MVptMjUyLjYtLjRjLTEgMC0xLjgtLjQtMi41LTFzLTEuMS0xLjYtMS4xLTIuNi4zLTEuOCAxLTIuNSAxLjYtMSAyLjYtMSAxLjguMyAyLjUgMWEzLjQgMy40IDAgMCAxIC42IDQuMyAzLjcgMy43IDAgMCAxLTMgMS44em0yMy4yLTMzLjVoNnYyMy4zYzAgMi4xLS40IDQtMS4zIDUuNWE5LjEgOS4xIDAgMCAxLTMuOCAzLjVjLTEuNi44LTMuNSAxLjMtNS43IDEuMy0yIDAtMy43LS40LTUuMy0xcy0yLjgtMS44LTMuNy0zLjJjLS45LTEuMy0xLjQtMy0xLjQtNWg2Yy4xLjguMyAxLjYuNyAyLjJzMSAxLjIgMS42IDEuNWMuNy40IDEuNS41IDIuNC41IDEgMCAxLjgtLjIgMi40LS42YTQgNCAwIDAgMCAxLjYtMS44Yy4zLS44LjUtMS44LjUtM1Y0NS41em0zMC45IDkuMWE0LjQgNC40IDAgMCAwLTItMy4zIDcuNSA3LjUgMCAwIDAtNC4zLTEuMWMtMS4zIDAtMi40LjItMy4zLjUtLjkuNC0xLjYgMS0yIDEuNmEzLjUgMy41IDAgMCAwLS4zIDRjLjMuNS43LjkgMS4zIDEuMmwxLjggMSAyIC41IDMuMi44YzEuMy4zIDIuNS43IDMuNyAxLjJhMTMgMTMgMCAwIDEgMy4yIDEuOCA4LjEgOC4xIDAgMCAxIDMgNi41YzAgMi0uNSAzLjctMS41IDUuMWExMCAxMCAwIDAgMS00LjQgMy41Yy0xLjguOC00LjEgMS4yLTYuOCAxLjItMi42IDAtNC45LS40LTYuOC0xLjItMi0uOC0zLjQtMi00LjUtMy41YTEwIDEwIDAgMCAxLTEuNy01LjZoNmE1IDUgMCAwIDAgMy41IDQuNmMxIC40IDIuMi42IDMuNC42IDEuMyAwIDIuNS0uMiAzLjUtLjYgMS0uNCAxLjgtMSAyLjQtMS43YTQgNCAwIDAgMCAuOC0yLjRjMC0uOS0uMi0xLjYtLjctMi4yYTExIDExIDAgMCAwLTIuMS0xLjRsLTMuMi0xLTMuOC0xYy0yLjgtLjctNS0xLjctNi42LTMuMmE3LjIgNy4yIDAgMCAxLTIuNC01LjcgOCA4IDAgMCAxIDEuNy01IDEwIDEwIDAgMCAxIDQuMy0zLjVjMi0uOCA0LTEuMiA2LjQtMS4yIDIuMyAwIDQuNC40IDYuMiAxLjIgMS44LjggMy4yIDIgNC4zIDMuNCAxIDEuNCAxLjUgMyAxLjUgNWgtNS44eiIvPjwvc3ZnPg==\")\nassets.set(\"/vercel.svg\", \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyODMgNjQiPjxwYXRoIGZpbGw9ImJsYWNrIiBkPSJNMTQxIDE2Yy0xMSAwLTE5IDctMTkgMThzOSAxOCAyMCAxOGM3IDAgMTMtMyAxNi03bC03LTVjLTIgMy02IDQtOSA0LTUgMC05LTMtMTAtN2gyOHYtM2MwLTExLTgtMTgtMTktMTh6bS05IDE1YzEtNCA0LTcgOS03czggMyA5IDdoLTE4em0xMTctMTVjLTExIDAtMTkgNy0xOSAxOHM5IDE4IDIwIDE4YzYgMCAxMi0zIDE2LTdsLTgtNWMtMiAzLTUgNC04IDQtNSAwLTktMy0xMS03aDI4bDEtM2MwLTExLTgtMTgtMTktMTh6bS0xMCAxNWMyLTQgNS03IDEwLTdzOCAzIDkgN2gtMTl6bS0zOSAzYzAgNiA0IDEwIDEwIDEwIDQgMCA3LTIgOS01bDggNWMtMyA1LTkgOC0xNyA4LTExIDAtMTktNy0xOS0xOHM4LTE4IDE5LTE4YzggMCAxNCAzIDE3IDhsLTggNWMtMi0zLTUtNS05LTUtNiAwLTEwIDQtMTAgMTB6bTgzLTI5djQ2aC05VjVoOXpNMzcgMGwzNyA2NEgwTDM3IDB6bTkyIDUtMjcgNDhMNzQgNWgxMGwxOCAzMCAxNy0zMGgxMHptNTkgMTJ2MTBsLTMtMWMtNiAwLTEwIDQtMTAgMTB2MTVoLTlWMTdoOXY5YzAtNSA2LTkgMTMtOXoiLz48L3N2Zz4=\")\n\n\n  /**\n   * HTTP Component serving static html text\n   * \n   */\n  http.HttpComponent.serve((req: http.Request) => {\n    let response: string = '404 not found.'\n    let status: u32 = 404\n    let contentType: string = 'text/html'\n\n    let url = req.url\n    let urlWithoutSlash = url.endsWith('/') ? url.slice(0, -1) : url\n\n    // Serve the index file for the homepage\n    if (url === '/' && assets.has('/index.html')) {\n      url = '/index.html'\n    }\n\n    // Serve nested index.html for any folder route\n    // Serve matching html for a non html route \n    if (!assets.has(urlWithoutSlash) && assets.has(urlWithoutSlash + '/index.html')) {\n      url = urlWithoutSlash + '/index.html'\n    } else if (!assets.has(urlWithoutSlash) && assets.has(urlWithoutSlash + '.html')) {\n      url = urlWithoutSlash + '.html'\n    }\n    \n    // Match assets and serve data\n    if (assets.has(url)) {\n      // Parse content type and format\n      const content = assets.get(url)\n\n      if (content.startsWith('data:')) {\n        const matchString = content.replace('data:', '')\n        const matchTypeSplit = matchString.split(';')\n        \n        contentType = matchTypeSplit[0]\n      }\n\n      response = assets.get(url)\n      status = 200\n    } else if (assets.has('/404.html')) {\n      response = assets.get('/404.html')\n    }\n\n    return new http.Response(response)\n      .header('Content-Type', contentType)\n      .status(status)\n  })\n  ","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\nimport { idof, isArray as builtin_isArray } from \"./builtins\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_EMPTYARRAY, E_HOLEYARRAY } from \"./util/error\";\n\n// @ts-ignore: decorator\n@inline @lazy const MIN_SIZE: usize = 8;\n\n/** Ensures that the given array has _at least_ the specified backing size. */\nfunction ensureCapacity(array: usize, newSize: usize, alignLog2: u32, canGrow: bool = true): void {\n  // Depends on the fact that Arrays mimic ArrayBufferView\n  let oldCapacity = <usize>changetype<ArrayBufferView>(array).byteLength;\n  if (newSize > oldCapacity >>> alignLog2) {\n    if (newSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);\n    // Grows old capacity by factor of two.\n    // Make sure we don't reach BLOCK_MAXSIZE for new growed capacity.\n    let newCapacity = max(newSize, MIN_SIZE) << alignLog2;\n    if (canGrow) newCapacity = max(min(oldCapacity << 1, BLOCK_MAXSIZE), newCapacity);\n    let newData = __renew(oldData, newCapacity);\n    // __new / __renew already init memory range as zeros in Incremental runtime.\n    // So try to avoid this.\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\n    }\n    if (newData != oldData) { // oldData has been free'd\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"buffer\"));\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"dataStart\"));\n      __link(array, changetype<usize>(newData), false);\n    }\n    store<u32>(array, <u32>newCapacity, offsetof<ArrayBufferView>(\"byteLength\"));\n  }\n}\n\nexport class Array<T> {\n  [key: number]: T;\n\n  // Mimicking ArrayBufferView isn't strictly necessary here but is done to allow glue code\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\n  // `dataStart` (equals `buffer`) and `byteLength` (equals computed `buffer.byteLength`), but the\n  // block is 16 bytes anyway so it's fine to have a couple extra fields in there.\n\n  private buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  private byteLength: i32; // Uses here as capacity\n\n  // Also note that Array<T> with non-nullable T must guard against uninitialized null values\n  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee\n  // type-safety anymore. For lack of a better word, such an array is \"holey\".\n\n  private length_: i32;\n\n  static isArray<U>(value: U): bool {\n    return isReference<U>() ? changetype<usize>(value) != 0 && builtin_isArray(value) : false;\n  }\n\n  static create<T>(capacity: i32 = 0): Array<T> {\n    WARNING(\"'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.\");\n    let array = new Array<T>(capacity);\n    array.length = 0;\n    return array;\n  }\n\n  constructor(length: i32 = 0) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    // reserve capacity for at least MIN_SIZE elements\n    let bufferSize = max(<usize>length, MIN_SIZE) << alignof<T>();\n    let buffer = changetype<ArrayBuffer>(__new(bufferSize, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, bufferSize);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = <i32>bufferSize;\n    this.length_ = length;\n  }\n\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(newLength: i32) {\n    ensureCapacity(changetype<usize>(this), newLength, alignof<T>(), false);\n    this.length_ = newLength;\n  }\n\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (!fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length_) {\n      if (index < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n      ensureCapacity(changetype<usize>(this), index + 1, alignof<T>());\n      this.length_ = index + 1;\n    }\n    store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  at(index: i32): T {\n    let len = this.length_;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    if (isManaged<T>()) {\n      FILL<usize>(this.dataStart, this.length_, changetype<usize>(value), start, end);\n      __link(changetype<usize>(this), changetype<usize>(value), false);\n    } else {\n      FILL<T>(this.dataStart, this.length_, value, start, end);\n    }\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let len = this.length_;\n      if (len == 0 || fromIndex >= len) return false;\n      if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n      let ptr = this.dataStart;\n      while (fromIndex < len) {\n        let elem = load<T>(ptr + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    let len = this.length_;\n    if (len == 0 || fromIndex >= len) return -1;\n    if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n    let ptr = this.dataStart;\n    while (fromIndex < len) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\n    let len = this.length_;\n    if (len == 0) return -1;\n    if (fromIndex < 0) fromIndex = len + fromIndex;\n    else if (fromIndex >= len) fromIndex = len - 1;\n    let ptr = this.dataStart;\n    while (fromIndex >= 0) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(value: T): i32 {\n    let oldLen = this.length_;\n    let len = oldLen + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    if (isManaged<T>()) {\n      store<usize>(this.dataStart + (<usize>oldLen << alignof<T>()), changetype<usize>(value));\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    } else {\n      store<T>(this.dataStart + (<usize>oldLen << alignof<T>()), value);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    let thisLen = this.length_;\n    let otherLen = other.length_;\n    let outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    let out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n    let outStart = out.dataStart;\n    let thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = this.dataStart;\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, this.dataStart, thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Array<T> {\n    let ptr = this.dataStart;\n    let len = this.length_;\n\n    end = min<i32>(end, len);\n\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\n    let count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  pop(): T {\n    let len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    let val = load<T>(this.dataStart + (<usize>(--len) << alignof<T>()));\n    this.length_ = len;\n    return val;\n  }\n\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    let len = this.length_;\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    let outStart = out.dataStart;\n    for (let i = 0; i < min(len, this.length_); ++i) {\n      let result = fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      let value = load<T>(this.dataStart + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  shift(): T {\n    let len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    let base = this.dataStart;\n    let element = load<T>(base);\n    let lastIndex = len - 1;\n    memory.copy(\n      base,\n      base + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    if (isReference<T>()) {\n      store<usize>(base + (<usize>lastIndex << alignof<T>()), 0);\n    } else {\n      // @ts-ignore\n      store<T>(base + (<usize>lastIndex << alignof<T>()), <T>0);\n    }\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(value: T): i32 {\n    let len = this.length_ + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    let ptr = this.dataStart;\n    memory.copy(\n      ptr + sizeof<T>(),\n      ptr,\n      <usize>(len - 1) << alignof<T>()\n    );\n    store<T>(ptr, value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    let len = this.length_;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end  , len);\n    len = max(end - start, 0);\n    let slice = changetype<Array<T>>(__newArray(len, alignof<T>(), idof<Array<T>>()));\n    let sliceBase = slice.dataStart;\n    let thisBase = this.dataStart + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>len << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, len << alignof<T>());\n    }\n    return slice;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    let len = this.length_;\n    start       = start < 0 ? max<i32>(len + start, 0) : min<i32>(start, len);\n    deleteCount = max<i32>(min<i32>(deleteCount, len - start), 0);\n    let result  = changetype<Array<T>>(__newArray(deleteCount, alignof<T>(), idof<Array<T>>()));\n    let resultStart = result.dataStart;\n    let thisStart = this.dataStart;\n    let thisBase  = thisStart + (<usize>start << alignof<T>());\n    memory.copy(\n      resultStart,\n      thisBase,\n      <usize>deleteCount << alignof<T>()\n    );\n    let offset = start + deleteCount;\n    if (len != offset) {\n      memory.copy(\n        thisBase,\n        thisStart + (<usize>offset << alignof<T>()),\n        <usize>(len - offset) << alignof<T>()\n      );\n    }\n    this.length_ = len - deleteCount;\n    return result;\n  }\n\n  reverse(): Array<T> {\n    REVERSE<T>(this.dataStart, this.length_);\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): Array<T> {\n    SORT<T>(this.dataStart, this.length_, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    let ptr = this.dataStart;\n    let len = this.length_;\n    if (isBoolean<T>())   return joinBooleanArray(ptr, len, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(ptr, len, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(ptr, len, separator);\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(ptr, len, separator);\n    }\n    // For rest objects and arrays use general join routine\n    if (isReference<T>()) return joinReferenceArray<T>(ptr, len, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  flat(): T {\n    if (!isArray<T>()) {\n      ERROR(\"Cannot call flat() on Array<T> where T is not an Array.\");\n    }\n    // Get the length and data start values\n    let ptr = this.dataStart;\n    let len = this.length_;\n\n    // calculate the end size with an initial pass\n    let size = 0;\n    for (let i = 0; i < len; ++i) {\n      let child = load<usize>(ptr + (i << alignof<T>()));\n      size += child == 0 ? 0 : load<i32>(child, offsetof<T>(\"length_\"));\n    }\n\n    // calculate the byteLength of the resulting backing ArrayBuffer\n    const align = alignof<valueof<T>>();\n    let byteLength = <usize>size << align;\n    let outBuffer = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n\n    // create the return value and initialize it\n    let outArray = changetype<T>(__new(offsetof<T>(), idof<T>()));\n    store<i32>(changetype<usize>(outArray), size, offsetof<T>(\"length_\"));\n\n    // byteLength, dataStart, and buffer are all readonly\n    store<i32>(changetype<usize>(outArray), byteLength, offsetof<T>(\"byteLength\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"dataStart\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"buffer\"));\n    __link(changetype<usize>(outArray), changetype<usize>(outBuffer), false);\n\n    // set the elements\n    let resultOffset: usize = 0;\n    for (let i = 0; i < len; ++i) { // for each child\n      let child = load<usize>(ptr + (<usize>i << alignof<T>()));\n\n      // ignore null arrays\n      if (!child) continue;\n\n      // copy the underlying buffer data to the result buffer\n      let childDataLength = <usize>load<i32>(child, offsetof<T>(\"length_\")) << align;\n      memory.copy(\n        changetype<usize>(outBuffer) + resultOffset,\n        load<usize>(child, offsetof<T>(\"dataStart\")),\n        childDataLength\n      );\n\n      // advance the result length\n      resultOffset += childDataLength;\n    }\n\n    // if the `valueof<T>` type is managed, we must link each reference\n    if (isManaged<valueof<T>>()) {\n      for (let i = 0; i < size; ++i) {\n        let ref = load<usize>(changetype<usize>(outBuffer) + (<usize>i << usize(alignof<valueof<T>>())));\n        __link(changetype<usize>(outBuffer), ref, true);\n      }\n    }\n\n    return outArray;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = this.dataStart;\n      let end = cur + (<usize>this.length_ << alignof<T>());\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n    __visit(changetype<usize>(this.buffer), cookie);\n  }\n}\n","import { strtol, strtod, strtob } from \"./util/string\";\n\ntype auto = i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isBoolean<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isInteger<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isSigned<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFloat<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVector<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isReference<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isString<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArray<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArrayLike<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFunction<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNullable<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isDefined(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isConstant(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isManaged<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVoid<T>(): bool;\n\n// @ts-ignore\n@builtin\nexport declare function lengthof<T>(func?: T): i32;\n\n// @ts-ignore\n@builtin\nexport declare function bswap<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function clz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ctz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function popcnt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotl<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotr<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function abs<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function max<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function min<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ceil<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function floor<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function copysign<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function nearest<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function reinterpret<T>(value: number): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sqrt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function trunc<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function add<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sub<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function mul<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function div<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function eq<T>(left: T, right: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ne<T>(left: T, right: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rem<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function store<T>(ptr: usize, value: auto, immOffset?: usize, immAlign?: usize): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sizeof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function alignof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function idof<T>(): u32;\n\n// @ts-ignore\n@builtin\nexport declare function nameof<T>(): string;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unreachable(): auto;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function changetype<T>(value: auto): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function assert<T>(isTrueish: T, message?: string): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unchecked<T>(expr: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function call_indirect<T>(index: u32, ...args: auto[]): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function instantiate<T>(...args: auto[]): T;\n\nexport namespace atomic {\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load<T>(ptr: usize, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store<T>(ptr: usize, value: T, immOffset?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function notify(ptr: usize, count: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function fence(): void;\n}\n\n// @ts-ignore: decorator\n@lazy\nexport const enum AtomicWaitResult {\n  OK = 0,\n  NOT_EQUAL = 1,\n  TIMED_OUT = 2\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8(value: auto): i8;\n\nexport namespace i8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i8 = -128;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i8 =  127;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16(value: auto): i16;\n\nexport namespace i16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i16 = -32768;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i16 =  32767;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32(value: auto): i32;\n\nexport namespace i32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i32 = -2147483648;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i32 =  2147483647;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i32 {\n    return strtol<i32>(value, radix);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_s(left: i32, right: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_u(left: u32, right: u32): u32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f32(value: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64(value: auto): i64;\n\nexport namespace i64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i64 = -9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i64 =  9223372036854775807;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: i64, right:i64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: i64, right:i64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_s(left: i64, right: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_u(left: u64, right: u64): u64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f64(value: f64): i64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load32_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store32(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw32 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isize(value: auto): isize;\n\nexport namespace isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u8(value: auto): u8;\n\nexport namespace u8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u8 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u8 = 255;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u16(value: auto): u16;\n\nexport namespace u16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u16 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u16 = 65535;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u32(value: auto): u32;\n\nexport namespace u32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u32 = 4294967295;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u64(value: auto): u64;\n\nexport namespace u64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u64 = 18446744073709551615;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function usize(value: auto): usize;\n\nexport namespace usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: usize = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function bool(value: auto): bool;\n\nexport namespace bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: bool = false;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: bool = true;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): bool {\n    return strtob(value);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32(value: auto): f32;\n\nexport namespace f32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f32 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f32 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f32 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): f32 {\n    return <f32>strtod(value);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f32, y: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i32(value: i32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: f32, right: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: f32, right: f32): i32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64(value: auto): f64;\n\nexport namespace f64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f64 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f64 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f64 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): f64 {\n    return strtod(value);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f64, y: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i64(value: i64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: f64, right: f64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: f64, right: f64): i32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function v128(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace v128 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat<T>(x: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane<T>(x: v128, idx: u8): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_zero<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load8_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load16_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function andnot(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function not(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask<T>(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot<T>(a: v128, b: v128): v128; // i16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr<T>(a: v128, b: v128): v128; // u8, u16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_zero<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function demote_zero<T = f64>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function promote_low<T = f32>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function q15mulr_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high<T>(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8x16(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace i8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8,\n    l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\n\nexport namespace i16x8 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function q15mulr_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i8x16_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i8x16_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i8x16_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i8x16_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\n\nexport namespace i32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_s_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_u_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64x2(a: i64, b: i64): v128;\n\nexport namespace i64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\n\nexport namespace f32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function demote_f64x2_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64x2(a: f64, b: f64): v128;\n\nexport namespace f64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function promote_low_f32x4(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n}\n\n@final\nexport abstract class i31 { // FIXME: usage of 'new' requires a class :(\n\n  // @ts-ignore: decorator\n  @builtin\n  static new(value: i32): i31ref { return changetype<i31ref>(unreachable()); }\n\n  // @ts-ignore: decorator\n  @builtin\n  static get(i31expr: i31ref): i32 { return unreachable(); }\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n// @ts-ignore: decorator\n@external(\"env\", \"abort\")\n@external.js(\"throw Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);\")\ndeclare function abort(\n  message?: string | null,\n  fileName?: string | null,\n  lineNumber?: u32,\n  columnNumber?: u32\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"trace\")\n@external.js(\"console.log(message, ...[a0, a1, a2, a3, a4].slice(0, n));\")\ndeclare function trace(\n  message: string,\n  n?: i32,\n  a0?: f64,\n  a1?: f64,\n  a2?: f64,\n  a3?: f64,\n  a4?: f64\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"seed\")\n@external.js(\"return Date.now() * Math.random();\")\ndeclare function seed(): f64;\n\n/* eslint-enable @typescript-eslint/no-unused-vars */\n","import { JSON } from \"../json\";\nimport { HttpHandle, HttpOptions, HttpOpen } from \"./handler\";\nimport { HttpStdin } from \"./stdin\"\n\nclass ClientOptions {\n    public baseUrl: string\n    public headers: Map<string, string>\n\n    constructor(baseUrl: string, headers: Map<string, string>) {\n        this.baseUrl = baseUrl\n        this.headers = headers\n    }\n\n    public getHeaders(): string {\n        const obj = new JSON.Obj\n        const keys = this.headers.keys()\n\n        for (let i = 0; i < this.headers.size; i++) {\n            obj.set(keys[i], this.headers.get(keys[i]))\n        }\n\n        return obj.toString()\n    }\n}\n\nclass Client {\n    options: ClientOptions\n\n    constructor(options: ClientOptions = new ClientOptions('', new Map())) {\n        this.options = options\n    }\n\n    private formatUrl(url: string): string {\n        return this.options.baseUrl ? this.options.baseUrl + url : url\n    }\n\n    get(url: string): JSON.Obj {\n        const options = new HttpOptions('GET')\n        options.headers = this.options.getHeaders()\n\n        return Client.request(this.formatUrl(url), options)\n    }\n\n    post(url: string, body: string): JSON.Obj {\n        const options = new HttpOptions(\"POST\")\n        options.headers = this.options.getHeaders()\n\n        if (body) options.body = body\n\n        return Client.request(this.formatUrl(url), options)\n    }\n\n    static request(url: string, options: HttpOptions): JSON.Obj {\n        let body: string | null = null\n        let response: JSON.Obj = <JSON.Obj>JSON.parse('{}')\n        const handle: HttpHandle | null = HttpOpen(url, options)\n\n        if (handle != null) {\n            body = handle.getAllBody()!\n            handle.close()\n\n            // TODO: Parse non JSON content types as well\n            if (body) {\n                response = <JSON.Obj>JSON.parse(body)\n            }\n        }\n\n        return response\n    }\n}\n\nclass Request {\n    public url: string\n    public method: string\n    public headers: Map<string, string>\n    public query: Map<string, string>\n    public body: string | null\n\n    constructor(\n        method: string,\n        url: string,\n        query: Map<string, string>,\n        headers: Map<string, string>,\n        body: string\n    ) {\n        this.method = method\n        this.url = url\n        this.query = query\n        this.headers = headers\n        this.body = !!body ? body : null\n    }\n}\n\nclass Response {\n    public code: u32 = 200;\n    public headers: Map<string, string>\n    public body: string = '';\n\n    constructor(body: string = \"\") {\n        this.body = body;\n        this.headers = new Map();\n    }\n\n    status(code: u32): Response {\n        this.code = code\n\n        return this\n    }\n\n    header(key: string, value: string): Response {\n        this.headers.set(key, value)\n\n        return this\n    }\n\n    getHeaders(): string {\n        const obj = new JSON.Obj\n        const keys = this.headers.keys()\n\n        for (let i = 0; i < this.headers.size; i++) {\n            obj.set(keys[i], this.headers.get(keys[i]))\n        }\n\n        return obj.toString()\n    }\n\n    toJSON(): JSON.Obj {\n        const obj = new JSON.Obj\n        obj.set('code', this.code.toString())\n        obj.set('body', this.body)\n        obj.set('headers', this.getHeaders())\n\n        return obj\n    }\n\n    toString(): string {\n        let content = ''\n\n        content = this.body\n\n        return content\n    }\n}\n\nclass HttpComponent {\n    static serve(handler: (request: Request) => Response): void {\n        HttpStdin.initalize()\n\n        // Build request\n        const request = new Request(\n            HttpStdin.method,\n            HttpStdin.path,\n            HttpStdin.query,\n            HttpStdin.headers,\n            HttpStdin.body\n        )\n\n        // Call handler, generate response\n        const response = handler(request)\n\n        // Encode body into buffer\n        if (response && response.body) {\n            process.stdout.write(response.toString())\n        }\n    }\n\n    static getRequest(): Request {\n        HttpStdin.initalize()\n\n        // Build request\n        return new Request(\n            HttpStdin.method,\n            HttpStdin.path,\n            HttpStdin.query,\n            HttpStdin.headers,\n            HttpStdin.body\n        )\n    }\n\n    static send(response: Response): void {\n        // Encode body into buffer\n        if (response && response.body) {\n            process.stdout.write(response.toString())\n        }\n    }\n}\n\nexport {\n    HttpHandle,\n    HttpOptions,\n    HttpOpen,\n    Client,\n    ClientOptions,\n    HttpComponent,\n    Request,\n    Response\n}","import { Buffer } from \"./util\";\nimport { JSONDecoder, JSONHandler } from './decoder';\n\nclass Handler extends JSONHandler {\n  stack: Value[] = new Array<Value>();\n\n  reset(): void {\n    while (this.stack.length > 0) {\n      this.stack.pop();\n    }\n  }\n\n  get peek(): Value {\n    return this.stack[this.stack.length - 1];\n  }\n\n  setString(name: string, value: string): void {\n    const obj: Value = Value.String(value);\n    this.addValue(name, obj);\n  }\n\n  setBoolean(name: string, value: bool): void {\n    const obj = Value.Bool(value);\n    this.addValue(name, obj);\n  }\n\n  setNull(name: string): void {\n    const obj = Value.Null();\n    this.addValue(name, obj);\n  }\n\n  setInteger(name: string, value: i64): void {\n    const obj = Value.Integer(value);\n    this.addValue(name, obj);\n  }\n\n  setFloat(name: string, value: f64): void {\n    const obj = Value.Float(value);\n    this.addValue(name, obj);\n  }\n\n  pushArray(name: string): bool {\n    const obj: Value = Value.Array();\n    if (this.stack.length == 0) {\n      this.stack.push(obj);\n    } else {\n      this.addValue(name, obj);\n      this.stack.push(obj);\n    }\n    return true;\n  }\n\n  popArray(): void {\n    if (this.stack.length > 1) {\n      this.stack.pop();\n    }\n  }\n\n  pushObject(name: string): bool {\n    const obj: Value = Value.Object();\n    this.addValue(name, obj);\n    this.stack.push(obj);\n    return true;\n  }\n\n  popObject(): void {\n    if (this.stack.length > 1) {\n      this.stack.pop();\n    }\n  }\n\n  addValue(name: string, obj: Value): void {\n    if (name.length == 0 && this.stack.length == 0) {\n      this.stack.push(obj);\n      return;\n    }\n    if (this.peek instanceof Obj) {\n      (this.peek as Obj).set(name, obj);\n    } else if (this.peek instanceof Arr) {\n      (<Arr>this.peek).push(obj);\n    }\n  }\n}\n\nnamespace _JSON {\n  /** Parses a string or Uint8Array and returns a Json Value. */\n  export function parse<T = Uint8Array>(str: T): Value {\n    const handler: Handler = new Handler();\n    const decoder: JSONDecoder<Handler> = new JSONDecoder<Handler>(\n      handler\n    );\n\n    var arr: Uint8Array;\n    if (isString<T>(str)) {\n      arr = Buffer.fromString(<string>str);\n    } else {\n      arr = changetype<Uint8Array>(str);\n    }\n    decoder.deserialize(arr);\n    const res = decoder.handler.peek;\n    decoder.handler.reset();\n    return res;\n  }\n}\n\n// @ts-ignore\n@lazy const NULL: Null = new Null();\n\nexport abstract class Value {\n  static String(str: string): Str {\n    return new Str(str);\n  }\n  static Number(num: f64): Num {\n    return new Num(num);\n  }\n  static Float(num: f64): Float {\n    return new Float(num);\n  }\n  static Integer(num: i64): Integer {\n    return new Integer(num);\n  }\n  static Bool(b: bool): Bool {\n    return new Bool(b);\n  }\n  static Null(): Null {\n    return NULL;\n  }\n  static Array(): Arr {\n    return new Arr();\n  }\n  static Object(): Obj {\n    return new Obj();\n  }\n\n  get isString(): boolean {\n    return this instanceof Str;\n  }\n\n  get isNum(): boolean {\n    return this instanceof Num;\n  }\n\n  get isFloat(): boolean {\n    return this instanceof Float;\n  }\n\n  get isInteger(): boolean {\n    return this instanceof Integer;\n  }\n\n  get isBool(): boolean {\n    return this instanceof Bool;\n  }\n\n  get isNull(): boolean {\n    return this instanceof Null;\n  }\n\n  get isArr(): boolean {\n    return this instanceof Arr;\n  }\n\n  get isObj(): boolean {\n    return this instanceof Obj;\n  }\n\n  /**\n   * @returns A valid JSON string of the value\n   */\n  abstract stringify(): string;\n\n  /**\n   * \n   * @returns A AS string corresponding to the value. \n   */\n  toString(): string {\n    return this.stringify();\n  }\n}\n\nfunction escapeChar(char: string): string {\n  const charCode = char.charCodeAt(0);\n  switch (charCode) {\n    case 0x22: return '\\\\\"';\n    case 0x5C: return \"\\\\\\\\\";\n    case 0x08: return \"\\\\b\";\n    case 0x0A: return \"\\\\n\";\n    case 0x0D: return \"\\\\r\";\n    case 0x09: return \"\\\\t\";\n    case 0x0C: return \"\\\\f\";\n    case 0x0B: return \"\\\\u000b\";\n    default: return char;\n  }\n}\n\nexport class Str extends Value {\n\n  constructor(public _str: string) {\n    super();\n  }\n\n  stringify(): string {\n    let escaped: string[] = new Array(this._str.length);\n    for (let i = 0; i < this._str.length; i++) {\n      const char = this._str.at(i);\n      escaped[i] = escapeChar(char);\n    }\n    return `\"${escaped.join('')}\"`;\n  }\n\n  toString(): string {\n    return this._str;\n  }\n\n  valueOf(): string {\n    return this._str;\n  }\n}\n\nexport class Num extends Value {\n  constructor(public _num: f64) {\n    super();\n  }\n\n  stringify(): string {\n    return this._num.toString();\n  }\n\n  valueOf(): f64 {\n    return this._num;\n  }\n}\n\nexport class Float extends Num {\n}\n\nexport class Integer extends Value {\n  constructor(public _num: i64) {\n    super();\n  }\n\n  stringify(): string {\n    return this._num.toString();\n  }\n\n  valueOf(): i64 {\n    return this._num;\n  }\n}\n\nexport class Null extends Value {\n  constructor() {\n    super();\n  }\n\n  stringify(): string {\n    return \"null\";\n  }\n\n  valueOf(): null {\n    return null;\n  }\n}\n\nexport class Bool extends Value {\n  constructor(public _bool: bool) {\n    super();\n  }\n\n  stringify(): string {\n    return this._bool.toString();\n  }\n\n  valueOf(): bool {\n    return this._bool;\n  }\n}\n\nexport class Arr extends Value {\n    _arr: Array<Value>;\n    constructor() {\n      super();\n      this._arr = new Array<Value>();\n    }\n\n    push(obj: Value): void {\n      this._arr.push(obj);\n    }\n\n    stringify(): string {\n      return (\n        \"[\" +\n        this._arr\n          .map<string>((val: Value, i: i32, _arr: Value[]): string =>\n            val.stringify()\n          )\n          .join(\",\") +\n        \"]\"\n      );\n    }\n\n    valueOf(): Array<Value> {\n      return this._arr;\n    }\n}\n\nexport class Obj extends Value {\n    _obj: Map<string, Value>;\n\n    constructor() {\n      super();\n      this._obj = new Map();\n    }\n\n    get keys(): string[] {\n      return this._obj.keys();\n    }\n\n    stringify(): string {\n      const keys = this._obj.keys();\n      const objs: string[] = new Array<string>(keys.length);\n      for (let i: i32 = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this._obj.get(key);\n        // Currently must get the string value before interpolation \n        // see: https://github.com/AssemblyScript/assemblyscript/issues/1944\n        const valStr = value.stringify();\n        objs[i] = `\"${key}\":${valStr}`;\n      }\n\n      return `{${objs.join(\",\")}}`;\n    }\n\n    valueOf(): Map<string, Value> {\n      return this._obj;\n    }\n\n    set<T>(key: string, value: T): void {\n      if (isReference<T>(value)) {\n        if (value instanceof Value) {\n          this._obj.set(key, <Value>value);\n          return;\n        }\n      }\n      this._obj.set(key, from<T>(value));\n    }\n\n    has(key: string): bool {\n      return this._obj.has(key);\n    }\n\n    get(key: string): Value | null {\n      if (!this._obj.has(key)) {\n        return null;\n      }\n      return this._obj.get(key);\n    }\n\n    getValue(key: string): Value | null {\n      return this.get(key);\n    }\n\n    getString(key: string): Str | null {\n      let jsonValue = this.get(key);\n      if (jsonValue != null && jsonValue.isString) {\n        return <Str>jsonValue;\n      }\n      return null;\n    }\n\n    getNum(key: string): Num | null {\n      let jsonValue = this.get(key);\n      if (jsonValue != null && jsonValue.isNum) {\n        return <Num>jsonValue;\n      }\n      return null;\n    }\n\n    getFloat(key: string): Float | null {\n      let jsonValue = this.get(key);\n      if (jsonValue != null && jsonValue.isFloat) {\n        return <Float>jsonValue;\n      }\n      return null;\n    }\n\n    getInteger(key: string): Integer | null {\n      let jsonValue = this.get(key);\n      if (jsonValue != null && jsonValue.isInteger) {\n        return <Integer>jsonValue;\n      }\n      return null;\n    }\n\n    getBool(key: string): Bool | null {\n      let jsonValue = this.get(key);\n      if (jsonValue != null && jsonValue.isBool) {\n        return <Bool>jsonValue;\n      }\n      return null;\n    }\n\n    getArr(key: string): Arr | null {\n      let jsonValue = this.get(key);\n      if (jsonValue != null && jsonValue.isArr) {\n        return <Arr>jsonValue;\n      }\n      return null;\n    }\n\n    getObj(key: string): Obj | null {\n      let jsonValue = this.get(key);\n      if (jsonValue != null && jsonValue.isObj) {\n        return <Obj>jsonValue;\n      }\n      return null;\n    }\n}\n\nexport function from<T>(val: T): Value {\n  if (isBoolean<T>(val)) {\n    return Value.Bool(<bool>val);\n  }\n  if (isInteger<T>(val)) {\n    return Value.Integer(val);\n  }\n  if (isFloat<T>(val)) {\n    return Value.Float(val);\n  }\n  if (isString<T>(val)) {\n    return Value.String(<string>val);\n  }\n  if (val == null) {\n    return Value.Null();\n  }\n  if (isArrayLike<T>(val)) {\n    const arr = Value.Array();\n    for (let i: i32 = 0; i < val.length; i++) {\n      // @ts-ignore\n      arr.push(from<valueof<T>>(val[i]));\n    }\n    return arr;\n  }\n  /**\n     * TODO: add object support.\n     */\n  return Value.Object();\n}\n\n// @ts-ignore\n@inline\n/** Parses a string or Uint8Array and returns a Json Value. */\nexport function parse<T = Uint8Array>(str: T): Value {\n  return _JSON.parse(str);\n}\n","import { Buffer } from \"./util\";\n\n/**\n * Extend from this class to handle events from parser.\n * Default implementation traverses whole object tree and does nothing.\n */\nexport abstract class JSONHandler {\n  setString(name: string, value: string): void {}\n\n  setBoolean(name: string, value: bool): void {}\n\n  setNull(name: string): void {}\n\n  setInteger(name: string, value: i64): void {}\n\n  setFloat(name: string, value: f64): void {}\n\n  pushArray(name: string): bool {\n    return true;\n  }\n\n  popArray(): void {}\n\n  pushObject(name: string): bool {\n    return true;\n  }\n\n  popObject(): void {}\n}\n\n/**\n * Extend from this class to handle events from parser.\n * This implementation crashes on every unimplemented set/push method\n * to allow easier validation of input.\n */\nexport class ThrowingJSONHandler extends JSONHandler {\n  setString(name: string, value: string): void {\n    assert(false, \"Unexpected string field \" + name + ' : \"' + value + '\"');\n  }\n\n  setBoolean(name: string, value: bool): void {\n    assert(\n      false,\n      \"Unexpected bool field \" + name + \" : \" + (value ? \"true\" : \"false\")\n    );\n  }\n\n  setNull(name: string): void {\n    assert(false, \"Unexpected null field \" + name);\n  }\n\n  setInteger(name: string, value: i64): void {\n    // @ts-ignore integer does have toString\n    assert(\n      false,\n      \"Unexpected integer field \" + name + \" : \" + value.toString()\n    );\n  }\n\n  setFloat(name: string, value: f64): void {\n    // @ts-ignore integer does have toString\n    assert(\n      false,\n      \"Unexpected float field \" + name + \" : \" + value.toString()\n    );\n  }\n\n  pushArray(name: string): bool {\n    assert(false, \"Unexpected array field \" + name);\n    return true;\n  }\n\n  pushObject(name: string): bool {\n    assert(false, \"Unexpected object field \" + name);\n    return true;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy const TRUE_STR = \"true\";\n// @ts-ignore: decorator\n@lazy const FALSE_STR = \"false\";\n// @ts-ignore: decorator\n@lazy const NULL_STR = \"null\";\n// @ts-ignore: decorator\n@lazy const CHAR_0: i32 = 48; // \"0\".charCodeAt(0);\n// @ts-ignore: decorator\n@lazy const CHAR_9: i32 = 57; // \"9\".charCodeAt(0);\n// @ts-ignore: decorator\n@lazy const CHAR_A: i32 = 65; // \"A\".charCodeAt(0);\n// @ts-ignore: decorator\n@lazy const CHAR_A_LOWER: i32 = 97; // \"a\".charCodeAt(0);\n// @ts-ignore: decorator\n@lazy const CHAR_PERIOD: i32 = 46; // \".\".charCodeAt(0);\n// @ts-ignore: decorator\n@lazy const CHAR_MINUS: i32 = 45; // \"-\".charCodeAt(0);\n// @ts-ignore: decorator\n@lazy const CHAR_PLUS: i32 = 43; // \"+\".charCodeAt(0);\n// @ts-ignore: decorator\n@lazy const CHAR_E: i32 = 69; // \"E\".charCodeAt(0);\n// @ts-ignore: decorator\n@lazy const CHAR_E_LOWER: i32 = 101; // \"e\".charCodeAt(0);\n\nexport class DecoderState {\n  lastKey: string = \"\";\n  readIndex: i32 = 0;\n  constructor(public buffer: Uint8Array) {}\n\n  get ptr(): usize {\n    return Buffer.getDataPtr(this.buffer);\n  }\n\n  readString(start: usize, end: usize = this.readIndex): string {\n    return Buffer.readString(this.buffer, start, end - 1);\n  }\n}\n\nexport class JSONDecoder<JSONHandlerT extends JSONHandler> {\n  handler: JSONHandlerT;\n  _state: DecoderState | null = null;\n\n  constructor(handler: JSONHandlerT) {\n    this.handler = handler;\n  }\n\n  get state(): DecoderState {\n    return <DecoderState>this._state;\n  }\n\n  set state(state: DecoderState) {\n    this._state = state;\n  }\n\n  deserialize(\n    buffer: Uint8Array,\n    decoderState: DecoderState | null = null\n  ): void {\n    if (decoderState != null) {\n      this.state = decoderState;\n    } else {\n      this.state = new DecoderState(buffer);\n    }\n\n    assert(this.parseValue(), \"Cannot parse JSON\");\n    // TODO: Error if input left\n  }\n\n  private peekChar(): i32 {\n    if (this.state.readIndex >= this.state.buffer.length) {\n      return -1;\n    }\n    return this.state.buffer[this.state.readIndex];\n  }\n\n  private readChar(): i32 {\n    assert(\n      this.state.readIndex < this.state.buffer.length,\n      \"Unexpected input end\"\n    );\n    return this.state.buffer[this.state.readIndex++];\n  }\n\n  private parseValue(): bool {\n    this.skipWhitespace();\n    let result =\n      this.parseObject() ||\n      this.parseArray() ||\n      this.parseString() ||\n      this.parseBoolean() ||\n      this.parseNumber() ||\n      this.parseNull();\n    this.skipWhitespace();\n    return result;\n  }\n\n  private parseObject(): bool {\n    if (this.peekChar() != \"{\".charCodeAt(0)) {\n      return false;\n    }\n    let key = this.state.lastKey;\n    // @ts-ignore can be null\n    this.state.lastKey = \"\";\n    if (this.handler.pushObject(key)) {\n      this.readChar();\n      this.skipWhitespace();\n\n      let firstItem = true;\n      while (this.peekChar() != \"}\".charCodeAt(0)) {\n        if (!firstItem) {\n          assert(this.readChar() == \",\".charCodeAt(0), \"Expected ','\");\n        } else {\n          firstItem = false;\n        }\n        this.parseKey();\n        this.parseValue();\n      }\n      assert(this.readChar() == \"}\".charCodeAt(0), \"Unexpected end of object\");\n    }\n    this.handler.popObject();\n    return true;\n  }\n\n  private parseKey(): void {\n    this.skipWhitespace();\n    this.state.lastKey = this.readString();\n    this.skipWhitespace();\n    assert(this.readChar() == \":\".charCodeAt(0), \"Expected ':'\");\n  }\n\n  private parseArray(): bool {\n    if (this.peekChar() != \"[\".charCodeAt(0)) {\n      return false;\n    }\n    let key = this.state.lastKey;\n    // @ts-ignore can be null\n    this.state.lastKey = \"\";\n    if (this.handler.pushArray(key)) {\n      this.readChar();\n      this.skipWhitespace();\n\n      let firstItem = true;\n      while (this.peekChar() != \"]\".charCodeAt(0)) {\n        if (!firstItem) {\n          assert(this.readChar() == \",\".charCodeAt(0), \"Expected ','\");\n        } else {\n          firstItem = false;\n        }\n        this.parseValue();\n      }\n      assert(this.readChar() == \"]\".charCodeAt(0), \"Unexpected end of array\");\n    }\n    this.handler.popArray();\n    return true;\n  }\n\n  private parseString(): bool {\n    if (this.peekChar() != '\"'.charCodeAt(0)) {\n      return false;\n    }\n    this.handler.setString(this.state.lastKey, this.readString());\n    return true;\n  }\n\n  private readString(): string {\n    assert(\n      this.readChar() == '\"'.charCodeAt(0),\n      \"Expected double-quoted string\"\n    );\n    let savedIndex = this.state.readIndex;\n    // @ts-ignore can be null\n    let stringParts: Array<string> = new Array<string>();\n    for (;;) {\n      let byte = this.readChar();\n      assert(byte >= 0x20, \"Unexpected control character\");\n      if (byte == '\"'.charCodeAt(0)) {\n        let s = this.state.readString(savedIndex);\n        if (stringParts.length == 0) {\n          return s;\n        }\n        stringParts.push(s);\n        return stringParts.join(\"\");\n      } else if (byte == \"\\\\\".charCodeAt(0)) {\n        if (this.state.readIndex > savedIndex + 1) {\n          stringParts.push(this.state.readString(savedIndex));\n        }\n        stringParts.push(this.readEscapedChar());\n        savedIndex = this.state.readIndex;\n      }\n    }\n    // Should never happen\n    return \"\";\n  }\n\n  private readEscapedChar(): string {\n    let byte = this.readChar();\n    // TODO: Use lookup table for anything except \\u\n    if (byte == '\"'.charCodeAt(0)) {\n      return '\"';\n    }\n    if (byte == \"\\\\\".charCodeAt(0)) {\n      return \"\\\\\";\n    }\n    if (byte == \"/\".charCodeAt(0)) {\n      return \"/\";\n    }\n    if (byte == \"b\".charCodeAt(0)) {\n      return \"\\b\";\n    }\n    if (byte == \"n\".charCodeAt(0)) {\n      return \"\\n\";\n    }\n    if (byte == \"r\".charCodeAt(0)) {\n      return \"\\r\";\n    }\n    if (byte == \"t\".charCodeAt(0)) {\n      return \"\\t\";\n    }\n    if (byte == \"u\".charCodeAt(0)) {\n      let d1 = this.readHexDigit();\n      let d2 = this.readHexDigit();\n      let d3 = this.readHexDigit();\n      let d4 = this.readHexDigit();\n      let charCode = d1 * 0x1000 + d2 * 0x100 + d3 * 0x10 + d4;\n      return String.fromCodePoint(charCode);\n    }\n    assert(false, \"Unexpected escaped character: \" + String.fromCharCode(byte));\n    return \"\";\n  }\n\n  private readHexDigit(): i32 {\n    let byte = this.readChar();\n    let digit = byte - CHAR_0;\n    if (digit > 9) {\n      digit = byte - CHAR_A + 10;\n      if (digit < 10 || digit > 15) {\n        digit = byte - CHAR_A_LOWER + 10;\n      }\n    }\n    assert(digit >= 0 && digit < 16, \"Unexpected \\\\u digit\");\n    return digit;\n  }\n\n  private parseNumber(): bool {\n    let number: f64 = 0;\n    let sign: f64 = 1;\n    let isFloat: boolean = false;\n    // Also keeping the number as a string, because we will want to use the\n    // AS parseFloat as it handles precision best.\n    let numberAsString: string = \"\";\n\n    if (this.peekChar() == CHAR_MINUS) {\n      sign = -1;\n      numberAsString += String.fromCharCode(this.readChar());\n    }\n    let digits = 0;\n    while (\n      (CHAR_0 <= this.peekChar() && this.peekChar() <= CHAR_9) ||\n      CHAR_PERIOD == this.peekChar() ||\n      CHAR_MINUS == this.peekChar() ||\n      CHAR_PLUS == this.peekChar() ||\n      CHAR_E == this.peekChar() ||\n      CHAR_E_LOWER == this.peekChar()\n    ) {\n\n      let charCode = this.readChar();\n      numberAsString += String.fromCharCode(charCode);\n\n      if (charCode == CHAR_E || charCode == CHAR_E_LOWER || charCode == CHAR_PERIOD || charCode == CHAR_PLUS || charCode == CHAR_MINUS) {\n        isFloat = true;\n      } else {\n        if (!isFloat) {\n          let value: f64 = charCode - CHAR_0;\n          number *= 10;\n          number += value;\n        }\n        digits++;\n      }\n    }\n    if (digits > 0) {\n      if (isFloat || numberAsString == \"-0\") {\n        this.handler.setFloat(this.state.lastKey, parseFloat(numberAsString));\n      } else {\n        this.handler.setInteger(this.state.lastKey, <i64>(number * sign));\n      }\n      return true;\n    }\n    return false;\n  }\n\n  private parseBoolean(): bool {\n    if (this.peekChar() == FALSE_STR.charCodeAt(0)) {\n      this.readAndAssert(FALSE_STR);\n      this.handler.setBoolean(this.state.lastKey, false);\n      return true;\n    }\n    if (this.peekChar() == TRUE_STR.charCodeAt(0)) {\n      this.readAndAssert(TRUE_STR);\n      this.handler.setBoolean(this.state.lastKey, true);\n      return true;\n    }\n\n    return false;\n  }\n\n  private parseNull(): bool {\n    if (this.peekChar() == NULL_STR.charCodeAt(0)) {\n      this.readAndAssert(NULL_STR);\n      this.handler.setNull(this.state.lastKey);\n      return true;\n    }\n    return false;\n  }\n\n  private readAndAssert(str: string): void {\n    for (let i = 0; i < str.length; i++) {\n      assert(str.charCodeAt(i) == this.readChar(), \"Expected '\" + str + \"'\");\n    }\n  }\n\n  private skipWhitespace(): void {\n    while (this.isWhitespace(this.peekChar())) {\n      this.readChar();\n    }\n  }\n\n  private isWhitespace(charCode: i32): bool {\n    return (\n      charCode == 0x9 || charCode == 0xa || charCode == 0xd || charCode == 0x20\n    );\n  }\n}\n","export namespace Buffer {\n  export function fromString(str: string): Uint8Array {\n    const buffer = String.UTF8.encode(str, false);\n\n    // Workaround for https://github.com/AssemblyScript/assemblyscript/issues/1066\n    if (buffer.byteLength === 0) return new Uint8Array(0);\n\n    return Uint8Array.wrap(buffer);\n  }\n\n  export function toString(arr: Uint8Array): string {\n    return String.UTF8.decode(arr.buffer, false);\n  }\n\n  /**\n   * Returns a pointer to the start of the raw data (i.e. after the header)\n   *\n   * @see https://docs.assemblyscript.org/details/memory#internals\n   */\n  export function getDataPtr(arr: Uint8Array): usize {\n    return changetype<usize>(arr.buffer) + arr.byteOffset;\n  }\n\n  export function readString(\n    arr: Uint8Array,\n    start: usize,\n    end: usize\n  ): string {\n    return String.UTF8.decodeUnsafe(getDataPtr(arr) + start, end - start);\n  }\n}\n","import { COMPARATOR, SORT } from \"./util/sort\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_NOTIMPLEMENTED } from \"./util/error\";\nimport { joinIntegerArray, joinFloatArray } from \"./util/string\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\nexport class Int8Array extends ArrayBufferView {\n  [key: number]: i8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i8>();\n\n  constructor(length: i32) {\n    super(length, alignof<i8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i8 {\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i8>): void {\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): i8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: i8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\n    SORT<i8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SLICE<Int8Array, i8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int8Array {\n    return COPY_WITHIN<Int8Array, i8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\n    return MAP<Int8Array, i8>(this, fn);\n  }\n\n  filter(fn: (value: i8, index: i32, self: Int8Array) => bool): Int8Array {\n    return FILTER<Int8Array, i8>(this, fn);\n  }\n\n  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return SOME<Int8Array, i8>(this, fn);\n  }\n\n  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return EVERY<Int8Array, i8>(this, fn);\n  }\n\n  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {\n    FOREACH<Int8Array, i8>(this, fn);\n  }\n\n  reverse(): Int8Array {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i8>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int8Array {\n    return WRAP<Int8Array, i8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8Array extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): u8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\n    SORT<u8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SLICE<Uint8Array, u8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return COPY_WITHIN<Uint8Array, u8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\n    return MAP<Uint8Array, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8Array) => bool): Uint8Array {\n    return FILTER<Uint8Array, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return SOME<Uint8Array, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return EVERY<Uint8Array, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {\n    FOREACH<Uint8Array, u8>(this, fn);\n  }\n\n  reverse(): Uint8Array {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8Array {\n    return WRAP<Uint8Array, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8ClampedArray extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  at(index: i32): u8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    value = ~(value >> 31) & (((255 - value) >> 31) | value);\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\n    SORT<u8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SLICE<Uint8ClampedArray, u8>(this, begin, end);\n  }\n\n  subarray(start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return COPY_WITHIN<Uint8ClampedArray, u8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\n    return MAP<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): Uint8ClampedArray {\n    return FILTER<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_LAST_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return SOME<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return EVERY<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\n    FOREACH<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  reverse(): Uint8ClampedArray {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8ClampedArray {\n    return WRAP<Uint8ClampedArray, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int16Array extends ArrayBufferView {\n  [key: number]: i16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i16>();\n\n  constructor(length: i32) {\n    super(length, alignof<i16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i16 {\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i16>): void {\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  at(index: i32): i16 {\n    let len = this.byteLength >>> alignof<i16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  includes(searchElement: i16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    FILL<u16>(this.dataStart, this.length, u16(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\n    SORT<i16>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SLICE<Int16Array, i16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int16Array {\n    return COPY_WITHIN<Int16Array, i16>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\n    return MAP<Int16Array, i16>(this, fn);\n  }\n\n  filter(fn: (value: i16, index: i32, self: Int16Array) => bool): Int16Array {\n    return FILTER<Int16Array, i16>(this, fn);\n  }\n\n  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return SOME<Int16Array, i16>(this, fn);\n  }\n\n  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return EVERY<Int16Array, i16>(this, fn);\n  }\n\n  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {\n    FOREACH<Int16Array, i16>(this, fn);\n  }\n\n  reverse(): Int16Array {\n    REVERSE<u16>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int16Array {\n    return WRAP<Int16Array, i16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint16Array extends ArrayBufferView {\n  [key: number]: u16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u16>();\n\n  constructor(length: i32) {\n    super(length, alignof<u16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u16 {\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u16>): void {\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  at(index: i32): u16 {\n    let len = this.byteLength >>> alignof<u16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  includes(searchElement: u16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    FILL<u16>(this.dataStart, this.length, u16(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\n    SORT<u16>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SLICE<Uint16Array, u16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return COPY_WITHIN<Uint16Array, u16>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\n    return MAP<Uint16Array, u16>(this, fn);\n  }\n\n  filter(fn: (value: u16, index: i32, self: Uint16Array) => bool): Uint16Array {\n    return FILTER<Uint16Array, u16>(this, fn);\n  }\n\n  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return SOME<Uint16Array, u16>(this, fn);\n  }\n\n  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return EVERY<Uint16Array, u16>(this, fn);\n  }\n\n  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {\n    FOREACH<Uint16Array, u16>(this, fn);\n  }\n\n  reverse(): Uint16Array {\n    REVERSE<u16>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint16Array {\n    return WRAP<Uint16Array, u16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int32Array extends ArrayBufferView {\n  [key: number]: i32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i32>();\n\n  constructor(length: i32) {\n    super(length, alignof<i32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i32 {\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i32): void {\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  at(index: i32): i32 {\n    let len = this.byteLength >>> alignof<i32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  includes(searchElement: i32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    FILL<u32>(this.dataStart, this.length, u32(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\n    SORT<i32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SLICE<Int32Array, i32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int32Array {\n    return COPY_WITHIN<Int32Array, i32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\n    return MAP<Int32Array, i32>(this, fn);\n  }\n\n  filter(fn: (value: i32, index: i32, self: Int32Array) => bool): Int32Array {\n    return FILTER<Int32Array, i32>(this, fn);\n  }\n\n  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return SOME<Int32Array, i32>(this, fn);\n  }\n\n  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return EVERY<Int32Array, i32>(this, fn);\n  }\n\n  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {\n    FOREACH<Int32Array, i32>(this, fn);\n  }\n\n  reverse(): Int32Array {\n    REVERSE<u32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int32Array {\n    return WRAP<Int32Array, i32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint32Array extends ArrayBufferView {\n  [key: number]: u32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u32>();\n\n  constructor(length: i32) {\n    super(length, alignof<u32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u32 {\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u32): void {\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  at(index: i32): u32 {\n    let len = this.byteLength >>> alignof<u32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  includes(searchElement: u32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    FILL<u32>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\n    SORT<u32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SLICE<Uint32Array, u32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return COPY_WITHIN<Uint32Array, u32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\n    return MAP<Uint32Array, u32>(this, fn);\n  }\n\n  filter(fn: (value: u32, index: i32, self: Uint32Array) => bool): Uint32Array {\n    return FILTER<Uint32Array, u32>(this, fn);\n  }\n\n  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return SOME<Uint32Array, u32>(this, fn);\n  }\n\n  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return EVERY<Uint32Array, u32>(this, fn);\n  }\n\n  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {\n    FOREACH<Uint32Array, u32>(this, fn);\n  }\n\n  reverse(): Uint32Array {\n    REVERSE<u32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint32Array {\n    return WRAP<Uint32Array, u32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int64Array extends ArrayBufferView {\n  [key: number]: i64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i64>();\n\n  constructor(length: i32) {\n    super(length, alignof<i64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i64 {\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i64): void {\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  at(index: i32): i64 {\n    let len = this.byteLength >>> alignof<i64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  includes(searchElement: i64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    FILL<u64>(this.dataStart, this.length, u64(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\n    SORT<i64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SLICE<Int64Array, i64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int64Array {\n    return COPY_WITHIN<Int64Array, i64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\n    return MAP<Int64Array, i64>(this, fn);\n  }\n\n  filter(fn: (value: i64, index: i32, self: Int64Array) => bool): Int64Array {\n    return FILTER<Int64Array, i64>(this, fn);\n  }\n\n  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return SOME<Int64Array, i64>(this, fn);\n  }\n\n  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return EVERY<Int64Array, i64>(this, fn);\n  }\n\n  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {\n    FOREACH<Int64Array, i64>(this, fn);\n  }\n\n  reverse(): Int64Array {\n    REVERSE<u64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int64Array {\n    return WRAP<Int64Array, i64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint64Array extends ArrayBufferView {\n  [key: number]: u64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u64>();\n\n  constructor(length: i32) {\n    super(length, alignof<u64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u64 {\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u64): void {\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  at(index: i32): u64 {\n    let len = this.byteLength >>> alignof<u64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  includes(searchElement: u64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    FILL<u64>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\n    SORT<u64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SLICE<Uint64Array, u64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return COPY_WITHIN<Uint64Array, u64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\n    return MAP<Uint64Array, u64>(this, fn);\n  }\n\n  filter(fn: (value: u64, index: i32, self: Uint64Array) => bool): Uint64Array {\n    return FILTER<Uint64Array, u64>(this, fn);\n  }\n\n  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return SOME<Uint64Array, u64>(this, fn);\n  }\n\n  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return EVERY<Uint64Array, u64>(this, fn);\n  }\n\n  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {\n    FOREACH<Uint64Array, u64>(this, fn);\n  }\n\n  reverse(): Uint64Array {\n    REVERSE<u64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint64Array {\n    return WRAP<Uint64Array, u64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float32Array extends ArrayBufferView {\n  [key: number]: f32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f32>();\n\n  constructor(length: i32) {\n    super(length, alignof<f32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f32 {\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f32): void {\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  at(index: i32): f32 {\n    let len = this.byteLength >>> alignof<f32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  includes(searchElement: f32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    FILL<f32>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\n    SORT<f32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SLICE<Float32Array, f32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float32Array {\n    return COPY_WITHIN<Float32Array, f32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\n    return MAP<Float32Array, f32>(this, fn);\n  }\n\n  filter(fn: (value: f32, index: i32, self: Float32Array) => bool): Float32Array {\n    return FILTER<Float32Array, f32>(this, fn);\n  }\n\n  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return SOME<Float32Array, f32>(this, fn);\n  }\n\n  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return EVERY<Float32Array, f32>(this, fn);\n  }\n\n  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {\n    FOREACH<Float32Array, f32>(this, fn);\n  }\n\n  reverse(): Float32Array {\n    REVERSE<f32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float32Array {\n    return WRAP<Float32Array, f32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float64Array extends ArrayBufferView {\n  [key: number]: f64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f64>();\n\n  constructor(length: i32) {\n    super(length, alignof<f64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f64 {\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f64): void {\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  at(index: i32): f64 {\n    let len = this.byteLength >>> alignof<f64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  includes(searchElement: f64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    FILL<f64>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\n    SORT<f64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SLICE<Float64Array, f64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float64Array {\n    return COPY_WITHIN<Float64Array, f64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\n    return MAP<Float64Array, f64>(this, fn);\n  }\n\n  filter(fn: (value: f64, index: i32, self: Float64Array) => bool): Float64Array {\n    return FILTER<Float64Array, f64>(this, fn);\n  }\n\n  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return SOME<Float64Array, f64>(this, fn);\n  }\n\n  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return EVERY<Float64Array, f64>(this, fn);\n  }\n\n  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {\n    FOREACH<Float64Array, f64>(this, fn);\n  }\n\n  reverse(): Float64Array {\n    REVERSE<f64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float64Array {\n    return WRAP<Float64Array, f64>(buffer, byteOffset, length);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SLICE<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  start: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  start  = start < 0 ? max(start + len, 0) : min(start, len);\n  end    = end   < 0 ? max(end   + len, 0) : min(end  , len);\n  len = max(end - start, 0);\n  let slice = instantiate<TArray>(len);\n  memory.copy(\n    slice.dataStart,\n    array.dataStart + (<usize>start << alignof<T>()),\n    <usize>len << alignof<T>()\n  );\n  return slice;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SUBARRAY<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  end   = max(end, begin);\n\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<usize>(array.buffer);\n  store<usize>(changetype<usize>(out), buf, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), buf, false);\n  store<usize>(changetype<usize>(out), array.dataStart + (<usize>begin << alignof<T>()), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction COPY_WITHIN<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  target: i32,\n  start: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  let ptr = array.dataStart;\n\n  end   = min<i32>(end, len);\n  let to    = target < 0 ? max(len + target, 0) : min(target, len);\n  let from  = start < 0 ? max(len + start, 0) : min(start, len);\n  let last  = end < 0 ? max(len + end, 0) : min(end, len);\n  let count = min(last - from, len - to);\n\n  memory.copy(\n    ptr + (<usize>to << alignof<T>()),\n    ptr + (<usize>from << alignof<T>()),\n    <usize>count << alignof<T>()\n  );\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE<TArray extends ArrayBufferView, T extends number, TRet extends number>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE_RIGHT<TArray extends ArrayBufferView, T extends number, TRet extends number>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  let ptr = array.dataStart;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction MAP<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  let len = array.length;\n  let ptr = array.dataStart;\n\n  let byteLength = len << alignof<T>();\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n  for (let i = 0; i < len; i++) {\n    store<T>(\n      changetype<usize>(buf) + (<usize>i << alignof<T>()),\n      fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)\n    );\n  }\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buf), false);\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILTER<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => bool,\n): TArray {\n  let len = array.length;\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<ArrayBuffer>(__new(len << alignof<T>(), idof<ArrayBuffer>()));\n  let dataStart  = array.dataStart;\n  let j: usize = 0;\n  for (let i = 0; i < len; i++) {\n    let value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    if (fn(value, i, array)) {\n      store<T>(\n        changetype<usize>(buf) + (j++ << alignof<T>()),\n        value\n      );\n    }\n  }\n  // shrink output buffer\n  let byteLength = j << alignof<T>();\n  let data = __renew(changetype<usize>(buf), byteLength);\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), data, false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_INDEX<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_LAST_INDEX<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  let ptr = array.dataStart;\n  for (let i = array.length - 1; i >= 0; --i) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INCLUDES<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): bool {\n  if (isFloat<T>()) {\n    let index: isize = fromIndex;\n    let len: isize = array.length;\n    if (len == 0 || index >= len) return false;\n    if (index < 0) index = max(len + index, 0);\n    let dataStart = array.dataStart;\n    while (index < len) {\n      let elem = load<T>(dataStart + (index << alignof<T>()));\n      // @ts-ignore\n      if (elem == searchElement || isNaN(elem) & isNaN(searchElement)) return true;\n      ++index;\n    }\n    return false;\n  } else {\n    return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INDEX_OF<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  let index: isize = fromIndex;\n  let len: isize = array.length;\n  if (len == 0 || index >= len) return -1;\n  if (index < 0) index = max(len + index, 0);\n  let dataStart = array.dataStart;\n  while (index < len) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    ++index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction LAST_INDEX_OF<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  let index: isize = fromIndex;\n  let len: isize = array.length;\n  if (len == 0) return -1;\n  if (index < 0) index = len + index; // no need to clamp\n  else if (index >= len) index = len - 1;\n  let dataStart = array.dataStart;\n  while (index >= 0) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    --index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SOME<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return true;\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction EVERY<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) continue;\n    return false;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FOREACH<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => void,\n): void {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction WRAP<TArray extends ArrayBufferView, T>(\n  buffer: ArrayBuffer,\n  byteOffset: i32 = 0,\n  len: i32 = -1\n): TArray {\n  let byteLength: i32;\n  let bufferByteLength = buffer.byteLength;\n  const mask: u32 = sizeof<T>() - 1;\n  if (i32(<u32>byteOffset > <u32>bufferByteLength) | (byteOffset & mask)) {\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  if (len < 0) {\n    if (len == -1) {\n      if (bufferByteLength & mask) {\n        throw new RangeError(E_INVALIDLENGTH);\n      }\n      byteLength = bufferByteLength - byteOffset;\n    } else {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  } else {\n    byteLength = len << alignof<T>();\n    if (byteOffset + byteLength > bufferByteLength) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  }\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buffer), false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer) + <usize>byteOffset, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SET<\n  TArray extends ArrayLike<number>,\n  UArray extends ArrayLike<number>\n>(\n  target: TArray,\n  source: UArray,\n  offset: i32 = 0\n): void {\n  // need to assert at compile time that U is not a reference or a function\n  if (isReference<valueof<UArray>>()) {\n    ERROR(E_NOTIMPLEMENTED);\n  }\n  let sourceLen = source.length;\n  if (offset < 0 || sourceLen + offset > target.length) {\n    // offset is out of bounds\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  // @ts-ignore: dataStart\n  let targetStart = target.dataStart + (<usize>offset << (alignof<valueof<TArray>>()));\n  // @ts-ignore: dataStart\n  let sourceStart = source.dataStart;\n  // if the types align and match, use memory.copy() instead of manual loop\n  if (\n    isInteger<valueof<TArray>>() == isInteger<valueof<UArray>>() &&\n    alignof<valueof<TArray>>() == alignof<valueof<UArray>>() &&\n    !(isSigned<valueof<UArray>>() && target instanceof Uint8ClampedArray)\n  ) {\n    memory.copy(targetStart, sourceStart, <usize>sourceLen << (alignof<valueof<UArray>>()));\n  } else {\n    for (let i = 0; i < sourceLen; i++) {\n      let ptr = targetStart + (<usize>i << (alignof<valueof<TArray>>()));\n      let value = load<valueof<UArray>>(sourceStart + (<usize>i << (alignof<valueof<UArray>>())));\n      // if TArray is Uint8ClampedArray, then values must be clamped\n      if (target instanceof Uint8ClampedArray) {\n        if (isFloat<valueof<UArray>>()) {\n          store<valueof<TArray>>(ptr,\n            isFinite<valueof<UArray>>(value)\n              ? <valueof<TArray>>max<valueof<UArray>>(0, min<valueof<UArray>>(255, value))\n              : 0\n          );\n        } else {\n          if (!isSigned<valueof<UArray>>()) {\n            store<valueof<TArray>>(ptr, min<valueof<UArray>>(255, value));\n          } else if (sizeof<valueof<TArray>>() <= 4) {\n            store<valueof<TArray>>(ptr, ~(<i32>value >> 31) & (((255 - <i32>value) >> 31) | value));\n          } else {\n            store<valueof<TArray>>(ptr, ~(<i64>value >> 63) & (((255 - <i64>value) >> 63) | value));\n          }\n        }\n      } else {\n        if (isFloat<valueof<UArray>>() && !isFloat<valueof<TArray>>()) {\n          store<valueof<TArray>>(ptr, isFinite<valueof<UArray>>(value) ? <valueof<TArray>>value : 0);\n        } else {\n          store<valueof<TArray>>(ptr, <valueof<TArray>>value);\n        }\n      }\n    }\n  }\n}\n","import { itoa32, utoa32, itoa64, utoa64, dtoa } from \"./util/number\";\nimport { strtol, strtod } from \"./util/string\";\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const NaN: f64 = 0 / 0;\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const Infinity: f64 = 1 / 0;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNaN<T extends number>(value: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFinite<T extends number>(value: T): bool;\n\n@final @unmanaged\nexport abstract class I8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n\n  toString(this: i8, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n\n  toString(this: i16, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i32 {\n    return <i32>strtol<i32>(value, radix);\n  }\n\n  toString(this: i32, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  toString(this: i64, radix: i32 = 10): String {\n    return itoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n\n  toString(this: isize, radix: i32 = 10): String {\n    if (sizeof<isize>() == 4) {\n      return itoa32(<i32>this, radix);\n    } else {\n      return itoa64(<i64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class U8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n\n  toString(this: u8, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n\n  toString(this: u16, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n\n  toString(this: u32, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n\n  toString(this: u64, radix: i32 = 10): String {\n    return utoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n\n  toString(this: usize, radix: i32 = 10): String {\n    if (sizeof<usize>() == 4) {\n      return utoa32(<u32>this, radix);\n    } else {\n      return utoa64(<u64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class Bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\n\n  toString(this: bool, radix: i32 = 0): String {\n    return this ? \"true\" : \"false\";\n  }\n}\n\nexport { Bool as Boolean };\n\n@final @unmanaged\nexport abstract class F32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f32 = f32.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f32 = f32.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f32 = f32.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f32 = f32.NaN;\n\n  static isNaN(value: f32): bool {\n    return isNaN<f32>(value);\n  }\n\n  static isFinite(value: f32): bool {\n    return isFinite<f32>(value);\n  }\n\n  static isSafeInteger(value: f32): bool {\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\n  }\n\n  static isInteger(value: f32): bool {\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\n  }\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): f32 {\n    return <f32>strtol<f64>(value, radix);\n  }\n\n  /** @deprecated */\n  static parseFloat(value: string): f32 {\n    return <f32>strtod(value);\n  }\n\n  toString(this: f32, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\n@final @unmanaged\nexport abstract class F64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f64 = f64.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f64 = f64.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f64 = f64.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f64 = f64.NaN;\n\n  static isNaN(value: f64): bool {\n    return isNaN<f64>(value);\n  }\n\n  static isFinite(value: f64): bool {\n    return isFinite<f64>(value);\n  }\n\n  static isSafeInteger(value: f64): bool {\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\n  }\n\n  static isInteger(value: f64): bool {\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\n  }\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): f64 {\n    return strtol<f64>(value, radix);\n  }\n\n  /** @deprecated */\n  static parseFloat(value: string): f64 {\n    return strtod(value);\n  }\n\n  toString(this: f64, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\nexport { F64 as Number };\n","import { Math as JSMath } from \"./bindings/dom\";\nexport { JSMath };\n\nimport {\n  pow_lut, exp_lut, exp2_lut, log_lut, log2_lut,\n  powf_lut, expf_lut, exp2f_lut, logf_lut, log2f_lut\n} from \"./util/math\";\n\nimport {\n  abs as builtin_abs,\n  ceil as builtin_ceil,\n  clz as builtin_clz,\n  copysign as builtin_copysign,\n  floor as builtin_floor,\n  max as builtin_max,\n  min as builtin_min,\n  sqrt as builtin_sqrt,\n  trunc as builtin_trunc\n} from \"./builtins\";\n\n// SUN COPYRIGHT NOTICE\n//\n// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n// Developed at SunPro, a Sun Microsystems, Inc. business.\n// Permission to use, copy, modify, and distribute this software\n// is freely granted, provided that this notice is preserved.\n//\n// Applies to all functions marked with a comment referring here.\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy let rempio2_y0: f64, rempio2_y1: f64, res128_hi: u64;\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy @inline const PIO2_TABLE = memory.data<u64>([\n  0x00000000A2F9836E, 0x4E441529FC2757D1, 0xF534DDC0DB629599, 0x3C439041FE5163AB,\n  0xDEBBC561B7246E3A, 0x424DD2E006492EEA, 0x09D1921CFE1DEB1C, 0xB129A73EE88235F5,\n  0x2EBB4484E99C7026, 0xB45F7E413991D639, 0x835339F49C845F8B, 0xBDF9283B1FF897FF,\n  0xDE05980FEF2F118B, 0x5A0A6D1F6D367ECF, 0x27CB09B74F463F66, 0x9E5FEA2D7527BAC7,\n  0xEBE5F17B3D0739F7, 0x8A5292EA6BFB5FB1, 0x1F8D5D0856033046, 0xFC7B6BABF0CFBC20,\n  0x9AF4361DA9E39161, 0x5EE61B086599855F, 0x14A068408DFFD880, 0x4D73273106061557\n]);\n\n/** @internal */\nfunction R(z: f64): f64 { // Rational approximation of (asin(x)-x)/x^3\n  const                   // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f64>(0x3FC5555555555555), //  1.66666666666666657415e-01\n    pS1 = reinterpret<f64>(0xBFD4D61203EB6F7D), // -3.25565818622400915405e-01\n    pS2 = reinterpret<f64>(0x3FC9C1550E884455), //  2.01212532134862925881e-01\n    pS3 = reinterpret<f64>(0xBFA48228B5688F3B), // -4.00555345006794114027e-02\n    pS4 = reinterpret<f64>(0x3F49EFE07501B288), //  7.91534994289814532176e-04\n    pS5 = reinterpret<f64>(0x3F023DE10DFDF709), //  3.47933107596021167570e-05\n    qS1 = reinterpret<f64>(0xC0033A271C8A2D4B), // -2.40339491173441421878e+00\n    qS2 = reinterpret<f64>(0x40002AE59C598AC8), //  2.02094576023350569471e+00\n    qS3 = reinterpret<f64>(0xBFE6066C1B8D0159), // -6.88283971605453293030e-01\n    qS4 = reinterpret<f64>(0x3FB3B8C5B12E9282); //  7.70381505559019352791e-02\n\n  let p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));\n  let q = 1.0 + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));\n  return p / q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction expo2(x: f64, sign: f64): f64 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                       // see: musl/src/math/__expo2.c\n    k    = <u32>2043,\n    kln2 = reinterpret<f64>(0x40962066151ADD8B); // 0x1.62066151add8bp+10\n  let scale = reinterpret<f64>(<u64>((<u32>0x3FF + k / 2) << 20) << 32);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMath.exp(x - kln2) * (sign * scale) * scale;\n}\n\n/** @internal */\n/* Helper function to eventually get bits of π/2 * |x|\n *\n * y = π/4 * (frac << clz(frac) >> 11)\n * return clz(frac)\n *\n * Right shift 11 bits to make upper half fit in `double`\n */\n// @ts-ignore: decorator\n@inline\nfunction pio2_right(q0: u64, q1: u64): u64 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  // Bits of π/4\n  const p0: u64 = 0xC4C6628B80DC1CD1;\n  const p1: u64 = 0xC90FDAA22168C234;\n\n  const Ox1p_64 = reinterpret<f64>(0x3BF0000000000000); // 0x1p-64\n  const Ox1p_75 = reinterpret<f64>(0x3B40000000000000); // 0x1p-75\n\n  let shift = clz(q1);\n\n  q1 = q1 << shift | q0 >> (64 - shift);\n  q0 <<= shift;\n\n  let lo = umuldi(p1, q1);\n  let hi = res128_hi;\n\n  let ahi = hi >> 11;\n  let alo = lo >> 11 | hi << 53;\n  let blo = <u64>(Ox1p_75 * <f64>p0 * <f64>q1 + Ox1p_75 * <f64>p1 * <f64>q0);\n\n  rempio2_y0 = <f64>(ahi + u64(lo < blo));\n  rempio2_y1 = Ox1p_64 * <f64>(alo + blo);\n\n  return shift;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction umuldi(u: u64, v: u64): u64 {\n  let u1: u64 , v1: u64, w0: u64, w1: u64, t: u64;\n\n  u1 = u & 0xFFFFFFFF;\n  v1 = v & 0xFFFFFFFF;\n\n  u >>= 32;\n  v >>= 32;\n\n  t  = u1 * v1;\n  w0 = t & 0xFFFFFFFF;\n  t  = u * v1 + (t >> 32);\n  w1 = t >> 32;\n  t  = u1 * v + (t & 0xFFFFFFFF);\n\n  res128_hi = u * v + w1 + (t >> 32);\n  return (t << 32) + w0;\n}\n\n/** @internal */\nfunction pio2_large_quot(x: f64, u: i64): i32 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  let magnitude = u & 0x7FFFFFFFFFFFFFFF;\n  let offset = (magnitude >> 52) - 1045;\n  let shift  = offset & 63;\n  let tblPtr = PIO2_TABLE + (<i32>(offset >> 6) << 3);\n  let s0: u64, s1: u64, s2: u64;\n\n  let b0 = load<u64>(tblPtr, 0 << 3);\n  let b1 = load<u64>(tblPtr, 1 << 3);\n  let b2 = load<u64>(tblPtr, 2 << 3);\n\n  // Get 192 bits of 0x1p-31 / π with `offset` bits skipped\n  if (shift) {\n    let rshift = 64 - shift;\n    let b3 = load<u64>(tblPtr, 3 << 3);\n    s0 = b1 >> rshift | b0 << shift;\n    s1 = b2 >> rshift | b1 << shift;\n    s2 = b3 >> rshift | b2 << shift;\n  } else {\n    s0 = b0;\n    s1 = b1;\n    s2 = b2;\n  }\n\n  let significand = (u & 0x000FFFFFFFFFFFFF) | 0x0010000000000000;\n\n  // First 128 bits of fractional part of x/(2π)\n  let blo = umuldi(s1, significand);\n  let bhi = res128_hi;\n\n  let ahi = s0 * significand;\n  let clo = (s2 >> 32) * (significand >> 32);\n  let plo = blo + clo;\n  let phi = ahi + bhi + u64(plo < clo);\n\n  // r: u128 = p << 2\n  let rlo = plo << 2;\n  let rhi = phi << 2 | plo >> 62;\n\n  // s: i128 = r >> 127\n  let slo = <i64>rhi >> 63;\n  let shi = slo >> 1;\n  let q   = (<i64>phi >> 62) - slo;\n\n  let shifter = 0x3CB0000000000000 - (pio2_right(rlo ^ slo, rhi ^ shi) << 52);\n  let signbit = (u ^ rhi) & 0x8000000000000000;\n  let coeff   = reinterpret<f64>(shifter | signbit);\n\n  rempio2_y0 *= coeff;\n  rempio2_y1 *= coeff;\n\n  return <i32>q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction rempio2(x: f64, u: u64, sign: i32): i32 {\n  const\n    pio2_1  = reinterpret<f64>(0x3FF921FB54400000), // 1.57079632673412561417e+00\n    pio2_1t = reinterpret<f64>(0x3DD0B4611A626331), // 6.07710050650619224932e-11\n    pio2_2  = reinterpret<f64>(0x3DD0B4611A600000), // 6.07710050630396597660e-11\n    pio2_2t = reinterpret<f64>(0x3BA3198A2E037073), // 2.02226624879595063154e-21\n    pio2_3  = reinterpret<f64>(0x3BA3198A2E000000), // 2.02226624871116645580e-21\n    pio2_3t = reinterpret<f64>(0x397B839A252049C1), // 8.47842766036889956997e-32\n    invpio2 = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  let ix = <u32>(u >> 32) & 0x7FFFFFFF;\n\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (ix < 0x4002D97C) { // |x| < 3pi/4, special case with n=+-1\n      let q = 1, z: f64, y0: f64, y1: f64;\n      if (!sign) {\n        z = x - pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z - pio2_1t;\n          y1 = (z - y0) - pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z -= pio2_2;\n          y0 = z - pio2_2t;\n          y1 = (z - y0) - pio2_2t;\n        }\n      } else { // negative x\n        z = x + pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z + pio2_1t;\n          y1 = (z - y0) + pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z += pio2_2;\n          y0 = z + pio2_2t;\n          y1 = (z - y0) + pio2_2t;\n        }\n        q = -1;\n      }\n      rempio2_y0 = y0;\n      rempio2_y1 = y1;\n      return q;\n    }\n  }\n\n  if (ix < 0x413921FB) { // |x| ~< 2^20*pi/2 (1647099)\n    // Use precise Cody Waite scheme\n    let q  = nearest(x * invpio2);\n    let r  = x - q * pio2_1;\n    let w  = q * pio2_1t; // 1st round good to 85 bit\n    let j  = ix >> 20;\n    let y0 = r - w;\n    let hi = <u32>(reinterpret<u64>(y0) >> 32);\n    let i  = j - ((hi >> 20) & 0x7FF);\n\n    if (i > 16) { // 2nd iteration needed, good to 118\n      let t = r;\n      w  = q * pio2_2;\n      r  = t - w;\n      w  = q * pio2_2t - ((t - r) - w);\n      y0 = r - w;\n      hi = <u32>(reinterpret<u64>(y0) >> 32);\n      i = j - ((hi >> 20) & 0x7FF);\n      if (i > 49) { // 3rd iteration need, 151 bits acc\n        let t = r;\n        w  = q * pio2_3;\n        r  = t - w;\n        w  = q * pio2_3t - ((t - r) - w);\n        y0 = r - w;\n      }\n    }\n    let y1 = (r - y0) - w;\n    rempio2_y0 = y0;\n    rempio2_y1 = y1;\n    return <i32>q;\n  }\n  let q = pio2_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction sin_kern(x: f64, y: f64, iy: i32): f64 { // see: musl/tree/src/math/__sin.c\n  const\n    S1 = reinterpret<f64>(0xBFC5555555555549), // -1.66666666666666324348e-01\n    S2 = reinterpret<f64>(0x3F8111111110F8A6), //  8.33333333332248946124e-03\n    S3 = reinterpret<f64>(0xBF2A01A019C161D5), // -1.98412698298579493134e-04\n    S4 = reinterpret<f64>(0x3EC71DE357B1FE7D), //  2.75573137070700676789e-06\n    S5 = reinterpret<f64>(0xBE5AE5E68A2B9CEB), // -2.50507602534068634195e-08\n    S6 = reinterpret<f64>(0x3DE5D93A5ACFD57C); //  1.58969099521155010221e-10\n\n  let z = x * x;\n  let w = z * z;\n  let r = S2 + z * (S3 + z * S4) + z * w * (S5 + z * S6);\n  let v = z * x;\n  if (!iy) {\n    return x + v * (S1 + z * r);\n  } else {\n    return x - ((z * (0.5 * y - v * r) - y) - v * S1);\n  }\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction cos_kern(x: f64, y: f64): f64 { // see: musl/tree/src/math/__cos.c\n  const\n    C1 = reinterpret<f64>(0x3FA555555555554C), //  4.16666666666666019037e-02\n    C2 = reinterpret<f64>(0xBF56C16C16C15177), // -1.38888888888741095749e-03\n    C3 = reinterpret<f64>(0x3EFA01A019CB1590), //  2.48015872894767294178e-05\n    C4 = reinterpret<f64>(0xBE927E4F809C52AD), // -2.75573143513906633035e-07\n    C5 = reinterpret<f64>(0x3E21EE9EBDB4B1C4), //  2.08757232129817482790e-09\n    C6 = reinterpret<f64>(0xBDA8FAE9BE8838D4); // -1.13596475577881948265e-11\n\n  let z = x * x;\n  let w = z * z;\n  let r = z * (C1 + z * (C2 + z * C3)) + w * w * (C4 + z * (C5 + z * C6));\n  let hz = 0.5 * z;\n  w = 1.0 - hz;\n  return w + (((1.0 - w) - hz) + (z * r - x * y));\n}\n\n/** @internal */\nfunction tan_kern(x: f64, y: f64, iy: i32): f64 { // see: src/lib/msun/src/k_tan.c\n  const\n    T0  = reinterpret<f64>(0x3FD5555555555563), //  3.33333333333334091986e-01\n    T1  = reinterpret<f64>(0x3FC111111110FE7A), //  1.33333333333201242699e-01\n    T2  = reinterpret<f64>(0x3FABA1BA1BB341FE), //  5.39682539762260521377e-02\n    T3  = reinterpret<f64>(0x3F9664F48406D637), //  2.18694882948595424599e-02\n    T4  = reinterpret<f64>(0x3F8226E3E96E8493), //  8.86323982359930005737e-03\n    T5  = reinterpret<f64>(0x3F6D6D22C9560328), //  3.59207910759131235356e-03\n    T6  = reinterpret<f64>(0x3F57DBC8FEE08315), //  1.45620945432529025516e-03\n    T7  = reinterpret<f64>(0x3F4344D8F2F26501), //  5.88041240820264096874e-04\n    T8  = reinterpret<f64>(0x3F3026F71A8D1068), //  2.46463134818469906812e-04\n    T9  = reinterpret<f64>(0x3F147E88A03792A6), //  7.81794442939557092300e-05\n    T10 = reinterpret<f64>(0x3F12B80F32F0A7E9), //  7.14072491382608190305e-05\n    T11 = reinterpret<f64>(0xBEF375CBDB605373), // -1.85586374855275456654e-05\n    T12 = reinterpret<f64>(0x3EFB2A7074BF7AD4); //  2.59073051863633712884e-05\n\n  const\n    one    = reinterpret<f64>(0x3FF0000000000000), // 1.00000000000000000000e+00\n    pio4   = reinterpret<f64>(0x3FE921FB54442D18), // 7.85398163397448278999e-01\n    pio4lo = reinterpret<f64>(0x3C81A62633145C07); // 3.06161699786838301793e-17\n\n  let z: f64, r: f64, v: f64, w: f64, s: f64;\n  let hx = <i32>(reinterpret<u64>(x) >> 32); // high word of x\n  let ix = hx & 0x7FFFFFFF; // high word of |x|\n  let big = ix >= 0x3FE59428;\n  if (big) { // |x| >= 0.6744\n    if (hx < 0) { x = -x, y = -y; }\n    z = pio4 - x;\n    w = pio4lo - y;\n    x = z + w;\n    y = 0.0;\n  }\n  z = x * x;\n  w = z * z;\n  r = T1 + w * (T3 + w * (T5 + w * (T7 + w * (T9 + w * T11))));\n  v = z * (T2 + w * (T4 + w * (T6 + w * (T8 + w * (T10 + w * T12)))));\n  s = z * x;\n  r = y + z * (s * (r + v) + y);\n  r += T0 * s;\n  w = x + r;\n  if (big) {\n    v = iy;\n    return (1 - ((hx >> 30) & 2)) * (v - 2.0 * (x - (w * w / (w + v) - r)));\n  }\n  if (iy == 1) return w;\n  let a: f64, t: f64;\n  z = w;\n  z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF00000000);\n  v = r - (z - x);  // z + v = r + x\n  t = a = -one / w; // a = -1.0 / w\n  t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n  s = one + t * z;\n  return t + a * (s + t * v);\n}\n\n/** @internal */\nfunction dtoi32(x: f64): i32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    const inv32 = 1.0 / 4294967296;\n    return <i32><i64>(x - 4294967296 * floor(x * inv32));\n  } else {\n    let result = 0;\n    let u = reinterpret<u64>(x);\n    let e = (u >> 52) & 0x7FF;\n    if (e <= 1023 + 30) {\n      result = <i32>x;\n    } else if (e <= 1023 + 30 + 53) {\n      let v = (u & ((<u64>1 << 52) - 1)) | (<u64>1 << 52);\n      v = v << e - 1023 - 52 + 32;\n      result = <i32>(v >> 32);\n      result = select<i32>(-result, result, <i64>u < 0);\n    }\n    return result;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy let random_seeded = false;\n\n// @ts-ignore: decorator\n@lazy let random_state0_64: u64, random_state1_64: u64;\n\n// @ts-ignore: decorator\n@lazy let random_state0_32: u32, random_state1_32: u32;\n\nfunction murmurHash3(h: u64): u64 { // Force all bits of a hash block to avalanche\n  h ^= h >> 33;                     // see: https://github.com/aappleby/smhasher\n  h *= 0xFF51AFD7ED558CCD;\n  h ^= h >> 33;\n  h *= 0xC4CEB9FE1A85EC53;\n  h ^= h >> 33;\n  return h;\n}\n\nfunction splitMix32(h: u32): u32 {\n  h += 0x6D2B79F5;\n  h  = (h ^ (h >> 15)) * (h | 1);\n  h ^= h + (h ^ (h >> 7)) * (h | 61);\n  return h ^ (h >> 14);\n}\n\nexport namespace NativeMath {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = reinterpret<f64>(0x4005BF0A8B145769); // 2.7182818284590452354\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.69314718055994530942\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = reinterpret<f64>(0x40026BB1BBB55516); // 2.30258509299404568402\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = reinterpret<f64>(0x3FF71547652B82FE); // 1.4426950408889634074\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = reinterpret<f64>(0x3FDBCB7B1526E50E); // 0.43429448190325182765\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = reinterpret<f64>(0x400921FB54442D18); // 3.14159265358979323846\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = reinterpret<f64>(0x3FE6A09E667F3BCD); // 0.70710678118654752440\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = reinterpret<f64>(0x3FF6A09E667F3BCD); // 1.41421356237309504880\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_sin: f64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_cos: f64 = 0;\n\n  // @ts-ignore: decorator\n  @inline export function abs(x: f64): f64 {\n    return builtin_abs<f64>(x);\n  }\n\n  export function acos(x: f64): f64 { // see: musl/src/math/acos.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    let hx = <u32>(reinterpret<u64>(x) >> 32);\n    let ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) {\n        if (<i32>hx < 0) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix <= 0x3C600000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * R(x * x)));\n    }\n    let s: f64, w: f64, z: f64;\n    if (<i32>hx < 0) {\n      // z = (1.0 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f64>(z);\n      w = R(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1.0 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f64>(z);\n    let df = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n    let c = (z - df * df) / (s + df);\n    w = R(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f64): f64 { // see: musl/src/math/acosh.c\n    const s = reinterpret<f64>(0x3FE62E42FEFA39EF);\n    let u = reinterpret<u64>(x);\n    // Prevent propagation for all input values less than 1.0.\n    // Note musl lib didn't fix this yet.\n    if (<i64>u < 0x3FF0000000000000) return (x - x) / 0.0;\n    let e = u >> 52 & 0x7FF;\n    if (e < 0x3FF + 1) return log1p(x - 1 + builtin_sqrt<f64>((x - 1) * (x - 1) + 2 * (x - 1)));\n    if (e < 0x3FF + 26) return log(2 * x - 1 / (x + builtin_sqrt<f64>(x * x - 1)));\n    return log(x) + s;\n  }\n\n  export function asin(x: f64): f64 { // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    let hx = <u32>(reinterpret<u64>(x) >> 32);\n    let ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) return x * pio2_hi + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix < 0x3E500000 && ix >= 0x00100000) return x;\n      return x + x * R(x * x);\n    }\n    // let z = (1.0 - builtin_abs<f64>(x)) * 0.5;\n    let z = 0.5 - builtin_abs<f64>(x) * 0.5;\n    let s = builtin_sqrt<f64>(z);\n    let r = R(z);\n    if (ix >= 0x3FEF3333) x = pio2_hi - (2 * (s + s * r) - pio2_lo);\n    else {\n      let f = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n      let c = (z - f * f) / (s + f);\n      x = 0.5 * pio2_hi - (2 * s * r - (pio2_lo - 2 * c) - (0.5 * pio2_hi - 2 * f));\n    }\n    return select(-x, x, <i32>hx < 0);\n  }\n\n  export function asinh(x: f64): f64 { // see: musl/src/math/asinh.c\n    const c = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.693147180559945309417232121458176568\n    let u = reinterpret<u64>(x);\n    let e = u >> 52 & 0x7FF;\n    let y = reinterpret<f64>(u & 0x7FFFFFFFFFFFFFFF);\n    if (e >= 0x3FF + 26) y = log(y) + c;\n    else if (e >= 0x3FF + 1)  y =   log(2 * y + 1 / (builtin_sqrt<f64>(y * y + 1) + y));\n    else if (e >= 0x3FF - 26) y = log1p(y + y * y / (builtin_sqrt<f64>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f64): f64 { // see musl/src/math/atan.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f64>(0x3FDDAC670561BB4F), //  4.63647609000806093515e-01\n      atanhi1   = reinterpret<f64>(0x3FE921FB54442D18), //  7.85398163397448278999e-01\n      atanhi2   = reinterpret<f64>(0x3FEF730BD281F69B), //  9.82793723247329054082e-01\n      atanhi3   = reinterpret<f64>(0x3FF921FB54442D18), //  1.57079632679489655800e+00\n      atanlo0   = reinterpret<f64>(0x3C7A2B7F222F65E2), //  2.26987774529616870924e-17\n      atanlo1   = reinterpret<f64>(0x3C81A62633145C07), //  3.06161699786838301793e-17\n      atanlo2   = reinterpret<f64>(0x3C7007887AF0CBBD), //  1.39033110312309984516e-17\n      atanlo3   = reinterpret<f64>(0x3C91A62633145C07), //  6.12323399573676603587e-17\n      aT0       = reinterpret<f64>(0x3FD555555555550D), //  3.33333333333329318027e-01\n      aT1       = reinterpret<f64>(0xBFC999999998EBC4), // -1.99999999998764832476e-01\n      aT2       = reinterpret<f64>(0x3FC24924920083FF), //  1.42857142725034663711e-01\n      aT3       = reinterpret<f64>(0xBFBC71C6FE231671), // -1.11111104054623557880e-01,\n      aT4       = reinterpret<f64>(0x3FB745CDC54C206E), //  9.09088713343650656196e-02\n      aT5       = reinterpret<f64>(0xBFB3B0F2AF749A6D), // -7.69187620504482999495e-02\n      aT6       = reinterpret<f64>(0x3FB10D66A0D03D51), //  6.66107313738753120669e-02\n      aT7       = reinterpret<f64>(0xBFADDE2D52DEFD9A), // -5.83357013379057348645e-02\n      aT8       = reinterpret<f64>(0x3FA97B4B24760DEB), //  4.97687799461593236017e-02\n      aT9       = reinterpret<f64>(0xBFA2B4442C6A6C2F), // -3.65315727442169155270e-02\n      aT10      = reinterpret<f64>(0x3F90AD3AE322DA11), //  1.62858201153657823623e-02\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    let ix = <u32>(reinterpret<u64>(x) >> 32);\n    let sx = x;\n    ix &= 0x7FFFFFFF;\n    let z: f64;\n    if (ix >= 0x44100000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign<f64>(z, sx);\n    }\n    let id: i32;\n    if (ix < 0x3FDC0000) {\n      if (ix < 0x3E400000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f64>(x);\n      if (ix < 0x3FF30000) {\n        if (ix < 0x3FE60000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x40038000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    let w = z * z;\n    let s1 = z * (aT0 + w * (aT2 + w * (aT4 + w * (aT6 + w * (aT8 + w * aT10)))));\n    let s2 = w * (aT1 + w * (aT3 + w * (aT5 + w * (aT7 + w * aT9))));\n    let s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign<f64>(z, sx);\n  }\n\n  export function atanh(x: f64): f64 { // see: musl/src/math/atanh.c\n    let u = reinterpret<u64>(x);\n    let e = u >> 52 & 0x7FF;\n    let y = builtin_abs(x);\n    if (e < 0x3FF - 1) {\n      if (e >= 0x3FF - 32) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));\n    } else {\n      y = 0.5 * log1p(2 * (y / (1 - y)));\n    }\n    return builtin_copysign<f64>(y, x);\n  }\n\n  export function atan2(y: f64, x: f64): f64 { // see: musl/src/math/atan2.c and SUN COPYRIGHT NOTICE above\n    const pi_lo = reinterpret<f64>(0x3CA1A62633145C07); // 1.2246467991473531772E-16\n    if (isNaN(x) || isNaN(y)) return x + y;\n    let u = reinterpret<u64>(x);\n    let ix = <u32>(u >> 32);\n    let lx = <u32>u;\n    u = reinterpret<u64>(y);\n    let iy = <u32>(u >> 32);\n    let ly = <u32>u;\n    if ((ix - 0x3FF00000 | lx) == 0) return atan(y);\n    let m = ((iy >> 31) & 1) | ((ix >> 30) & 2);\n    ix = ix & 0x7FFFFFFF;\n    iy = iy & 0x7FFFFFFF;\n    if ((iy | ly) == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  PI;\n        case 3: return -PI;\n      }\n    }\n    if ((ix | lx) == 0) return m & 1 ? -PI / 2 : PI / 2;\n    if (ix == 0x7FF00000) {\n      if (iy == 0x7FF00000) {\n        let t = m & 2 ? 3 * PI / 4 : PI / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t = m & 2 ? PI : 0;\n        return m & 1 ? -t : t;\n      }\n    }\n    let z: f64;\n    if (ix + (64 << 20) < iy || iy == 0x7FF00000) return m & 1 ? -PI / 2 : PI / 2;\n    if ((m & 2) && iy + (64 << 20) < ix) z = 0;\n    else z = atan(builtin_abs<f64>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return PI - (z - pi_lo);\n      case 3: return (z - pi_lo) - PI;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f64): f64 { // see: musl/src/math/cbrt.c and SUN COPYRIGHT NOTICE above\n    const\n      B1     = <u32>715094163,\n      B2     = <u32>696219795,\n      P0     = reinterpret<f64>(0x3FFE03E60F61E692), //  1.87595182427177009643\n      P1     = reinterpret<f64>(0xBFFE28E092F02420), // -1.88497979543377169875\n      P2     = reinterpret<f64>(0x3FF9F1604A49D6C2), //  1.621429720105354466140\n      P3     = reinterpret<f64>(0xBFE844CBBEE751D9), // -0.758397934778766047437\n      P4     = reinterpret<f64>(0x3FC2B000D4E4EDD7), //  0.145996192886612446982\n      Ox1p54 = reinterpret<f64>(0x4350000000000000); //  0x1p54\n\n    let u = reinterpret<u64>(x);\n    let hx = <u32>(u >> 32) & 0x7FFFFFFF;\n    if (hx >= 0x7FF00000) return x + x;\n    if (hx < 0x00100000) {\n      u = reinterpret<u64>(x * Ox1p54);\n      hx = <u32>(u >> 32) & 0x7FFFFFFF;\n      if (hx == 0) return x;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 1 << 63;\n    u |= <u64>hx << 32;\n    let t = reinterpret<f64>(u);\n    let r = (t * t) * (t / x);\n    t = t * ((P0 + r * (P1 + r * P2)) + ((r * r) * r) * (P3 + r * P4));\n    t = reinterpret<f64>((reinterpret<u64>(t) + 0x80000000) & 0xFFFFFFFFC0000000);\n    let s = t * t;\n    r = x / s;\n    r = (r - t) / (2 * t + r);\n    t = t + t * r;\n    return t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f64): f64 {\n    return builtin_ceil<f64>(x);\n  }\n\n  export function clz32(x: f64): f64 {\n    if (!isFinite(x)) return 32;\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    return builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f64): f64 { // see: musl/src/math/cos.c\n    let u  = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >> 31;\n\n    ux &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ux <= 0x3FE921FB) {\n      if (ux < 0x3E46A09E) {  // |x| < 2**-27 * sqrt(2)\n        return 1.0;\n      }\n      return cos_kern(x, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    let n  = rempio2(x, u, sign);\n    let y0 = rempio2_y0;\n    let y1 = rempio2_y1;\n\n    x = n & 1 ? sin_kern(y0, y1, 1) : cos_kern(y0, y1);\n    return (n + 1) & 2 ? -x : x;\n  }\n\n  export function cosh(x: f64): f64 { // see: musl/src/math/cosh.c\n    let u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    x = reinterpret<f64>(u);\n    let w = <u32>(u >> 32);\n    let t: f64;\n    if (w < 0x3FE62E42) {\n      if (w < 0x3FF00000 - (26 << 20)) return 1;\n      t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (w < 0x40862E42) {\n      t = exp(x);\n      return 0.5 * (t + 1 / t);\n    }\n    t = expo2(x, 1);\n    return t;\n  }\n\n  export function exp(x: f64): f64 { // see: musl/src/math/exp.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return exp_lut(x);\n    } else {\n      const\n        ln2hi     = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n        ln2lo     = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n        invln2    = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        P1        = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2        = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3        = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4        = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5        = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        overflow  = reinterpret<f64>(0x40862E42FEFA39EF), //  709.782712893383973096\n        underflow = reinterpret<f64>(0xC0874910D52D3051), // -745.13321910194110842\n        Ox1p1023  = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\n\n      let hx = u32(reinterpret<u64>(x) >> 32);\n      let sign = hx >> 31;\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x4086232B) {\n        if (isNaN(x)) return x;\n        if (x > overflow)  return x * Ox1p1023;\n        if (x < underflow) return 0;\n      }\n      let hi: f64, lo: f64 = 0;\n      let k = 0;\n      if (hx > 0x3FD62E42) {\n        if (hx >= 0x3FF0A2B2) {\n          k = i32(invln2 * x + builtin_copysign<f64>(0.5, x));\n        } else {\n          k = 1 - (sign << 1);\n        }\n        hi = x - k * ln2hi;\n        lo = k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x3E300000) {\n        hi = x;\n      } else return 1.0 + x;\n      let xs = x * x;\n      // let c = x - xp2 * (P1 + xp2 * (P2 + xp2 * (P3 + xp2 * (P4 + xp2 * P5))));\n      let xq = xs * xs;\n      let c = x - (xs * P1 + xq * ((P2 + xs * P3) + xq * (P4 + xs * P5)));\n      let y = 1.0 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f64): f64 {\n    return exp2_lut(x);\n  }\n\n  export function expm1(x: f64): f64 { // see: musl/src/math/expm1.c and SUN COPYRIGHT NOTICE above\n    const\n      o_threshold = reinterpret<f64>(0x40862E42FEFA39EF), //  7.09782712893383973096e+02\n      ln2_hi      = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n      ln2_lo      = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n      invln2      = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      Q1          = reinterpret<f64>(0xBFA11111111110F4), // -3.33333333333331316428e-02\n      Q2          = reinterpret<f64>(0x3F5A01A019FE5585), //  1.58730158725481460165e-03\n      Q3          = reinterpret<f64>(0xBF14CE199EAADBB7), // -7.93650757867487942473e-05\n      Q4          = reinterpret<f64>(0x3ED0CFCA86E65239), //  4.00821782732936239552e-06\n      Q5          = reinterpret<f64>(0xBE8AFDB76E09C32D), // -2.01099218183624371326e-07\n      Ox1p1023    = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\n\n    let u = reinterpret<u64>(x);\n    let hx = u32(u >> 32) & 0x7FFFFFFF;\n    let sign = u32(u >> 63);\n    let k = 0;\n    if (hx >= 0x4043687A) {\n      if (isNaN(x)) return x;\n      if (sign) return -1;\n      if (x > o_threshold) return x * Ox1p1023;\n    }\n    let c = 0.0, t: f64;\n    if (hx > 0x3FD62E42) {\n      k = select<i32>(\n        1 - (sign << 1),\n        i32(invln2 * x + builtin_copysign<f64>(0.5, x)),\n        hx < 0x3FF0A2B2\n      );\n      t = <f64>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x3C900000) return x;\n    let hfx = 0.5 * x;\n    let hxs = x * hfx;\n    // let r1 = 1.0 + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));\n    let hxq = hxs * hxs;\n    let r1 = (1.0 + hxs * Q1) + hxq * ((Q2 + hxs * Q3) + hxq * (Q4 + hxs * Q5));\n    t = 3.0 - r1 * hfx;\n    let e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x3FF + k) << 52;\n    let twopk = reinterpret<f64>(u);\n    let y: f64;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 1024) y = y * 2.0 * Ox1p1023;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x3FF - k) << 52;\n    y = reinterpret<f64>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f64): f64 {\n    return builtin_floor<f64>(x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f64): f64 {\n    return <f32>x;\n  }\n\n  export function hypot(x: f64, y: f64): f64 { // see: musl/src/math/hypot.c\n    const\n      SPLIT    = reinterpret<f64>(0x41A0000000000000) + 1, // 0x1p27 + 1\n      Ox1p700  = reinterpret<f64>(0x6BB0000000000000),\n      Ox1p_700 = reinterpret<f64>(0x1430000000000000);\n\n    let ux = reinterpret<u64>(x);\n    let uy = reinterpret<u64>(y);\n    ux &= 0x7FFFFFFFFFFFFFFF;\n    uy &= 0x7FFFFFFFFFFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    let ex = i32(ux >> 52);\n    let ey = i32(uy >> 52);\n    y = reinterpret<f64>(uy);\n    if (ey == 0x7FF) return y;\n    x = reinterpret<f64>(ux);\n    if (ex == 0x7FF || uy == 0) return x;\n    if (ex - ey > 64) return x + y;\n    let z = 1.0;\n    if (ex > 0x3FF + 510) {\n      z  = Ox1p700;\n      x *= Ox1p_700;\n      y *= Ox1p_700;\n    } else if (ey < 0x3FF - 450) {\n      z  = Ox1p_700;\n      x *= Ox1p700;\n      y *= Ox1p700;\n    }\n    let c = x * SPLIT;\n    let h = x - c + c;\n    let l = x - h;\n    let hx = x * x;\n    let lx = h * h - hx + (2 * h + l) * l;\n    c = y * SPLIT;\n    h = y - c + c;\n    l = y - h;\n    let hy = y * y;\n    let ly = h * h - hy + (2 * h + l) * l;\n    return z * builtin_sqrt(ly + lx + hy + hx);\n  }\n\n  export function imul(x: f64, y: f64): f64 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return dtoi32(x) * dtoi32(y);\n  }\n\n  export function log(x: f64): f64 { // see: musl/src/math/log.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log_lut(x);\n    } else {\n      const\n        ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n        ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n        Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54 = reinterpret<f64>(0x4350000000000000); // 0x1p54\n\n      let u = reinterpret<u64>(x);\n      let hx = u32(u >> 32);\n      let k = 0;\n      let sign = hx >> 31;\n      if (sign || hx < 0x00100000) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = u32(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += (<i32>hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let dk = <f64>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f64): f64 { // see: musl/src/math/log10.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f64>(0x3FDBCB7B15200000), // 4.34294481878168880939e-01\n      ivln10lo  = reinterpret<f64>(0x3DBB9438CA9AADD5), // 2.50829467116452752298e-11\n      log10_2hi = reinterpret<f64>(0x3FD34413509F6000), // 3.01029995663611771306e-01\n      log10_2lo = reinterpret<f64>(0x3D59FEF311F12B36), // 3.69423907715893078616e-13\n      Lg1       = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2       = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3       = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4       = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5       = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6       = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7       = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54    = reinterpret<f64>(0x4350000000000000); // 0x1p54\n\n    let u = reinterpret<u64>(x);\n    let hx = u32(u >> 32);\n    let k = 0;\n    let sign = hx >> 31;\n    if (sign || hx < 0x00100000) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (sign) return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = u32(u >> 32);\n    } else if (hx >= 0x7FF00000) {\n      return x;\n    } else if (hx == 0x3FF00000 && u << 32 == 0) {\n      return 0;\n    }\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += i32(hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    let f = x - 1.0;\n    let hfsq = 0.5 * f * f;\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    let r = t2 + t1;\n    let hi = f - hfsq;\n    u = reinterpret<u64>(hi);\n    u &= 0xFFFFFFFF00000000;\n    hi = reinterpret<f64>(u);\n    let lo = f - hi - hfsq + s * (hfsq + r);\n    let val_hi = hi * ivln10hi;\n    let dk = <f64>k;\n    let y = dk * log10_2hi;\n    let val_lo = dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi;\n    w = y + val_hi;\n    val_lo += (y - w) + val_hi;\n    return val_lo + w;\n  }\n\n  export function log1p(x: f64): f64 { // see: musl/src/math/log1p.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244); // 1.479819860511658591e-01\n\n    let u = reinterpret<u64>(x);\n    let hx = u32(u >> 32);\n    let k = 1;\n    let c = 0.0, f = 0.0;\n    if (hx < 0x3FDA827A || bool(hx >> 31)) {\n      if (hx >= 0xBFF00000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (hx << 1 < 0x3CA00000 << 1) return x;\n      if (hx <= 0xBFD2BEC4) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (hx >= 0x7FF00000) return x;\n    if (k) {\n      u = reinterpret<u64>(1 + x);\n      let hu = u32(u >> 32);\n      hu += 0x3FF00000 - 0x3FE6A09E;\n      k = i32(hu >> 20) - 0x3FF;\n      if (k < 54) {\n        let uf = reinterpret<f64>(u);\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      hu = (hu & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hu << 32 | (u & 0xFFFFFFFF);\n      f = reinterpret<f64>(u) - 1;\n    }\n    let hfsq = 0.5 * f * f;\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    let r = t2 + t1;\n    let dk = <f64>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f64): f64 { // see: musl/src/math/log2.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f64>(0x3FF7154765200000), // 1.44269504072144627571e+00\n        ivln2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 1.67517131648865118353e-10\n        Lg1     = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2     = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3     = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4     = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5     = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6     = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7     = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54  = reinterpret<f64>(0x4350000000000000); // 1p54\n\n      let u = reinterpret<u64>(x);\n      let hx = u32(u >> 32);\n      let k = 0;\n      let sign = hx >> 31;\n      if (sign || hx < 0x00100000) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = u32(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += i32(hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let hi = f - hfsq;\n      u = reinterpret<u64>(hi);\n      u &= 0xFFFFFFFF00000000;\n      hi = reinterpret<f64>(u);\n      let lo = f - hi - hfsq + s * (hfsq + r);\n      let val_hi = hi * ivln2hi;\n      let val_lo = (lo + hi) * ivln2lo + lo * ivln2hi;\n      let y = <f64>k;\n      w = y + val_hi;\n      val_lo += (y - w) + val_hi;\n      val_hi = w;\n      return val_lo + val_hi;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f64, value2: f64): f64 {\n    return builtin_max<f64>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f64, value2: f64): f64 {\n    return builtin_min<f64>(value1, value2);\n  }\n\n  export function pow(x: f64, y: f64): f64 { // see: musl/src/math/pow.c and SUN COPYRIGHT NOTICE above\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\n    if (builtin_abs<f64>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f64>(\n          builtin_abs<f64>(builtin_sqrt<f64>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      return pow_lut(x, y);\n    } else {\n      const\n        dp_h1   = reinterpret<f64>(0x3FE2B80340000000), //  5.84962487220764160156e-01\n        dp_l1   = reinterpret<f64>(0x3E4CFDEB43CFD006), //  1.35003920212974897128e-08\n        two53   = reinterpret<f64>(0x4340000000000000), //  9007199254740992.0\n        huge    = reinterpret<f64>(0x7E37E43C8800759C), //  1e+300\n        tiny    = reinterpret<f64>(0x01A56E1FC2F8F359), //  1e-300\n        L1      = reinterpret<f64>(0x3FE3333333333303), //  5.99999999999994648725e-01\n        L2      = reinterpret<f64>(0x3FDB6DB6DB6FABFF), //  4.28571428578550184252e-01\n        L3      = reinterpret<f64>(0x3FD55555518F264D), //  3.33333329818377432918e-01\n        L4      = reinterpret<f64>(0x3FD17460A91D4101), //  2.72728123808534006489e-01\n        L5      = reinterpret<f64>(0x3FCD864A93C9DB65), //  2.30660745775561754067e-01\n        L6      = reinterpret<f64>(0x3FCA7E284A454EEF), //  2.06975017800338417784e-01\n        P1      = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2      = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3      = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4      = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5      = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        lg2     = reinterpret<f64>(0x3FE62E42FEFA39EF), //  6.93147180559945286227e-01\n        lg2_h   = reinterpret<f64>(0x3FE62E4300000000), //  6.93147182464599609375e-01\n        lg2_l   = reinterpret<f64>(0xBE205C610CA86C39), // -1.90465429995776804525e-09\n        ovt     = reinterpret<f64>(0x3C971547652B82FE), //  8.0085662595372944372e-017\n        cp      = reinterpret<f64>(0x3FEEC709DC3A03FD), //  9.61796693925975554329e-01\n        cp_h    = reinterpret<f64>(0x3FEEC709E0000000), //  9.61796700954437255859e-01\n        cp_l    = reinterpret<f64>(0xBE3E2FE0145B01F5), // -7.02846165095275826516e-09\n        ivln2   = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        ivln2_h = reinterpret<f64>(0x3FF7154760000000), //  1.44269502162933349609e+00\n        ivln2_l = reinterpret<f64>(0x3E54AE0BF85DDF44), //  1.92596299112661746887e-08\n        inv3    = reinterpret<f64>(0x3FD5555555555555); //  0.3333333333333333333333\n\n      let u_ = reinterpret<u64>(x);\n      let hx = i32(u_ >> 32);\n      let lx = <u32>u_;\n      u_ = reinterpret<u64>(y);\n      let hy = i32(u_ >> 32);\n      let ly = <u32>u_;\n      let ix = hx & 0x7FFFFFFF;\n      let iy = hy & 0x7FFFFFFF;\n      if ((iy | ly) == 0) return 1.0; // x**0 = 1, even if x is NaN\n      // if (hx == 0x3FF00000 && lx == 0) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\n      if ( // NaN if either arg is NaN\n        ix > 0x7FF00000 || (ix == 0x7FF00000 && lx != 0) ||\n        iy > 0x7FF00000 || (iy == 0x7FF00000 && ly != 0)\n      ) return x + y;\n      let yisint = 0, k: i32;\n      if (hx < 0) {\n        if (iy >= 0x43400000) yisint = 2;\n        else if (iy >= 0x3FF00000) {\n          k = (iy >> 20) - 0x3FF;\n          let offset = select<u32>(52, 20, k > 20) - k;\n          let Ly = select<u32>(ly, iy, k > 20);\n          let jj = Ly >> offset;\n          if ((jj << offset) == Ly) yisint = 2 - (jj & 1);\n        }\n      }\n      if (ly == 0) {\n        if (iy == 0x7FF00000) { // y is +-inf\n          if (((ix - 0x3FF00000) | lx) == 0) return NaN; // C: (-1)**+-inf is 1, JS: NaN\n          else if (ix >= 0x3FF00000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\n          else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\n        }\n        if (iy == 0x3FF00000) {\n          if (hy >= 0) return x;\n          return 1 / x;\n        }\n        if (hy == 0x40000000) return x * x;\n        if (hy == 0x3FE00000) {\n          if (hx >= 0) return builtin_sqrt(x);\n        }\n      }\n      let ax = builtin_abs<f64>(x), z: f64;\n      if (lx == 0) {\n        if (ix == 0 || ix == 0x7FF00000 || ix == 0x3FF00000) {\n          z = ax;\n          if (hy < 0) z = 1.0 / z;\n          if (hx < 0) {\n            if (((ix - 0x3FF00000) | yisint) == 0) {\n              let d = z - z;\n              z = d / d;\n            } else if (yisint == 1) z = -z;\n          }\n          return z;\n        }\n      }\n      let s = 1.0;\n      if (hx < 0) {\n        if (yisint == 0) {\n          let d = x - x;\n          return d / d;\n        }\n        if (yisint == 1) s = -1.0;\n      }\n      let t1: f64, t2: f64, p_h: f64, p_l: f64, r: f64, t: f64, u: f64, v: f64, w: f64;\n      let j: i32, n: i32;\n      if (iy > 0x41E00000) {\n        if (iy > 0x43F00000) {\n          if (ix <= 0x3FEFFFFF) return hy < 0 ? huge * huge : tiny * tiny;\n          if (ix >= 0x3FF00000) return hy > 0 ? huge * huge : tiny * tiny;\n        }\n        if (ix < 0x3FEFFFFF) return hy < 0 ? s * huge * huge : s * tiny * tiny;\n        if (ix > 0x3FF00000) return hy > 0 ? s * huge * huge : s * tiny * tiny;\n        t = ax - 1.0;\n        w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\n        u = ivln2_h * t;\n        v = t * ivln2_l - w * ivln2;\n        t1 = u + v;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = v - (t1 - u);\n      } else {\n        let ss: f64, s2: f64, s_h: f64, s_l: f64, t_h: f64, t_l: f64;\n        n = 0;\n        if (ix < 0x00100000) {\n          ax *= two53;\n          n -= 53;\n          ix = <u32>(reinterpret<u64>(ax) >> 32);\n        }\n        n += (ix >> 20) - 0x3FF;\n        j = ix & 0x000FFFFF;\n        ix = j | 0x3FF00000;\n        if (j <= 0x3988E) k = 0;\n        else if (j < 0xBB67A) k = 1;\n        else {\n          k = 0;\n          n += 1;\n          ix -= 0x00100000;\n        }\n        ax = reinterpret<f64>(reinterpret<u64>(ax) & 0xFFFFFFFF | (<u64>ix << 32));\n        let bp = select<f64>(1.5, 1.0, k); // k ? 1.5 : 1.0\n        u = ax - bp;\n        v = 1.0 / (ax + bp);\n        ss = u * v;\n        s_h = ss;\n        s_h = reinterpret<f64>(reinterpret<u64>(s_h) & 0xFFFFFFFF00000000);\n        t_h = reinterpret<f64>(u64(((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18)) << 32);\n        t_l = ax - (t_h - bp);\n        s_l = v * ((u - s_h * t_h) - s_h * t_l);\n        s2 = ss * ss;\n        r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\n        r += s_l * (s_h + ss);\n        s2 = s_h * s_h;\n        t_h = 3.0 + s2 + r;\n        t_h = reinterpret<f64>(reinterpret<u64>(t_h) & 0xFFFFFFFF00000000);\n        t_l = r - ((t_h - 3.0) - s2);\n        u = s_h * t_h;\n        v = s_l * t_h + t_l * ss;\n        p_h = u + v;\n        p_h = reinterpret<f64>(reinterpret<u64>(p_h) & 0xFFFFFFFF00000000);\n        p_l = v - (p_h - u);\n        let z_h = cp_h * p_h;\n        let dp_l = select<f64>(dp_l1, 0.0, k);\n        let z_l = cp_l * p_h + p_l * cp + dp_l;\n        t = <f64>n;\n        let dp_h = select<f64>(dp_h1, 0.0, k);\n        t1 = ((z_h + z_l) + dp_h) + t;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = z_l - (((t1 - t) - dp_h) - z_h);\n      }\n      let y1 = y;\n      y1 = reinterpret<f64>(reinterpret<u64>(y1) & 0xFFFFFFFF00000000);\n      p_l = (y - y1) * t1 + y * t2;\n      p_h = y1 * t1;\n      z = p_l + p_h;\n      u_ = reinterpret<u64>(z);\n      j = u32(u_ >> 32);\n      let i = <i32>u_;\n      if (j >= 0x40900000) {\n        if (((j - 0x40900000) | i) != 0) return s * huge * huge;\n        if (p_l + ovt > z - p_h) return s * huge * huge;\n      } else if ((j & 0x7FFFFFFF) >= 0x4090CC00) {\n        if (((j - 0xC090CC00) | i) != 0) return s * tiny * tiny;\n        if (p_l <= z - p_h) return s * tiny * tiny;\n      }\n      i = j & 0x7FFFFFFF;\n      k = (i >> 20) - 0x3FF;\n      n = 0;\n      if (i > 0x3FE00000) {\n        n = j + (0x00100000 >> (k + 1));\n        k = ((n & 0x7FFFFFFF) >> 20) - 0x3FF;\n        t = 0.0;\n        t = reinterpret<f64>(u64(n & ~(0x000FFFFF >> k)) << 32);\n        n = ((n & 0x000FFFFF) | 0x00100000) >> (20 - k);\n        if (j < 0) n = -n;\n        p_h -= t;\n      }\n      t = p_l + p_h;\n      t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n      u = t * lg2_h;\n      v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\n      z = u + v;\n      w = v - (z - u);\n      t = z * z;\n      t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\n      r = (z * t1) / (t1 - 2.0) - (w + z * w);\n      z = 1.0 - (r - z);\n      j = u32(reinterpret<u64>(z) >> 32);\n      j += n << 20;\n      if ((j >> 20) <= 0) z = scalbn(z, n);\n      else z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF | (<u64>j << 32));\n      return s * z;\n    }\n  }\n\n  export function seedRandom(value: i64): void {\n    // Instead zero seed use golden ratio:\n    // phi = (1 + sqrt(5)) / 2\n    // trunc(2^64 / phi) = 0x9e3779b97f4a7c15\n    if (value == 0) value = 0x9e3779b97f4a7c15;\n    random_state0_64 = murmurHash3(value);\n    random_state1_64 = murmurHash3(~random_state0_64);\n    random_state0_32 = splitMix32(<u32>value);\n    random_state1_32 = splitMix32(random_state0_32);\n    random_seeded = true;\n  }\n\n  export function random(): f64 { // see: v8/src/base/utils/random-number-generator.cc\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n    let s1 = random_state0_64;\n    let s0 = random_state1_64;\n    random_state0_64 = s0;\n    s1 ^= s1 << 23;\n    s1 ^= s1 >> 17;\n    s1 ^= s0;\n    s1 ^= s0 >> 26;\n    random_state1_64 = s1;\n    let r = (s0 >> 12) | 0x3FF0000000000000;\n    return reinterpret<f64>(r) - 1;\n  }\n\n  export function round(x: f64): f64 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_ceil<f64>(x) - f64(builtin_ceil<f64>(x) - 0.5 > x);\n    } else {\n      let roundUp = builtin_ceil<f64>(x);\n      return select<f64>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);\n    }\n  }\n\n  export function sign(x: f64): f64 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return select<f64>(builtin_copysign<f64>(1, x), x, builtin_abs(x) > 0);\n    } else {\n      return select<f64>(1, select<f64>(-1, x, x < 0), x > 0);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f64): bool {\n    return bool(reinterpret<u64>(x) >>> 63);\n  }\n\n  export function sin(x: f64): f64 { // see: musl/src/math/sin.c\n    let u  = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >> 31;\n\n    ux &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ux <= 0x3FE921FB) {\n      if (ux < 0x3E500000) { // |x| < 2**-26\n        return x;\n      }\n      return sin_kern(x, 0.0, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    let n  = rempio2(x, u, sign);\n    let y0 = rempio2_y0;\n    let y1 = rempio2_y1;\n\n    x = n & 1 ? cos_kern(y0, y1) : sin_kern(y0, y1, 1);\n    return n & 2 ? -x : x;\n  }\n\n  export function sinh(x: f64): f64 { // see: musl/src/math/sinh.c\n    let u = reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF;\n    let a = reinterpret<f64>(u);\n    let w = u32(u >> 32);\n    let h = builtin_copysign(0.5, x);\n    if (w < 0x40862E42) {\n      let t = expm1(a);\n      if (w < 0x3FF00000) {\n        if (w < 0x3FF00000 - (26 << 20)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2(a, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f64): f64 {\n    return builtin_sqrt<f64>(x);\n  }\n\n  export function tan(x: f64): f64 { // see: musl/src/math/tan.c\n    let u = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >>> 31;\n\n    ux &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ux <= 0x3FE921FB) {\n      if (ux < 0x3E400000) { // |x| < 2**-27\n        return x;\n      }\n      return tan_kern(x, 0.0, 1);\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ux >= 0x7FF00000) return x - x;\n\n    let n = rempio2(x, u, sign);\n    return tan_kern(rempio2_y0, rempio2_y1, 1 - ((n & 1) << 1));\n  }\n\n  export function tanh(x: f64): f64 { // see: musl/src/math/tanh.c\n    let u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    let y = reinterpret<f64>(u);\n    let w = u32(u >> 32);\n    let t: f64;\n    if (w > 0x3FE193EA) {\n      if (w > 0x40340000) {\n        t = 1 - 0 / y;\n      } else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (w > 0x3FD058AE) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (w >= 0x00100000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f64>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f64): f64 {\n    return builtin_trunc<f64>(x);\n  }\n\n  export function scalbn(x: f64, n: i32): f64 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbn.c\n    const\n      Ox1p53    = reinterpret<f64>(0x4340000000000000),\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000),\n      Ox1p_1022 = reinterpret<f64>(0x0010000000000000);\n\n    let y = x;\n    if (n > 1023) {\n      y *= Ox1p1023;\n      n -= 1023;\n      if (n > 1023) {\n        y *= Ox1p1023;\n        n = builtin_min<i32>(n - 1023, 1023);\n      }\n    } else if (n < -1022) {\n      // make sure final n < -53 to avoid double\n      // rounding in the subnormal range\n      y *= Ox1p_1022 * Ox1p53;\n      n += 1022 - 53;\n      if (n < -1022) {\n        y *= Ox1p_1022 * Ox1p53;\n        n = builtin_max<i32>(n + 1022 - 53, -1022);\n      }\n    }\n    return y * reinterpret<f64>(<u64>(0x3FF + n) << 52);\n  }\n\n  export function mod(x: f64, y: f64): f64 { // see: musl/src/math/fmod.c\n    if (builtin_abs<f64>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler's optimization pass.\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\n      return builtin_copysign<f64>(x - builtin_trunc<f64>(x), x);\n    }\n    let ux = reinterpret<u64>(x);\n    let uy = reinterpret<u64>(y);\n    let ex = i64(ux >> 52 & 0x7FF);\n    let ey = i64(uy >> 52 & 0x7FF);\n    let sx = ux >> 63;\n    let uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0x7FF || isNaN<f64>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    let ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      return x * f64(ux1 != uy1);\n    }\n    if (!ex) {\n      ex -= builtin_clz<i64>(ux << 12);\n      ux <<= 1 - ex;\n    } else {\n      ux &= u64(-1) >> 12;\n      ux |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u64(-1) >> 12;\n      uy |= 1 << 52;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 52); ux <<= 1) --ex;\n    let shift = builtin_clz<i64>(ux << 11);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 52;\n      ux |= ex << 52;\n    } else {\n      ux >>= -ex + 1;\n    }\n    return reinterpret<f64>(ux | (sx << 63));\n  }\n\n  export function rem(x: f64, y: f64): f64 { // see: musl/src/math/remquo.c\n    let ux = reinterpret<u64>(x);\n    let uy = reinterpret<u64>(y);\n    let ex = i64(ux >> 52 & 0x7FF);\n    let ey = i64(uy >> 52 & 0x7FF);\n    if (uy << 1 == 0 || ex == 0x7FF || isNaN(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    if (ux << 1 == 0) return x;\n    let uxi = ux;\n    if (!ex) {\n      ex -= builtin_clz<i64>(uxi << 12);\n      uxi <<= 1 - ex;\n    } else {\n      uxi &= u64(-1) >> 12;\n      uxi |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u64(-1) >> 12;\n      uy |= 1 << 52;\n    }\n    let q: u32 = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -60;\n      else {\n        let shift = builtin_clz<i64>(uxi << 11);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 52;\n      uxi |= ex << 52;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f64>(uxi);\n    y = builtin_abs<f64>(y);\n    let x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (x2 > y || (x2 == y && <bool>(q & 1))))) {\n      x -= y;\n      // ++q;\n    }\n    return <i64>ux < 0 ? -x : x;\n  }\n\n  export function sincos(x: f64): void { // see: musl/tree/src/math/sincos.c\n    let u = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3FE921FB) {  // |x| ~<= π/4\n      if (ux < 0x3E46A09E) { // if |x| < 2**-27 * sqrt(2)\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kern(x, 0, 0);\n      sincos_cos = cos_kern(x, 0);\n      return;\n    }\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    let n = rempio2(x, u, sign);\n    let y0 = rempio2_y0;\n    let y1 = rempio2_y1;\n    let s = sin_kern(y0, y1, 1);\n    let c = cos_kern(y0, y1);\n    let sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy let rempio2f_y: f64;\n\n// @ts-ignore: decorator\n@lazy @inline const PIO2F_TABLE = memory.data<u64>([\n  0xA2F9836E4E441529,\n  0xFC2757D1F534DDC0,\n  0xDB6295993C439041,\n  0xFE5163ABDEBBC561\n]);\n\nfunction Rf(z: f32): f32 { // Rational approximation of (asin(x)-x)/x^3\n  const                    // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f32>(0x3E2AAA75), //  1.6666586697e-01f\n    pS1 = reinterpret<f32>(0xBD2F13BA), // -4.2743422091e-02f\n    pS2 = reinterpret<f32>(0xBC0DD36B), // -8.6563630030e-03f\n    qS1 = reinterpret<f32>(0xBF34E5AE); // -7.0662963390e-01f\n\n  let p = z * (pS0 + z * (pS1 + z * pS2));\n  let q: f32 = 1 + z * qS1;\n  return p / q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction expo2f(x: f32, sign: f32): f32 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                                // see: musl/src/math/__expo2f.c\n    k    = <u32>235,\n    kln2 = reinterpret<f32>(0x4322E3BC); // 0x1.45c778p+7f\n  let scale = reinterpret<f32>(u32(0x7F + (k >> 1)) << 23);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMathf.exp(x - kln2) * (sign * scale) * scale;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pio2f_large_quot(x: f32, u: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const coeff = reinterpret<f64>(0x3BF921FB54442D18); // π * 0x1p-65 = 8.51530395021638647334e-20\n\n  let offset = (u >> 23) - 152;\n  let shift  = u64(offset & 63);\n  let tblPtr = PIO2F_TABLE + (offset >> 6 << 3);\n\n  let b0 = load<u64>(tblPtr, 0 << 3);\n  let b1 = load<u64>(tblPtr, 1 << 3);\n  let lo: u64;\n\n  if (shift > 32) {\n    let b2 = load<u64>(tblPtr, 2 << 3);\n    lo  = b2 >> (96 - shift);\n    lo |= b1 << (shift - 32);\n  } else {\n    lo = b1 >> (32 - shift);\n  }\n\n  let hi = (b1 >> (64 - shift)) | (b0 << shift);\n  let mantissa: u64 = (u & 0x007FFFFF) | 0x00800000;\n  let product = mantissa * hi + (mantissa * lo >> 32);\n  let r: i64 = product << 2;\n  let q = i32((product >> 62) + (r >>> 63));\n  rempio2f_y = copysign<f64>(coeff, x) * <f64>r;\n  return q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction rempio2f(x: f32, u: u32, sign: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const\n    pi2hi = reinterpret<f64>(0x3FF921FB50000000), // 1.57079631090164184570\n    pi2lo = reinterpret<f64>(0x3E5110B4611A6263), // 1.58932547735281966916e-8\n    _2_pi = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  if (u < 0x4DC90FDB) { // π * 0x1p28\n    let q = nearest(x * _2_pi);\n    rempio2f_y = x - q * pi2hi - q * pi2lo;\n    return <i32>q;\n  }\n\n  let q = pio2f_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n// |sin(x)/x - s(x)| < 2**-37.5 (~[-4.89e-12, 4.824e-12]).\n// @ts-ignore: decorator\n@inline\nfunction sin_kernf(x: f64): f32 { // see: musl/tree/src/math/__sindf.c\n  const\n    S1 = reinterpret<f64>(0xBFC5555554CBAC77), // -0x15555554cbac77.0p-55\n    S2 = reinterpret<f64>(0x3F811110896EFBB2), //  0x111110896efbb2.0p-59\n    S3 = reinterpret<f64>(0xBF2A00F9E2CAE774), // -0x1a00f9e2cae774.0p-65\n    S4 = reinterpret<f64>(0x3EC6CD878C3B46A7); //  0x16cd878c3b46a7.0p-71\n\n  let z = x * x;\n  let w = z * z;\n  let r = S3 + z * S4;\n  let s = z * x;\n  return f32((x + s * (S1 + z * S2)) + s * w * r);\n}\n\n// |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]).\n// @ts-ignore: decorator\n@inline\nfunction cos_kernf(x: f64): f32 { // see: musl/tree/src/math/__cosdf.c\n  const\n    C0 = reinterpret<f64>(0xBFDFFFFFFD0C5E81), // -0x1ffffffd0c5e81.0p-54\n    C1 = reinterpret<f64>(0x3FA55553E1053A42), //  0x155553e1053a42.0p-57\n    C2 = reinterpret<f64>(0xBF56C087E80F1E27), // -0x16c087e80f1e27.0p-62\n    C3 = reinterpret<f64>(0x3EF99342E0EE5069); //  0x199342e0ee5069.0p-68\n\n  let z = x * x;\n  let w = z * z;\n  let r = C2 + z * C3;\n  return f32(((1 + z * C0) + w * C1) + (w * z) * r);\n}\n\n// |tan(x)/x - t(x)| < 2**-25.5 (~[-2e-08, 2e-08]).\n// @ts-ignore: decorator\n@inline\nfunction tan_kernf(x: f64, odd: i32): f32 { // see: musl/tree/src/math/__tandf.c\n  const\n    T0 = reinterpret<f64>(0x3FD5554D3418C99F), // 0x15554d3418c99f.0p-54\n    T1 = reinterpret<f64>(0x3FC112FD38999F72), // 0x1112fd38999f72.0p-55\n    T2 = reinterpret<f64>(0x3FAB54C91D865AFE), // 0x1b54c91d865afe.0p-57\n    T3 = reinterpret<f64>(0x3F991DF3908C33CE), // 0x191df3908c33ce.0p-58\n    T4 = reinterpret<f64>(0x3F685DADFCECF44E), // 0x185dadfcecf44e.0p-61\n    T5 = reinterpret<f64>(0x3F8362B9BF971BCD); // 0x1362b9bf971bcd.0p-59\n\n  let z = x * x;\n  let r = T4 + z * T5;\n  let t = T2 + z * T3;\n  let w = z * z;\n  let s = z * x;\n  let u = T0 + z * T1;\n\n  r = (x + s * u) + (s * w) * (t + w * r);\n  return f32(odd ? -1 / r : r);\n}\n\n// See: jdh8/metallic/src/math/float/log2f.c and jdh8/metallic/src/math/float/kernel/atanh.h\n// @ts-ignore: decorator\n@inline\nfunction log2f(x: f64): f64 {\n  const\n    log2e = reinterpret<f64>(0x3FF71547652B82FE), // 1.44269504088896340736\n    c0 = reinterpret<f64>(0x3FD555554FD9CAEF),    // 0.33333332822728226129\n    c1 = reinterpret<f64>(0x3FC999A7A8AF4132),    // 0.20000167595436263505\n    c2 = reinterpret<f64>(0x3FC2438D79437030),    // 0.14268654271188685375\n    c3 = reinterpret<f64>(0x3FBE2F663B001C97);    // 0.11791075649681414150\n\n  let i = reinterpret<i64>(x);\n  let exponent = (i - 0x3FE6A09E667F3BCD) >> 52;\n  x = reinterpret<f64>(i - (exponent << 52));\n  x = (x - 1) / (x + 1);\n  let xx = x * x;\n  let y = x + x * xx * (c0 + c1 * xx + (c2 + c3 * xx) * (xx * xx));\n  return (2 * log2e) * y + <f64>exponent;\n}\n\n// See: jdh8/metallic/src/math/float/exp2f.h and jdh8/metallic/blob/master/src/math/float/kernel/exp2f.h\n// @ts-ignore: decorator\n@inline\nfunction exp2f(x: f64): f64 {\n  const\n    c0 = reinterpret<f64>(0x3FE62E4302FCC24A), // 6.931471880289532425e-1\n    c1 = reinterpret<f64>(0x3FCEBFBE07D97B91), // 2.402265108421173406e-1\n    c2 = reinterpret<f64>(0x3FAC6AF6CCFC1A65), // 5.550357105498874537e-2\n    c3 = reinterpret<f64>(0x3F83B29E3CE9AEF6), // 9.618030771171497658e-3\n    c4 = reinterpret<f64>(0x3F55F0896145A89F), // 1.339086685300950937e-3\n    c5 = reinterpret<f64>(0x3F2446C81E384864); // 1.546973499989028719e-4\n\n  if (x < -1022) return 0;\n  if (x >= 1024) return Infinity;\n\n  let n = nearest(x);\n  x -= n;\n  let xx = x * x;\n  let y = 1 + x * (c0 + c1 * x + (c2 + c3 * x) * xx + (c4 + c5 * x) * (xx * xx));\n  return reinterpret<f64>(reinterpret<i64>(y) + (<i64>n << 52));\n}\n\nexport namespace NativeMathf {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = <f32>NativeMath.E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = <f32>NativeMath.LN2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = <f32>NativeMath.LN10;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = <f32>NativeMath.LOG2E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = <f32>NativeMath.LOG10E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = <f32>NativeMath.PI;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = <f32>NativeMath.SQRT1_2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = <f32>NativeMath.SQRT2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_sin: f32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_cos: f32 = 0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function abs(x: f32): f32 {\n    return builtin_abs<f32>(x);\n  }\n\n  export function acos(x: f32): f32 { // see: musl/src/math/acosf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f32>(0x3FC90FDA), // 1.5707962513e+00f\n      pio2_lo   = reinterpret<f32>(0x33A22168), // 7.5497894159e-08f\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\n\n    let hx = reinterpret<u32>(x);\n    let ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3F800000) {\n      if (ix == 0x3F800000) {\n        return select<f32>(2 * pio2_hi + Ox1p_120f, 0, <i32>hx < 0);\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3F000000) {\n      if (ix <= 0x32800000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * Rf(x * x)));\n    }\n    let z: f32, w: f32, s: f32;\n    if (<i32>hx < 0) {\n      // z = (1 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f32>(z);\n      w = Rf(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f32>(z);\n    hx = reinterpret<u32>(s);\n    let df = reinterpret<f32>(hx & 0xFFFFF000);\n    let c = (z - df * df) / (s + df);\n    w = Rf(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f32): f32 { // see: musl/src/math/acoshf.c\n    const s = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    let u = reinterpret<u32>(x);\n    let a = u & 0x7FFFFFFF;\n    if (a < 0x3F800000 + (1 << 23)) { // |x| < 2, invalid if x < 1\n      let xm1 = x - 1;\n      return log1p(xm1 + builtin_sqrt(xm1 * (xm1 + 2)));\n    }\n    if (u < 0x3F800000 + (12 << 23)) { // 2 <= x < 0x1p12\n      return log(2 * x - 1 / (x + builtin_sqrt<f32>(x * x - 1)));\n    }\n    // x >= 0x1p12 or x <= -2 or NaN\n    return log(x) + s;\n  }\n\n  export function asin(x: f32): f32 { // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2      = reinterpret<f32>(0x3FC90FDB), // 1.570796326794896558e+00f\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\n\n    let sx = x;\n    let hx = reinterpret<u32>(x) & 0x7FFFFFFF;\n    if (hx >= 0x3F800000) {\n      if (hx == 0x3F800000) return x * pio2 + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (hx < 0x3F000000) {\n      if (hx < 0x39800000 && hx >= 0x00800000) return x;\n      return x + x * Rf(x * x);\n    }\n    // let z: f32 = (1 - builtin_abs<f32>(x)) * 0.5;\n    let z: f32 = 0.5 - builtin_abs<f32>(x) * 0.5;\n    let s = builtin_sqrt<f64>(z); // sic\n    x = f32(pio2 - 2 * (s + s * Rf(z)));\n    return builtin_copysign(x, sx);\n  }\n\n  export function asinh(x: f32): f32 { // see: musl/src/math/asinhf.c\n    const c = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    let u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    let y = reinterpret<f32>(u);\n    if (u >= 0x3F800000 + (12 << 23)) y = log(y) + c;\n    else if (u >= 0x3F800000 + (1 << 23))  y =   log(2 * y + 1 / (builtin_sqrt<f32>(y * y + 1) + y));\n    else if (u >= 0x3F800000 - (12 << 23)) y = log1p(y + y * y / (builtin_sqrt<f32>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f32): f32 { // see: musl/src/math/atanf.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f32>(0x3EED6338), //  4.6364760399e-01f\n      atanhi1   = reinterpret<f32>(0x3F490FDA), //  7.8539812565e-01f\n      atanhi2   = reinterpret<f32>(0x3F7B985E), //  9.8279368877e-01f\n      atanhi3   = reinterpret<f32>(0x3FC90FDA), //  1.5707962513e+00f\n      atanlo0   = reinterpret<f32>(0x31AC3769), //  5.0121582440e-09f\n      atanlo1   = reinterpret<f32>(0x33222168), //  3.7748947079e-08f\n      atanlo2   = reinterpret<f32>(0x33140FB4), //  3.4473217170e-08f\n      atanlo3   = reinterpret<f32>(0x33A22168), //  7.5497894159e-08f\n      aT0       = reinterpret<f32>(0x3EAAAAA9), //  3.3333328366e-01f\n      aT1       = reinterpret<f32>(0xBE4CCA98), // -1.9999158382e-01f\n      aT2       = reinterpret<f32>(0x3E11F50D), //  1.4253635705e-01f\n      aT3       = reinterpret<f32>(0xBDDA1247), // -1.0648017377e-01f\n      aT4       = reinterpret<f32>(0x3D7CAC25), //  6.1687607318e-02f\n      Ox1p_120f = reinterpret<f32>(0x03800000); //  0x1p-120f\n\n    let ix = reinterpret<u32>(x);\n    let sx = x;\n    ix &= 0x7FFFFFFF;\n    let z: f32;\n    if (ix >= 0x4C800000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign(z, sx);\n    }\n    let id: i32;\n    if (ix < 0x3EE00000) {\n      if (ix < 0x39800000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f32>(x);\n      if (ix < 0x3F980000) {\n        if (ix < 0x3F300000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x401C0000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    let w = z * z;\n    let s1 = z * (aT0 + w * (aT2 + w * aT4));\n    let s2 = w * (aT1 + w * aT3);\n    let s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign(z, sx);\n  }\n\n  export function atanh(x: f32): f32 { // see: musl/src/math/atanhf.c\n    let u = reinterpret<u32>(x);\n    let y = builtin_abs(x);\n    if (u < 0x3F800000 - (1 << 23)) {\n      if (u >= 0x3F800000 - (32 << 23)) y = 0.5 * log1p(2 * y * (1.0 + y / (1 - y)));\n    } else y = 0.5 * log1p(2 * (y / (1 - y)));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan2(y: f32, x: f32): f32 { // see: musl/src/math/atan2f.c and SUN COPYRIGHT NOTICE above\n    const\n      pi    = reinterpret<f32>(0x40490FDB), //  3.1415927410e+00f\n      pi_lo = reinterpret<f32>(0xB3BBBD2E); // -8.7422776573e-08f\n\n    if (isNaN(x) || isNaN(y)) return x + y;\n    let ix = reinterpret<u32>(x);\n    let iy = reinterpret<u32>(y);\n    if (ix == 0x3F800000) return atan(y);\n    let m = u32(((iy >> 31) & 1) | ((ix >> 30) & 2));\n    ix &= 0x7FFFFFFF;\n    iy &= 0x7FFFFFFF;\n    if (iy == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  pi;\n        case 3: return -pi;\n      }\n    }\n    if (ix == 0) return m & 1 ? -pi / 2 : pi / 2;\n    if (ix == 0x7F800000) {\n      if (iy == 0x7F800000) {\n        let t: f32 = m & 2 ? 3 * pi / 4 : pi / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t: f32 = m & 2 ? pi : 0.0;\n        return m & 1 ? -t : t;\n      }\n    }\n    if (ix + (26 << 23) < iy || iy == 0x7F800000) return m & 1 ? -pi / 2 : pi / 2;\n    let z: f32;\n    if ((m & 2) && iy + (26 << 23) < ix) z = 0.0;\n    else z = atan(builtin_abs<f32>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return pi - (z - pi_lo);\n      case 3: return (z - pi_lo) - pi;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f32): f32 { // see: musl/src/math/cbrtf.c and SUN COPYRIGHT NOTICE above\n    const\n      B1      = <u32>709958130,\n      B2      = <u32>642849266,\n      Ox1p24f = reinterpret<f32>(0x4B800000);\n\n    let u = reinterpret<u32>(x);\n    let hx = u & 0x7FFFFFFF;\n    if (hx >= 0x7F800000) return x + x;\n    if (hx < 0x00800000) {\n      if (hx == 0) return x;\n      u = reinterpret<u32>(x * Ox1p24f);\n      hx = u & 0x7FFFFFFF;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 0x80000000;\n    u |= hx;\n    let t = <f64>reinterpret<f32>(u);\n    let r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    return <f32>t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f32): f32 {\n    return builtin_ceil<f32>(x);\n  }\n\n  export function clz32(x: f32): f32 {\n    if (!isFinite(x)) return 32;\n    return <f32>builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f32): f32 { // see: musl/src/math/cosf.c\n    const\n      c1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\n      c2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\n      c3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\n      c4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        // raise inexact if x != 0\n        return 1;\n      }\n      return cos_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {  // |x| ~<= 5π/4\n        if (ux > 0x4016CBE3) { // |x|  ~> 3π/4\n          return -cos_kernf(sign ? x + c2pio2 : x - c2pio2);\n        } else {\n          return sign ? sin_kernf(x + c1pio2) : sin_kernf(c1pio2 - x);\n        }\n      }\n      if (ux <= 0x40E231D5) {  // |x| ~<= 9π/4\n        if (ux > 0x40AFEDDF) { // |x|  ~> 7π/4\n          return cos_kernf(sign ? x + c4pio2 : x - c4pio2);\n        } else {\n          return sign ? sin_kernf(-x - c3pio2) : sin_kernf(x - c3pio2);\n        }\n      }\n    }\n\n    // cos(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) return x - x;\n\n    // general argument reduction needed\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n\n    let t = n & 1 ? sin_kernf(y) : cos_kernf(y);\n    return (n + 1) & 2 ? -t : t;\n  }\n\n  export function cosh(x: f32): f32 { // see: musl/src/math/coshf.c\n    let u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    x = reinterpret<f32>(u);\n    if (u < 0x3F317217) {\n      if (u < 0x3F800000 - (12 << 23)) return 1;\n      let t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (u < 0x42B17217) {\n      let t = exp(x);\n      // return 0.5 * (t + 1 / t);\n      return 0.5 * t + 0.5 / t;\n    }\n    return expo2f(x, 1);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f32): f32 {\n    return builtin_floor<f32>(x);\n  }\n\n  export function exp(x: f32): f32 { // see: musl/src/math/expf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return expf_lut(x);\n    } else {\n      const\n        ln2hi    = reinterpret<f32>(0x3F317200), //  6.9314575195e-1f\n        ln2lo    = reinterpret<f32>(0x35BFBE8E), //  1.4286067653e-6f\n        invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+0f\n        P1       = reinterpret<f32>(0x3E2AAA8F), //  1.6666625440e-1f\n        P2       = reinterpret<f32>(0xBB355215), // -2.7667332906e-3f\n        Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\n\n      let hx = reinterpret<u32>(x);\n      let sign = hx >> 31;\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x42AEAC50) {\n        if (hx > 0x7F800000) return x; // NaN\n        if (hx >= 0x42B17218) {\n          if (!sign) return x * Ox1p127f;\n          else if (hx >= 0x42CFF1B5) return 0;\n        }\n      }\n      let hi: f32, lo: f32;\n      let k: i32;\n      if (hx > 0x3EB17218) {\n        if (hx > 0x3F851592) {\n          k = i32(invln2 * x + builtin_copysign<f32>(0.5, x));\n        } else {\n          k = 1 - (sign << 1);\n        }\n        hi = x - <f32>k * ln2hi;\n        lo = <f32>k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x39000000) {\n        k = 0;\n        hi = x;\n        lo = 0;\n      } else {\n        return 1 + x;\n      }\n      let xx = x * x;\n      let c = x - xx * (P1 + xx * P2);\n      let y: f32 = 1 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f32): f32 {\n    return exp2f_lut(x);\n  }\n\n  export function expm1(x: f32): f32 { // see: musl/src/math/expm1f.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi   = reinterpret<f32>(0x3F317180), //  6.9313812256e-01f\n      ln2_lo   = reinterpret<f32>(0x3717F7D1), //  9.0580006145e-06f\n      invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00f\n      Q1       = reinterpret<f32>(0xBD088868), // -3.3333212137e-02f\n      Q2       = reinterpret<f32>(0x3ACF3010), //  1.5807170421e-03f\n      Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\n\n    let u = reinterpret<u32>(x);\n    let hx = u & 0x7FFFFFFF;\n    let sign = u >> 31;\n    if (hx >= 0x4195B844) {\n      if (hx > 0x7F800000) return x;\n      if (sign) return -1;\n      if (hx > 0x42B17217) { // x > log(FLT_MAX)\n        x *= Ox1p127f;\n        return x;\n      }\n    }\n    let c: f32 = 0.0, t: f32, k: i32;\n    if (hx > 0x3EB17218) {\n      k = select<i32>(\n        1 - (sign << 1),\n        i32(invln2 * x + builtin_copysign<f32>(0.5, x)),\n        hx < 0x3F851592\n      );\n      t = <f32>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x33000000) {\n      return x;\n    } else k = 0;\n    let hfx: f32 = 0.5 * x;\n    let hxs: f32 = x * hfx;\n    let r1: f32 = 1.0 + hxs * (Q1 + hxs * Q2);\n    t  = 3.0 - r1 * hfx;\n    let e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e  = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x7F + k) << 23;\n    let twopk = reinterpret<f32>(u);\n    let y: f32;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 128) y = y * 2.0 * Ox1p127f;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x7F - k) << 23;\n    y = reinterpret<f32>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f32): f32 {\n    return x;\n  }\n\n  export function hypot(x: f32, y: f32): f32 { // see: musl/src/math/hypotf.c\n    const\n      Ox1p90f  = reinterpret<f32>(0x6C800000),\n      Ox1p_90f = reinterpret<f32>(0x12800000);\n\n    let ux = reinterpret<u32>(x);\n    let uy = reinterpret<u32>(y);\n    ux &= 0x7FFFFFFF;\n    uy &= 0x7FFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    x = reinterpret<f32>(ux);\n    y = reinterpret<f32>(uy);\n    if (uy == 0xFF << 23) return y;\n    if (ux >= 0xFF << 23 || uy == 0 || ux - uy >= 25 << 23) return x + y;\n    let z: f32 = 1;\n    if (ux >= (0x7F + 60) << 23) {\n      z  = Ox1p90f;\n      x *= Ox1p_90f;\n      y *= Ox1p_90f;\n    } else if (uy < (0x7F - 60) << 23) {\n      z  = Ox1p_90f;\n      x *= Ox1p90f;\n      y *= Ox1p90f;\n    }\n    return z * builtin_sqrt<f32>(f32(<f64>x * x + <f64>y * y));\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function imul(x: f32, y: f32): f32 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return <f32>(dtoi32(x) * dtoi32(y));\n  }\n\n  export function log(x: f32): f32 { // see: musl/src/math/logf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return logf_lut(x);\n    } else {\n      const\n        ln2_hi  = reinterpret<f32>(0x3F317180), // 6.9313812256e-01f\n        ln2_lo  = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06f\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f\n        Lg4     = reinterpret<f32>(0x3E789E26), // 0xf89e26.0p-26f\n        Ox1p25f = reinterpret<f32>(0x4C000000);\n\n      let u = reinterpret<u32>(x);\n      let k = 0;\n      let sign = u >> 31;\n      if (sign || u < 0x00800000) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0;\n        k -= 25;\n        x *= Ox1p25f;\n        u = reinterpret<u32>(x);\n      } else if (u >= 0x7F800000) {\n        return x;\n      } else if (u == 0x3F800000) {\n        return 0;\n      }\n      u += 0x3F800000 - 0x3F3504F3;\n      k += i32(u >> 23) - 0x7F;\n      u = (u & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(u);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq = <f32>0.5 * f * f;\n      let dk = <f32>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f32): f32 { // see: musl/src/math/log10f.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f32>(0x3EDE6000), //  4.3432617188e-01f\n      ivln10lo  = reinterpret<f32>(0xB804EAD9), // -3.1689971365e-05f\n      log10_2hi = reinterpret<f32>(0x3E9A2080), //  3.0102920532e-01f\n      log10_2lo = reinterpret<f32>(0x355427DB), //  7.9034151668e-07f\n      Lg1       = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2       = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n      Lg3       = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n      Lg4       = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n      Ox1p25f   = reinterpret<f32>(0x4C000000); //  0x1p25f\n\n    let ux = reinterpret<u32>(x);\n    let k = 0;\n    let sign = ux >> 31;\n    if (sign || ux < 0x00800000) {\n      if (ux << 1 == 0) return -1 / (x * x);\n      if (sign) return (x - x) / 0.0;\n      k -= 25;\n      x *= Ox1p25f;\n      ux = reinterpret<u32>(x);\n    } else if (ux >= 0x7F800000) {\n      return x;\n    } else if (ux == 0x3F800000) {\n      return 0;\n    }\n    ux += 0x3F800000 - 0x3F3504F3;\n    k += i32(ux >> 23) - 0x7F;\n    ux = (ux & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(ux);\n    let f = x - 1.0;\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * Lg4);\n    let t2 = z * (Lg1 + w * Lg3);\n    let r = t2 + t1;\n    let hfsq: f32 = 0.5 * f * f;\n    let hi = f - hfsq;\n    ux = reinterpret<u32>(hi);\n    ux &= 0xFFFFF000;\n    hi = reinterpret<f32>(ux);\n    let lo = f - hi - hfsq + s * (hfsq + r);\n    let dk = <f32>k;\n    return dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi + hi * ivln10hi + dk * log10_2hi;\n  }\n\n  export function log1p(x: f32): f32 { // see: musl/src/math/log1pf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f32>(0x3F317180), // 6.9313812256e-01\n      ln2_lo = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06\n      Lg1    = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2    = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f, 0.40000972152f\n      Lg3    = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f, 0.28498786688f\n      Lg4    = reinterpret<f32>(0x3E789E26); // 0xf89e26.0p-26f, 0.24279078841f\n\n    let ix = reinterpret<u32>(x);\n    let c: f32 = 0;\n    let f: f32 = 0;\n    let k = 1;\n    if (ix < 0x3ED413D0 || bool(ix >> 31)) {\n      if (ix >= 0xBF800000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (ix << 1 < 0x33800000 << 1) return x;\n      if (ix <= 0xBE95F619) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (ix >= 0x7F800000) return x;\n    if (k) {\n      let uf: f32 = 1 + x;\n      let iu = reinterpret<u32>(uf);\n      iu += 0x3F800000 - 0x3F3504F3;\n      k = i32(iu >> 23) - 0x7F;\n      if (k < 25) {\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      iu = (iu & 0x007FFFFF) + 0x3F3504F3;\n      f = reinterpret<f32>(iu) - 1;\n    }\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * Lg4);\n    let t2 = z * (Lg1 + w * Lg3);\n    let r = t2 + t1;\n    let hfsq: f32 = 0.5 * f * f;\n    let dk = <f32>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f32): f32 { // see: musl/src/math/log2f.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2f_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f32>(0x3FB8B000), //  1.4428710938e+00f\n        ivln2lo = reinterpret<f32>(0xB9389AD4), // -1.7605285393e-04\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n        Lg4     = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n        Ox1p25f = reinterpret<f32>(0x4C000000); //  0x1p25f\n\n      let ux = reinterpret<u32>(x);\n      let k = 0;\n      let sign = ux >> 31;\n      if (sign || ux < 0x00800000) {\n        if (ux << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0.0;\n        k -= 25;\n        x *= Ox1p25f;\n        ux = reinterpret<u32>(x);\n      } else if (ux >= 0x7F800000) {\n        return x;\n      } else if (ux == 0x3F800000) {\n        return 0;\n      }\n      ux += 0x3F800000 - 0x3F3504F3;\n      k += i32(ux >> 23) - 0x7F;\n      ux = (ux & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(ux);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq: f32 = 0.5 * f * f;\n      let hi = f - hfsq;\n      let u = reinterpret<u32>(hi);\n      u &= 0xFFFFF000;\n      hi = reinterpret<f32>(u);\n      let lo: f32 = f - hi - hfsq + s * (hfsq + r);\n      let dk = <f32>k;\n      return (lo + hi) * ivln2lo + lo * ivln2hi + hi * ivln2hi + dk;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f32, value2: f32): f32 {\n    return builtin_max<f32>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f32, value2: f32): f32 {\n    return builtin_min<f32>(value1, value2);\n  }\n\n  export function pow(x: f32, y: f32): f32 {\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\n    if (builtin_abs<f32>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f32>(\n          builtin_abs<f32>(builtin_sqrt<f32>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      // see: musl/src/math/powf.c\n      return powf_lut(x, y);\n    } else {\n      // based on:  jdh8/metallic/src/math/float/powf.c\n      if (y == 0) return 1;\n      // @ts-ignore: cast\n      if (isNaN(x) | isNaN(y)) {\n        return NaN;\n      }\n      let sign: u32 = 0;\n      let uy = reinterpret<u32>(y);\n      let ux = reinterpret<u32>(x);\n      let sx = ux >> 31;\n      ux &= 0x7FFFFFFF;\n      if (sx && nearest(y) == y) {\n        x = -x;\n        sx = 0;\n        sign = u32(nearest(y * 0.5) != y * 0.5) << 31;\n      }\n      let m: u32;\n      if (ux == 0x3F800000) { // x == 1\n        m = sx | u32((uy & 0x7FFFFFFF) == 0x7F800000) ? 0x7FC00000 : 0x3F800000;\n      } else if (ux == 0) {\n        m = <i32>uy < 0 ? 0x7F800000 : 0;\n      } else if (ux == 0x7F800000) {\n        m = <i32>uy < 0 ? 0 : 0x7F800000;\n      } else if (sx) {\n        m = 0x7FC00000;\n      } else {\n        m = reinterpret<u32>(<f32>exp2f(<f64>y * log2f(x)));\n      }\n      return reinterpret<f32>(m | sign);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function seedRandom(value: i64): void {\n    NativeMath.seedRandom(value);\n  }\n\n  // Using xoroshiro64starstar from http://xoshiro.di.unimi.it/xoroshiro64starstar.c\n  export function random(): f32 {\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n\n    let s0 = random_state0_32;\n    let s1 = random_state1_32;\n    let r  = rotl<u32>(s0 * 0x9E3779BB, 5) * 5;\n\n    s1 ^= s0;\n    random_state0_32 = rotl<u32>(s0, 26) ^ s1 ^ (s1 << 9);\n    random_state1_32 = rotl<u32>(s1, 13);\n\n    return reinterpret<f32>((r >> 9) | (127 << 23)) - 1.0;\n  }\n\n  export function round(x: f32): f32 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_ceil<f32>(x) - f32(builtin_ceil<f32>(x) - 0.5 > x);\n    } else {\n      let roundUp = builtin_ceil<f32>(x);\n      return select<f32>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);\n    }\n  }\n\n  export function sign(x: f32): f32 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return select<f32>(builtin_copysign<f32>(1, x), x, builtin_abs(x) > 0);\n    } else {\n      return select<f32>(1, select<f32>(-1, x, x < 0), x > 0);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f32): bool {\n    return <bool>(reinterpret<u32>(x) >>> 31);\n  }\n\n  export function sin(x: f32): f32 { // see: musl/src/math/sinf.c\n    const\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return sin_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5π/4\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3π/4\n          return sign ? -cos_kernf(x + s1pio2) : cos_kernf(x - s1pio2);\n        }\n        return sin_kernf(-(sign ? x + s2pio2 : x - s2pio2));\n      }\n\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9π/4\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7π/4\n          return sign ? cos_kernf(x + s3pio2) : -cos_kernf(x - s3pio2);\n        }\n        return sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n      }\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) return x - x;\n\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n\n    let t = n & 1 ? cos_kernf(y) : sin_kernf(y);\n    return n & 2 ? -t : t;\n  }\n\n  export function sinh(x: f32): f32 { // see: musl/src/math/sinhf.c\n    let u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    let a = reinterpret<f32>(u);\n    let h = builtin_copysign<f32>(0.5, x);\n    if (u < 0x42B17217) {\n      let t = expm1(a);\n      if (u < 0x3F800000) {\n        if (u < 0x3F800000 - (12 << 23)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2f(a, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f32): f32 {\n    return builtin_sqrt<f32>(x);\n  }\n\n  export function tan(x: f32): f32 { // see: musl/src/math/tanf.c\n    const\n      t1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\n      t2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\n      t3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\n      t4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return tan_kernf(x, 0);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5π/4\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3π/4\n          return tan_kernf((sign ? x + t1pio2 : x - t1pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t2pio2 : x - t2pio2), 0);\n        }\n      }\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9π/4\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7π/4\n          return tan_kernf((sign ? x + t3pio2 : x - t3pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t4pio2 : x - t4pio2), 0);\n        }\n      }\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) return x - x;\n\n    // argument reduction\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n    return tan_kernf(y, n & 1);\n  }\n\n  export function tanh(x: f32): f32 { // see: musl/src/math/tanhf.c\n    let u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    let y = reinterpret<f32>(u);\n    let t: f32;\n    if (u > 0x3F0C9F54) {\n      if (u > 0x41200000) t = 1 + 0 / y;\n      else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (u > 0x3E82C578) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (u >= 0x00800000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f32>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f32): f32 {\n    return builtin_trunc<f32>(x);\n  }\n\n  export function scalbn(x: f32, n: i32): f32 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbnf.c\n    const\n      Ox1p24f   = reinterpret<f32>(0x4B800000),\n      Ox1p127f  = reinterpret<f32>(0x7F000000),\n      Ox1p_126f = reinterpret<f32>(0x00800000);\n\n    let y = x;\n    if (n > 127) {\n      y *= Ox1p127f;\n      n -= 127;\n      if (n > 127) {\n        y *= Ox1p127f;\n        n = builtin_min<i32>(n - 127, 127);\n      }\n    } else if (n < -126) {\n      y *= Ox1p_126f * Ox1p24f;\n      n += 126 - 24;\n      if (n < -126) {\n        y *= Ox1p_126f * Ox1p24f;\n        n = builtin_max<i32>(n + 126 - 24, -126);\n      }\n    }\n    return y * reinterpret<f32>(<u32>(0x7F + n) << 23);\n  }\n\n  export function mod(x: f32, y: f32): f32 { // see: musl/src/math/fmodf.c\n    if (builtin_abs<f32>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler's optimization pass.\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\n      return builtin_copysign<f32>(x - builtin_trunc<f32>(x), x);\n    }\n    let ux = reinterpret<u32>(x);\n    let uy = reinterpret<u32>(y);\n    let ex = i32(ux >> 23 & 0xFF);\n    let ey = i32(uy >> 23 & 0xFF);\n    let sm = ux & 0x80000000;\n    let uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0xFF || isNaN<f32>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    let ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      return x * f32(ux1 != uy1);\n    }\n    if (!ex) {\n      ex -= builtin_clz<u32>(ux << 9);\n      ux <<= 1 - ex;\n    } else {\n      ux &= <u32>-1 >> 9;\n      ux |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u32(-1) >> 9;\n      uy |= 1 << 23;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 23); ux <<= 1) --ex;\n    let shift = <i32>builtin_clz<u32>(ux << 8);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 23;\n      ux |= <u32>ex << 23;\n    } else {\n      ux >>= -ex + 1;\n    }\n    return reinterpret<f32>(ux | sm);\n  }\n\n  export function rem(x: f32, y: f32): f32 { // see: musl/src/math/remquof.c\n    let ux = reinterpret<u32>(x);\n    let uy = reinterpret<u32>(y);\n    let ex = i32(ux >> 23 & 0xFF);\n    let ey = i32(uy >> 23 & 0xFF);\n    let uxi = ux;\n    if (uy << 1 == 0 || ex == 0xFF || isNaN(y)) return (x * y) / (x * y);\n    if (ux << 1 == 0) return x;\n    if (!ex) {\n      ex -= builtin_clz<u32>(uxi << 9);\n      uxi <<= 1 - ex;\n    } else {\n      uxi &= u32(-1) >> 9;\n      uxi |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u32(-1) >> 9;\n      uy |= 1 << 23;\n    }\n    let q = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -30;\n      else {\n        let shift = builtin_clz<i32>(uxi << 8);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 23;\n      uxi |= <u32>ex << 23;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f32>(uxi);\n    y = builtin_abs<f32>(y);\n    let x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (<f32>x2 > y || (<f32>x2 == y && bool(q & 1))))) {\n      x -= y;\n      // q++;\n    }\n    return <i32>ux < 0 ? -x : x;\n  }\n\n  export function sincos(x: f32): void { // see: musl/tree/src/math/sincosf.c\n    const\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kernf(x);\n      sincos_cos = cos_kernf(x);\n      return;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5π/4\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3π/4\n          if (sign) {\n            sincos_sin = -cos_kernf(x + s1pio2);\n            sincos_cos =  sin_kernf(x + s1pio2);\n          } else {\n            sincos_sin = cos_kernf(s1pio2 - x);\n            sincos_cos = sin_kernf(s1pio2 - x);\n          }\n          return;\n        }\n        // -sin(x + c) is not correct if x+c could be 0: -0 vs +0\n        sincos_sin = -sin_kernf(sign ? x + s2pio2 : x - s2pio2);\n        sincos_cos = -cos_kernf(sign ? x + s2pio2 : x - s2pio2);\n        return;\n      }\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9π/4\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7π/4\n          if (sign) {\n            sincos_sin =  cos_kernf(x + s3pio2);\n            sincos_cos = -sin_kernf(x + s3pio2);\n          } else {\n            sincos_sin = -cos_kernf(x - s3pio2);\n            sincos_cos =  sin_kernf(x - s3pio2);\n          }\n          return;\n        }\n        sincos_sin = sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n        sincos_cos = cos_kernf(sign ? x + s4pio2 : x - s4pio2);\n        return;\n      }\n    }\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n    let s = sin_kernf(y);\n    let c = cos_kernf(y);\n    let sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\nexport function ipow32(x: i32, e: i32): i32 {\n  let out = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (x == 2) {\n      return select<i32>(1 << e, 0, <u32>e < 32);\n    }\n    if (e <= 0) {\n      if (x == -1) return select<i32>(-1, 1, e & 1);\n      return i32(e == 0) | i32(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 32) {\n      let log = 32 - clz(e);\n      // 32 = 2 ^ 5, so need only five cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\nexport function ipow64(x: i64, e: i64): i64 {\n  let out: i64 = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (x == 2) {\n      return select<i64>(1 << e, 0, <u64>e < 64);\n    }\n    if (e <= 0) {\n      if (x == -1) return select<i64>(-1, 1, e & 1);\n      return i64(e == 0) | i64(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 64) {\n      let log = 64 - <i32>clz(e);\n      // 64 = 2 ^ 6, so need only six cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 6: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\n/*\nTODO:\nIn compile time if only exponent is constant we could replace ipow32/ipow64 by shortest addition chains\nwhich usually faster than exponentiation by squaring\n\nfor ipow32 and e < 32:\n\nlet b: i32, c: i32, d: i32, h: i32, k: i32, g: i32;\nswitch (e) {\n  case  1: return x;\n  case  2: return x * x;\n  case  3: return x * x * x;\n  case  4: return (b = x * x) * b;\n  case  5: return (b = x * x) * b * x;\n  case  6: return (b = x * x) * b * b;\n  case  7: return (b = x * x) * b * b * x;\n  case  8: return (d = (b = x * x) * b) * d;\n  case  9: return (c = x * x * x) * c * c;\n  case 10: return (d = (b = x * x) * b) * d * b;\n  case 11: return (d = (b = x * x) * b) * d * b * x;\n  case 12: return (d = (b = x * x) * b) * d * d;\n  case 13: return (d = (b = x * x) * b) * d * d * x;\n  case 14: return (d = (b = x * x) * b) * d * d * b;\n  case 15: return (k = (b = x * x) * b * x) * k * k;\n  case 16: return (h = (d = (b = x * x) * b) * d) * h;\n  case 17: return (h = (d = (b = x * x) * b) * d) * h * x;\n  case 18: return (h = (d = (b = x * x) * b) * d * x) * h;\n  case 19: return (h = (d = (b = x * x) * b) * d * x) * h * x;\n  case 20: return (h = (k = (b = x * x) * b * x) * k) * h;\n  case 21: return (h = (k = (b = x * x) * b * x) * k) * h * x;\n  case 22: return (g = (h = (k = (b = x * x) * b * x) * k) * x) * g;\n  case 23: return (h = (d = (c = (b = x * x) * x) * b) * d) * h * c;\n  case 24: return (h = (d = (c = x * x * x) * c) * d) * h;\n  case 25: return (h = (d = (c = x * x * x) * c) * d) * h * x;\n  case 26: return (g = (h = (d = (c = x * x * x) * c) * d) * x) * g;\n  case 27: return (h = (d = (c = x * x * x) * c) * d) * h * c;\n  case 28: return (h = (d = (c = x * x * x) * c * x) * d) * h;\n  case 29: return (h = (d = (c = x * x * x) * c * x) * d) * h * x;\n  case 30: return (h = (d = (c = x * x * x) * c) * d * c) * h;\n  case 31: return (h = (d = (c = x * x * x) * c) * d * c) * h * x;\n}\n\nfor ipow64: TODO\nswitch (e) {\n  case 32:\n  ...\n  case 63:\n}\n*/\n","import {\r\n  args_get,\r\n  args_sizes_get,\r\n  environ_get,\r\n  environ_sizes_get,\r\n  proc_exit,\r\n  fd_write,\r\n  fd_close,\r\n  fd_read,\r\n  clock_time_get,\r\n  clockid,\r\n  errnoToString,\r\n  fd\r\n} from \"./bindings/wasi_snapshot_preview1\";\r\n\r\nimport {\r\n  tempbuf\r\n} from \"./wasi_internal\";\r\n\r\nimport {\r\n  E_INDEXOUTOFRANGE\r\n} from \"util/error\";\r\n\r\nexport namespace wasi_process {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy export const arch = sizeof<usize>() == 4 ? \"wasm32\" : \"wasm64\";\r\n  // @ts-ignore: decorator\r\n  @lazy export const platform = \"wasm\";\r\n  // @ts-ignore: decorator\r\n  @lazy export const argv = lazyArgv();\r\n  // @ts-ignore: decorator\r\n  @lazy export const env = lazyEnv();\r\n  // @ts-ignore: decorator\r\n  @lazy export var exitCode = 0;\r\n\r\n  export function exit(code: i32 = exitCode): void {\r\n    proc_exit(code);\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy export const stdin = changetype<ReadableStream>(0);\r\n  // @ts-ignore: decorator\r\n  @lazy export const stdout = changetype<WritableStream>(1);\r\n  // @ts-ignore: decorator\r\n  @lazy export const stderr = changetype<WritableStream>(2);\r\n\r\n  export function time(): i64 {\r\n    let err = clock_time_get(clockid.REALTIME, 1000000, tempbuf);\r\n    if (err) throw new Error(errnoToString(err));\r\n    return load<u64>(tempbuf) / 1000000;\r\n  }\r\n\r\n  export function hrtime(): u64 {\r\n    let err = clock_time_get(clockid.MONOTONIC, 0, tempbuf);\r\n    if (err) throw new Error(errnoToString(err));\r\n    return load<u64>(tempbuf);\r\n  }\r\n}\r\n\r\nfunction lazyArgv(): string[] {\r\n  let err = args_sizes_get(tempbuf, tempbuf + sizeof<usize>());\r\n  if (err) throw new Error(errnoToString(err));\r\n  let count = load<usize>(tempbuf);\r\n  let ptrsSize = count * sizeof<usize>();\r\n  let dataSize = load<usize>(tempbuf, sizeof<usize>());\r\n  let bufSize = ptrsSize + dataSize;\r\n  let buf = __alloc(bufSize);\r\n  err = args_get(buf, buf + ptrsSize);\r\n  if (err) throw new Error(errnoToString(err));\r\n  let count32 = <i32>count;\r\n  let argv = new Array<string>(count32);\r\n  for (let i = 0; i < count32; ++i) {\r\n    let ptr = load<usize>(buf + i * sizeof<usize>());\r\n    let str = String.UTF8.decodeUnsafe(ptr, ptr + bufSize - buf, true);\r\n    argv[i] = str;\r\n  }\r\n  __free(buf);\r\n  return argv;\r\n}\r\n\r\nfunction lazyEnv(): Map<string,string> {\r\n  let err = environ_sizes_get(tempbuf, tempbuf + 4);\r\n  if (err) throw new Error(errnoToString(err));\r\n  let count = load<usize>(tempbuf);\r\n  let ptrsSize = count * sizeof<usize>();\r\n  let dataSize = load<usize>(tempbuf, sizeof<usize>());\r\n  let bufSize = ptrsSize + dataSize;\r\n  let buf = __alloc(bufSize);\r\n  err = environ_get(buf, buf + ptrsSize);\r\n  if (err) throw new Error(errnoToString(err));\r\n  let env = new Map<string,string>();\r\n  for (let i: usize = 0; i < count; ++i) {\r\n    let ptr = load<usize>(buf + i * sizeof<usize>());\r\n    let str = String.UTF8.decodeUnsafe(ptr, ptr + bufSize - buf, true);\r\n    let pos = str.indexOf(\"=\");\r\n    if (~pos) {\r\n      env.set(str.substring(0, pos), str.substring(pos + 1));\r\n      // __dispose(changetype<usize>(str));\r\n    } else {\r\n      env.set(str, \"\");\r\n    }\r\n  }\r\n  __free(buf);\r\n  return env;\r\n}\r\n\r\n@unmanaged\r\nabstract class Stream {\r\n  close(): void {\r\n    var err = fd_close(<u32>changetype<usize>(this));\r\n    if (err) throw new Error(errnoToString(err));\r\n  }\r\n}\r\n\r\n@unmanaged\r\nabstract class WritableStream extends Stream {\r\n  write<T>(data: T): void {\r\n    if (isString<T>()) {\r\n      writeString(<u32>changetype<usize>(this), changetype<string>(data));\r\n    } else if (data instanceof ArrayBuffer) {\r\n      writeBuffer(<u32>changetype<usize>(this), data);\r\n    } else {\r\n      ERROR(\"String or ArrayBuffer expected\");\r\n    }\r\n  }\r\n}\r\n\r\n@unmanaged\r\nabstract class ReadableStream extends Stream {\r\n  read(buffer: ArrayBuffer, offset: isize = 0): i32 {\r\n    var end = <usize>buffer.byteLength;\r\n    if (offset < 0 || <usize>offset > end) {\r\n      throw new Error(E_INDEXOUTOFRANGE);\r\n    }\r\n    store<usize>(tempbuf, changetype<usize>(buffer) + offset);\r\n    store<usize>(tempbuf, end - offset, sizeof<usize>());\r\n    var err = fd_read(<u32>changetype<usize>(this), tempbuf, 1, tempbuf + 2 * sizeof<usize>());\r\n    if (err) throw new Error(errnoToString(err));\r\n    return <i32>load<isize>(tempbuf, 2 * sizeof<usize>());\r\n  }\r\n}\r\n\r\nfunction writeBuffer(fd: fd, data: ArrayBuffer): void {\r\n  store<usize>(tempbuf, changetype<usize>(data));\r\n  store<usize>(tempbuf, data.byteLength, sizeof<usize>());\r\n  var err = fd_write(<u32>fd, tempbuf, 1, tempbuf + 2 * sizeof<usize>());\r\n  if (err) throw new Error(errnoToString(err));\r\n}\r\n\r\nfunction writeString(fd: fd, data: string): void {\r\n  var len = data.length;\r\n  var\r\n    char2: u32 = 0,\r\n    char3: u32 = 0,\r\n    char4: u32 = 0;\r\n  switch (len) {\r\n    case 4: { // \"null\"\r\n      char4 = <u32>load<u16>(changetype<usize>(data), 6);\r\n      if (char4 >= 0x80) break;\r\n    }\r\n    case 3: { // \"ms\\n\"\r\n      char3 = <u32>load<u16>(changetype<usize>(data), 4);\r\n      if (char3 >= 0x80) break;\r\n    }\r\n    case 2: { // \"\\r\\n\"\r\n      char2 = <u32>load<u16>(changetype<usize>(data), 2);\r\n      if (char2 >= 0x80) break;\r\n    }\r\n    case 1: { // \"\\n\"\r\n      let char1 = <u32>load<u16>(changetype<usize>(data));\r\n      if (char1 >= 0x80) break;\r\n      store<usize>(tempbuf, tempbuf + 2 * sizeof<usize>());\r\n      store<usize>(tempbuf, len, sizeof<usize>());\r\n      store<u32>(tempbuf, char1 | char2 << 8 | char3 << 16 | char4 << 24, 2 * sizeof<usize>());\r\n      let err = fd_write(<u32>fd, tempbuf, 1, tempbuf + 3 * sizeof<usize>());\r\n      if (err) throw new Error(errnoToString(err));\r\n    }\r\n    case 0: return;\r\n  }\r\n  var utf8len = <usize>String.UTF8.byteLength(data);\r\n  var utf8buf = __alloc(utf8len);\r\n  assert(String.UTF8.encodeUnsafe(changetype<usize>(data), len, utf8buf) == utf8len);\r\n  store<usize>(tempbuf, utf8buf);\r\n  store<usize>(tempbuf, utf8len, sizeof<usize>());\r\n  var err = fd_write(<u32>fd, tempbuf, 1, tempbuf + 2 * sizeof<usize>());\r\n  __free(utf8buf);\r\n  if (err) throw new Error(errnoToString(err));\r\n}\r\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_HOLEYARRAY } from \"./util/error\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\n\n@final\nexport class StaticArray<T> {\n  [key: number]: T;\n\n  // Note that the interface of StaticArray instances must be a semantically\n  // compatible subset of Array<T> in order for syntax highlighting to work\n  // properly, for instance when creating static arrays from array literals.\n  // The additionally provided static methods take care of dealing with static\n  // arrays exclusively, without having to convert to Array<T> first.\n\n  static fromArray<T>(source: Array<T>): StaticArray<T> {\n    let length = source.length;\n    let outSize = <usize>length << alignof<T>();\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (isManaged<T>()) {\n      let sourcePtr = source.dataStart;\n      for (let i = 0; i < length; ++i) {\n        let off = <usize>i << alignof<T>();\n        let ref = load<usize>(sourcePtr + off);\n        store<usize>(changetype<usize>(out) + off, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(changetype<usize>(out), source.dataStart, outSize);\n    }\n    return out;\n  }\n\n  /** @deprecated Please use source.concat<StaticArray<T>> instead. */\n  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T> {\n    return source.concat<StaticArray<T>>(other);\n  }\n\n  /** @deprecated Please use source.slice<StaticArray<T>> instead. */\n  static slice<T>(source: StaticArray<T>, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    return source.slice<StaticArray<T>>(start, end);\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    let outSize = <usize>length << alignof<T>();\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(out), 0, outSize);\n    }\n    return out;\n  }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >>> alignof<T>();\n  }\n\n  at(index: i32): T {\n    let len = this.length;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    this.__uset(index, value);\n  }\n\n  @unsafe @operator(\"{}=\") private __uset(index: i32, value: T): void {\n    store<T>(changetype<usize>(this) + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    if (isManaged<T>()) {\n      FILL<usize>(changetype<usize>(this), this.length, changetype<usize>(value), start, end);\n      __link(changetype<usize>(this), changetype<usize>(value), false);\n    } else {\n      FILL<T>(changetype<usize>(this), this.length, value, start, end);\n    }\n    return this;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    let ptr = changetype<usize>(this);\n    let len = this.length;\n\n    end = min<i32>(end, len);\n\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\n    let count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let length = this.length;\n      if (length == 0 || fromIndex >= length) return false;\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n      while (fromIndex < length) {\n        let elem = load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    let length = this.length;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    while (fromIndex < length) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length): i32 {\n    let length = this.length;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex;\n    else if (fromIndex >= length) fromIndex = length - 1;\n    while (fromIndex >= 0) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  concat<U extends ArrayLike<T> = Array<T>>(other: U): U {\n    let sourceLen = this.length;\n    let otherLen = other.length;\n    let outLen = sourceLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) {\n      throw new Error(E_INVALIDLENGTH);\n    }\n    let sourceSize = <usize>sourceLen << alignof<T>();\n    let out = changetype<U>(this); // FIXME: instanceof needs *some* value\n\n    if (out instanceof Array<T>) {\n      out = changetype<U>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n      // ^ FIXME: Function returns type U, but can't __newArray(U extends Array<T>)\n      let outStart = changetype<Array<T>>(out).dataStart;\n      let otherStart = changetype<Array<T>>(other).dataStart;\n      let thisStart = changetype<usize>(this);\n\n      if (isManaged<T>()) {\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n          let ref = load<usize>(thisStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n        outStart += sourceSize;\n        let otherSize = <usize>otherLen << alignof<T>();\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n          let ref = load<usize>(otherStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n      } else {\n        memory.copy(outStart, thisStart, sourceSize);\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\n      }\n    } else if (out instanceof StaticArray<T>) {\n      out = changetype<U>(__new(<usize>outLen << alignof<T>(), idof<StaticArray<T>>()));\n      let outStart = changetype<usize>(out);\n      let otherStart = changetype<usize>(other);\n      let thisStart = changetype<usize>(this);\n\n      if (isManaged<T>()) {\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n          let ref = load<usize>(thisStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(outStart, ref, true);\n        }\n        outStart += sourceSize;\n        let otherSize = <usize>otherLen << alignof<T>();\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n          let ref = load<usize>(otherStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(outStart, ref, true);\n        }\n      } else {\n        memory.copy(outStart, thisStart, sourceSize);\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\n      }\n    } else {\n      ERROR(\"Only Array<T> and StaticArray<T> accept for 'U' parameter\");\n    }\n    return out;\n  }\n\n  slice<U extends ArrayLike<T> = Array<T>>(start: i32 = 0, end: i32 = i32.MAX_VALUE): U {\n    let length = this.length;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end,   length);\n    length = max(end - start, 0);\n\n    let sourceStart = changetype<usize>(this) + (<usize>start << alignof<T>());\n    let size = <usize>length << alignof<T>();\n    let out = changetype<U>(this); // FIXME: instanceof needs *some* value\n\n    if (out instanceof Array<T>) {\n      // return Array\n      out = changetype<U>(__newArray(length, alignof<T>(), idof<Array<T>>()));\n      // ^ FIXME: Function returns type U, but can't __newArray(U extends Array<T>)\n      let outStart = changetype<Array<T>>(out).dataStart;\n      if (isManaged<T>()) {\n        let off: usize = 0;\n        while (off < size) {\n          let ref = load<usize>(sourceStart + off);\n          store<usize>(outStart + off, ref);\n          __link(changetype<usize>(out), ref, true);\n          off += sizeof<usize>();\n        }\n      } else {\n        memory.copy(outStart, sourceStart, size);\n      }\n    } else if (out instanceof StaticArray<T>) {\n      // return StaticArray\n      out = changetype<U>(__new(size, idof<StaticArray<T>>()));\n      let outStart = changetype<usize>(out);\n      if (isManaged<T>()) {\n        let off: usize = 0;\n        while (off < size) {\n          let ref = load<usize>(sourceStart + off);\n          store<usize>(outStart + off, ref);\n          __link(outStart, ref, true);\n          off += sizeof<usize>();\n        }\n      } else {\n        memory.copy(outStart, sourceStart, size);\n      }\n    } else {\n      ERROR(\"Only Array<T> and StaticArray<T> accept for 'U' parameter\");\n    }\n    return out;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = this.length - 1; i >= 0; --i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  forEach(fn: (value: T, index: i32, array: StaticArray<T>) => void): void {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: StaticArray<T>) => U): Array<U> {\n    let len = this.length;\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    let outStart = out.dataStart;\n    for (let i = 0; i < len; ++i) {\n      let result = fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: StaticArray<T>) => bool): Array<T> {\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length; i < len; ++i) {\n      let value = load<T>(changetype<usize>(this) + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = 0, len = this.length; i < len; ++i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = this.length - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  every(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (!fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  some(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): StaticArray<T> {\n    SORT<T>(changetype<usize>(this), this.length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    if (isBoolean<T>())   return joinBooleanArray(changetype<usize>(this), this.length, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(changetype<usize>(this), this.length, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(changetype<usize>(this), this.length, separator);\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(changetype<usize>(this), this.length, separator);\n    }\n    if (isReference<T>()) return joinReferenceArray<T>(changetype<usize>(this), this.length, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  reverse(): StaticArray<T> {\n    REVERSE<T>(changetype<usize>(this), this.length);\n    return this;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = changetype<usize>(this);\n      let end = cur + changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n  }\n}\n","type auto = i32;\n\n@final export abstract class Function<T> {\n  private _index: u32;\n  private _env: usize;\n\n  // @ts-ignore: this on getter\n  get index(this: T): u32 {\n    return load<u32>(changetype<usize>(this), offsetof<Function<T>>(\"_index\"));\n  }\n\n  // @ts-ignore: this on getter\n  get name(this: T): string {\n    return \"\";\n  }\n\n  // @ts-ignore: this on getter\n  get length(this: T): i32 {\n    // @ts-ignore: T is function\n    return lengthof<T>();\n  }\n\n  // @ts-ignore: T is function\n  @builtin call(thisArg: thisof<T> | null, ...args: auto[]): returnof<T> {\n    return unreachable();\n  }\n\n  toString(this: T): string {\n    return \"function() { [native code] }\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    // Env is either `null` (nop) or compiler-generated\n    __visit(this._env, cookie);\n  }\n}\n"]}